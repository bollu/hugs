
const char *exception_hs = "-- This is a cut-down version of GHC's Exception module\n"
"--\n"
"-- The main difference is that Hugs does not throw asynchronous\n"
"-- exceptions, in particular heap and stack overflow and ctrl-C.\n"
"-- Indeed, it is not entirely clear what to do in response to ctrl-C.\n"
"\n"
"module Hugs.Exception(\n"
"Exception(..),\n"
"IOException(..),\n"
"ArithException(..),\n"
"ArrayException(..),\n"
"AsyncException(..),\n"
"\n"
"catchException,		-- :: IO a -> (Exception -> IO a) -> IO a\n"
"\n"
"-- Throwing exceptions\n"
"\n"
"throwIO,		-- :: Exception -> IO a\n"
"throw,			-- :: Exception -> a\n"
"\n"
"evaluate,		-- :: a -> IO a\n"
"\n"
"-- Async exception control\n"
"\n"
"block,			-- :: IO a -> IO a\n"
"unblock,		-- :: IO a -> IO a\n"
") where\n"
"\n"
"import Hugs.Prelude\n"
"\n"
"instance Eq Exception where\n"
"ArithException e1   == ArithException e2   = e1 == e2\n"
"ArrayException e1   == ArrayException e2   = e1 == e2\n"
"AssertionFailed e1  == AssertionFailed e2  = e1 == e2\n"
"AsyncException e1   == AsyncException e2   = e1 == e2\n"
"BlockedOnDeadMVar   == BlockedOnDeadMVar   = True\n"
"Deadlock            == Deadlock            = True\n"
"DynException _      == DynException _      = False -- incomparable\n"
"ErrorCall e1        == ErrorCall e2        = e1 == e2\n"
"ExitException e1    == ExitException e2    = e1 == e2\n"
"IOException e1      == IOException e2      = e1 == e2\n"
"NoMethodError e1    == NoMethodError e2    = e1 == e2\n"
"NonTermination      == NonTermination      = True\n"
"PatternMatchFail e1 == PatternMatchFail e2 = e1 == e2\n"
"RecConError e1      == RecConError e2      = e1 == e2\n"
"RecSelError e1      == RecSelError e2      = e1 == e2\n"
"RecUpdError e1      == RecUpdError e2      = e1 == e2\n"
"_                   == _                   = False\n"
"\n"
"----------------------------------------------------------------\n"
"-- Primitive throw and catch\n"
"----------------------------------------------------------------\n"
"\n"
"throwIO :: Exception -> IO a\n"
"throwIO exn = IO (\\ s -> throw exn)\n"
"\n"
"evaluate :: a -> IO a\n"
"evaluate x = IO (\\ s -> x `seq` s x)\n"
"\n"
"----------------------------------------------------------------\n"
"-- dummy implementations of block and unblock\n"
"----------------------------------------------------------------\n"
"\n"
"block, unblock :: IO a -> IO a\n"
"block   m = m\n"
"unblock m = m\n"
"\n"
"----------------------------------------------------------------\n"
"-- End\n"
"----------------------------------------------------------------\n";
const char *system_hs = "-----------------------------------------------------------------------------\n"
"-- Standard Library: System operations\n"
"--\n"
"-- Note: on Windows 9x, system always yields ExitSuccess.\n"
"--\n"
"-- Suitable for use with Hugs 98\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.System (\n"
"getArgs, getProgName, withArgs, withProgName, getEnv,\n"
"system\n"
") where\n"
"\n"
"import Hugs.Prelude( ExitCode(..), catchException, throw )\n"
"\n"
"-- In interpretive mode, the initial values of these two are [] and \"Hugs\",\n"
"-- but they can be (temporarily) changed using withArgs and withProgName.\n"
"primitive getArgs     \"primGetArgs\"     :: IO [String]\n"
"primitive getProgName \"primGetProgName\" :: IO String\n"
"\n"
"primitive setArgs     \"primSetArgs\"     :: [String] -> IO ()\n"
"primitive setProgName \"primSetProgName\" :: String -> IO ()\n"
"\n"
"-- Run an action with a value temporarily overridden\n"
"-- (a special case of Control.Exception.bracket)\n"
"with :: IO a -> (a -> IO ()) -> a -> IO b -> IO b\n"
"with getVal setVal newVal act = do\n"
"oldVal <- getVal\n"
"setVal newVal\n"
"r <- act `catchException` \\e -> setVal oldVal >> throw e\n"
"setVal oldVal\n"
"return r\n"
"\n"
"withArgs :: [String] -> IO a -> IO a\n"
"withArgs = with getArgs setArgs\n"
"\n"
"withProgName :: String -> IO a -> IO a\n"
"withProgName = with getProgName setProgName\n"
"\n"
"primitive getEnv            :: String -> IO String\n"
"\n"
"system                      :: String -> IO ExitCode\n"
"system s                     = do r <- primSystem s\n"
"return (toExitCode r)\n"
"\n"
"primitive primSystem        :: String -> IO Int\n"
"\n"
"toExitCode                  :: Int -> ExitCode\n"
"toExitCode 0                 = ExitSuccess\n"
"toExitCode n                 = ExitFailure n\n"
"\n"
"-----------------------------------------------------------------------------\n";
const char *trex_hs = "-----------------------------------------------------------------------------\n"
"-- Trex utilities:  Functions to compare and show record values\n"
"--\n"
"-- Warning: This file is an integral part of the TREX implementation, and\n"
"-- should not be modified without corresponding changes in the interpreter.\n"
"--\n"
"-- Suitable for use with Hugs 98, if compiled with TREX support.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.Trex( Rec, emptyRec, EmptyRow,\n"
"ShowRecRow(..), EqRecRow(..), insertField ) where\n"
"\n"
"import Hugs.Prelude ( Rec, emptyRec, EmptyRow )\n"
"\n"
"-- Code for equalities:\n"
"\n"
"instance EqRecRow r => Eq (Rec r) where\n"
"r == s = eqFields (eqRecRow r s)\n"
"where eqFields = and . map snd\n"
"\n"
"class EqRecRow r where\n"
"eqRecRow :: Rec r -> Rec r -> [(String,Bool)]\n"
"\n"
"instance EqRecRow EmptyRow where\n"
"eqRecRow _ _ = []\n"
"\n"
"\n"
"-- Code for showing values:\n"
"\n"
"instance ShowRecRow r => Show (Rec r) where\n"
"showsPrec d = showFields . showRecRow\n"
"where\n"
"showFields   :: [(String, ShowS)] -> ShowS\n"
"showFields [] = showString \"emptyRec\"\n"
"showFields xs = showChar '(' . foldr1 comma (map fld xs) . showChar ')'\n"
"where comma a b = a . showString \", \" . b\n"
"fld (s,v) = showString s . showChar '=' . v\n"
"\n"
"class ShowRecRow r where\n"
"showRecRow :: Rec r -> [(String, ShowS)]\n"
"\n"
"instance ShowRecRow EmptyRow where\n"
"showRecRow _ = []\n"
"\n"
"\n"
"-- General utility:\n"
"\n"
"insertField       :: String -> v -> [(String, v)] -> [(String, v)]\n"
"insertField n v fs = {- case fs of\n"
"[]     -> [(n,v)]\n"
"(r:rs) -> if n <= fst r\n"
"then (n,v):fs\n"
"else r : insertField n v rs -}\n"
"bef ++ [(n,v)] ++ aft\n"
"where (bef,aft) = span (\\r -> n > fst r) fs\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n";
const char *stable_hs = "module Hugs.Stable where\n"
"\n"
"data StableName a -- abstract\n"
"\n"
"primitive makeStableName   :: a -> IO (StableName a)\n"
"primitive deRefStableName  :: StableName a -> a\n"
"primitive hashStableName   :: StableName a -> Int\n"
"primitive eqStableName	   :: StableName a -> StableName a -> Bool\n"
"\n"
"instance Eq (StableName a) where\n"
"(==) = eqStableName\n";
const char *st_hs = "-----------------------------------------------------------------------------\n"
"-- Strict State Thread module\n"
"--\n"
"-- This library provides support for strict state threads, as described\n"
"-- in the PLDI '94 paper by John Launchbury and Simon Peyton Jones.\n"
"-- In addition to the monad ST, it also provides mutable variables STRef\n"
"-- and mutable arrays STArray.\n"
"--\n"
"-- Suitable for use with Hugs 98.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.ST\n"
"( ST(..)\n"
", runST\n"
", unsafeRunST\n"
", RealWorld\n"
", stToIO\n"
", unsafeIOToST\n"
"\n"
", STRef\n"
"-- instance Eq (STRef s a)\n"
", newSTRef\n"
", readSTRef\n"
", writeSTRef\n"
"\n"
", STArray\n"
"-- instance Eq (STArray s ix elt)\n"
", newSTArray\n"
", boundsSTArray\n"
", readSTArray\n"
", writeSTArray\n"
", thawSTArray\n"
", freezeSTArray\n"
", unsafeFreezeSTArray\n"
"\n"
", unsafeReadSTArray\n"
", unsafeWriteSTArray\n"
") where\n"
"\n"
"import Hugs.Prelude(IO(..))\n"
"import Hugs.Array(Array,Ix(index,rangeSize),bounds,elems)\n"
"import Hugs.IOExts(unsafePerformIO)\n"
"import Control.Monad\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- The ST representation generalizes that of IO (cf. Hugs.Prelude),\n"
"-- so it can use IO primitives that manipulate local state.\n"
"\n"
"newtype ST s a = ST (forall r. (a -> r) -> r)\n"
"\n"
"data RealWorld = RealWorld\n"
"\n"
"primitive thenStrictST \"primbindIO\" :: ST s a -> (a -> ST s b) -> ST s b\n"
"primitive returnST     \"primretIO\"  :: a -> ST s a\n"
"\n"
"unST                :: ST s a -> (a -> r) -> r\n"
"unST (ST f)          = f\n"
"\n"
"runST               :: (forall s. ST s a) -> a\n"
"runST m              = unST m id\n"
"\n"
"unsafeRunST         :: ST s a -> a\n"
"unsafeRunST m        = unST m id\n"
"\n"
"stToIO              :: ST RealWorld a -> IO a\n"
"stToIO (ST f)        = IO f\n"
"\n"
"unsafeIOToST        :: IO a -> ST s a\n"
"unsafeIOToST         = unsafePerformIO . liftM returnST\n"
"\n"
"instance Functor (ST s) where\n"
"fmap = liftM\n"
"\n"
"instance Monad (ST s) where\n"
"(>>=)  = thenStrictST\n"
"return = returnST\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"data STRef s a   -- implemented as an internal primitive\n"
"\n"
"primitive newSTRef   \"newRef\"     :: a -> ST s (STRef s a)\n"
"primitive readSTRef  \"getRef\"     :: STRef s a -> ST s a\n"
"primitive writeSTRef \"setRef\"     :: STRef s a -> a -> ST s ()\n"
"primitive eqSTRef    \"eqRef\"      :: STRef s a -> STRef s a -> Bool\n"
"\n"
"instance Eq (STRef s a) where (==) = eqSTRef\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"data STArray s ix elt -- implemented as an internal primitive\n"
"\n"
"newSTArray          :: Ix ix => (ix,ix) -> elt -> ST s (STArray s ix elt)\n"
"boundsSTArray       :: Ix ix => STArray s ix elt -> (ix, ix)\n"
"readSTArray         :: Ix ix => STArray s ix elt -> ix -> ST s elt\n"
"writeSTArray        :: Ix ix => STArray s ix elt -> ix -> elt -> ST s ()\n"
"thawSTArray         :: Ix ix => Array ix elt -> ST s (STArray s ix elt)\n"
"freezeSTArray       :: Ix ix => STArray s ix elt -> ST s (Array ix elt)\n"
"unsafeFreezeSTArray :: Ix ix => STArray s ix elt -> ST s (Array ix elt)\n"
"\n"
"unsafeReadSTArray   :: Ix i => STArray s i e -> Int -> ST s e\n"
"unsafeReadSTArray    = primReadArr\n"
"\n"
"unsafeWriteSTArray  :: Ix i => STArray s i e -> Int -> e -> ST s ()\n"
"unsafeWriteSTArray   = primWriteArr\n"
"\n"
"newSTArray bs e      = primNewArr bs (rangeSize bs) e\n"
"boundsSTArray a      = primBounds a\n"
"readSTArray a i      = unsafeReadSTArray a (index (boundsSTArray a) i)\n"
"writeSTArray a i e   = unsafeWriteSTArray a (index (boundsSTArray a) i) e\n"
"thawSTArray arr      = do\n"
"stArr <- newSTArray (bounds arr) err\n"
"sequence_ (zipWith (unsafeWriteSTArray stArr)\n"
"[0..] (elems arr))\n"
"return stArr\n"
"where\n"
"err = error \"thawArray: element not overwritten\" -- shouldnae happen\n"
"freezeSTArray a      = primFreeze a\n"
"unsafeFreezeSTArray  = freezeSTArray  -- not as fast as GHC\n"
"\n"
"instance Eq (STArray s ix elt) where\n"
"(==) = eqSTArray\n"
"\n"
"primitive primNewArr   \"IONewArr\"\n"
":: (a,a) -> Int -> b -> ST s (STArray s a b)\n"
"primitive primReadArr  \"IOReadArr\"\n"
":: STArray s a b -> Int -> ST s b\n"
"primitive primWriteArr \"IOWriteArr\"\n"
":: STArray s a b -> Int -> b -> ST s ()\n"
"primitive primFreeze   \"IOFreeze\"\n"
":: STArray s a b -> ST s (Array a b)\n"
"primitive primBounds   \"IOBounds\"\n"
":: STArray s a b -> (a,a)\n"
"primitive eqSTArray    \"IOArrEq\"\n"
":: STArray s a b -> STArray s a b -> Bool\n"
"\n"
"-----------------------------------------------------------------------------\n";
const char *bytearray_hs = "-- Mutable and immutable byte arrays (identical internally), usable for\n"
"-- unboxed arrays, and built from FFI primitives.\n"
"\n"
"module Hugs.ByteArray (\n"
"MutableByteArray,\n"
"newMutableByteArray, readMutableByteArray, writeMutableByteArray,\n"
"ByteArray,\n"
"unsafeFreezeMutableByteArray, thawByteArray, readByteArray\n"
") where\n"
"\n"
"import Data.Word		( Word8 )\n"
"import Foreign.ForeignPtr	( ForeignPtr,\n"
"mallocForeignPtrBytes, withForeignPtr )\n"
"import Foreign.Marshal.Utils	( copyBytes )\n"
"import Foreign.Ptr		( castPtr )\n"
"import Foreign.Storable		( Storable( peekElemOff, pokeElemOff ))\n"
"\n"
"import Hugs.IOExts		( unsafeCoerce )\n"
"import Hugs.ST			( ST, unsafeRunST )\n"
"\n"
"-- This implementation is based on the principle that the FFI primitives\n"
"-- used, though declared as IO actions, actually only manipulate local\n"
"-- state, and thus could have been declared in the strict ST monad:\n"
"--\n"
"--	mallocForeignPtrBytes :: Int -> ST s (STForeignPtr s a)\n"
"--	withForeignPtr :: STForeignPtr s a -> (STPtr s a -> ST s b) -> ST s b\n"
"--	copyBytes :: STPtr s a -> STPtr s a -> Int -> ST s ()\n"
"--	castPtr :: STPtr s a -> STPtr s b\n"
"--	peekElemOff :: Storable a => STPtr s a -> Int -> ST s a\n"
"--	pokeElemOff :: Storable a => STPtr s a -> Int -> a -> ST s ()\n"
"--\n"
"-- (where STPtr s and STForeignPtr s are just like Ptr and ForeignPtr,\n"
"-- but confined to the region s)\n"
"--\n"
"-- Since the strict ST monad has the same representation as the IO monad,\n"
"-- we are justified in coercing such actions to the ST monad.\n"
"\n"
"-- This conversion may be safely applied to computations that manipulate\n"
"-- only local state, but will give a runtime error if the IO action does\n"
"-- any concurrency.\n"
"specialIOToST :: IO a -> ST s a\n"
"specialIOToST = unsafeCoerce\n"
"\n"
"type BytePtr = ForeignPtr Word8\n"
"\n"
"data MutableByteArray s = MutableByteArray !Int !BytePtr\n"
"\n"
"newMutableByteArray :: Int -> ST s (MutableByteArray s)\n"
"newMutableByteArray size = do\n"
"fp <- specialIOToST (mallocForeignPtrBytes size)\n"
"return (MutableByteArray size fp)\n"
"\n"
"readMutableByteArray :: Storable e => MutableByteArray s -> Int -> ST s e\n"
"readMutableByteArray (MutableByteArray _ fp) i =\n"
"specialIOToST $ withForeignPtr fp $ \\a -> peekElemOff (castPtr a) i\n"
"\n"
"writeMutableByteArray :: Storable e => MutableByteArray s -> Int -> e -> ST s ()\n"
"writeMutableByteArray (MutableByteArray _ fp) i e =\n"
"specialIOToST $ withForeignPtr fp $ \\a -> pokeElemOff (castPtr a) i e\n"
"\n"
"data ByteArray = ByteArray !Int !BytePtr\n"
"\n"
"-- Don't change the MutableByteArray after calling this.\n"
"unsafeFreezeMutableByteArray :: MutableByteArray s -> ST s ByteArray\n"
"unsafeFreezeMutableByteArray (MutableByteArray size fp) =\n"
"return (ByteArray size fp)\n"
"\n"
"thawByteArray :: ByteArray -> ST s (MutableByteArray s)\n"
"thawByteArray (ByteArray size fp) = specialIOToST $ do\n"
"fp' <- mallocForeignPtrBytes size\n"
"withForeignPtr fp $ \\p ->\n"
"withForeignPtr fp' $ \\p' ->\n"
"copyBytes p' p size\n"
"return (MutableByteArray size fp')\n"
"\n"
"-- This one is safe because ByteArrays are immutable\n"
"-- (cf. unsafeFreezeMutableByteArray)\n"
"readByteArray :: Storable a => ByteArray -> Int -> a\n"
"readByteArray (ByteArray _ fp) i = unsafeRunST $ specialIOToST $\n"
"withForeignPtr fp $ \\p -> peekElemOff (castPtr p) i\n";
const char *cvhassert_hs = "----------------------------------------------------------------\n"
"-- This is a simple implementation of Cordy Hall's assertions\n"
"-- (for performance debugging).\n"
"--\n"
"-- NB These primitives are an _experimental_ feature which may be\n"
"--    removed in future versions of Hugs.\n"
"--    They can only be used if hugs was configured with the\n"
"--    \"--enable-internal-prims\" flag.\n"
"--\n"
"-- These primitives mostly break referential transparency - but you're\n"
"-- only supposed to use them for debugging purposes.\n"
"----------------------------------------------------------------\n"
"\n"
"module Hugs.CVHAssert(\n"
"Test, Action,\n"
"assert,\n"
"isEvaluated,\n"
"pointerEqual\n"
") where\n"
"\n"
"import Hugs.Internals(\n"
"ptrEq,\n"
"Name,   nameInfo,\n"
"Cell,   getCell, cellPtrEq,\n"
"CellKind(..), classifyCell,\n"
")\n"
"import Hugs.IOExts(\n"
"unsafePerformIO\n"
")\n"
"\n"
"----------------------------------------------------------------\n"
"-- High level operations\n"
"----------------------------------------------------------------\n"
"\n"
"type Test a   = a -> Bool\n"
"type Action a = a -> IO ()\n"
"\n"
"assert :: Test a -> Action a -> a -> a\n"
"assert test action x =\n"
"unsafePerformIO (if test x then return () else action x)\n"
"`seq`\n"
"x\n"
"\n"
"isEvaluated :: a -> Bool\n"
"isEvaluated x = unsafePerformIO (\n"
"isEvaluatedCell (getCell x)\n"
")\n"
"\n"
"representationSize :: a -> Int\n"
"representationSize x = unsafePerformIO (do\n"
"cells <- cellsOf (getCell x) []\n"
"return (cellSize * length cells)\n"
")\n"
"\n"
"pointerEqual :: a -> a -> Bool\n"
"pointerEqual = ptrEq\n"
"\n"
"----------------------------------------------------------------\n"
"-- Utilities\n"
"----------------------------------------------------------------\n"
"\n"
"isEvaluatedCell :: Cell -> IO Bool\n"
"isEvaluatedCell cell = do\n"
"kind <- classifyCell False cell\n"
"\n"
"case kind of\n"
"Apply fun args -> do\n"
"funkind <- classifyCell False fun\n"
"case funkind of\n"
"Fun nm    -> return (nameArity nm > length args)\n"
"_         -> return True\n"
"_            -> return True\n"
"\n"
"arityOf :: Cell -> IO Int\n"
"arityOf cell = do\n"
"kind <- classifyCell False cell\n"
"\n"
"case kind of\n"
"Apply fun args -> do\n"
"funarity <- arityOf fun\n"
"return (funarity - length args)\n"
"\n"
"Fun   nm -> return (nameArity nm)\n"
"Con   nm -> return (nameArity nm)\n"
"Tuple i  -> return i\n"
"_            -> return 0\n"
"\n"
"\n"
"nameArity :: Name -> Int\n"
"nameArity nm = case nameInfo nm of (arity,_,_) -> arity\n"
"\n"
"-- list cells occurring in Cell\n"
"cellsOf :: Cell -> [Cell] -> IO [Cell]\n"
"\n"
"cellsOf cell seen\n"
"| cell `elemCell` seen\n"
"= return seen\n"
"| otherwise\n"
"= do\n"
"let seen' = cell:seen\n"
"\n"
"kind <- classifyCell False cell\n"
"\n"
"case kind of\n"
"Apply f xs -> do\n"
"seen'' <- cellsOf f seen'\n"
"cellsOf' xs seen''\n"
"Fun     _  -> return seen'\n"
"Con     _  -> return seen'\n"
"Tuple   _  -> return seen'\n"
"Int     _  -> return seen'\n"
"Integer _  -> return seen'\n"
"Float   _  -> return seen'\n"
"Char    _  -> return seen'\n"
"Prim    _  -> return seen'\n"
"Error   _  -> return seen'	-- we could argue about this one\n"
"\n"
"cellsOf' :: [Cell] -> [Cell] -> IO [Cell]\n"
"cellsOf' []     seen = return seen\n"
"cellsOf' (x:xs) seen = do seen' <- cellsOf x seen\n"
"cellsOf' xs seen'\n"
"\n"
"elemCell :: Cell -> [Cell] -> Bool\n"
"x `elemCell` []     = False\n"
"x `elemCell` (y:ys) = x `cellPtrEq` y || x `elemCell` ys\n"
"\n"
"cellSize :: Int\n"
"cellSize = 8\n"
"\n"
"----------------------------------------------------------------\n";
const char *prelude_hs = "{----------------------------------------------------------------------------\n"
"__   __ __  __  ____   ___    _______________________________________________\n"
"||   || ||  || ||  || ||__    Hugs 98: The Nottingham and Yale Haskell system\n"
"||___|| ||__|| ||__||  __||   Copyright (c) 1994-1999\n"
"||---||         ___||         World Wide Web: http://haskell.org/hugs\n"
"||   ||                       Report bugs to: hugs-bugs@haskell.org\n"
"||   || Version: February 1999_______________________________________________\n"
"\n"
"This is the Hugs 98 Standard Prelude, based very closely on the Standard\n"
"Prelude for Haskell 98.\n"
"\n"
"WARNING: This file is an integral part of the Hugs source code.  Changes to\n"
"the definitions in this file without corresponding modifications in other\n"
"parts of the program may cause the interpreter to fail unexpectedly.  Under\n"
"normal circumstances, you should not attempt to modify this file in any way!\n"
"\n"
"-----------------------------------------------------------------------------\n"
"The Hugs 98 system is Copyright (c) Mark P Jones, Alastair Reid, the\n"
"Yale Haskell Group, and the OGI School of Science & Engineering at OHSU,\n"
"1994-2003, All rights reserved.  It is distributed as free software under\n"
"the license in the file \"License\", which is included in the distribution.\n"
"----------------------------------------------------------------------------}\n"
"\n"
"module Hugs.Prelude (\n"
"--  module PreludeList,\n"
"map, (++), concat, filter,\n"
"head, last, tail, init, null, length, (!!),\n"
"foldl, foldl1, scanl, scanl1, foldr, foldr1, scanr, scanr1,\n"
"iterate, repeat, replicate, cycle,\n"
"take, drop, splitAt, takeWhile, dropWhile, span, break,\n"
"lines, words, unlines, unwords, reverse, and, or,\n"
"any, all, elem, notElem, lookup,\n"
"sum, product, maximum, minimum, concatMap,\n"
"zip, zip3, zipWith, zipWith3, unzip, unzip3,\n"
"--  module PreludeText,\n"
"ReadS, ShowS,\n"
"Read(readsPrec, readList),\n"
"Show(show, showsPrec, showList),\n"
"reads, shows, read, lex,\n"
"showChar, showString, readParen, showParen,\n"
"--  module PreludeIO,\n"
"FilePath, IOError, ioError, userError, catch,\n"
"putChar, putStr, putStrLn, print,\n"
"getChar, getLine, getContents, interact,\n"
"readFile, writeFile, appendFile, readIO, readLn,\n"
"--  module Ix,\n"
"Ix(range, index, unsafeIndex, inRange, rangeSize, unsafeRangeSize),\n"
"--  module Char,\n"
"isSpace, isUpper, isLower,\n"
"isAlpha, isDigit, isOctDigit, isHexDigit, isAlphaNum,\n"
"readLitChar, showLitChar, lexLitChar,\n"
"--  module Numeric\n"
"showSigned, showInt,\n"
"readSigned, readInt,\n"
"readDec, readOct, readHex, readSigned,\n"
"readFloat, lexDigits,\n"
"--  module Ratio,\n"
"Ratio((:%)), (%), numerator, denominator,\n"
"--  Non-standard exports\n"
"IO(..), IOResult(..),\n"
"IOException(..), IOErrorType(..),\n"
"Exception(..),\n"
"ArithException(..), ArrayException(..), AsyncException(..),\n"
"ExitCode(..),\n"
"FunPtr, Ptr, Addr,\n"
"Word, StablePtr, ForeignObj, ForeignPtr,\n"
"Int8, Int16, Int32, Int64,\n"
"Word8, Word16, Word32, Word64,\n"
"Handle, Object,\n"
"basicIORun, blockIO, IOFinished(..),\n"
"threadToIOResult,\n"
"catchException, throw,\n"
"Dynamic(..), TypeRep(..), Key(..), TyCon(..), Obj,\n"
"\n"
"Bool(False, True),\n"
"Maybe(Nothing, Just),\n"
"Either(Left, Right),\n"
"Ordering(LT, EQ, GT),\n"
"Char, String, Int, Integer, Float, Double, Rational, IO,\n"
"--  List type: []((:), [])\n"
"(:),\n"
"--  Tuple types: (,), (,,), etc.\n"
"--  Trivial type: ()\n"
"--  Functions: (->)\n"
"Rec, emptyRec, EmptyRow, -- non-standard, should only be exported if TREX\n"
"Eq((==), (/=)),\n"
"Ord(compare, (<), (<=), (>=), (>), max, min),\n"
"Enum(succ, pred, toEnum, fromEnum, enumFrom, enumFromThen,\n"
"enumFromTo, enumFromThenTo),\n"
"Bounded(minBound, maxBound),\n"
"--  Num((+), (-), (*), negate, abs, signum, fromInteger),\n"
"Num((+), (-), (*), negate, abs, signum, fromInteger, fromInt),\n"
"Real(toRational),\n"
"--  Integral(quot, rem, div, mod, quotRem, divMod, toInteger),\n"
"Integral(quot, rem, div, mod, quotRem, divMod, toInteger, toInt),\n"
"--  Fractional((/), recip, fromRational),\n"
"Fractional((/), recip, fromRational, fromDouble),\n"
"Floating(pi, exp, log, sqrt, (**), logBase, sin, cos, tan,\n"
"asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh),\n"
"RealFrac(properFraction, truncate, round, ceiling, floor),\n"
"RealFloat(floatRadix, floatDigits, floatRange, decodeFloat,\n"
"encodeFloat, exponent, significand, scaleFloat, isNaN,\n"
"isInfinite, isDenormalized, isIEEE, isNegativeZero, atan2),\n"
"Monad((>>=), (>>), return, fail),\n"
"Functor(fmap),\n"
"mapM, mapM_, sequence, sequence_, (=<<),\n"
"maybe, either,\n"
"(&&), (||), not, otherwise,\n"
"subtract, even, odd, gcd, lcm, (^), (^^),\n"
"fromIntegral, realToFrac,\n"
"fst, snd, curry, uncurry, id, const, (.), flip, ($), until,\n"
"asTypeOf, error, undefined,\n"
"seq, ($!),\n"
"\n"
"numericEnumFrom,\n"
"numericEnumFromTo,\n"
"numericEnumFromThen,\n"
"numericEnumFromThenTo\n"
") where\n"
"\n"
"-- Standard value bindings {Prelude} ----------------------------------------\n"
"\n"
"infixr 9  .\n"
"infixl 9  !!\n"
"infixr 8  ^, ^^, **\n"
"infixl 7  *, /, `quot`, `rem`, `div`, `mod`, :%, %\n"
"infixl 6  +, -\n"
"--infixr 5  :    -- this fixity declaration is hard-wired into Hugs\n"
"infixr 5  ++\n"
"infix  4  ==, /=, <, <=, >=, >, `elem`, `notElem`\n"
"infixr 3  &&\n"
"infixr 2  ||\n"
"infixl 1  >>, >>=\n"
"infixr 1  =<<\n"
"infixr 0  $, $!, `seq`\n"
"\n"
"-- Equality and Ordered classes ---------------------------------------------\n"
"\n"
"class Eq a where\n"
"(==), (/=) :: a -> a -> Bool\n"
"\n"
"-- Minimal complete definition: (==) or (/=)\n"
"x == y      = not (x/=y)\n"
"x /= y      = not (x==y)\n"
"\n"
"class (Eq a) => Ord a where\n"
"compare                :: a -> a -> Ordering\n"
"(<), (<=), (>=), (>)   :: a -> a -> Bool\n"
"max, min               :: a -> a -> a\n"
"\n"
"-- Minimal complete definition: (<=) or compare\n"
"-- using compare can be more efficient for complex types\n"
"compare x y | x==y      = EQ\n"
"| x<=y      = LT\n"
"| otherwise = GT\n"
"\n"
"x <= y                  = compare x y /= GT\n"
"x <  y                  = compare x y == LT\n"
"x >= y                  = compare x y /= LT\n"
"x >  y                  = compare x y == GT\n"
"\n"
"max x y   | x <= y      = y\n"
"| otherwise   = x\n"
"min x y   | x <= y      = x\n"
"| otherwise   = y\n"
"\n"
"class Bounded a where\n"
"minBound, maxBound :: a\n"
"-- Minimal complete definition: All\n"
"\n"
"-- Numeric classes ----------------------------------------------------------\n"
"\n"
"class (Eq a, Show a) => Num a where\n"
"(+), (-), (*)  :: a -> a -> a\n"
"negate         :: a -> a\n"
"abs, signum    :: a -> a\n"
"fromInteger    :: Integer -> a\n"
"fromInt        :: Int -> a\n"
"\n"
"-- Minimal complete definition: All, except negate or (-)\n"
"x - y           = x + negate y\n"
"fromInt         = fromIntegral\n"
"negate x        = 0 - x\n"
"\n"
"class (Num a, Ord a) => Real a where\n"
"toRational     :: a -> Rational\n"
"\n"
"class (Real a, Enum a) => Integral a where\n"
"quot, rem, div, mod :: a -> a -> a\n"
"quotRem, divMod     :: a -> a -> (a,a)\n"
"toInteger           :: a -> Integer\n"
"toInt               :: a -> Int\n"
"\n"
"-- Minimal complete definition: quotRem and toInteger\n"
"n `quot` d           = q where (q,r) = quotRem n d\n"
"n `rem` d            = r where (q,r) = quotRem n d\n"
"n `div` d            = q where (q,r) = divMod n d\n"
"n `mod` d            = r where (q,r) = divMod n d\n"
"divMod n d           = if signum r == - signum d then (q-1, r+d) else qr\n"
"where qr@(q,r) = quotRem n d\n"
"toInt                = toInt . toInteger\n"
"\n"
"class (Num a) => Fractional a where\n"
"(/)          :: a -> a -> a\n"
"recip        :: a -> a\n"
"fromRational :: Rational -> a\n"
"fromDouble   :: Double -> a\n"
"\n"
"-- Minimal complete definition: fromRational and ((/) or recip)\n"
"recip x       = 1 / x\n"
"fromDouble    = fromRational . fromDouble\n"
"x / y         = x * recip y\n"
"\n"
"\n"
"class (Fractional a) => Floating a where\n"
"pi                  :: a\n"
"exp, log, sqrt      :: a -> a\n"
"(**), logBase       :: a -> a -> a\n"
"sin, cos, tan       :: a -> a\n"
"asin, acos, atan    :: a -> a\n"
"sinh, cosh, tanh    :: a -> a\n"
"asinh, acosh, atanh :: a -> a\n"
"\n"
"-- Minimal complete definition: pi, exp, log, sin, cos, sinh, cosh,\n"
"--				    asinh, acosh, atanh\n"
"pi                   = 4 * atan 1\n"
"x ** y               = exp (log x * y)\n"
"logBase x y          = log y / log x\n"
"sqrt x               = x ** 0.5\n"
"tan x                = sin x / cos x\n"
"sinh x               = (exp x - exp (-x)) / 2\n"
"cosh x               = (exp x + exp (-x)) / 2\n"
"tanh x               = sinh x / cosh x\n"
"asinh x              = log (x + sqrt (x*x + 1))\n"
"acosh x              = log (x + sqrt (x*x - 1))\n"
"atanh x              = (log (1 + x) - log (1 - x)) / 2\n"
"\n"
"class (Real a, Fractional a) => RealFrac a where\n"
"properFraction   :: (Integral b) => a -> (b,a)\n"
"truncate, round  :: (Integral b) => a -> b\n"
"ceiling, floor   :: (Integral b) => a -> b\n"
"\n"
"-- Minimal complete definition: properFraction\n"
"truncate x        = m where (m,_) = properFraction x\n"
"\n"
"round x           = let (n,r) = properFraction x\n"
"m     = if r < 0 then n - 1 else n + 1\n"
"in case signum (abs r - 0.5) of\n"
"-1 -> n\n"
"0  -> if even n then n else m\n"
"1  -> m\n"
"\n"
"ceiling x         = if r > 0 then n + 1 else n\n"
"where (n,r) = properFraction x\n"
"\n"
"floor x           = if r < 0 then n - 1 else n\n"
"where (n,r) = properFraction x\n"
"\n"
"class (RealFrac a, Floating a) => RealFloat a where\n"
"floatRadix       :: a -> Integer\n"
"floatDigits      :: a -> Int\n"
"floatRange       :: a -> (Int,Int)\n"
"decodeFloat      :: a -> (Integer,Int)\n"
"encodeFloat      :: Integer -> Int -> a\n"
"exponent         :: a -> Int\n"
"significand      :: a -> a\n"
"scaleFloat       :: Int -> a -> a\n"
"isNaN, isInfinite, isDenormalized, isNegativeZero, isIEEE\n"
":: a -> Bool\n"
"atan2	     :: a -> a -> a\n"
"\n"
"-- Minimal complete definition: All, except exponent, signficand,\n"
"--				    scaleFloat, atan2\n"
"exponent x        = if m==0 then 0 else n + floatDigits x\n"
"where (m,n) = decodeFloat x\n"
"significand x     = encodeFloat m (- floatDigits x)\n"
"where (m,_) = decodeFloat x\n"
"scaleFloat k x    = encodeFloat m (n+k)\n"
"where (m,n) = decodeFloat x\n"
"atan2 y x\n"
"| x>0           = atan (y/x)\n"
"| x==0 && y>0   = pi/2\n"
"| x<0 && y>0    = pi + atan (y/x)\n"
"| (x<=0 && y<0) ||\n"
"(x<0 && isNegativeZero y) ||\n"
"(isNegativeZero x && isNegativeZero y)\n"
"= - atan2 (-y) x\n"
"| y==0 && (x<0 || isNegativeZero x)\n"
"= pi    -- must be after the previous test on zero y\n"
"| x==0 && y==0  = y     -- must be after the other double zero tests\n"
"| otherwise     = x + y -- x or y is a NaN, return a NaN (via +)\n"
"\n"
"-- Numeric functions --------------------------------------------------------\n"
"\n"
"subtract       :: Num a => a -> a -> a\n"
"subtract        = flip (-)\n"
"\n"
"even, odd        :: (Integral a) => a -> Bool\n"
"even n           =  n `rem` 2 == 0\n"
"odd              =  not . even\n"
"\n"
"gcd            :: Integral a => a -> a -> a\n"
"gcd 0 0         = error \"Prelude.gcd: gcd 0 0 is undefined\"\n"
"gcd x y         = gcd' (abs x) (abs y)\n"
"where gcd' x 0 = x\n"
"gcd' x y = gcd' y (x `rem` y)\n"
"\n"
"lcm            :: (Integral a) => a -> a -> a\n"
"lcm _ 0         = 0\n"
"lcm 0 _         = 0\n"
"lcm x y         = abs ((x `quot` gcd x y) * y)\n"
"\n"
"(^)            :: (Num a, Integral b) => a -> b -> a\n"
"x ^ 0           = 1\n"
"x ^ n  | n > 0  = f x (n-1) x\n"
"where f _ 0 y = y\n"
"f x n y = g x n where\n"
"g x n | even n    = g (x*x) (n`quot`2)\n"
"| otherwise = f x (n-1) (x*y)\n"
"_ ^ _           = error \"Prelude.^: negative exponent\"\n"
"\n"
"(^^)           :: (Fractional a, Integral b) => a -> b -> a\n"
"x ^^ n          = if n >= 0 then x ^ n else recip (x^(-n))\n"
"\n"
"fromIntegral   :: (Integral a, Num b) => a -> b\n"
"fromIntegral    = fromInteger . toInteger\n"
"\n"
"realToFrac     :: (Real a, Fractional b) => a -> b\n"
"realToFrac      = fromRational . toRational\n"
"\n"
"-- Index and Enumeration classes --------------------------------------------\n"
"\n"
"class (Ord a) => Ix a where\n"
"range                :: (a,a) -> [a]\n"
"index, unsafeIndex   :: (a,a) -> a -> Int\n"
"inRange              :: (a,a) -> a -> Bool\n"
"rangeSize            :: (a,a) -> Int\n"
"unsafeRangeSize      :: (a,a) -> Int\n"
"\n"
"-- Must specify one of index, unsafeIndex\n"
"index b i | inRange b i = unsafeIndex b i\n"
"| otherwise   = error \"Error in array index\"\n"
"unsafeIndex b i = index b i\n"
"\n"
"-- As long as you don't override the default rangeSize,\n"
"-- you can specify unsafeRangeSize as follows, to speed up\n"
"-- some operations:\n"
"--\n"
"--    unsafeRangeSize b@(_l,h) = unsafeIndex b h + 1\n"
"--\n"
"rangeSize b@(_l,h) | inRange b h = unsafeIndex b h + 1\n"
"| otherwise   = 0\n"
"unsafeRangeSize b = rangeSize b\n"
"\n"
"-- NB: replacing \"inRange b h\" by  \"l <= u\"\n"
"-- fails if the bounds are tuples.  For example,\n"
"-- 	(1,2) <= (2,1)\n"
"-- but the range is nevertheless empty\n"
"--	range ((1,2),(2,1)) = []\n"
"\n"
"class Enum a where\n"
"succ, pred           :: a -> a\n"
"toEnum               :: Int -> a\n"
"fromEnum             :: a -> Int\n"
"enumFrom             :: a -> [a]              -- [n..]\n"
"enumFromThen         :: a -> a -> [a]         -- [n,m..]\n"
"enumFromTo           :: a -> a -> [a]         -- [n..m]\n"
"enumFromThenTo       :: a -> a -> a -> [a]    -- [n,n'..m]\n"
"\n"
"-- Minimal complete definition: toEnum, fromEnum\n"
"succ                  = toEnum . (1+)       . fromEnum\n"
"pred                  = toEnum . subtract 1 . fromEnum\n"
"enumFrom x            = map toEnum [ fromEnum x ..]\n"
"enumFromTo x y        = map toEnum [ fromEnum x .. fromEnum y ]\n"
"enumFromThen x y      = map toEnum [ fromEnum x, fromEnum y ..]\n"
"enumFromThenTo x y z  = map toEnum [ fromEnum x, fromEnum y .. fromEnum z ]\n"
"\n"
"-- Read and Show classes ------------------------------------------------------\n"
"\n"
"type ReadS a = String -> [(a,String)]\n"
"type ShowS   = String -> String\n"
"\n"
"class Read a where\n"
"readsPrec :: Int -> ReadS a\n"
"readList  :: ReadS [a]\n"
"\n"
"-- Minimal complete definition: readsPrec\n"
"readList   = readParen False (\\r -> [pr | (\"[\",s) <- lex r,\n"
"pr      <- readl s ])\n"
"where readl  s = [([],t)   | (\"]\",t) <- lex s] ++\n"
"[(x:xs,u) | (x,t)   <- reads s,\n"
"(xs,u)  <- readl' t]\n"
"readl' s = [([],t)   | (\"]\",t) <- lex s] ++\n"
"[(x:xs,v) | (\",\",t) <- lex s,\n"
"(x,u)   <- reads t,\n"
"(xs,v)  <- readl' u]\n"
"\n"
"class Show a where\n"
"show      :: a -> String\n"
"showsPrec :: Int -> a -> ShowS\n"
"showList  :: [a] -> ShowS\n"
"\n"
"-- Minimal complete definition: show or showsPrec\n"
"show x          = showsPrec 0 x \"\"\n"
"showsPrec _ x s = show x ++ s\n"
"showList []     = showString \"[]\"\n"
"showList (x:xs) = showChar '[' . shows x . showl xs\n"
"where showl []     = showChar ']'\n"
"showl (x:xs) = showChar ',' . shows x . showl xs\n"
"\n"
"-- Monad classes ------------------------------------------------------------\n"
"\n"
"class Functor f where\n"
"fmap :: (a -> b) -> (f a -> f b)\n"
"\n"
"class Monad m where\n"
"return :: a -> m a\n"
"(>>=)  :: m a -> (a -> m b) -> m b\n"
"(>>)   :: m a -> m b -> m b\n"
"fail   :: String -> m a\n"
"\n"
"-- Minimal complete definition: (>>=), return\n"
"p >> q  = p >>= \\ _ -> q\n"
"fail s  = error s\n"
"\n"
"sequence       :: Monad m => [m a] -> m [a]\n"
"sequence []     = return []\n"
"sequence (c:cs) = do x  <- c\n"
"xs <- sequence cs\n"
"return (x:xs)\n"
"\n"
"sequence_        :: Monad m => [m a] -> m ()\n"
"sequence_         = foldr (>>) (return ())\n"
"\n"
"mapM             :: Monad m => (a -> m b) -> [a] -> m [b]\n"
"mapM f            = sequence . map f\n"
"\n"
"mapM_            :: Monad m => (a -> m b) -> [a] -> m ()\n"
"mapM_ f           = sequence_ . map f\n"
"\n"
"(=<<)            :: Monad m => (a -> m b) -> m a -> m b\n"
"f =<< x           = x >>= f\n"
"\n"
"-- Evaluation and strictness ------------------------------------------------\n"
"\n"
"primitive seq           :: a -> b -> b\n"
"\n"
"primitive ($!) \"strict\" :: (a -> b) -> a -> b\n"
"-- f $! x                = x `seq` f x\n"
"\n"
"-- Trivial type -------------------------------------------------------------\n"
"\n"
"-- data () = () deriving (Eq, Ord, Ix, Enum, Read, Show, Bounded)\n"
"\n"
"instance Eq () where\n"
"() == ()  =  True\n"
"\n"
"instance Ord () where\n"
"compare () () = EQ\n"
"\n"
"instance Ix () where\n"
"range ((),())      = [()]\n"
"index ((),()) ()   = 0\n"
"inRange ((),()) () = True\n"
"\n"
"instance Enum () where\n"
"toEnum 0           = ()\n"
"fromEnum ()        = 0\n"
"enumFrom ()        = [()]\n"
"enumFromThen () () = [()]\n"
"\n"
"instance Read () where\n"
"readsPrec p = readParen False (\\r -> [((),t) | (\"(\",s) <- lex r,\n"
"(\")\",t) <- lex s ])\n"
"\n"
"instance Show () where\n"
"showsPrec p () = showString \"()\"\n"
"\n"
"instance Bounded () where\n"
"minBound = ()\n"
"maxBound = ()\n"
"\n"
"-- Boolean type -------------------------------------------------------------\n"
"\n"
"data Bool    = False | True\n"
"deriving (Eq, Ord, Ix, Enum, Read, Show, Bounded)\n"
"\n"
"(&&), (||)  :: Bool -> Bool -> Bool\n"
"False && x   = False\n"
"True  && x   = x\n"
"False || x   = x\n"
"True  || x   = True\n"
"\n"
"not         :: Bool -> Bool\n"
"not True     = False\n"
"not False    = True\n"
"\n"
"otherwise   :: Bool\n"
"otherwise    = True\n"
"\n"
"-- Character type -----------------------------------------------------------\n"
"\n"
"data Char               -- builtin datatype of ISO Latin characters\n"
"type String = [Char]    -- strings are lists of characters\n"
"\n"
"primitive primEqChar    :: Char -> Char -> Bool\n"
"primitive primCmpChar   :: Char -> Char -> Ordering\n"
"\n"
"instance Eq Char  where (==)    = primEqChar\n"
"instance Ord Char where compare = primCmpChar\n"
"\n"
"primitive primCharToInt :: Char -> Int\n"
"primitive primIntToChar :: Int -> Char\n"
"\n"
"instance Enum Char where\n"
"toEnum           = primIntToChar\n"
"fromEnum         = primCharToInt\n"
"enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Char)]\n"
"enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (lastChar::Char)]\n"
"where lastChar = if d < c then minBound else maxBound\n"
"\n"
"instance Ix Char where\n"
"range (c,c')      = [c..c']\n"
"index b@(c,c') ci\n"
"| inRange b ci = fromEnum ci - fromEnum c\n"
"| otherwise    = error \"Ix.index: Index out of range.\"\n"
"inRange (c,c') ci = fromEnum c <= i && i <= fromEnum c'\n"
"where i = fromEnum ci\n"
"\n"
"instance Read Char where\n"
"readsPrec p      = readParen False\n"
"(\\r -> [(c,t) | ('\\'':s,t) <- lex r,\n"
"(c,\"\\'\")   <- readLitChar s ])\n"
"readList = readParen False (\\r -> [(l,t) | ('\"':s, t) <- lex r,\n"
"(l,_)      <- readl s ])\n"
"where readl ('\"':s)      = [(\"\",s)]\n"
"readl ('\\\\':'&':s) = readl s\n"
"readl s            = [(c:cs,u) | (c ,t) <- readLitChar s,\n"
"(cs,u) <- readl t ]\n"
"instance Show Char where\n"
"showsPrec p '\\'' = showString \"'\\\\''\"\n"
"showsPrec p c    = showChar '\\'' . showLitChar c . showChar '\\''\n"
"\n"
"showList cs   = showChar '\"' . showl cs\n"
"where showl \"\"       = showChar '\"'\n"
"showl ('\"':cs) = showString \"\\\\\\\"\" . showl cs\n"
"showl (c:cs)   = showLitChar c . showl cs\n"
"\n"
"instance Bounded Char where\n"
"minBound = '\\0'\n"
"maxBound = '\\255'\n"
"\n"
"isSpace, isUpper, isLower, isAlpha, isDigit, isAlphaNum :: Char -> Bool\n"
"\n"
"isSpace c              =  c == ' '  ||\n"
"c == '\\t' ||\n"
"c == '\\n' ||\n"
"c == '\\r' ||\n"
"c == '\\f' ||\n"
"c == '\\v' ||\n"
"c == '\\xa0'\n"
"\n"
"isUpper c              =  c >= 'A'    && c <= 'Z'    ||\n"
"c >= '\\xc0' && c <= '\\xd6' ||\n"
"c >= '\\xd8' && c <= '\\xde'\n"
"\n"
"isLower c              =  c >= 'a'   &&  c <= 'z'    ||\n"
"c >= '\\xdf' && c <= '\\xf6' ||\n"
"c >= '\\xf8' && c <= '\\xff'\n"
"\n"
"isAlpha c              =  isUpper c  ||  isLower c\n"
"isDigit c              =  c >= '0'   &&  c <= '9'\n"
"isAlphaNum c           =  isAlpha c  ||  isDigit c\n"
"\n"
"-- Maybe type ---------------------------------------------------------------\n"
"\n"
"data Maybe a = Nothing | Just a\n"
"deriving (Eq, Ord, Read, Show)\n"
"\n"
"maybe             :: b -> (a -> b) -> Maybe a -> b\n"
"maybe n f Nothing  = n\n"
"maybe n f (Just x) = f x\n"
"\n"
"instance Functor Maybe where\n"
"fmap f Nothing  = Nothing\n"
"fmap f (Just x) = Just (f x)\n"
"\n"
"instance Monad Maybe where\n"
"Just x  >>= k = k x\n"
"Nothing >>= k = Nothing\n"
"return        = Just\n"
"fail s        = Nothing\n"
"\n"
"-- Either type --------------------------------------------------------------\n"
"\n"
"data Either a b = Left a | Right b\n"
"deriving (Eq, Ord, Read, Show)\n"
"\n"
"either              :: (a -> c) -> (b -> c) -> Either a b -> c\n"
"either l r (Left x)  = l x\n"
"either l r (Right y) = r y\n"
"\n"
"-- Ordering type ------------------------------------------------------------\n"
"\n"
"data Ordering = LT | EQ | GT\n"
"deriving (Eq, Ord, Ix, Enum, Read, Show, Bounded)\n"
"\n"
"-- Lists --------------------------------------------------------------------\n"
"\n"
"-- data [a] = [] | a : [a] deriving (Eq, Ord)\n"
"\n"
"instance Eq a => Eq [a] where\n"
"[]     == []     =  True\n"
"(x:xs) == (y:ys) =  x==y && xs==ys\n"
"_      == _      =  False\n"
"\n"
"instance Ord a => Ord [a] where\n"
"compare []     (_:_)  = LT\n"
"compare []     []     = EQ\n"
"compare (_:_)  []     = GT\n"
"compare (x:xs) (y:ys) = primCompAux x y (compare xs ys)\n"
"\n"
"instance Functor [] where\n"
"fmap = map\n"
"\n"
"instance Monad [ ] where\n"
"(x:xs) >>= f = f x ++ (xs >>= f)\n"
"[]     >>= f = []\n"
"return x     = [x]\n"
"fail s       = []\n"
"\n"
"instance Read a => Read [a]  where\n"
"readsPrec p = readList\n"
"\n"
"instance Show a => Show [a]  where\n"
"showsPrec p = showList\n"
"\n"
"-- Tuples -------------------------------------------------------------------\n"
"\n"
"-- data (a,b) = (a,b) deriving (Eq, Ord, Ix, Read, Show)\n"
"-- etc..\n"
"\n"
"-- Standard Integral types --------------------------------------------------\n"
"\n"
"data Int      -- builtin datatype of fixed size integers\n"
"data Integer  -- builtin datatype of arbitrary size integers\n"
"\n"
"primitive primEqInt      :: Int -> Int -> Bool\n"
"primitive primCmpInt     :: Int -> Int -> Ordering\n"
"primitive primEqInteger  :: Integer -> Integer -> Bool\n"
"primitive primCmpInteger :: Integer -> Integer -> Ordering\n"
"\n"
"instance Eq  Int     where (==)    = primEqInt\n"
"instance Eq  Integer where (==)    = primEqInteger\n"
"instance Ord Int     where compare = primCmpInt\n"
"instance Ord Integer where compare = primCmpInteger\n"
"\n"
"primitive primPlusInt,\n"
"primMinusInt,\n"
"primMulInt	   :: Int -> Int -> Int\n"
"primitive primNegInt	   :: Int -> Int\n"
"primitive primIntegerToInt :: Integer -> Int\n"
"\n"
"instance Num Int where\n"
"(+)           = primPlusInt\n"
"(-)           = primMinusInt\n"
"negate        = primNegInt\n"
"(*)           = primMulInt\n"
"abs           = absReal\n"
"signum        = signumReal\n"
"fromInteger   = primIntegerToInt\n"
"fromInt x     = x\n"
"\n"
"primitive primMinInt, primMaxInt :: Int\n"
"\n"
"instance Bounded Int where\n"
"minBound = primMinInt\n"
"maxBound = primMaxInt\n"
"\n"
"primitive primPlusInteger,\n"
"primMinusInteger,\n"
"primMulInteger   :: Integer -> Integer -> Integer\n"
"primitive primNegInteger   :: Integer -> Integer\n"
"primitive primIntToInteger :: Int -> Integer\n"
"\n"
"instance Num Integer where\n"
"(+)           = primPlusInteger\n"
"(-)           = primMinusInteger\n"
"negate        = primNegInteger\n"
"(*)           = primMulInteger\n"
"abs           = absReal\n"
"signum        = signumReal\n"
"fromInteger x = x\n"
"fromInt       = primIntToInteger\n"
"\n"
"absReal x    | x >= 0    = x\n"
"| otherwise = -x\n"
"\n"
"signumReal x | x == 0    =  0\n"
"| x > 0     =  1\n"
"| otherwise = -1\n"
"\n"
"instance Real Int where\n"
"toRational x = toInteger x % 1\n"
"\n"
"instance Real Integer where\n"
"toRational x = x % 1\n"
"\n"
"primitive primDivInt,\n"
"primQuotInt,\n"
"primRemInt,\n"
"primModInt  :: Int -> Int -> Int\n"
"primitive primQrmInt  :: Int -> Int -> (Int,Int)\n"
"\n"
"instance Integral Int where\n"
"div       = primDivInt\n"
"quot      = primQuotInt\n"
"rem       = primRemInt\n"
"mod       = primModInt\n"
"quotRem   = primQrmInt\n"
"toInteger = primIntToInteger\n"
"toInt x   = x\n"
"\n"
"primitive primQrmInteger  :: Integer -> Integer -> (Integer,Integer)\n"
"\n"
"instance Integral Integer where\n"
"quotRem     = primQrmInteger\n"
"toInteger x = x\n"
"toInt       = primIntegerToInt\n"
"\n"
"instance Ix Int where\n"
"range (m,n)          = [m..n]\n"
"index b@(m,n) i\n"
"| inRange b i = i - m\n"
"| otherwise   = error \"index: Index out of range\"\n"
"inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Ix Integer where\n"
"range (m,n)          = [m..n]\n"
"index b@(m,n) i\n"
"| inRange b i = fromInteger (i - m)\n"
"| otherwise   = error \"index: Index out of range\"\n"
"inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Int where\n"
"toEnum               = id\n"
"fromEnum             = id\n"
"enumFrom       = numericEnumFrom\n"
"enumFromTo     = numericEnumFromTo\n"
"enumFromThen   = numericEnumFromThen\n"
"enumFromThenTo = numericEnumFromThenTo\n"
"\n"
"instance Enum Integer where\n"
"succ x         = x + 1\n"
"pred x         = x - 1\n"
"\n"
"toEnum         = primIntToInteger\n"
"fromEnum       = primIntegerToInt\n"
"enumFrom       = numericEnumFrom\n"
"enumFromThen   = numericEnumFromThen\n"
"enumFromTo     = numericEnumFromTo\n"
"enumFromThenTo = numericEnumFromThenTo\n"
"\n"
"\n"
"numericEnumFrom        :: Real a => a -> [a]\n"
"numericEnumFromThen    :: Real a => a -> a -> [a]\n"
"numericEnumFromTo      :: Real a => a -> a -> [a]\n"
"numericEnumFromThenTo  :: Real a => a -> a -> a -> [a]\n"
"numericEnumFrom n            = n : (numericEnumFrom $! (n+1))\n"
"numericEnumFromThen n m      = iterate ((m-n)+) n\n"
"numericEnumFromTo n m        = takeWhile (<= m) (numericEnumFrom n)\n"
"numericEnumFromThenTo n n' m = takeWhile p (numericEnumFromThen n n')\n"
"where p | n' >= n   = (<= m)\n"
"| otherwise = (>= m)\n"
"\n"
"primitive primShowsInt :: Int -> Int -> ShowS\n"
"\n"
"instance Read Int where\n"
"readsPrec p = readSigned readDec\n"
"\n"
"instance Show Int where\n"
"showsPrec   = primShowsInt\n"
"\n"
"primitive primShowsInteger :: Int -> Integer -> ShowS\n"
"\n"
"instance Read Integer where\n"
"readsPrec p = readSigned readDec\n"
"\n"
"instance Show Integer where\n"
"showsPrec   = primShowsInteger\n"
"\n"
"-- Standard Floating types --------------------------------------------------\n"
"\n"
"data Float     -- builtin datatype of single precision floating point numbers\n"
"data Double    -- builtin datatype of double precision floating point numbers\n"
"\n"
"primitive primEqFloat   :: Float -> Float -> Bool\n"
"primitive primCmpFloat  :: Float -> Float -> Ordering\n"
"primitive primEqDouble  :: Double -> Double -> Bool\n"
"primitive primCmpDouble :: Double -> Double -> Ordering\n"
"\n"
"instance Eq  Float  where (==) = primEqFloat\n"
"instance Eq  Double where (==) = primEqDouble\n"
"\n"
"instance Ord Float  where compare = primCmpFloat\n"
"instance Ord Double where compare = primCmpDouble\n"
"\n"
"primitive primPlusFloat,\n"
"primMinusFloat,\n"
"primMulFloat       :: Float -> Float -> Float\n"
"primitive primNegFloat       :: Float -> Float\n"
"primitive primIntToFloat     :: Int -> Float\n"
"primitive primIntegerToFloat :: Integer -> Float\n"
"\n"
"instance Num Float where\n"
"(+)           = primPlusFloat\n"
"(-)           = primMinusFloat\n"
"negate        = primNegFloat\n"
"(*)           = primMulFloat\n"
"abs           = absReal\n"
"signum        = signumReal\n"
"fromInteger   = primIntegerToFloat\n"
"fromInt       = primIntToFloat\n"
"\n"
"primitive primPlusDouble,\n"
"primMinusDouble,\n"
"primMulDouble       :: Double -> Double -> Double\n"
"primitive primNegDouble       :: Double -> Double\n"
"primitive primIntToDouble     :: Int -> Double\n"
"primitive primIntegerToDouble :: Integer -> Double\n"
"\n"
"instance Num Double where\n"
"(+)         = primPlusDouble\n"
"(-)         = primMinusDouble\n"
"negate      = primNegDouble\n"
"(*)         = primMulDouble\n"
"abs         = absReal\n"
"signum      = signumReal\n"
"fromInteger = primIntegerToDouble\n"
"fromInt     = primIntToDouble\n"
"\n"
"instance Real Float where\n"
"toRational = floatToRational\n"
"\n"
"instance Real Double where\n"
"toRational = doubleToRational\n"
"\n"
"-- Calls to these functions are optimised when passed as arguments to\n"
"-- fromRational.\n"
"floatToRational  :: Float  -> Rational\n"
"doubleToRational :: Double -> Rational\n"
"floatToRational  x = realFloatToRational x\n"
"doubleToRational x = realFloatToRational x\n"
"\n"
"realFloatToRational x = (m%1)*(b%1)^^n\n"
"where (m,n) = decodeFloat x\n"
"b     = floatRadix x\n"
"\n"
"primitive primDivFloat      :: Float -> Float -> Float\n"
"primitive doubleToFloat     :: Double -> Float\n"
"\n"
"instance Fractional Float where\n"
"(/)          = primDivFloat\n"
"fromRational = primRationalToFloat\n"
"fromDouble   = doubleToFloat\n"
"\n"
"primitive primDivDouble :: Double -> Double -> Double\n"
"\n"
"instance Fractional Double where\n"
"(/)          = primDivDouble\n"
"fromRational = primRationalToDouble\n"
"fromDouble x = x\n"
"\n"
"-- These primitives are equivalent to (and are defined using)\n"
"-- rationalTo{Float,Double}.  The difference is that they test to see\n"
"-- if their argument is of the form (fromDouble x) - which allows a much\n"
"-- more efficient implementation.\n"
"primitive primRationalToFloat  :: Rational -> Float\n"
"primitive primRationalToDouble :: Rational -> Double\n"
"\n"
"-- These functions are used by Hugs - don't change their types.\n"
"rationalToFloat  :: Rational -> Float\n"
"rationalToDouble :: Rational -> Double\n"
"rationalToFloat  = rationalToRealFloat\n"
"rationalToDouble = rationalToRealFloat\n"
"\n"
"rationalToRealFloat x = x'\n"
"where x'    = f e\n"
"f e   = if e' == e then y else f e'\n"
"where y      = encodeFloat (round (x * (1%b)^^e)) e\n"
"(_,e') = decodeFloat y\n"
"(_,e) = decodeFloat (fromInteger (numerator x) `asTypeOf` x'\n"
"/ fromInteger (denominator x))\n"
"b     = floatRadix x'\n"
"\n"
"primitive primSinFloat,  primAsinFloat, primCosFloat,\n"
"primAcosFloat, primTanFloat,  primAtanFloat,\n"
"primLogFloat,  primExpFloat,  primSqrtFloat :: Float -> Float\n"
"\n"
"instance Floating Float where\n"
"exp   = primExpFloat\n"
"log   = primLogFloat\n"
"sqrt  = primSqrtFloat\n"
"sin   = primSinFloat\n"
"cos   = primCosFloat\n"
"tan   = primTanFloat\n"
"asin  = primAsinFloat\n"
"acos  = primAcosFloat\n"
"atan  = primAtanFloat\n"
"\n"
"primitive primSinDouble,  primAsinDouble, primCosDouble,\n"
"primAcosDouble, primTanDouble,  primAtanDouble,\n"
"primLogDouble,  primExpDouble,  primSqrtDouble :: Double -> Double\n"
"\n"
"instance Floating Double where\n"
"exp   = primExpDouble\n"
"log   = primLogDouble\n"
"sqrt  = primSqrtDouble\n"
"sin   = primSinDouble\n"
"cos   = primCosDouble\n"
"tan   = primTanDouble\n"
"asin  = primAsinDouble\n"
"acos  = primAcosDouble\n"
"atan  = primAtanDouble\n"
"\n"
"instance RealFrac Float where\n"
"properFraction = floatProperFraction\n"
"\n"
"instance RealFrac Double where\n"
"properFraction = floatProperFraction\n"
"\n"
"floatProperFraction x\n"
"| n >= 0      = (fromInteger m * fromInteger b ^ n, 0)\n"
"| otherwise   = (fromInteger w, encodeFloat r n)\n"
"where (m,n) = decodeFloat x\n"
"b     = floatRadix x\n"
"(w,r) = quotRem m (b^(-n))\n"
"\n"
"primitive primFloatRadix  :: Integer\n"
"primitive primFloatDigits :: Int\n"
"primitive primFloatMinExp,\n"
"primFloatMaxExp :: Int\n"
"primitive primFloatEncode :: Integer -> Int -> Float\n"
"primitive primFloatDecode :: Float -> (Integer, Int)\n"
"\n"
"instance RealFloat Float where\n"
"floatRadix  _ = primFloatRadix\n"
"floatDigits _ = primFloatDigits\n"
"floatRange  _ = (primFloatMinExp, primFloatMaxExp)\n"
"encodeFloat = primFloatEncode\n"
"decodeFloat = primFloatDecode\n"
"isNaN       _ = False\n"
"isInfinite  _ = False\n"
"isDenormalized _ = False\n"
"isNegativeZero _ = False\n"
"isIEEE      _ = False\n"
"\n"
"primitive primDoubleRadix  :: Integer\n"
"primitive primDoubleDigits :: Int\n"
"primitive primDoubleMinExp,\n"
"primDoubleMaxExp :: Int\n"
"primitive primDoubleEncode :: Integer -> Int -> Double\n"
"primitive primDoubleDecode :: Double -> (Integer, Int)\n"
"\n"
"instance RealFloat Double where\n"
"floatRadix  _ = primDoubleRadix\n"
"floatDigits _ = primDoubleDigits\n"
"floatRange  _ = (primDoubleMinExp, primDoubleMaxExp)\n"
"encodeFloat   = primDoubleEncode\n"
"decodeFloat   = primDoubleDecode\n"
"isNaN       _ = False\n"
"isInfinite  _ = False\n"
"isDenormalized _ = False\n"
"isNegativeZero _ = False\n"
"isIEEE      _ = False\n"
"\n"
"instance Enum Float where\n"
"succ x                = x+1\n"
"pred x                = x-1\n"
"toEnum		  = primIntToFloat\n"
"fromEnum		  = fromInteger . truncate   -- may overflow\n"
"enumFrom		  = numericEnumFrom\n"
"enumFromThen	  = numericEnumFromThen\n"
"enumFromTo n m	  = numericEnumFromTo n (m+1/2)\n"
"enumFromThenTo n n' m = numericEnumFromThenTo n n' (m + (n'-n)/2)\n"
"\n"
"instance Enum Double where\n"
"succ x                = x+1\n"
"pred x                = x-1\n"
"toEnum		  = primIntToDouble\n"
"fromEnum		  = fromInteger . truncate   -- may overflow\n"
"enumFrom		  = numericEnumFrom\n"
"enumFromThen	  = numericEnumFromThen\n"
"enumFromTo n m	  = numericEnumFromTo n (m+1/2)\n"
"enumFromThenTo n n' m = numericEnumFromThenTo n n' (m + (n'-n)/2)\n"
"\n"
"primitive primShowsFloat :: Int -> Float -> ShowS\n"
"\n"
"instance Read Float where\n"
"readsPrec p = readSigned readFloat\n"
"\n"
"-- Note that showFloat in Numeric isn't used here\n"
"instance Show Float where\n"
"showsPrec   = primShowsFloat\n"
"\n"
"primitive primShowsDouble :: Int -> Double -> ShowS\n"
"\n"
"instance Read Double where\n"
"readsPrec p = readSigned readFloat\n"
"\n"
"-- Note that showFloat in Numeric isn't used here\n"
"instance Show Double where\n"
"showsPrec   = primShowsDouble\n"
"\n"
"-- Some standard functions --------------------------------------------------\n"
"\n"
"fst            :: (a,b) -> a\n"
"fst (x,_)       = x\n"
"\n"
"snd            :: (a,b) -> b\n"
"snd (_,y)       = y\n"
"\n"
"curry          :: ((a,b) -> c) -> (a -> b -> c)\n"
"curry f x y     = f (x,y)\n"
"\n"
"uncurry        :: (a -> b -> c) -> ((a,b) -> c)\n"
"uncurry f p     = f (fst p) (snd p)\n"
"\n"
"id             :: a -> a\n"
"id    x         = x\n"
"\n"
"const          :: a -> b -> a\n"
"const k _       = k\n"
"\n"
"(.)            :: (b -> c) -> (a -> b) -> (a -> c)\n"
"(f . g) x       = f (g x)\n"
"\n"
"flip           :: (a -> b -> c) -> b -> a -> c\n"
"flip f x y      = f y x\n"
"\n"
"($)            :: (a -> b) -> a -> b\n"
"f $ x           = f x\n"
"\n"
"until          :: (a -> Bool) -> (a -> a) -> a -> a\n"
"until p f x     = if p x then x else until p f (f x)\n"
"\n"
"asTypeOf       :: a -> a -> a\n"
"asTypeOf        = const\n"
"\n"
"error          :: String -> a\n"
"error s         = throw (ErrorCall s)\n"
"\n"
"undefined      :: a\n"
"undefined       = error \"Prelude.undefined\"\n"
"\n"
"-- Standard functions on rational numbers {PreludeRatio} --------------------\n"
"\n"
"data Integral a => Ratio a = !a :% !a deriving (Eq)\n"
"type Rational              = Ratio Integer\n"
"\n"
"(%)                       :: Integral a => a -> a -> Ratio a\n"
"x % y                      = reduce (x * signum y) (abs y)\n"
"\n"
"reduce                    :: Integral a => a -> a -> Ratio a\n"
"reduce x y | y == 0        = error \"Ratio.%: zero denominator\"\n"
"| otherwise     = (x `quot` d) :% (y `quot` d)\n"
"where d = gcd x y\n"
"\n"
"numerator, denominator    :: Integral a => Ratio a -> a\n"
"numerator (x :% y)         = x\n"
"denominator (x :% y)       = y\n"
"\n"
"instance Integral a => Ord (Ratio a) where\n"
"compare (x:%y) (x':%y') = compare (x*y') (x'*y)\n"
"\n"
"instance Integral a => Num (Ratio a) where\n"
"(x:%y) + (x':%y') = reduce (x*y' + x'*y) (y*y')\n"
"(x:%y) * (x':%y') = reduce (x*x') (y*y')\n"
"negate (x :% y)   = negate x :% y\n"
"abs (x :% y)      = abs x :% y\n"
"signum (x :% y)   = signum x :% 1\n"
"fromInteger x     = fromInteger x :% 1\n"
"fromInt           = intToRatio\n"
"\n"
"-- Hugs optimises code of the form fromRational (intToRatio x)\n"
"intToRatio :: Integral a => Int -> Ratio a\n"
"intToRatio x = fromInt x :% 1\n"
"\n"
"instance Integral a => Real (Ratio a) where\n"
"toRational (x:%y) = toInteger x :% toInteger y\n"
"\n"
"instance Integral a => Fractional (Ratio a) where\n"
"(x:%y) / (x':%y')   = (x*y') % (y*x')\n"
"recip (x:%y)        = y % x\n"
"fromRational (x:%y) = fromInteger x :% fromInteger y\n"
"fromDouble 		= doubleToRatio\n"
"\n"
"-- Hugs optimises code of the form fromRational (doubleToRatio x)\n"
"-- Since this function is private, and only used to convert floating point\n"
"-- literals, it yields a decimal fraction, hopefully the one the user\n"
"-- specified in the first place (but some precision may be lost).  A real\n"
"-- Haskell implementation would use Rational to represent these literals.\n"
"doubleToRatio :: Integral a => Double -> Ratio a\n"
"doubleToRatio x\n"
"| n>=0      = (round (x / fromInteger pow) * fromInteger pow) % 1\n"
"| otherwise = fromRational (round (x * fromInteger denom) % denom)\n"
"where (m,n) = decodeFloat x\n"
"n_dec = ceiling (logBase 10 (encodeFloat 1 n))\n"
"denom = 10 ^ (-n_dec)\n"
"pow   = 10 ^ n_dec\n"
"\n"
"instance Integral a => RealFrac (Ratio a) where\n"
"properFraction (x:%y) = (fromIntegral q, r:%y)\n"
"where (q,r) = quotRem x y\n"
"\n"
"instance Integral a => Enum (Ratio a) where\n"
"succ x         = x+1\n"
"pred x         = x-1\n"
"toEnum         = fromInt\n"
"fromEnum       = fromInteger . truncate   -- may overflow\n"
"enumFrom       = numericEnumFrom\n"
"enumFromTo     = numericEnumFromTo\n"
"enumFromThen   = numericEnumFromThen\n"
"enumFromThenTo = numericEnumFromThenTo\n"
"\n"
"instance (Read a, Integral a) => Read (Ratio a) where\n"
"readsPrec p = readParen (p > 7)\n"
"(\\r -> [(x%y,u) | (x,s)   <- reads r,\n"
"(\"%\",t) <- lex s,\n"
"(y,u)   <- reads t ])\n"
"\n"
"instance Integral a => Show (Ratio a) where\n"
"showsPrec p (x:%y) = showParen (p > 7)\n"
"(shows x . showString \" % \" . shows y)\n"
"\n"
"-- Standard list functions {PreludeList} ------------------------------------\n"
"\n"
"head             :: [a] -> a\n"
"head (x:_)        = x\n"
"\n"
"last             :: [a] -> a\n"
"last [x]          = x\n"
"last (_:xs)       = last xs\n"
"\n"
"tail             :: [a] -> [a]\n"
"tail (_:xs)       = xs\n"
"\n"
"init             :: [a] -> [a]\n"
"init [x]          = []\n"
"init (x:xs)       = x : init xs\n"
"\n"
"null             :: [a] -> Bool\n"
"null []           = True\n"
"null (_:_)        = False\n"
"\n"
"(++)             :: [a] -> [a] -> [a]\n"
"[]     ++ ys      = ys\n"
"(x:xs) ++ ys      = x : (xs ++ ys)\n"
"\n"
"map              :: (a -> b) -> [a] -> [b]\n"
"map f xs          = [ f x | x <- xs ]\n"
"\n"
"filter           :: (a -> Bool) -> [a] -> [a]\n"
"filter p xs       = [ x | x <- xs, p x ]\n"
"\n"
"concat           :: [[a]] -> [a]\n"
"concat            = foldr (++) []\n"
"\n"
"length           :: [a] -> Int\n"
"length            = foldl' (\\n _ -> n + 1) 0\n"
"\n"
"(!!)             :: [a] -> Int -> a\n"
"(x:_)  !! 0       = x\n"
"(_:xs) !! n | n>0 = xs !! (n-1)\n"
"(_:_)  !! _       = error \"Prelude.!!: negative index\"\n"
"[]     !! _       = error \"Prelude.!!: index too large\"\n"
"\n"
"foldl            :: (a -> b -> a) -> a -> [b] -> a\n"
"foldl f z []      = z\n"
"foldl f z (x:xs)  = foldl f (f z x) xs\n"
"\n"
"foldl'           :: (a -> b -> a) -> a -> [b] -> a\n"
"foldl' f a []     = a\n"
"foldl' f a (x:xs) = (foldl' f $! f a x) xs\n"
"\n"
"foldl1           :: (a -> a -> a) -> [a] -> a\n"
"foldl1 f (x:xs)   = foldl f x xs\n"
"\n"
"scanl            :: (a -> b -> a) -> a -> [b] -> [a]\n"
"scanl f q xs      = q : (case xs of\n"
"[]   -> []\n"
"x:xs -> scanl f (f q x) xs)\n"
"\n"
"scanl1           :: (a -> a -> a) -> [a] -> [a]\n"
"scanl1 _ []       = []\n"
"scanl1 f (x:xs)   = scanl f x xs\n"
"\n"
"foldr            :: (a -> b -> b) -> b -> [a] -> b\n"
"foldr f z []      = z\n"
"foldr f z (x:xs)  = f x (foldr f z xs)\n"
"\n"
"foldr1           :: (a -> a -> a) -> [a] -> a\n"
"foldr1 f [x]      = x\n"
"foldr1 f (x:xs)   = f x (foldr1 f xs)\n"
"\n"
"scanr            :: (a -> b -> b) -> b -> [a] -> [b]\n"
"scanr f q0 []     = [q0]\n"
"scanr f q0 (x:xs) = f x q : qs\n"
"where qs@(q:_) = scanr f q0 xs\n"
"\n"
"scanr1           :: (a -> a -> a) -> [a] -> [a]\n"
"scanr1 f []       = []\n"
"scanr1 f [x]      = [x]\n"
"scanr1 f (x:xs)   = f x q : qs\n"
"where qs@(q:_) = scanr1 f xs\n"
"\n"
"iterate          :: (a -> a) -> a -> [a]\n"
"iterate f x       = x : iterate f (f x)\n"
"\n"
"repeat           :: a -> [a]\n"
"repeat x          = xs where xs = x:xs\n"
"\n"
"replicate        :: Int -> a -> [a]\n"
"replicate n x     = take n (repeat x)\n"
"\n"
"cycle            :: [a] -> [a]\n"
"cycle []          = error \"Prelude.cycle: empty list\"\n"
"cycle xs          = xs' where xs'=xs++xs'\n"
"\n"
"take                :: Int -> [a] -> [a]\n"
"take n _  | n <= 0  = []\n"
"take _ []           = []\n"
"take n (x:xs)       = x : take (n-1) xs\n"
"\n"
"drop                :: Int -> [a] -> [a]\n"
"drop n xs | n <= 0  = xs\n"
"drop _ []           = []\n"
"drop n (_:xs)       = drop (n-1) xs\n"
"\n"
"splitAt               :: Int -> [a] -> ([a], [a])\n"
"splitAt n xs | n <= 0 = ([],xs)\n"
"splitAt _ []          = ([],[])\n"
"splitAt n (x:xs)      = (x:xs',xs'') where (xs',xs'') = splitAt (n-1) xs\n"
"\n"
"takeWhile           :: (a -> Bool) -> [a] -> [a]\n"
"takeWhile p []       = []\n"
"takeWhile p (x:xs)\n"
"| p x       = x : takeWhile p xs\n"
"| otherwise = []\n"
"\n"
"dropWhile           :: (a -> Bool) -> [a] -> [a]\n"
"dropWhile p []       = []\n"
"dropWhile p xs@(x:xs')\n"
"| p x       = dropWhile p xs'\n"
"| otherwise = xs\n"
"\n"
"span, break         :: (a -> Bool) -> [a] -> ([a],[a])\n"
"span p []            = ([],[])\n"
"span p xs@(x:xs')\n"
"| p x       = (x:ys, zs)\n"
"| otherwise = ([],xs)\n"
"where (ys,zs) = span p xs'\n"
"break p              = span (not . p)\n"
"\n"
"lines     :: String -> [String]\n"
"lines \"\"   = []\n"
"lines s    = let (l,s') = break ('\\n'==) s\n"
"in l : case s' of []      -> []\n"
"(_:s'') -> lines s''\n"
"\n"
"words     :: String -> [String]\n"
"words s    = case dropWhile isSpace s of\n"
"\"\" -> []\n"
"s' -> w : words s''\n"
"where (w,s'') = break isSpace s'\n"
"\n"
"unlines   :: [String] -> String\n"
"unlines []      = []\n"
"unlines (l:ls)  = l ++ '\\n' : unlines ls\n"
"\n"
"unwords   :: [String] -> String\n"
"unwords []	=  \"\"\n"
"unwords [w]	= w\n"
"unwords (w:ws)	= w ++ ' ' : unwords ws\n"
"\n"
"reverse   :: [a] -> [a]\n"
"reverse    = foldl (flip (:)) []\n"
"\n"
"and, or   :: [Bool] -> Bool\n"
"and        = foldr (&&) True\n"
"or         = foldr (||) False\n"
"\n"
"any, all  :: (a -> Bool) -> [a] -> Bool\n"
"any p      = or  . map p\n"
"all p      = and . map p\n"
"\n"
"elem, notElem    :: Eq a => a -> [a] -> Bool\n"
"elem              = any . (==)\n"
"notElem           = all . (/=)\n"
"\n"
"lookup           :: Eq a => a -> [(a,b)] -> Maybe b\n"
"lookup k []       = Nothing\n"
"lookup k ((x,y):xys)\n"
"| k==x      = Just y\n"
"| otherwise = lookup k xys\n"
"\n"
"sum, product     :: Num a => [a] -> a\n"
"sum               = foldl' (+) 0\n"
"product           = foldl' (*) 1\n"
"\n"
"maximum, minimum :: Ord a => [a] -> a\n"
"maximum           = foldl1 max\n"
"minimum           = foldl1 min\n"
"\n"
"concatMap        :: (a -> [b]) -> [a] -> [b]\n"
"concatMap f       = concat . map f\n"
"\n"
"zip              :: [a] -> [b] -> [(a,b)]\n"
"zip               = zipWith  (\\a b -> (a,b))\n"
"\n"
"zip3             :: [a] -> [b] -> [c] -> [(a,b,c)]\n"
"zip3              = zipWith3 (\\a b c -> (a,b,c))\n"
"\n"
"zipWith                  :: (a->b->c) -> [a]->[b]->[c]\n"
"zipWith z (a:as) (b:bs)   = z a b : zipWith z as bs\n"
"zipWith _ _      _        = []\n"
"\n"
"zipWith3                 :: (a->b->c->d) -> [a]->[b]->[c]->[d]\n"
"zipWith3 z (a:as) (b:bs) (c:cs)\n"
"= z a b c : zipWith3 z as bs cs\n"
"zipWith3 _ _ _ _          = []\n"
"\n"
"unzip                    :: [(a,b)] -> ([a],[b])\n"
"unzip                     = foldr (\\(a,b) ~(as,bs) -> (a:as, b:bs)) ([], [])\n"
"\n"
"unzip3                   :: [(a,b,c)] -> ([a],[b],[c])\n"
"unzip3                    = foldr (\\(a,b,c) ~(as,bs,cs) -> (a:as,b:bs,c:cs))\n"
"([],[],[])\n"
"\n"
"-- PreludeText ----------------------------------------------------------------\n"
"\n"
"reads        :: Read a => ReadS a\n"
"reads         = readsPrec 0\n"
"\n"
"shows        :: Show a => a -> ShowS\n"
"shows         = showsPrec 0\n"
"\n"
"read         :: Read a => String -> a\n"
"read s        =  case [x | (x,t) <- reads s, (\"\",\"\") <- lex t] of\n"
"[x] -> x\n"
"[]  -> error \"Prelude.read: no parse\"\n"
"_   -> error \"Prelude.read: ambiguous parse\"\n"
"\n"
"showChar     :: Char -> ShowS\n"
"showChar      = (:)\n"
"\n"
"showString   :: String -> ShowS\n"
"showString    = (++)\n"
"\n"
"showParen    :: Bool -> ShowS -> ShowS\n"
"showParen b p = if b then showChar '(' . p . showChar ')' else p\n"
"\n"
"showField    :: Show a => String -> a -> ShowS\n"
"showField m v = showString m . showChar '=' . shows v\n"
"\n"
"readParen    :: Bool -> ReadS a -> ReadS a\n"
"readParen b g = if b then mandatory else optional\n"
"where optional r  = g r ++ mandatory r\n"
"mandatory r = [(x,u) | (\"(\",s) <- lex r,\n"
"(x,t)   <- optional s,\n"
"(\")\",u) <- lex t    ]\n"
"\n"
"readField    :: Read a => String -> ReadS a\n"
"readField m s0 = [ r | (t,  s1) <- lex s0, t == m,\n"
"(\"=\",s2) <- lex s1,\n"
"r        <- reads s2 ]\n"
"\n"
"lex                    :: ReadS String\n"
"lex \"\"                  = [(\"\",\"\")]\n"
"lex (c:s) | isSpace c   = lex (dropWhile isSpace s)\n"
"lex ('\\'':s)            = [('\\'':ch++\"'\", t) | (ch,'\\'':t)  <- lexLitChar s,\n"
"ch /= \"'\"                ]\n"
"lex ('\"':s)             = [('\"':str, t)      | (str,t) <- lexString s]\n"
"where\n"
"lexString ('\"':s) = [(\"\\\"\",s)]\n"
"lexString s = [(ch++str, u)\n"
"| (ch,t)  <- lexStrItem s,\n"
"(str,u) <- lexString t  ]\n"
"\n"
"lexStrItem ('\\\\':'&':s) = [(\"\\\\&\",s)]\n"
"lexStrItem ('\\\\':c:s) | isSpace c\n"
"= [(\"\",t) | '\\\\':t <- [dropWhile isSpace s]]\n"
"lexStrItem s            = lexLitChar s\n"
"\n"
"lex (c:s) | isSym c     = [(c:sym,t)         | (sym,t) <- [span isSym s]]\n"
"| isAlpha c   = [(c:nam,t)         | (nam,t) <- [span isIdChar s]]\n"
"-- '_' can be the start of a single char or a name/id.\n"
"| c == '_'    = case span isIdChar s of\n"
"([],_) -> [([c],s)]\n"
"(nm,t) -> [((c:nm),t)]\n"
"| isSingle c  = [([c],s)]\n"
"| isDigit c   = [(c:ds++fe,t)      | (ds,s)  <- [span isDigit s],\n"
"(fe,t)  <- lexFracExp s     ]\n"
"| otherwise   = []    -- bad character\n"
"where\n"
"isSingle c  =  c `elem` \",;()[]{}_`\"\n"
"isSym c     =  c `elem` \"!@#$%&*+./<=>?\\\\^|:-~\"\n"
"isIdChar c  =  isAlphaNum c || c `elem` \"_'\"\n"
"\n"
"lexFracExp ('.':c:cs) | isDigit c\n"
"= [('.':ds++e,u) | (ds,t) <- lexDigits (c:cs),\n"
"(e,u)  <- lexExp t    ]\n"
"lexFracExp s       = lexExp s\n"
"\n"
"lexExp (e:s) | e `elem` \"eE\"\n"
"= [(e:c:ds,u) | (c:t)  <- [s], c `elem` \"+-\",\n"
"(ds,u) <- lexDigits t] ++\n"
"[(e:ds,t)   | (ds,t) <- lexDigits s]\n"
"lexExp s = [(\"\",s)]\n"
"\n"
"lexDigits               :: ReadS String\n"
"lexDigits               =  nonnull isDigit\n"
"\n"
"nonnull                 :: (Char -> Bool) -> ReadS String\n"
"nonnull p s             =  [(cs,t) | (cs@(_:_),t) <- [span p s]]\n"
"\n"
"lexLitChar          :: ReadS String\n"
"lexLitChar \"\"       =  []\n"
"lexLitChar (c:s)\n"
"| c /= '\\\\'        =  [([c],s)]\n"
"| otherwise        =  map (prefix '\\\\') (lexEsc s)\n"
"where\n"
"lexEsc (c:s)     | c `elem` \"abfnrtv\\\\\\\"'\" = [([c],s)]\n"
"lexEsc ('^':c:s) | c >= '@' && c <= '_'    = [(['^',c],s)]\n"
"-- Numeric escapes\n"
"lexEsc ('o':s)  = [prefix 'o' (span isOctDigit s)]\n"
"lexEsc ('x':s)  = [prefix 'x' (span isHexDigit s)]\n"
"lexEsc s@(c:_)\n"
"| isDigit c   = [span isDigit s]\n"
"| isUpper c   = case [(mne,s') | (c, mne) <- table,\n"
"([],s') <- [lexmatch mne s]] of\n"
"(pr:_) -> [pr]\n"
"[]     -> []\n"
"lexEsc _        = []\n"
"\n"
"table = ('\\DEL',\"DEL\") : asciiTab\n"
"prefix c (t,s) = (c:t, s)\n"
"\n"
"isOctDigit c  =  c >= '0' && c <= '7'\n"
"isHexDigit c  =  isDigit c || c >= 'A' && c <= 'F'\n"
"|| c >= 'a' && c <= 'f'\n"
"\n"
"lexmatch                   :: (Eq a) => [a] -> [a] -> ([a],[a])\n"
"lexmatch (x:xs) (y:ys) | x == y  =  lexmatch xs ys\n"
"lexmatch xs     ys               =  (xs,ys)\n"
"\n"
"asciiTab = zip ['\\NUL'..' ']\n"
"[\"NUL\", \"SOH\", \"STX\", \"ETX\", \"EOT\", \"ENQ\", \"ACK\", \"BEL\",\n"
"\"BS\",  \"HT\",  \"LF\",  \"VT\",  \"FF\",  \"CR\",  \"SO\",  \"SI\",\n"
"\"DLE\", \"DC1\", \"DC2\", \"DC3\", \"DC4\", \"NAK\", \"SYN\", \"ETB\",\n"
"\"CAN\", \"EM\",  \"SUB\", \"ESC\", \"FS\",  \"GS\",  \"RS\",  \"US\",\n"
"\"SP\"]\n"
"\n"
"readLitChar            :: ReadS Char\n"
"readLitChar ('\\\\':s)    = readEsc s\n"
"where\n"
"readEsc ('a':s)  = [('\\a',s)]\n"
"readEsc ('b':s)  = [('\\b',s)]\n"
"readEsc ('f':s)  = [('\\f',s)]\n"
"readEsc ('n':s)  = [('\\n',s)]\n"
"readEsc ('r':s)  = [('\\r',s)]\n"
"readEsc ('t':s)  = [('\\t',s)]\n"
"readEsc ('v':s)  = [('\\v',s)]\n"
"readEsc ('\\\\':s) = [('\\\\',s)]\n"
"readEsc ('\"':s)  = [('\"',s)]\n"
"readEsc ('\\'':s) = [('\\'',s)]\n"
"readEsc ('^':c:s) | c >= '@' && c <= '_'\n"
"= [(toEnum (fromEnum c - fromEnum '@'), s)]\n"
"readEsc s@(d:_) | isDigit d\n"
"= [(toEnum n, t) | (n,t) <- readDec s]\n"
"readEsc ('o':s)  = [(toEnum n, t) | (n,t) <- readOct s]\n"
"readEsc ('x':s)  = [(toEnum n, t) | (n,t) <- readHex s]\n"
"readEsc s@(c:_) | isUpper c\n"
"= let table = ('\\DEL',\"DEL\") : asciiTab\n"
"in case [(c,s') | (c, mne) <- table,\n"
"([],s') <- [lexmatch mne s]]\n"
"of (pr:_) -> [pr]\n"
"[]     -> []\n"
"readEsc _        = []\n"
"readLitChar (c:s)       = [(c,s)]\n"
"\n"
"showLitChar               :: Char -> ShowS\n"
"showLitChar c | c > '\\DEL' = showChar '\\\\' .\n"
"protectEsc isDigit (shows (fromEnum c))\n"
"showLitChar '\\DEL'         = showString \"\\\\DEL\"\n"
"showLitChar '\\\\'           = showString \"\\\\\\\\\"\n"
"showLitChar c | c >= ' '   = showChar c\n"
"showLitChar '\\a'           = showString \"\\\\a\"\n"
"showLitChar '\\b'           = showString \"\\\\b\"\n"
"showLitChar '\\f'           = showString \"\\\\f\"\n"
"showLitChar '\\n'           = showString \"\\\\n\"\n"
"showLitChar '\\r'           = showString \"\\\\r\"\n"
"showLitChar '\\t'           = showString \"\\\\t\"\n"
"showLitChar '\\v'           = showString \"\\\\v\"\n"
"showLitChar '\\SO'          = protectEsc ('H'==) (showString \"\\\\SO\")\n"
"showLitChar c              = showString ('\\\\' : snd (asciiTab!!fromEnum c))\n"
"\n"
"protectEsc p f             = f . cont\n"
"where cont s@(c:_) | p c  = \"\\\\&\" ++ s\n"
"cont s              = s\n"
"\n"
"-- Unsigned readers for various bases\n"
"readDec, readOct, readHex :: Integral a => ReadS a\n"
"readDec = readInt 10 isDigit    (\\ d -> fromEnum d - fromEnum_0)\n"
"readOct = readInt  8 isOctDigit (\\ d -> fromEnum d - fromEnum_0)\n"
"readHex = readInt 16 isHexDigit hex\n"
"where hex d = fromEnum d - (if isDigit d then fromEnum_0\n"
"else fromEnum (if isUpper d then 'A' else 'a') - 10)\n"
"\n"
"fromEnum_0 :: Int\n"
"fromEnum_0 = fromEnum '0'\n"
"\n"
"-- showInt is used for positive numbers only\n"
"showInt    :: Integral a => a -> ShowS\n"
"showInt n r | n < 0 = error \"Numeric.showInt: can't show negative numbers\"\n"
"| otherwise =\n"
"let (n',d) = quotRem n 10\n"
"r'     = toEnum (fromEnum '0' + fromIntegral d) : r\n"
"in  if n' == 0 then r' else showInt n' r'\n"
"\n"
"showSigned    :: Real a => (a -> ShowS) -> Int -> a -> ShowS\n"
"showSigned showPos p x = if x < 0 then showParen (p > 6)\n"
"(showChar '-' . showPos (-x))\n"
"else showPos x\n"
"\n"
"-- readInt reads a string of digits using an arbitrary base.\n"
"-- Leading minus signs must be handled elsewhere.\n"
"\n"
"readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a\n"
"readInt radix isDig digToInt s =\n"
"[(foldl1 (\\n d -> n * radix + d) (map (fromIntegral . digToInt) ds), r)\n"
"| (ds,r) <- nonnull isDig s ]\n"
"\n"
"readSigned:: Real a => ReadS a -> ReadS a\n"
"readSigned readPos = readParen False read'\n"
"where read' r  = read'' r ++\n"
"[(-x,t) | (\"-\",s) <- lex r,\n"
"(x,t)   <- read'' s]\n"
"read'' r = [(n,s)  | (str,s) <- lex r,\n"
"(n,\"\")  <- readPos str]\n"
"\n"
"\n"
"-- This floating point reader uses a less restrictive syntax for floating\n"
"-- point than the Haskell lexer.  The `.' is optional.\n"
"readFloat     :: RealFrac a => ReadS a\n"
"readFloat r    = [(fromRational ((n%1)*10^^(k-d)),t) | (n,d,s) <- readFix r,\n"
"(k,t)   <- readExp s] ++\n"
"[ (0/0, t) | (\"NaN\",t)      <- lex r] ++\n"
"[ (1/0, t) | (\"Infinity\",t) <- lex r]\n"
"where readFix r = [(read (ds++ds'), length ds', t)\n"
"| (ds, d) <- lexDigits r\n"
", (ds',t) <- lexFrac d   ]\n"
"\n"
"lexFrac ('.':s) = lexDigits s\n"
"lexFrac s       = [(\"\",s)]\n"
"\n"
"readExp (e:s) | e `elem` \"eE\" = readExp' s\n"
"readExp s                     = [(0,s)]\n"
"\n"
"readExp' ('-':s) = [(-k,t) | (k,t) <- readDec s]\n"
"readExp' ('+':s) = readDec s\n"
"readExp' s       = readDec s\n"
"\n"
"----------------------------------------------------------------\n"
"-- Exception datatype and operations\n"
"----------------------------------------------------------------\n"
"\n"
"data Exception\n"
"= ArithException      ArithException\n"
"| ArrayException      ArrayException\n"
"| AssertionFailed     String\n"
"| AsyncException      AsyncException\n"
"| BlockedOnDeadMVar\n"
"| Deadlock\n"
"| DynException        Dynamic\n"
"| ErrorCall           String\n"
"| ExitException       ExitCode\n"
"| IOException 	IOException	-- IO exceptions (from 'ioError')\n"
"| NoMethodError       String\n"
"| NonTermination\n"
"| PatternMatchFail    String\n"
"| RecConError         String\n"
"| RecSelError         String\n"
"| RecUpdError         String\n"
"\n"
"instance Show Exception where\n"
"showsPrec _ (ArithException e)  = shows e\n"
"showsPrec _ (ArrayException e)  = shows e\n"
"showsPrec _ (AssertionFailed s) = showException \"assertion failed\" s\n"
"showsPrec _ (AsyncException e)  = shows e\n"
"showsPrec _ BlockedOnDeadMVar   = showString \"thread blocked indefinitely\"\n"
"showsPrec _ Deadlock            = showString \"<<deadlock>>\"\n"
"showsPrec _ (DynException _)    = showString \"unknown exception\"\n"
"showsPrec _ (ErrorCall s)       = showString s\n"
"showsPrec _ (ExitException err) = showString \"exit: \" . shows err\n"
"showsPrec _ (IOException err)	  = shows err\n"
"showsPrec _ (NoMethodError s)   = showException \"undefined member\" s\n"
"showsPrec _ NonTermination	  = showString \"<<loop>>\"\n"
"showsPrec _ (PatternMatchFail s) = showException \"pattern match failure\" s\n"
"showsPrec _ (RecConError s)     = showException \"undefined field\" s\n"
"showsPrec _ (RecSelError s)     = showException \"select of missing field\" s\n"
"showsPrec _ (RecUpdError s)     = showException \"update of missing field\" s\n"
"\n"
"data ArithException\n"
"= Overflow\n"
"| Underflow\n"
"| LossOfPrecision\n"
"| DivideByZero\n"
"| Denormal\n"
"deriving (Eq, Ord)\n"
"\n"
"instance Show ArithException where\n"
"showsPrec _ Overflow        = showString \"arithmetic overflow\"\n"
"showsPrec _ Underflow       = showString \"arithmetic underflow\"\n"
"showsPrec _ LossOfPrecision = showString \"loss of precision\"\n"
"showsPrec _ DivideByZero    = showString \"divide by zero\"\n"
"showsPrec _ Denormal        = showString \"denormal\"\n"
"\n"
"data ArrayException\n"
"= IndexOutOfBounds    String\n"
"| UndefinedElement    String\n"
"deriving (Eq, Ord)\n"
"\n"
"instance Show ArrayException where\n"
"showsPrec _ (IndexOutOfBounds s) =\n"
"showException \"array index out of range\" s\n"
"showsPrec _ (UndefinedElement s) =\n"
"showException \"undefined array element\" s\n"
"\n"
"data AsyncException\n"
"= StackOverflow\n"
"| HeapOverflow\n"
"| ThreadKilled\n"
"deriving (Eq, Ord)\n"
"\n"
"instance Show AsyncException where\n"
"showsPrec _ StackOverflow   = showString \"stack overflow\"\n"
"showsPrec _ HeapOverflow    = showString \"heap overflow\"\n"
"showsPrec _ ThreadKilled    = showString \"thread killed\"\n"
"\n"
"showException :: String -> String -> ShowS\n"
"showException tag msg =\n"
"showString tag . (if null msg then id else showString \": \" . showString msg)\n"
"\n"
"data ExitCode = ExitSuccess | ExitFailure Int\n"
"deriving (Eq, Ord, Read, Show)\n"
"\n"
"-- data type describing IOErrors / exceptions.\n"
"type IOError = IOException\n"
"\n"
"data IOException\n"
"= IOError\n"
"{ ioe_handle      :: Maybe Handle   -- the handle used by the action\n"
"-- flagging the error\n"
", ioe_type        :: IOErrorType    -- what kind of (std) error\n"
", ioe_location    :: String         -- location of the error\n"
", ioe_description :: String         -- error-specific string\n"
", ioe_filename    :: Maybe FilePath -- the resource involved.\n"
"}\n"
"deriving (Eq)\n"
"\n"
"data IOErrorType\n"
"= AlreadyExists\n"
"| NoSuchThing\n"
"| ResourceBusy\n"
"| ResourceExhausted\n"
"| EOF\n"
"| IllegalOperation\n"
"| PermissionDenied\n"
"| UserError\n"
"-- GHC compatibility\n"
"| UnsupportedOperation\n"
"| OtherError\n"
"-- DOTNET only\n"
"| DotNetException\n"
"deriving (Eq)\n"
"\n"
"instance Show IOErrorType where\n"
"show x =\n"
"case x of\n"
"AlreadyExists     -> \"already exists\"\n"
"NoSuchThing       -> \"does not exist\"\n"
"ResourceBusy      -> \"resource busy\"\n"
"ResourceExhausted -> \"resource exhausted\"\n"
"EOF               -> \"end of file\"\n"
"IllegalOperation  -> \"illegal operation\"\n"
"PermissionDenied  -> \"permission denied\"\n"
"UserError         -> \"user error\"\n"
"UnsupportedOperation -> \"unsupported operation\"\n"
"OtherError        -> \"failed\"\n"
"DotNetException   -> \".NET exception\"\n"
"\n"
"instance Show IOException where\n"
"showsPrec p (IOError hdl iot loc s fn) =\n"
"(case fn of\n"
"Nothing -> case hdl of\n"
"Nothing -> id\n"
"Just h  -> showsPrec p h . showString \": \"\n"
"Just name -> showString name . showString \": \") .\n"
"(case loc of\n"
"\"\" -> id\n"
"_  -> showString loc . showString \": \") .\n"
"showsPrec p iot .\n"
"(case s of\n"
"\"\" -> id\n"
"_  -> showString \" (\" . showString s . showString \")\")\n"
"\n"
"-- Monadic I/O: --------------------------------------------------------------\n"
"\n"
"--data IO a             -- builtin datatype of IO actions\n"
"\n"
"type FilePath = String  -- file pathnames are represented by strings\n"
"\n"
"primitive primbindIO		 :: IO a -> (a -> IO b) -> IO b\n"
"primitive primretIO		 :: a -> IO a\n"
"primitive putChar		 :: Char -> IO ()\n"
"primitive putStr		 :: String -> IO ()\n"
"primitive getChar   		 :: IO Char\n"
"\n"
"ioError :: IOError -> IO a\n"
"ioError e = IO (\\ s -> throw (IOException e))\n"
"\n"
"userError :: String -> IOError\n"
"userError str = IOError Nothing UserError \"\" str Nothing\n"
"\n"
"catch :: IO a -> (IOError -> IO a) -> IO a\n"
"catch m h = catchException m $ \\e -> case e of\n"
"IOException err -> h err\n"
"_ -> throw e\n"
"\n"
"print     :: Show a => a -> IO ()\n"
"print      = putStrLn . show\n"
"\n"
"putStrLn  :: String -> IO ()\n"
"putStrLn s = do putStr s\n"
"putChar '\\n'\n"
"\n"
"getLine :: IO String\n"
"getLine  = do\n"
"c <- getChar\n"
"if c=='\\n'\n"
"then return \"\"\n"
"else do\n"
"ls <- getRest\n"
"return (c:ls)\n"
"where\n"
"getRest = do\n"
"c <- catch getChar\n"
"(\\ ex -> if ioe_type ex == EOF then\n"
"return '\\n'\n"
"else\n"
"ioError ex)\n"
"if c=='\\n'\n"
"then return \"\"\n"
"else do\n"
"cs <- getRest\n"
"return (c:cs)\n"
"\n"
"-- raises an exception instead of an error\n"
"readIO          :: Read a => String -> IO a\n"
"readIO s         = case [x | (x,t) <- reads s, (\"\",\"\") <- lex t] of\n"
"[x] -> return x\n"
"[]  -> ioError (userError \"PreludeIO.readIO: no parse\")\n"
"_   -> ioError (userError\n"
"\"PreludeIO.readIO: ambiguous parse\")\n"
"\n"
"readLn          :: Read a => IO a\n"
"readLn           = do l <- getLine\n"
"r <- readIO l\n"
"return r\n"
"\n"
"primitive getContents 		 :: IO String\n"
"primitive writeFile   		 :: FilePath -> String -> IO ()\n"
"primitive appendFile  		 :: FilePath -> String -> IO ()\n"
"primitive readFile    		 :: FilePath -> IO String\n"
"\n"
"interact  :: (String -> String) -> IO ()\n"
"interact f = getContents >>= (putStr . f)\n"
"\n"
"instance Functor IO where\n"
"fmap f x = x >>= (return . f)\n"
"\n"
"instance Monad IO where\n"
"(>>=)  = primbindIO\n"
"return = primretIO\n"
"\n"
"fail s = ioError (userError s)\n"
"\n"
"-- Hooks for primitives: -----------------------------------------------------\n"
"-- Do not mess with these!\n"
"\n"
"data FunPtr a -- builtin datatype of C function pointers\n"
"data Ptr a    -- builtin datatype of C pointers\n"
"data Addr     -- builtin datatype of C pointers (deprecated)\n"
"data Word     -- builtin datatype of unsigned ints (deprecated)\n"
"data Int8\n"
"data Int16\n"
"data Int32\n"
"data Int64\n"
"data Word8\n"
"data Word16\n"
"data Word32\n"
"data Word64\n"
"data ForeignObj  -- builtin datatype of C pointers with finalizers (deprecated)\n"
"data ForeignPtr a -- builtin datatype of C pointers with finalizers\n"
"data StablePtr a\n"
"data Handle\n"
"\n"
"data Object a -- builtin datatype of external object references.\n"
"-- (needed as primitive since they're supported in FFI decls.)\n"
"\n"
"instance Eq Handle where (==) = primEqHandle\n"
"primitive primEqHandle :: Handle -> Handle -> Bool\n"
"\n"
"instance Show Handle where\n"
"showsPrec _ h = case primGetHandleNumber h of\n"
"0 -> showString \"stdin\"\n"
"1 -> showString \"stdout\"\n"
"2 -> showString \"stderr\"\n"
"_ -> showString \"<handle>\"\n"
"\n"
"primitive primGetHandleNumber :: Handle -> Int\n"
"\n"
"primitive unsafeCoerce \"primUnsafeCoerce\" :: a -> b\n"
"\n"
"data Dynamic = Dynamic TypeRep Obj\n"
"\n"
"data TypeRep = TypeRep !Key TyCon [TypeRep]\n"
"\n"
"instance Eq TypeRep where\n"
"(TypeRep k1 _ _) == (TypeRep k2 _ _) = k1 == k2\n"
"\n"
"data TyCon = TyCon !Key String\n"
"\n"
"instance Eq TyCon where\n"
"(TyCon t1 _) == (TyCon t2 _) = t1 == t2\n"
"\n"
"newtype Key = Key Int deriving( Eq )\n"
"\n"
"data Obj = Obj\n"
"\n"
"toObj :: a -> Obj\n"
"toObj   = unsafeCoerce\n"
"\n"
"fromObj :: Obj -> a\n"
"fromObj = unsafeCoerce\n"
"\n"
"newtype IO a = IO ((a -> IOResult) -> IOResult)\n"
"\n"
"data IOResult\n"
"= Hugs_ExitWith    Int\n"
"| Hugs_Catch       IOResult (Exception -> IOResult) (Obj -> IOResult)\n"
"| Hugs_ForkThread  IOResult IOResult\n"
"| Hugs_DeadThread\n"
"| Hugs_YieldThread IOResult\n"
"| Hugs_Return      Obj\n"
"| Hugs_BlockThread (Obj -> IOResult) ((Obj -> IOResult) -> IOResult)\n"
"\n"
"data IOFinished a\n"
"= Finished_ExitWith Int\n"
"| Finished_Return   a\n"
"\n"
"primitive throw \"primThrowException\" :: Exception -> a\n"
"primitive primCatchException :: a -> Either Exception a\n"
"\n"
"catchException :: IO a -> (Exception -> IO a) -> IO a\n"
"catchException (IO m) k = IO $ \\ s ->\n"
"Hugs_Catch (m hugsReturn)\n"
"(\\ e -> case (k e) of { IO k' -> k' s })\n"
"(s . fromObj)\n"
"\n"
"hugsReturn :: a -> IOResult\n"
"hugsReturn x = Hugs_Return (toObj x)\n"
"\n"
"-- reify current thread, execute 'm <thread>' and switch to next thread\n"
"blockIO :: ((a -> IOResult) -> IO ()) -> IO a\n"
"blockIO m = IO (\\ s -> Hugs_BlockThread (s . fromObj) m')\n"
"where\n"
"m' k = threadToIOResult (m (k . toObj))\n"
"\n"
"hugsIORun  :: IO a -> Either Int a\n"
"hugsIORun m =\n"
"case basicIORun (runAndShowError m) of\n"
"Finished_ExitWith i -> Left i\n"
"Finished_Return   a -> Right a\n"
"where\n"
"runAndShowError :: IO a -> IO a\n"
"runAndShowError m = m `catchException` exceptionHandler\n"
"exceptionHandler :: Exception -> IO a\n"
"exceptionHandler (ExitException ExitSuccess) = primExitWith 0\n"
"exceptionHandler (ExitException (ExitFailure n)) = primExitWith n\n"
"exceptionHandler err = runAndShowError $ do\n"
"putChar '\\n'\n"
"putStr \"Program error: \"\n"
"putStrLn (show err)\n"
"primExitWith 1\n"
"\n"
"basicIORun :: IO a -> IOFinished a\n"
"basicIORun (IO m) = loop [m hugsReturn]\n"
"\n"
"threadToIOResult :: IO a -> IOResult\n"
"threadToIOResult (IO m) = m (const Hugs_DeadThread)\n"
"\n"
"-- This is the queue of *runnable* threads.\n"
"-- There may be blocked threads attached to MVars\n"
"-- An important invariant is that at most one thread will result in\n"
"-- Hugs_Return - and its Obj value has type \\alpha\n"
"loop :: [IOResult] -> IOFinished a\n"
"loop []                      = error \"no more threads (deadlock?)\"\n"
"loop [Hugs_Return   a]       = Finished_Return (fromObj a)\n"
"loop (Hugs_Return   a:r)     = loop (r ++ [Hugs_Return a])\n"
"loop (Hugs_Catch m f s:r)    = loop (hugs_catch m f s : r)\n"
"loop (Hugs_ExitWith i:_)     = Finished_ExitWith i\n"
"loop (Hugs_DeadThread:r)     = loop r\n"
"loop (Hugs_ForkThread a b:r) = loop (a:b:r)\n"
"loop (Hugs_YieldThread a:r)  = loop (r ++ [a])\n"
"loop (Hugs_BlockThread a b:r)= loop (b a : r)\n"
"loop _                       = error \"Fatal error in Hugs scheduler\"\n"
"\n"
"hugs_catch :: IOResult -> (Exception -> IOResult) -> (Obj -> IOResult) -> IOResult\n"
"hugs_catch m f s = case primCatchException (catch' m) of\n"
"Left  exn                   -> f exn\n"
"Right (Hugs_Return a)       -> s a\n"
"Right (Hugs_ForkThread a b) -> Hugs_ForkThread (Hugs_Catch a f s) b\n"
"Right (Hugs_YieldThread a)  -> Hugs_YieldThread (Hugs_Catch a f s)\n"
"Right (Hugs_BlockThread a b)-> Hugs_BlockThread (\\x -> Hugs_Catch (a x) f s) b\n"
"Right r                     -> r\n"
"where\n"
"catch' :: IOResult -> IOResult\n"
"catch' (Hugs_Catch m' f' s') = catch' (hugs_catch m' f' s')\n"
"catch' x                     = x\n"
"\n"
"primExitWith     :: Int -> IO a\n"
"primExitWith c    = IO (\\ s -> Hugs_ExitWith c)\n"
"\n"
"primCompAux      :: Ord a => a -> a -> Ordering -> Ordering\n"
"primCompAux x y o = case compare x y of EQ -> o; LT -> LT; GT -> GT\n"
"\n"
"primPmInt        :: Num a => Int -> a -> Bool\n"
"primPmInt n x     = fromInt n == x\n"
"\n"
"primPmInteger    :: Num a => Integer -> a -> Bool\n"
"primPmInteger n x = fromInteger n == x\n"
"\n"
"primPmFlt        :: Fractional a => Double -> a -> Bool\n"
"primPmFlt n x     = fromDouble n == x\n"
"\n"
"-- The following primitives are only needed if (n+k) patterns are enabled:\n"
"primPmNpk        :: Integral a => Int -> a -> Maybe a\n"
"primPmNpk n x     = if n'<=x then Just (x-n') else Nothing\n"
"where n' = fromInt n\n"
"\n"
"primPmSub        :: Integral a => Int -> a -> a\n"
"primPmSub n x     = x - fromInt n\n"
"\n"
"-- Trex\n"
"emptyRec :: Rec EmptyRow\n"
"emptyRec = EmptyRec\n"
"\n"
"-- End of Hugs standard prelude ----------------------------------------------\n";
const char *foreignptr_hs = "module Hugs.ForeignPtr\n"
"(\n"
"ForeignPtr             -- abstract, instance of: Eq\n"
", FinalizerPtr\n"
", FinalizerEnvPtr\n"
", newForeignPtr_         -- :: Ptr a -> IO (ForeignPtr a)\n"
", addForeignPtrFinalizer -- :: FinalizerPtr a -> ForeignPtr a -> IO ()\n"
", addForeignPtrFinalizerEnv -- :: FinalizerEnvPtr env a -> Ptr env ->\n"
"--    ForeignPtr a -> IO ()\n"
", unsafeForeignPtrToPtr	 -- :: ForeignPtr a -> Ptr a\n"
", touchForeignPtr        -- :: ForeignPtr a -> IO ()\n"
", castForeignPtr	 -- :: ForeignPtr a -> ForeignPtr b\n"
")\n"
"where\n"
"\n"
"import Hugs.Prelude		( ForeignPtr )\n"
"import Foreign.Ptr		( Ptr, FunPtr )\n"
"\n"
"-- data ForeignPtr a -- defined in Prelude.hs\n"
"\n"
"type FinalizerPtr        a = FunPtr (           Ptr a -> IO ())\n"
"type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())\n"
"\n"
"primitive newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)\n"
"primitive addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()\n"
"primitive addForeignPtrFinalizerEnv ::\n"
"FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()\n"
"primitive touchForeignPtr :: ForeignPtr a -> IO ()\n"
"primitive unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a\n"
"primitive castForeignPtr \"primUnsafeCoerce\" :: ForeignPtr a -> ForeignPtr b\n";
const char *observe_hs = "module Hugs.Observe (observe, bkpt, setBkpt) where\n"
"\n"
"primitive observe :: String -> a -> a\n"
"primitive bkpt    :: String -> a -> a\n"
"primitive setBkpt :: String -> Bool -> IO ()\n";
const char *dynamic_hs = "module Hugs.Dynamic(module Data.Dynamic, coerceDynamic, runDyn) where\n"
"\n"
"import Data.Dynamic\n"
"\n"
"coerceDynamic :: Typeable a => Dynamic -> a\n"
"coerceDynamic d = fromDyn d def\n"
"where def = error (\"coerceDynamic: expecting \" ++ show (toDyn def) ++\n"
"\" found \" ++ show d)\n"
"\n"
"runDyn :: Dynamic -> IO ()\n"
"runDyn = coerceDynamic\n";
const char *word_hs = "-----------------------------------------------------------------------------\n"
"-- Unsigned Integers\n"
"-- Suitable for use with Hugs 98 on 32 bit systems.\n"
"-----------------------------------------------------------------------------\n"
"module Hugs.Word\n"
"( Word\n"
", Word8\n"
", Word16\n"
", Word32\n"
", Word64\n"
") where\n"
"\n"
"import Hugs.Prelude ( Word, Word8, Word16, Word32, Word64 )\n"
"import Data.Bits\n"
"import Data.Int\n"
"import Hugs.Prelude ( Ix(..) )\n"
"import Hugs.Prelude ( (%) )\n"
"import Hugs.Prelude ( readDec, showInt )\n"
"import Hugs.Prelude ( Num(fromInt), Integral(toInt) )\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- The \"official\" coercion functions\n"
"-----------------------------------------------------------------------------\n"
"\n"
"word8ToInt   :: Word8  -> Int\n"
"intToWord8   :: Int    -> Word8\n"
"word16ToInt  :: Word16 -> Int\n"
"intToWord16  :: Int    -> Word16\n"
"\n"
"word8ToInt  = word32ToInt    . word8ToWord32\n"
"intToWord8  = word32ToWord8  . intToWord32\n"
"word16ToInt = word32ToInt    . word16ToWord32\n"
"intToWord16 = word32ToWord16 . intToWord32\n"
"\n"
"primitive intToWord32 \"intToWord32\" :: Int    -> Word32\n"
"primitive word32ToInt \"word32ToInt\" :: Word32 -> Int\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Word8\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive word8ToWord32 \"primWord8ToWord32\" :: Word8  -> Word32\n"
"primitive word32ToWord8 \"primWord32ToWord8\" :: Word32 -> Word8\n"
"\n"
"instance Eq  Word8     where (==)    = binop (==)\n"
"instance Ord Word8     where compare = binop compare\n"
"\n"
"instance Num Word8 where\n"
"x + y         = to (binop (+) x y)\n"
"x - y         = to (binop (-) x y)\n"
"negate        = to . negate . from\n"
"x * y         = to (binop (*) x y)\n"
"abs           = absReal\n"
"signum        = signumReal\n"
"fromInteger   = to . primIntegerToWord\n"
"fromInt       = intToWord8\n"
"\n"
"instance Bounded Word8 where\n"
"minBound = 0\n"
"maxBound = 0xff\n"
"\n"
"instance Real Word8 where\n"
"toRational x = toInteger x % 1\n"
"\n"
"instance Integral Word8 where\n"
"x `div` y     = to  (binop div x y)\n"
"x `quot` y    = to  (binop quot x y)\n"
"x `rem` y     = to  (binop rem x y)\n"
"x `mod` y     = to  (binop mod x y)\n"
"x `quotRem` y = to2 (binop quotRem x y)\n"
"divMod        = quotRem\n"
"toInteger     = toInteger . from\n"
"toInt         = word8ToInt\n"
"\n"
"instance Ix Word8 where\n"
"range (m,n)          = [m..n]\n"
"index b@(m,n) i\n"
"| inRange b i = word32ToInt (from (i - m))\n"
"| otherwise   = error \"index: Index out of range\"\n"
"inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Word8 where\n"
"toEnum         = to . intToWord32\n"
"fromEnum       = word32ToInt . from\n"
"enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Word8)]\n"
"enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (last::Word8)]\n"
"where last = if d < c then minBound else maxBound\n"
"\n"
"instance Read Word8 where\n"
"readsPrec p = readDec\n"
"\n"
"instance Show Word8 where\n"
"showsPrec p = showInt  -- a particularily counterintuitive name!\n"
"\n"
"instance Bits Word8 where\n"
"x .&. y       = to (binop (.&.) x y)\n"
"x .|. y       = to (binop (.|.) x y)\n"
"x `xor` y     = to (binop xor x y)\n"
"complement    = to . complement . from\n"
"x `shift` i   = to (from x `shift` i)\n"
"x `rotate` i  = to (from x `rot` i)\n"
"where rot = primRotateWord 8\n"
"bit           = to . bit\n"
"setBit x i    = to (setBit (from x) i)\n"
"clearBit x i  = to (clearBit (from x) i)\n"
"complementBit x i = to (complementBit (from x) i)\n"
"testBit x i   = testBit (from x) i\n"
"bitSize  _    = 8\n"
"isSigned _    = False\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Word16\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive word16ToWord32 \"primWord16ToWord32\" :: Word16 -> Word32\n"
"primitive word32ToWord16 \"primWord32ToWord16\" :: Word32 -> Word16\n"
"\n"
"instance Eq  Word16     where (==)    = binop (==)\n"
"instance Ord Word16     where compare = binop compare\n"
"\n"
"instance Num Word16 where\n"
"x + y         = to (binop (+) x y)\n"
"x - y         = to (binop (-) x y)\n"
"negate        = to . negate . from\n"
"x * y         = to (binop (*) x y)\n"
"abs           = absReal\n"
"signum        = signumReal\n"
"fromInteger   = to . primIntegerToWord\n"
"fromInt       = intToWord16\n"
"\n"
"instance Bounded Word16 where\n"
"minBound = 0\n"
"maxBound = 0xffff\n"
"\n"
"instance Real Word16 where\n"
"toRational x = toInteger x % 1\n"
"\n"
"instance Integral Word16 where\n"
"x `div` y     = to  (binop div x y)\n"
"x `quot` y    = to  (binop quot x y)\n"
"x `rem` y     = to  (binop rem x y)\n"
"x `mod` y     = to  (binop mod x y)\n"
"x `quotRem` y = to2 (binop quotRem x y)\n"
"divMod        = quotRem\n"
"toInteger     = toInteger . from\n"
"toInt         = word16ToInt\n"
"\n"
"instance Ix Word16 where\n"
"range (m,n)          = [m..n]\n"
"index b@(m,n) i\n"
"| inRange b i = word32ToInt (from (i - m))\n"
"| otherwise   = error \"index: Index out of range\"\n"
"inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Word16 where\n"
"toEnum         = to . intToWord32\n"
"fromEnum       = word32ToInt . from\n"
"enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Word16)]\n"
"enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (last::Word16)]\n"
"where last = if d < c then minBound else maxBound\n"
"\n"
"instance Read Word16 where\n"
"readsPrec p = readDec\n"
"\n"
"instance Show Word16 where\n"
"showsPrec p = showInt  -- a particularily counterintuitive name!\n"
"\n"
"instance Bits Word16 where\n"
"x .&. y       = to (binop (.&.) x y)\n"
"x .|. y       = to (binop (.|.) x y)\n"
"x `xor` y     = to (binop xor x y)\n"
"complement    = to . complement . from\n"
"x `shift` i   = to (from x `shift` i)\n"
"x `rotate` i  = to (from x `rot` i)\n"
"where rot = primRotateWord 16\n"
"bit           = to . bit\n"
"setBit x i    = to (setBit (from x) i)\n"
"clearBit x i  = to (clearBit (from x) i)\n"
"complementBit x i = to (complementBit (from x) i)\n"
"testBit x i   = testBit (from x) i\n"
"bitSize  _    = 16\n"
"isSigned _    = False\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Word32\n"
"-----------------------------------------------------------------------------\n"
"\n"
"instance Eq  Word32     where (==)    = primEqWord\n"
"instance Ord Word32     where compare = primCmpWord\n"
"\n"
"instance Num Word32 where\n"
"(+)           = primPlusWord\n"
"(-)           = primMinusWord\n"
"negate        = primNegateWord\n"
"(*)           = primMulWord\n"
"abs           = absReal\n"
"signum        = signumReal\n"
"fromInteger   = primIntegerToWord\n"
"fromInt       = intToWord32\n"
"\n"
"instance Bounded Word32 where\n"
"minBound = 0\n"
"maxBound = primMaxWord\n"
"\n"
"instance Real Word32 where\n"
"toRational x = toInteger x % 1\n"
"\n"
"instance Integral Word32 where\n"
"div       = primDivWord\n"
"quot      = primQuotWord\n"
"rem       = primRemWord\n"
"mod       = primModWord\n"
"quotRem   = primQrmWord\n"
"divMod    = quotRem\n"
"toInteger = primWordToInteger\n"
"toInt     = word32ToInt\n"
"\n"
"instance Ix Word32 where\n"
"range (m,n)          = [m..n]\n"
"index b@(m,n) i\n"
"| inRange b i = word32ToInt (i - m)\n"
"| otherwise   = error \"index: Index out of range\"\n"
"inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Word32 where\n"
"toEnum        = intToWord32\n"
"fromEnum      = word32ToInt\n"
"\n"
"--No: suffers from overflow problems:\n"
"--   [4294967295 .. 1] :: [Word32]\n"
"--   = [4294967295,0,1]\n"
"--enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Word32)]\n"
"--enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (last::Word32)]\n"
"--     	           where last = if d < c then minBound else maxBound\n"
"\n"
"enumFrom       = boundedEnumFrom\n"
"enumFromTo     = boundedEnumFromTo\n"
"enumFromThen   = boundedEnumFromThen\n"
"enumFromThenTo = boundedEnumFromThenTo\n"
"\n"
"boundedEnumFrom        :: (Ord a, Num a, Bounded a, Enum a) => a -> [a]\n"
"boundedEnumFromThen    :: (Ord a, Num a, Bounded a, Enum a) => a -> a -> [a]\n"
"boundedEnumFromTo      :: (Ord a, Num a, Bounded a, Enum a) => a -> a -> [a]\n"
"boundedEnumFromThenTo  :: (Ord a, Num a, Bounded a, Enum a) => a -> a -> a -> [a]\n"
"boundedEnumFrom n\n"
"| n == maxBound = [n]\n"
"| otherwise     = n : (boundedEnumFrom $! (n+1))\n"
"boundedEnumFromThen n m\n"
"| n <= m    = enum (< maxBound - delta) delta n\n"
"| otherwise = enum (> minBound - delta) delta n\n"
"where\n"
"delta = m - n\n"
"boundedEnumFromTo n m = takeWhile (<= m) (boundedEnumFrom n)\n"
"boundedEnumFromThenTo n n' m\n"
"| n' >= n   = if n <= m then enum (<= m - delta) delta n else []\n"
"| otherwise = if n >= m then enum (>= m - delta) delta n else []\n"
"where\n"
"delta = n'-n\n"
"\n"
"enum :: (Num a) => (a -> Bool) -> a -> a -> [a]\n"
"enum p delta x = if p x then x : (enum p delta $! (x+delta)) else [x]\n"
"\n"
"instance Read Word32 where\n"
"readsPrec p = readDec\n"
"\n"
"instance Show Word32 where\n"
"showsPrec p = showInt  -- a particularily counterintuitive name!\n"
"\n"
"instance Bits Word32 where\n"
"(.&.)         = primAndWord\n"
"(.|.)         = primOrWord\n"
"xor           = primXorWord\n"
"complement    = primComplementWord\n"
"shift         = primShiftWord\n"
"rotate        = primRotateWord 32\n"
"bit           = primBitWord\n"
"setBit x i    = x .|. bit i\n"
"clearBit x i  = x .&. complement (bit i)\n"
"complementBit x i = x `xor` bit i\n"
"testBit       = primTestWord\n"
"bitSize  _    = 32\n"
"isSigned _    = False\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Word64\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive word64ToWord32 \"primWord64ToWord32\" :: Word64 -> (Word32,Word32)\n"
"primitive word32ToWord64 \"primWord32ToWord64\" :: Word32 -> Word32 -> Word64\n"
"\n"
"integerToW64 :: Integer -> Word64\n"
"integerToW64 x = case x `quotRem` 0x100000000 of\n"
"(hi,lo) -> word32ToWord64 (fromInteger hi) (fromInteger lo)\n"
"\n"
"w64ToInteger :: Word64 -> Integer\n"
"w64ToInteger x = case word64ToWord32 x of\n"
"(hi,lo) -> toInteger hi * 0x100000000 + toInteger lo\n"
"\n"
"instance Eq Word64 where\n"
"x == y = word64ToWord32 x == word64ToWord32 y\n"
"\n"
"instance Ord Word64 where\n"
"compare x y = compare (word64ToWord32 x) (word64ToWord32 y)\n"
"\n"
"instance Bounded Word64 where\n"
"minBound = word32ToWord64 minBound minBound\n"
"maxBound = word32ToWord64 maxBound maxBound\n"
"\n"
"instance Show Word64 where\n"
"showsPrec p = showInt . toInteger\n"
"\n"
"instance Read Word64 where\n"
"readsPrec p s = [ (fromInteger x,r) | (x,r) <- readDec s ]\n"
"\n"
"instance Num Word64 where\n"
"x + y         = fromInteger (toInteger x + toInteger y)\n"
"x - y         = fromInteger (toInteger x - toInteger y)\n"
"x * y         = fromInteger (toInteger x * toInteger y)\n"
"abs           = absReal\n"
"signum        = signumReal\n"
"fromInteger   = integerToW64\n"
"\n"
"instance Real Word64 where\n"
"toRational x = toInteger x % 1\n"
"\n"
"instance Ix Word64 where\n"
"range (m,n)          = [m..n]\n"
"index b@(m,n) i\n"
"| inRange b i = toInt (i - m)\n"
"| otherwise   = error \"index: Index out of range\"\n"
"inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Word64 where\n"
"toEnum           = fromInt\n"
"fromEnum         = toInt\n"
"\n"
"succ             = fromInteger . (+1) . toInteger\n"
"pred             = fromInteger . (subtract 1) . toInteger\n"
"enumFrom x       = map fromInteger [toInteger x ..]\n"
"enumFromTo x y   = map fromInteger [toInteger x .. toInteger y]\n"
"enumFromThen x y = map fromInteger [toInteger x, toInteger y ..]\n"
"enumFromThenTo x y z =\n"
"map fromInteger [toInteger x, toInteger y .. toInteger z]\n"
"\n"
"instance Integral Word64 where\n"
"x `quotRem` y = (fromInteger q, fromInteger r)\n"
"where (q,r) = toInteger x `quotRem` toInteger y\n"
"toInteger     = w64ToInteger\n"
"\n"
"instance Bits Word64 where\n"
"x .&. y       = liftBinary (.&.) x y\n"
"x .|. y       = liftBinary (.|.) x y\n"
"x `xor` y     = liftBinary xor x y\n"
"complement    = liftUnary complement\n"
"x `shift` i   = fromInteger (toInteger x `shift` i)\n"
"x `rotate` i  | i<0  = (x `shift` i) .|. (x `shift` (i+bitSize x))\n"
"| i==0 = x\n"
"| i>0  = (x `shift` i) .|. (x `shift` (i-bitSize x))\n"
"bit i | i `mod` 64 < 32 = word32ToWord64 0 (bit i)\n"
"| otherwise       = word32ToWord64 (bit i) 0\n"
"bitSize  _    = 64\n"
"isSigned _    = False\n"
"\n"
"liftBinary :: (Word32 -> Word32 -> Word32) -> Word64 -> Word64 -> Word64\n"
"liftBinary op x y = word32ToWord64 (op xhi yhi) (op xlo ylo)\n"
"where	(xhi,xlo) = word64ToWord32 x\n"
"(yhi,ylo) = word64ToWord32 y\n"
"\n"
"liftUnary :: (Word32 -> Word32) -> Word64 -> Word64\n"
"liftUnary op x = word32ToWord64 (op xhi) (op xlo)\n"
"where	(xhi,xlo) = word64ToWord32 x\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- End of exported definitions\n"
"--\n"
"-- The remainder of this file consists of definitions which are only\n"
"-- used in the implementation.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Coercions - used to make the instance declarations more uniform\n"
"-----------------------------------------------------------------------------\n"
"\n"
"class Coerce a where\n"
"to   :: Word32 -> a\n"
"from :: a -> Word32\n"
"\n"
"instance Coerce Word8 where\n"
"from = word8ToWord32\n"
"to   = word32ToWord8\n"
"\n"
"instance Coerce Word16 where\n"
"from = word16ToWord32\n"
"to   = word32ToWord16\n"
"\n"
"binop :: Coerce word => (Word32 -> Word32 -> a) -> (word -> word -> a)\n"
"binop op x y = from x `op` from y\n"
"\n"
"to2 :: Coerce word => (Word32, Word32) -> (word, word)\n"
"to2 (x,y) = (to x, to y)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- primitives\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive primEqWord        :: Word32 -> Word32 -> Bool\n"
"primitive primCmpWord       :: Word32 -> Word32 -> Ordering\n"
"primitive primPlusWord,\n"
"primMinusWord,\n"
"primMulWord	    :: Word32 -> Word32 -> Word32\n"
"primitive primNegateWord    :: Word32 -> Word32\n"
"primitive primIntegerToWord :: Integer -> Word32\n"
"primitive primMaxWord       :: Word32\n"
"primitive primDivWord,\n"
"primQuotWord,\n"
"primRemWord,\n"
"primModWord       :: Word32 -> Word32 -> Word32\n"
"primitive primQrmWord       :: Word32 -> Word32 -> (Word32,Word32)\n"
"primitive primWordToInteger :: Word32 -> Integer\n"
"primitive primAndWord       :: Word32 -> Word32 -> Word32\n"
"primitive primOrWord        :: Word32 -> Word32 -> Word32\n"
"primitive primXorWord       :: Word32 -> Word32 -> Word32\n"
"primitive primComplementWord:: Word32 -> Word32\n"
"primitive primShiftWord     :: Word32 -> Int -> Word32\n"
"primitive primRotateWord    :: Int -> Word32 -> Int -> Word32\n"
"primitive primBitWord       :: Int -> Word32\n"
"primitive primTestWord      :: Word32 -> Int -> Bool\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Code copied from the Prelude\n"
"-----------------------------------------------------------------------------\n"
"\n"
"absReal x    | x >= 0    = x\n"
"| otherwise = -x\n"
"\n"
"signumReal x | x == 0    =  0\n"
"| x > 0     =  1\n"
"| otherwise = -1\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- End\n"
"-----------------------------------------------------------------------------\n";
const char *quote_hs = "module Hugs.Quote(Quote, quote, trim) where\n"
"\n"
"import Data.List\n"
"import Data.Ratio(Ratio)\n"
"\n"
"class Quote a where\n"
"quote :: a -> String\n"
"\n"
"instance Quote Char where\n"
"quote c = [c]\n"
"\n"
"instance Quote String where\n"
"quote = id\n"
"\n"
"instance Quote Bool where\n"
"quote = show\n"
"\n"
"instance Show a => Quote (Maybe a) where\n"
"quote = show\n"
"\n"
"instance Quote Int where\n"
"quote = show\n"
"\n"
"instance Quote Integer where\n"
"quote = show\n"
"\n"
"instance Quote Float where\n"
"quote = show\n"
"\n"
"instance Quote Double where\n"
"quote = show\n"
"\n"
"instance Integral a => Quote (Ratio a) where\n"
"quote = show\n"
"\n"
"-- trims off leading whitespace up to a common prefix,\n"
"-- making it easy to layout here docs indented so that\n"
"-- are not visually confusing (especially if you are doing\n"
"-- something like using here docs to generate Haskell code)\n"
"\n"
"trim s = unlines' ls'\n"
"where ls  = lines' s\n"
"ls' = map (trimoff 0 n) ls\n"
"n = case filter (/= 0) $ map (whitecount 0) ls of\n"
"[] -> 0\n"
"xs -> minimum xs\n"
"\n"
"-- like the prelude functions, but preserve (lack of) trailing newline\n"
"lines' s    = let (l,s') = break ('\\n'==) s\n"
"in l : case s' of []      -> []\n"
"(_:s'') -> lines' s''\n"
"unlines' ss = concat $ intersperse \"\\n\" ss\n"
"\n"
"whitecount n []        = n\n"
"whitecount n (' ':cs)  = whitecount (n + 1) cs\n"
"whitecount n ('\\t':cs) = whitecount (8 * ((n + 8) `div` 8)) cs\n"
"whitecount n _         = n\n"
"\n"
"trimoff n m [] = []\n"
"trimoff n m cs | n >= m = cs\n"
"trimoff n m (' ' :cs) = trimoff (n + 1) m cs\n"
"trimoff n m ('\\t':cs) = trimoff (8 * ((n + 8) `div` 8)) m cs\n"
"trimoff n m cs        = cs\n";
const char *lazyst_hs = "-----------------------------------------------------------------------------\n"
"-- Lazy State Thread module\n"
"--\n"
"-- This library provides support for both lazy and strict state threads,\n"
"-- as described in the PLDI '94 paper by John Launchbury and Simon Peyton\n"
"-- Jones.  In addition to the monad ST, it also provides mutable variables\n"
"-- STRef and mutable arrays STArray.  It is identical to the ST module\n"
"-- except that the ST instance is lazy.\n"
"--\n"
"-- Suitable for use with Hugs 98.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.LazyST\n"
"( ST\n"
", runST\n"
", unsafeInterleaveST\n"
", fixST\n"
"\n"
", lazyToStrictST\n"
", strictToLazyST\n"
") where\n"
"\n"
"import qualified Hugs.ST as ST\n"
"import Control.Monad\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"newtype ST s a = ST (State s -> (a, State s))\n"
"\n"
"unST :: ST s a -> State s -> (a, State s)\n"
"unST (ST f) = f\n"
"\n"
"runST :: (forall s. ST s a) -> a\n"
"runST m = fst (unST m S)\n"
"\n"
"unsafeInterleaveST :: ST s a -> ST s a\n"
"unsafeInterleaveST (ST m) = return (fst (m S))\n"
"\n"
"fixST :: (a -> ST s a) -> ST s a\n"
"fixST f = ST (\\s -> let (x,s') = unST (f x) s in (x,s'))\n"
"\n"
"instance Functor (ST s) where\n"
"fmap = liftM\n"
"\n"
"instance Monad (ST s) where\n"
"return a = ST (\\s -> (a, s))\n"
"ST m >>= f = ST (\\S -> let (a,s') = m S in unST (f a) s')\n"
"-- ST m >>= f = ST (\\s -> let (a,s') = m s in unST (f a) s')\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"data State s = S\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"lazyToStrictST :: ST s a -> ST.ST s a\n"
"lazyToStrictST (ST m) = ST.ST (\\k -> case m S of (a,S) -> k a)\n"
"\n"
"strictToLazyST :: ST.ST s a -> ST s a\n"
"strictToLazyST (ST.ST m) = ST (\\S -> m delay)\n"
"--	\\s -> let (a',s') = case s of S -> m (\\a -> (a,S)) in (a',s'))\n"
"\n"
"delay :: a -> (a, State s)\n"
"delay a = (a,S)\n"
"\n"
"-----------------------------------------------------------------------------\n";
const char *char_hs = "module Hugs.Char (\n"
"isAscii, isLatin1, isControl, isPrint, isSpace, isUpper, isLower,\n"
"isAlpha, isDigit, isOctDigit, isHexDigit, isAlphaNum,\n"
"intToDigit,\n"
"toUpper, toLower,\n"
"ord, chr,\n"
"readLitChar, showLitChar, lexLitChar\n"
") where\n"
"\n"
"import Hugs.Prelude(\n"
"isSpace, isUpper, isLower,\n"
"isAlpha, isDigit, isOctDigit, isHexDigit, isAlphaNum,\n"
"readLitChar, showLitChar, lexLitChar)\n"
"\n"
"-- The Hugs Char type covers only the ISO 8859-1 (Latin-1) subset of Unicode,\n"
"-- i.e. '\\0' to '\\xff'.\n"
"\n"
"-- Character-testing operations (some others are in Hugs.Prelude)\n"
"isAscii, isLatin1, isControl, isPrint :: Char -> Bool\n"
"\n"
"isAscii c                =  c < '\\x80'\n"
"\n"
"isLatin1 c               =  True	-- c <= '\\xff'\n"
"\n"
"isControl c              =  c < ' ' || c >= '\\DEL' && c <= '\\x9f'\n"
"\n"
"isPrint c                =  not (isControl c)\n"
"\n"
"-- Digit conversion operations\n"
"intToDigit               :: Int -> Char\n"
"intToDigit i\n"
"| i >= 0  && i <=  9   =  toEnum (fromEnum '0' + i)\n"
"| i >= 10 && i <= 15   =  toEnum (fromEnum 'a' + i - 10)\n"
"| otherwise            =  error \"Char.intToDigit: not a digit\"\n"
"\n"
"-- Case-changing operations\n"
"toUpper                  :: Char -> Char\n"
"toUpper '\\xdf'           = '\\xdf'	-- lower, but no upper in Latin-1\n"
"toUpper '\\xff'           = '\\xff'	-- lower, but no upper in Latin-1\n"
"toUpper c | isLower c    =  toEnum (fromEnum c - fromEnum 'a' + fromEnum 'A')\n"
"| otherwise    =  c\n"
"\n"
"toLower                  :: Char -> Char\n"
"toLower c | isUpper c    =  toEnum (fromEnum c - fromEnum 'A' + fromEnum 'a')\n"
"| otherwise    =  c\n"
"\n"
"-- Character code functions\n"
"ord                      :: Char -> Int\n"
"ord                      =  fromEnum\n"
"\n"
"chr                      :: Int  -> Char\n"
"chr                      =  toEnum\n";
const char *internals_hs = "----------------------------------------------------------------\n"
"-- Primitives for accessing Hugs internals.\n"
"--\n"
"-- NB These primitives are an _experimental_ feature which may be\n"
"--    removed in future versions of Hugs.\n"
"--    They can only be used if hugs was configured with the\n"
"--    \"--enable-internal-prims\" flag.\n"
"--\n"
"-- The primitives defined in this module provide the means with\n"
"-- which to implement simple error-recovery and debugging facilities\n"
"-- in Haskell.\n"
"--\n"
"-- The error catching primitive only works if the \"failOnError\" flag\n"
"-- is FALSE - ie Hugs was invoked with the \"-f\" flag.\n"
"--\n"
"-- Despite appearances, these primitives are referentially transparent\n"
"-- (with the exception of the rarely used pointer equality operations)\n"
"-- (The proof is really neat - but there just isn't enough space in the margin)\n"
"----------------------------------------------------------------\n"
"\n"
"module Hugs.Internals(\n"
"ptrEq,\n"
"\n"
"Name,\n"
"nameString,\n"
"nameInfo,\n"
"nameEq,\n"
"Cell,\n"
"getCell,\n"
"cellPtrEq,\n"
"CellKind(..),\n"
"classifyCell,\n"
"\n"
"catchError,\n"
"\n"
"Addr,\n"
"nameCode,\n"
"Instr(..),\n"
"instrAt, instrsAt,\n"
"\n"
") where\n"
"\n"
"import Hugs.Prelude hiding ( Addr )\n"
"\n"
"----------------------------------------------------------------\n"
"-- pointer equality\n"
"----------------------------------------------------------------\n"
"\n"
"-- breaks referential transparency - use with care\n"
"primitive ptrEq \"unsafePtrEq\" :: a -> a -> Bool\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"-- Name\n"
"----------------------------------------------------------------\n"
"\n"
"data Name\n"
"-- newtype Name = Name Int\n"
"\n"
"-- returns (arity, precedence, associativity)\n"
"primitive nameInfo       :: Name -> (Int, Int, Char)\n"
"primitive nameString     :: Name -> String\n"
"primitive nameEq         :: Name -> Name -> Bool\n"
"\n"
"instance Show Name where\n"
"showsPrec _ nm = showString (nameString nm)\n"
"\n"
"instance Eq Name where\n"
"(==) = nameEq\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"-- Cell\n"
"-- Note: cellPtrEq breaks referential transparency - use with care\n"
"----------------------------------------------------------------\n"
"\n"
"data Cell\n"
"\n"
"primitive getCell                  :: a -> Cell\n"
"primitive cellPtrEq                :: Cell -> Cell -> Bool\n"
"primitive catchError \"catchError2\" :: a -> Either Cell a\n"
"\n"
"instance Show Cell where\n"
"showsPrec _ _ = showString \"{Cell}\"\n"
"\n"
"----------------------------------------------------------------\n"
"-- CellType\n"
"----------------------------------------------------------------\n"
"\n"
"data CellKind\n"
"= Apply   Cell [Cell]\n"
"| Fun     Name\n"
"| Con     Name\n"
"| Tuple   Int\n"
"| Int     Int\n"
"| Integer Integer\n"
"| Float   Float\n"
"| Double  Double\n"
"| Char    Char\n"
"| Prim    String\n"
"| Error   Cell\n"
"deriving (Show)\n"
"\n"
"primitive classifyCell :: Bool -> Cell -> IO CellKind\n"
"\n"
"----------------------------------------------------------------\n"
"-- Addr\n"
"----------------------------------------------------------------\n"
"\n"
"newtype Addr  = Addr  Int deriving (Eq, Show)\n"
"\n"
"s :: Addr -> Addr\n"
"s (Addr a) = Addr (a+1)\n"
"\n"
"primitive nameCode    :: Name -> Addr\n"
"primitive intAt       :: Addr -> Int\n"
"primitive floatAt     :: Addr -> Float\n"
"primitive doubleAt    :: Addr -> Double\n"
"primitive cellAt      :: Addr -> Cell\n"
"primitive nameAt      :: Addr -> Name\n"
"primitive textAt      :: Addr -> String\n"
"primitive addrAt      :: Addr -> Addr\n"
"primitive bytecodeAt :: Addr -> Bytecode\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"-- Bytecode\n"
"----------------------------------------------------------------\n"
"\n"
"newtype Bytecode = Bytecode Int deriving (Eq, Show)\n"
"\n"
"iLOAD    = Bytecode 0\n"
"iCELL	 = Bytecode 1\n"
"iCHAR	 = Bytecode 2\n"
"iINT	 = Bytecode 3\n"
"iFLOAT	 = Bytecode 4\n"
"iSTRING	 = Bytecode 5\n"
"iMKAP	 = Bytecode 6\n"
"iUPDATE	 = Bytecode 7\n"
"iUPDAP	 = Bytecode 8\n"
"iEVAL	 = Bytecode 9\n"
"iRETURN	 = Bytecode 10\n"
"iTEST	 = Bytecode 11\n"
"iGOTO	 = Bytecode 12\n"
"iSETSTK	 = Bytecode 13\n"
"iROOT	 = Bytecode 14\n"
"iDICT	 = Bytecode 15\n"
"iFAIL	 = Bytecode 16\n"
"iALLOC	 = Bytecode 17\n"
"iSLIDE	 = Bytecode 18\n"
"iSTAP	 = Bytecode 19\n"
"iTABLE	 = Bytecode 20\n"
"iLEVAL	 = Bytecode 21\n"
"iRUPDAP	 = Bytecode 22\n"
"iRUPDATE = Bytecode 23\n"
"\n"
"data Instr\n"
"= LOAD    Int\n"
"| CELL    Cell\n"
"| CHAR    Char\n"
"| INT	    Int\n"
"| FLOAT   Float\n"
"| DOUBLE  Double\n"
"| STRING  String\n"
"| MKAP    Int\n"
"| UPDATE  Int\n"
"| UPDAP   Int\n"
"| EVAL\n"
"| RETURN\n"
"| TEST    Name Addr\n"
"| GOTO    Addr\n"
"| SETSTK  Int\n"
"| ROOT    Int\n"
"| DICT    Int\n"
"| FAIL\n"
"| ALLOC   Int\n"
"| SLIDE   Int\n"
"| STAP\n"
"| TABLE\n"
"| LEVAL   Int\n"
"| RUPDAP\n"
"| RUPDATE\n"
"deriving (Show)\n"
"\n"
"instrAt :: Addr -> (Instr, Addr)\n"
"instrAt pc = case bytecodeAt pc of\n"
"i | i == iLOAD    -> (LOAD    (intAt   (s pc)), s (s pc))\n"
"i | i == iCELL    -> (CELL    (cellAt  (s pc)), s (s pc))\n"
"i | i == iCHAR    -> (CHAR    (toEnum (intAt (s pc))), s (s pc))\n"
"i | i == iINT     -> (INT     (intAt   (s pc)), s (s pc))\n"
"i | i == iFLOAT   -> (FLOAT   (floatAt (s pc)), s (s pc))\n"
"i | i == iSTRING  -> (STRING  (textAt  (s pc)), s (s pc))\n"
"i | i == iMKAP    -> (MKAP    (intAt   (s pc)), s (s pc))\n"
"i | i == iUPDATE  -> (UPDATE  (intAt   (s pc)), s (s pc))\n"
"i | i == iUPDAP   -> (UPDAP   (intAt   (s pc)), s (s pc))\n"
"i | i == iEVAL    -> (EVAL                    , s pc)\n"
"i | i == iRETURN  -> (RETURN                  , s pc)\n"
"i | i == iTEST    -> (TEST    (nameAt  (s pc)) (addrAt (s (s (pc)))), s (s (s pc)))\n"
"i | i == iGOTO    -> (GOTO    (addrAt  (s pc)), s (s pc))\n"
"i | i == iSETSTK  -> (SETSTK  (intAt   (s pc)), s (s pc))\n"
"i | i == iROOT    -> (ROOT    (intAt   (s pc)), s (s pc))\n"
"i | i == iDICT    -> (DICT    (intAt   (s pc)), s (s pc))\n"
"i | i == iFAIL    -> (FAIL                    , s pc)\n"
"i | i == iALLOC   -> (ALLOC   (intAt   (s pc)), s (s pc))\n"
"i | i == iSLIDE   -> (SLIDE   (intAt   (s pc)), s (s pc))\n"
"i | i == iSTAP    -> (STAP                    , s pc)\n"
"i | i == iTABLE   -> (TABLE                   , s pc)\n"
"i | i == iLEVAL   -> (LEVAL   (intAt   (s pc)), s (s pc))\n"
"i | i == iRUPDAP  -> (RUPDAP                  , s pc)\n"
"i | i == iRUPDATE -> (RUPDATE                 , s pc)\n"
"\n"
"-- list of instructions starting at given address\n"
"instrsAt :: Addr -> [Instr]\n"
"instrsAt pc = let (i, pc')  = instrAt pc in i : instrsAt pc'\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"-- tests\n"
"----------------------------------------------------------------\n"
"\n"
"-- test1, test2 :: Either Cell Int\n"
"--\n"
"-- test1 = catchError (error \"foo\")\n"
"-- test2 = catchError 1\n"
"--\n"
"--\n"
"-- test3, test4, test5 :: Int\n"
"--\n"
"-- test3 = myCatch (1+error \"foo\") 2\n"
"-- test4 = myCatch 1 (error \"bar\")\n"
"-- test5 = myCatch (error \"foo\") (error \"bar\")\n"
"--\n"
"--\n"
"-- test6, test7, test8, test9 :: IO ()\n"
"--\n"
"-- test6 = printString \"abcdefg\"\n"
"-- test7 = printString (error \"a\" : \"bcdefg\")\n"
"-- test8 = printString (\"abc\" ++ error \"defg\")\n"
"-- test9 = printString (error \"a\" : \"bc\" ++ error \"defg\")\n"
"--\n"
"-- -- if an error occurs, replace it with a default (hopefully error-free) value\n"
"-- myCatch :: a -> a -> a\n"
"-- myCatch x deflt = case catchError x of\n"
"-- 		   Right x' -> x'\n"
"-- 		   Left _   -> deflt\n"
"--\n"
"-- -- lazily print a string - catching any errors as necessary\n"
"-- printString :: String -> IO ()\n"
"-- printString str =\n"
"--   case catchError str of\n"
"--   Left _       -> putStr \"<error>\"\n"
"--   Right []     -> return ()\n"
"--   Right (c:cs) -> case catchError c of\n"
"-- 		     Left _   -> putStr \"<error>\" >> printString cs\n"
"-- 		     Right c' -> putChar c' >> printString cs\n"
"\n"
"\n"
"\n";
const char *memo_hs = "{-----------------------------------------------------------------------------\n"
"\n"
"A LIBRARY OF MEMOIZATION COMBINATORS\n"
"\n"
"15th September 1999\n"
"\n"
"Byron Cook\n"
"OGI\n"
"\n"
"This Hugs module implements several flavors of memoization functions,\n"
"as described in Haskell Workshop 1997.\n"
"-----------------------------------------------------------------------------}\n"
"\n"
"module Hugs.Memo(\n"
"memo,\n"
"memoN,\n"
"memoFix,\n"
"memoFixN,\n"
"cache,\n"
"cacheN,\n"
"cacheFix,\n"
"cacheFixN\n"
") where\n"
"\n"
"import Hugs.ST\n"
"-- import Hugs.IOExts (unsafePtrEq)\n"
"-- import Debug.Trace (trace)\n"
"\n"
"memo      :: (a -> b) -> (a -> b)\n"
"memoN     :: Int -> (a -> b) -> (a -> b)\n"
"memoFix   :: ((a -> b) -> (a -> b)) -> (a -> b)\n"
"memoFixN  :: Int -> ((a -> b) -> (a -> b)) -> (a -> b)\n"
"cache     :: (a -> b) -> (a -> b)\n"
"cacheN    :: Int -> (a -> b) -> (a -> b)\n"
"cacheFix  :: ((a -> b) -> (a -> b)) -> (a -> b)\n"
"cacheFixN :: Int -> ((a -> b) -> (a -> b)) -> (a -> b)\n"
"\n"
"----------------------------------------------------------------\n"
"-- Memoization Functions (memo-tables are hash-tables)\n"
"----------------------------------------------------------------\n"
"memo          = memoN defaultSize\n"
"memoN         = mkMemo eql hash\n"
"\n"
"memoFix       = memoFixN defaultSize\n"
"memoFixN n f  = let g = f h\n"
"h = memoN n g\n"
"in g\n"
"\n"
"----------------------------------------------------------------\n"
"-- Caching Functions (memo-tables are caches)\n"
"----------------------------------------------------------------\n"
"cache          = cacheN defaultSize\n"
"cacheN         = mkCache eql hash\n"
"cacheFix       = cacheFixN defaultSize\n"
"cacheFixN n f  = let g = f h\n"
"h = cacheN n g\n"
"in g\n"
"\n"
"----------------------------------------------------------------\n"
"-- Type synonyms\n"
"----------------------------------------------------------------\n"
"type TaintedEq a   = a -> a -> ST Mem Bool\n"
"type HashTable a b = STArray Mem Int [(a,b)]\n"
"type Cache a b     = STArray Mem Int (Maybe (a,b))\n"
"type HashSize      = Int\n"
"type HashFunc a    = a -> ST Mem Int\n"
"type Mem           = ()\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"-- Foundation functions\n"
"----------------------------------------------------------------\n"
"defaultSize :: HashSize\n"
"defaultSize = 40\n"
"\n"
"memoize :: ST Mem t -> (t -> a -> b -> ST Mem b) ->\n"
"(a -> b) -> a -> b\n"
"memoize new access f = {-trace \"memoize\" $-} unsafeRunST $ do\n"
"t <- new\n"
"return (\\x -> unsafeRunST $ access t x (f x))\n"
"\n"
"\n"
"mkMemo  :: TaintedEq a -> HashFunc a -> Int -> (a -> c) -> (a -> c)\n"
"mkCache :: TaintedEq a -> HashFunc a -> Int -> (a -> c) -> (a -> c)\n"
"\n"
"mkCache e h sz = memoize (newCache sz) (accessCache e h sz)\n"
"mkMemo  e h sz = memoize (newHash sz)  (accessHash e  h sz)\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"-- Hash and Cache Tables\n"
"----------------------------------------------------------------\n"
"accessHash  :: TaintedEq a ->\n"
"HashFunc a ->\n"
"Int ->\n"
"HashTable a b ->\n"
"a -> b -> ST Mem b\n"
"\n"
"accessHash equal h sz table x v = do\n"
"hv' <- h x\n"
"let hv = hv' `mod` sz\n"
"l <- readSTArray table hv\n"
"find l l hv\n"
"where find l [] hv = {-trace \"miss \" $-} do\n"
"u <- writeSTArray table  hv ((x,v):l)\n"
"case u of {() -> return v}\n"
"find l ((x',v'):xs) hv = do\n"
"a <- equal x x'\n"
"if a then {-trace \"hit \"-} (return $ v')\n"
"else find l xs hv\n"
"\n"
"newHash :: Int -> ST Mem (HashTable a b)\n"
"newHash n = newSTArray (0,n) []\n"
"\n"
"\n"
"accessCache  :: TaintedEq a ->\n"
"HashFunc a ->\n"
"Int ->\n"
"Cache a b ->\n"
"a -> b -> ST Mem b\n"
"\n"
"accessCache equal h sz table x v = do\n"
"hv' <- h x\n"
"let hv = hv' `mod` sz\n"
"l <-  readSTArray table hv\n"
"case l of\n"
"Nothing      -> do u <- writeSTArray table hv (Just (x,v))\n"
"case u of {() -> return v}\n"
"Just (x',y)  -> do e <- equal x' x\n"
"if e then return y\n"
"else do u <- writeSTArray table hv (Just (x,v))\n"
"case u of {() -> return v}\n"
"\n"
"newCache :: Int -> ST Mem (Cache a b)\n"
"newCache n = newSTArray (0,n) Nothing\n"
"\n"
"------------------------------------------------------------------\n"
"-- These functions are bad --- dont pay attention to them\n"
"\n"
"-- lisp style eql --- as described in \"Lazy-memo functions\"\n"
"primitive eql \"IOEql\" :: a -> a -> ST Mem Bool\n"
"-- a `eql` b = return (a `unsafePtrEq` b)\n"
"\n"
"-- hash based on addresses (or values if the arg is a base type)\n"
"primitive hash \"IOHash\" :: a -> ST Mem Int\n"
"\n"
"------------------------------------------------------------------\n";
const char *storable_aux_h = "#ifndef STORABLE_AUX_H\n"
"#define STORABLE_AUX_H\n"
"\n"
"#include \"HsFFI.h\"\n"
"\n"
"#define DECLARE(T) \\\n"
"void write##T##OffPtr(Hs##T *arg1, HsInt arg2, Hs##T arg3); \\\n"
"Hs##T read##T##OffPtr(Hs##T *arg1, HsInt arg2);\n"
"\n"
"DECLARE(Int       )\n"
"DECLARE(Char      )\n"
"/* DECLARE(WideChar  ) */\n"
"DECLARE(Word      )\n"
"DECLARE(Ptr       )\n"
"DECLARE(FunPtr    )\n"
"DECLARE(Float     )\n"
"DECLARE(Double    )\n"
"DECLARE(StablePtr )\n"
"DECLARE(Int8      )\n"
"DECLARE(Int16     )\n"
"DECLARE(Int32     )\n"
"DECLARE(Int64     )\n"
"DECLARE(Word8     )\n"
"DECLARE(Word16    )\n"
"DECLARE(Word32    )\n"
"DECLARE(Word64    )\n"
"\n"
"#undef DECLARE\n"
"\n"
"#endif /* STORABLE_AUX_H */\n";
const char *ioarray_hs = "-----------------------------------------------------------------------------\n"
"-- Mutable arrays in the IO monad:\n"
"--\n"
"-- Suitable for use with Hugs 98.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.IOArray\n"
"( IOArray			-- instance of: Eq, Typeable\n"
", newIOArray\n"
", boundsIOArray\n"
", readIOArray\n"
", writeIOArray\n"
", freezeIOArray\n"
", thawIOArray\n"
", unsafeFreezeIOArray\n"
", unsafeReadIOArray\n"
", unsafeWriteIOArray\n"
") where\n"
"\n"
"import Hugs.Array\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"data IOArray ix elt -- implemented as an internal primitive\n"
"\n"
"newIOArray          :: Ix ix => (ix,ix) -> elt -> IO (IOArray ix elt)\n"
"boundsIOArray       :: Ix ix => IOArray ix elt -> (ix, ix)\n"
"readIOArray         :: Ix ix => IOArray ix elt -> ix -> IO elt\n"
"writeIOArray        :: Ix ix => IOArray ix elt -> ix -> elt -> IO ()\n"
"thawIOArray         :: Ix ix => Array ix elt -> IO (IOArray ix elt)\n"
"freezeIOArray       :: Ix ix => IOArray ix elt -> IO (Array ix elt)\n"
"unsafeFreezeIOArray :: Ix ix => IOArray ix elt -> IO (Array ix elt)\n"
"\n"
"unsafeReadIOArray   :: Ix i => IOArray i e -> Int -> IO e\n"
"unsafeReadIOArray    = primReadArr\n"
"\n"
"unsafeWriteIOArray  :: Ix i => IOArray i e -> Int -> e -> IO ()\n"
"unsafeWriteIOArray   = primWriteArr\n"
"\n"
"newIOArray bs e      = primNewArr bs (rangeSize bs) e\n"
"boundsIOArray a      = primBounds a\n"
"readIOArray a i      = unsafeReadIOArray a (index (boundsIOArray a) i)\n"
"writeIOArray a i e   = unsafeWriteIOArray a (index (boundsIOArray a) i) e\n"
"thawIOArray arr      = do a <- newIOArray (bounds arr) err\n"
"let fillin []          = return a\n"
"fillin((ix,v):ixs) = do writeIOArray a ix v\n"
"fillin ixs\n"
"fillin (assocs arr)\n"
"where err =  error \"thawArray: element not overwritten\"\n"
"\n"
"freezeIOArray a      = primFreeze a\n"
"unsafeFreezeIOArray  = freezeIOArray  -- not as fast as GHC\n"
"\n"
"instance Eq (IOArray ix elt) where\n"
"(==) = eqIOArray\n"
"\n"
"primitive primNewArr   \"IONewArr\"\n"
":: (a,a) -> Int -> b -> IO (IOArray a b)\n"
"primitive primReadArr  \"IOReadArr\"\n"
":: IOArray a b -> Int -> IO b\n"
"primitive primWriteArr \"IOWriteArr\"\n"
":: IOArray a b -> Int -> b -> IO ()\n"
"primitive primFreeze   \"IOFreeze\"\n"
":: IOArray a b -> IO (Array a b)\n"
"primitive primBounds   \"IOBounds\"\n"
":: IOArray a b -> (a,a)\n"
"primitive eqIOArray    \"IOArrEq\"\n"
":: IOArray a b -> IOArray a b -> Bool\n"
"\n"
"-----------------------------------------------------------------------------\n";
const char *weak_hs = "-- A first cut at implementing the (key,value) form of Weak pointers.\n"
"--\n"
"-- Notes (please refer to the draft specification for background):\n"
"--\n"
"--  - Programmers using weak pointers should call runFinalizer at\n"
"--    regular intervals to ensure that finalizers are scheduled for\n"
"--    execution.  This implementation provides functions runFinalizer,\n"
"--    finalizerWaiting, and runAllFinalizers to provide programmers with\n"
"--    control over the execution of finalizers.  None of these functions\n"
"--    are part of the current specification.\n"
"--\n"
"-- Tested with Hugs 98.\n"
"\n"
"module Hugs.Weak(Weak,\n"
"mkWeak, deRefWeak, finalize, replaceFinalizer,\n"
"runFinalizer, finalizerWaiting, runAllFinalizers ) where\n"
"\n"
"data Weak a\n"
"\n"
"primitive mkWeak    :: k -> v -> Maybe (IO ()) -> IO (Weak v)\n"
"primitive deRefWeak :: Weak v -> IO (Maybe v)\n"
"primitive replaceFinalizer :: Weak v -> Maybe (IO ()) -> IO (Maybe (IO ()))\n"
"primitive finalize  :: Weak v -> IO ()\n"
"primitive weakPtrEq :: Weak a -> Weak a -> Bool\n"
"\n"
"instance Eq (Weak a) where\n"
"(==) = weakPtrEq\n"
"\n"
"primitive runFinalizer     :: IO ()\n"
"primitive finalizerWaiting :: IO Bool\n"
"\n"
"runAllFinalizers    :: IO ()\n"
"runAllFinalizers     = do waiting <- finalizerWaiting\n"
"if waiting then do runFinalizer\n"
"runAllFinalizers\n"
"else return ()\n"
"\n"
"{- for testing purposes\n"
"primitive gc \"primGC\" :: IO ()\n"
"\n"
"-- not a CAF!\n"
"test z = do\n"
"{ let k = [z]		-- use a list so we're sure it's heap allocated\n"
"; print k		-- this makes sure x is in whnf\n"
"; w <- mkWeak k \"value\" (Just (putStrLn (\"Finalizer for \"++show k)))\n"
"-- note that the finalizer uses the key, but\n"
"-- this shouldn't keep the weak ptr alive!\n"
"; showWeakPtr w\n"
"; gc\n"
"; print k		-- this makes sure k is still alive after the GC\n"
"; showWeakPtr w	-- so it's probably still alive here\n"
"; gc\n"
"; showWeakPtr w	-- but ought to be dead by here\n"
"}\n"
"\n"
"showWeakPtr :: Show a => Weak a -> IO ()\n"
"showWeakPtr w = do\n"
"{ x <- deRefWeak w\n"
"; print x\n"
"}\n"
"\n"
"-}\n"
"\n"
"-- End of module Weak\n";
const char *io_hs = "-----------------------------------------------------------------------------\n"
"-- Standard Library: IO operations, beyond those included in the prelude\n"
"--\n"
"-- Suitable for use with Hugs 98\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.IO (\n"
"Handle,          -- instances: Eq, Show.\n"
"HandlePosn,      -- instances: Eq, Show.\n"
"\n"
"IOMode(ReadMode,WriteMode,AppendMode,ReadWriteMode),\n"
"BufferMode(NoBuffering,LineBuffering,BlockBuffering),\n"
"SeekMode(AbsoluteSeek,RelativeSeek,SeekFromEnd),\n"
"\n"
"stdin, stdout, stderr,  -- :: Handle\n"
"openFile,		    -- :: FilePath -> IOMode -> IO Handle\n"
"hClose, 		    -- :: Handle -> IO ()\n"
"\n"
"hFileSize,		    -- :: Handle -> IO Integer\n"
"\n"
"hIsEOF,                 -- :: Handle -> IO Bool\n"
"isEOF,                  -- :: IO Bool\n"
"\n"
"hSetBuffering,          -- :: Handle -> BufferMode -> IO ()\n"
"hGetBuffering,          -- :: Handle -> IO BufferMode\n"
"\n"
"hFlush,                 -- :: Handle -> IO ()\n"
"hGetPosn,		    -- :: Handle -> IO HandlePosn\n"
"hSetPosn,               -- :: HandlePosn -> IO ()\n"
"hSeek,                  -- :: Handle -> SeekMode -> Integer -> IO ()\n"
"hTell,                  -- :: Handle -> IO Integer\n"
"\n"
"hLookAhead,             -- :: Handle -> IO Char\n"
"\n"
"hWaitForInput,          -- :: Handle -> Int -> IO Bool\n"
"\n"
"hGetChar,               -- :: Handle -> IO Char\n"
"hGetLine,               -- :: Handle -> IO String\n"
"hGetContents,           -- :: Handle -> IO String\n"
"\n"
"hPutChar,               -- :: Handle -> Char -> IO ()\n"
"hPutStr,                -- :: Handle -> String -> IO ()\n"
"\n"
"hIsOpen,		    -- :: Handle -> IO Bool\n"
"hIsClosed,		    -- :: Handle -> IO Bool\n"
"hIsReadable,            -- :: Handle -> IO Bool\n"
"hIsWritable,            -- :: Handle -> IO Bool\n"
"hIsSeekable,            -- :: Handle -> IO Bool\n"
"\n"
"-- Non-standard extensions\n"
"handleToFd,             -- :: Handle -> IO Int\n"
"openFd                  -- :: Int -> Bool -> IOMode -> Bool -> IO Handle\n"
") where\n"
"\n"
"import Hugs.Prelude	( Handle )\n"
"import Hugs.Prelude	( Ix(..) )\n"
"import System.IO.Error\n"
"\n"
"-- data Handle\n"
"\n"
"data IOMode      =  ReadMode | WriteMode | AppendMode | ReadWriteMode\n"
"deriving (Eq, Ord, Ix, Bounded, Enum, Read, Show)\n"
"data BufferMode  =  NoBuffering | LineBuffering\n"
"|  BlockBuffering (Maybe Int)\n"
"deriving (Eq, Ord, Read, Show)\n"
"data SeekMode    =  AbsoluteSeek | RelativeSeek | SeekFromEnd\n"
"deriving (Eq, Ord, Ix, Bounded, Enum, Read, Show)\n"
"\n"
"primitive stdin       :: Handle\n"
"primitive stdout      :: Handle\n"
"primitive stderr      :: Handle\n"
"primitive openFile    :: FilePath -> IOMode -> IO Handle\n"
"primitive hClose      :: Handle -> IO ()\n"
"\n"
"primitive hFileSize   :: Handle -> IO Integer\n"
"\n"
"primitive hIsEOF      :: Handle -> IO Bool\n"
"\n"
"isEOF               :: IO Bool\n"
"isEOF                = hIsEOF stdin\n"
"\n"
"hSetBuffering       :: Handle  -> BufferMode -> IO ()\n"
"hSetBuffering h bMode =\n"
"case bMode of\n"
"NoBuffering   -> hSetBuff h 0 0\n"
"LineBuffering -> hSetBuff h 1 0\n"
"BlockBuffering (Just x) -> hSetBuff h 2 x\n"
"BlockBuffering _        -> hSetBuff h 2 0\n"
"\n"
"primitive hSetBuff  :: Handle -> Int -> Int -> IO ()\n"
"\n"
"hGetBuffering       :: Handle  -> IO BufferMode\n"
"hGetBuffering h = do\n"
"(k, sz) <- hGetBuff h\n"
"case k of\n"
"1 -> return NoBuffering\n"
"2 -> return LineBuffering\n"
"3 -> return (BlockBuffering (Just sz))\n"
"-- fatal - never to happen.\n"
"_ -> error \"IO.hGetBuffering: unknown buffering mode\"\n"
"\n"
"primitive hGetBuff :: Handle -> IO (Int,Int)\n"
"\n"
"primitive hFlush   :: Handle -> IO ()\n"
"\n"
"data HandlePosn = HandlePosn Handle Int deriving Eq\n"
"\n"
"instance Show HandlePosn where\n"
"showsPrec p (HandlePosn h pos) =\n"
"showsPrec p h . showString \" at position \" . shows pos\n"
"\n"
"hGetPosn :: Handle -> IO HandlePosn\n"
"hGetPosn h = do\n"
"p <- hGetPosnPrim h\n"
"return (HandlePosn h p)\n"
"\n"
"hTell :: Handle -> IO Integer\n"
"hTell h = do\n"
"p <- hGetPosnPrim h\n"
"return (toInteger p)\n"
"\n"
"primitive hGetPosnPrim :: Handle -> IO Int\n"
"\n"
"hSetPosn :: HandlePosn -> IO ()\n"
"hSetPosn (HandlePosn h p) = hSetPosnPrim h p\n"
"\n"
"primitive hSetPosnPrim  :: Handle -> Int -> IO ()\n"
"\n"
"hSeek :: Handle -> SeekMode -> Integer -> IO ()\n"
"hSeek h sMode int\n"
"| int >  fromIntegral (maxBound :: Int) ||\n"
"int <  fromIntegral (minBound :: Int) =\n"
"ioError (userError (\"IO.hSeek: seek offset out of supported range\"))\n"
"| otherwise =\n"
"hSeekPrim h (fromEnum sMode) ((fromIntegral int)::Int)\n"
"\n"
"primitive hSeekPrim :: Handle -> Int -> Int -> IO ()\n"
"\n"
"primitive hWaitForInput :: Handle -> Int -> IO Bool\n"
"\n"
"primitive hGetChar    :: Handle -> IO Char\n"
"\n"
"hGetLine   :: Handle -> IO String\n"
"hGetLine h = do\n"
"c <- hGetChar h\n"
"if c=='\\n'\n"
"then return \"\"\n"
"else do\n"
"ls <- getRest\n"
"return (c:ls)\n"
"where\n"
"getRest = do\n"
"c <- catch (hGetChar h)\n"
"(\\ ex -> if isEOFError ex then\n"
"return '\\n'\n"
"else\n"
"ioError ex)\n"
"if c=='\\n'\n"
"then return \"\"\n"
"else do\n"
"cs <- getRest\n"
"return (c:cs)\n"
"\n"
"\n"
"primitive hLookAhead    :: Handle -> IO Char\n"
"primitive hGetContents  :: Handle -> IO String\n"
"primitive hPutChar      :: Handle -> Char -> IO ()\n"
"primitive hPutStr       :: Handle -> String -> IO ()\n"
"\n"
"primitive hIsOpen,\n"
"hIsClosed,\n"
"hIsReadable,\n"
"hIsWritable,\n"
"hIsSeekable :: Handle -> IO Bool\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- Extract the file descriptor from a Handle, closing the Handle\n"
"primitive handleToFd :: Handle -> IO Int\n"
"\n"
"--\n"
"-- Creating a handle from a file descriptor/socket.\n"
"--\n"
"primitive openFd    :: Int    -- file descriptor\n"
"-> Bool   -- True => it's a socket.\n"
"-> IOMode -- what mode to open the handle in.\n"
"-> Bool   -- binary?\n"
"-> IO Handle\n";
const char *array_hs = "-----------------------------------------------------------------------------\n"
"-- Standard Library: Array operations\n"
"--\n"
"-- Suitable for use with Hugs 98\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.Array (\n"
"module Data.Ix,  -- export all of Ix\n"
"unsafeIndex, unsafeRangeSize,\n"
"\n"
"Array, array, listArray, (!), bounds, indices, elems, assocs,\n"
"accumArray, (//), accum, ixmap,\n"
"unsafeArray, unsafeAt, unsafeReplace, unsafeAccum, unsafeAccumArray\n"
") where\n"
"\n"
"import Data.Ix\n"
"import Hugs.Prelude( unsafeIndex, unsafeRangeSize )\n"
"\n"
"infixl 9  !, //\n"
"\n"
"data Array a b -- Arrays are implemented as a primitive type\n"
"\n"
"array          :: Ix a => (a,a) -> [(a,b)] -> Array a b\n"
"listArray      :: Ix a => (a,a) -> [b] -> Array a b\n"
"(!)	       :: Ix a => Array a b -> a -> b\n"
"bounds         :: Ix a => Array a b -> (a,a)\n"
"indices        :: Ix a => Array a b -> [a]\n"
"elems          :: Ix a => Array a b -> [b]\n"
"assocs	       :: Ix a => Array a b -> [(a,b)]\n"
"(//)           :: Ix a => Array a b -> [(a,b)] -> Array a b\n"
"accum          :: Ix a => (b -> c -> b) -> Array a b -> [(a,c)] -> Array a b\n"
"accumArray     :: Ix a => (b -> c -> b) -> b -> (a,a) -> [(a,c)] -> Array a b\n"
"ixmap	       :: (Ix a, Ix b) => (a,a) -> (a -> b) -> Array b c -> Array a c\n"
"\n"
"primitive primArray :: (a,a) -> Int -> [(Int,b)] -> Array a b\n"
"primitive primUpdate :: [(Int,b)] -> Array a b -> Array a b\n"
"primitive primAccum :: [(Int,c)] -> Array a b -> (b -> c -> b) -> Array a b\n"
"primitive primAccumArray\n"
":: (a,a) -> Int -> (b -> c -> b) -> b -> [(Int,c)] -> Array a b\n"
"primitive primSubscript :: Array a b -> Int -> b\n"
"\n"
"primitive primBounds :: Array a b -> (a,a)\n"
"primitive primElems  :: Array a b -> [b]\n"
"primitive primAmap   :: (b -> c) -> Array a b -> Array a c\n"
"\n"
"unsafeArray :: Ix i => (i,i) -> [(Int, e)] -> Array i e\n"
"unsafeArray bnds	= primArray bnds (rangeSize bnds)\n"
"\n"
"unsafeAt :: Ix i => Array i e -> Int -> e\n"
"unsafeAt		= primSubscript\n"
"\n"
"unsafeReplace :: Ix i => Array i e -> [(Int, e)] -> Array i e\n"
"unsafeReplace iarr ies	= primUpdate ies iarr\n"
"\n"
"unsafeAccum :: Ix i => (e -> a -> e) -> Array i e -> [(Int, a)] -> Array i e\n"
"unsafeAccum f iarr ies	= primAccum ies iarr f\n"
"\n"
"unsafeAccumArray :: Ix i => (e -> a -> e) -> e -> (i,i) -> [(Int, a)] -> Array i e\n"
"unsafeAccumArray f z bnds = primAccumArray bnds (rangeSize bnds) f z\n"
"\n"
"indexAll :: Ix i => (i,i) -> [(i, a)] -> [(Int, a)]\n"
"indexAll bnds ivs = [(index bnds i,v) | (i,v) <- ivs]\n"
"\n"
"array bnds          = unsafeArray bnds . indexAll bnds\n"
"listArray bnds vs   = unsafeArray bnds (zip [0..rangeSize bnds-1] vs)\n"
"arr!i               = unsafeAt arr (index (bounds arr) i)\n"
"bounds              = primBounds\n"
"indices	            = range . bounds\n"
"elems               = primElems\n"
"assocs a            = zip (indices a) (elems a)\n"
"accumArray f z bnds = unsafeAccumArray f z bnds . indexAll bnds\n"
"a // ivs            = unsafeReplace a (indexAll (bounds a) ivs)\n"
"accum f a ivs       = unsafeAccum f a (indexAll (bounds a) ivs)\n"
"ixmap bnds f arr =\n"
"unsafeArray bnds [(unsafeIndex bnds i, arr ! f i) | i <- range bnds]\n"
"\n"
"instance (Ix a) => Functor (Array a) where\n"
"fmap = primAmap\n"
"\n"
"instance (Ix a, Eq b) => Eq (Array a b) where\n"
"a == a'   =   assocs a == assocs a'\n"
"\n"
"instance (Ix a, Ord b) => Ord (Array a b) where\n"
"a <= a'   =   assocs a <= assocs a'\n"
"\n"
"instance  (Ix a, Show a, Show b) => Show (Array a b)  where\n"
"showsPrec p a = showParen (p > 9) (\n"
"showString \"array \" .\n"
"shows (bounds a) . showChar ' ' .\n"
"shows (assocs a)                  )\n"
"\n"
"instance  (Ix a, Read a, Read b) => Read (Array a b)  where\n"
"readsPrec p = readParen (p > 9)\n"
"(\\r -> [(array b as, u) | (\"array\",s) <- lex r,\n"
"(b,t)       <- reads s,\n"
"(as,u)      <- reads t   ])\n"
"\n"
"-----------------------------------------------------------------------------\n";
const char *directory_hs = "--\n"
"-- Hugs98 implementation of the Haskell 98 module, Directory.\n"
"--\n"
"module Hugs.Directory\n"
"( Permissions ( readable     -- :: Permissions -> Bool\n"
", writable     -- :: Permissions -> Bool\n"
", executable   -- :: Permissions -> Bool\n"
", searchable   -- :: Permissions -> Bool\n"
")\n"
"-- instances: Eq, Ord, Read, Show\n"
", createDirectory	     -- :: FilePath -> IO ()\n"
"\n"
", removeDirectory            -- :: FilePath -> IO ()\n"
", removeFile                 -- :: FilePath -> IO ()\n"
"\n"
", renameDirectory            -- :: FilePath -> FilePath -> IO ()\n"
", renameFile		     -- :: FilePath -> FilePath -> IO ()\n"
"\n"
", getDirectoryContents       -- :: FilePath -> IO [FilePath]\n"
"\n"
", getCurrentDirectory        -- :: IO FilePath\n"
", setCurrentDirectory        -- :: FilePath -> IO ()\n"
"\n"
", doesFileExist	             -- :: FilePath -> IO Bool\n"
", doesDirectoryExist	     -- :: FilePath -> IO Bool\n"
"\n"
", getPermissions	     -- :: FilePath -> IO Permissions\n"
", setPermissions	     -- :: FilePath -> Permissions -> IO ()\n"
"\n"
", getModificationTime 	     -- :: FilePath -> IO ClockTime\n"
") where\n"
"\n"
"import System.Time ( ClockTime(..) )\n"
"\n"
"data Permissions\n"
"= Permissions\n"
"{ readable     :: Bool\n"
", writable     :: Bool\n"
", executable   :: Bool\n"
", searchable   :: Bool\n"
"} deriving (Eq, Ord, Read, Show)\n"
"\n"
"{-\n"
"This module is really just a wrapper for various directory\n"
"and file-related system calls.\n"
"-}\n"
"primitive createDirectory :: FilePath -> IO ()\n"
"\n"
"primitive removeFile :: FilePath -> IO ()\n"
"primitive removeDirectory :: FilePath -> IO ()\n"
"\n"
"primitive renameFile :: FilePath -> FilePath -> IO ()\n"
"primitive renameDirectory :: FilePath -> FilePath -> IO ()\n"
"\n"
"primitive setCurrentDirectory :: FilePath -> IO ()\n"
"primitive getCurrentDirectory :: IO FilePath\n"
"\n"
"primitive doesDirectoryExist :: FilePath -> IO Bool\n"
"primitive doesFileExist :: FilePath -> IO Bool\n"
"\n"
"getPermissions :: FilePath -> IO Permissions\n"
"getPermissions fpath = do\n"
"(r,w,e,s) <- getPerms fpath\n"
"return (Permissions{readable=r,writable=w,executable=e,searchable=s})\n"
"\n"
"setPermissions :: FilePath -> Permissions -> IO ()\n"
"setPermissions fpath perms =\n"
"setPerms fpath (readable perms)\n"
"(writable perms)\n"
"(executable perms)\n"
"(searchable perms)\n"
"\n"
"primitive getPerms :: FilePath -> IO (Bool,Bool,Bool,Bool)\n"
"primitive setPerms :: FilePath -> Bool -> Bool -> Bool -> Bool -> IO ()\n"
"\n"
"getDirectoryContents :: FilePath -> IO [FilePath]\n"
"getDirectoryContents fpath = do\n"
"ls <- getDirContents fpath\n"
"-- it is easiest for the primitive to create the\n"
"-- list of entries in the order in which they're\n"
"-- read, so the resulting list will be back to front.\n"
"-- Hence, list reversal is needed.\n"
"return (reverse ls)\n"
"\n"
"primitive getDirContents :: FilePath -> IO [FilePath]\n"
"\n"
"getModificationTime :: FilePath -> IO ClockTime\n"
"getModificationTime fPath = do\n"
"x <- getModTime fPath\n"
"return (TOD (fromIntegral x) 0)\n"
"\n"
"primitive getModTime :: FilePath -> IO Int\n";
const char *concbase_hs = "-----------------------------------------------------------------------------\n"
"-- This implements Concurrent Haskell's \"MVar\"s as described in the paper\n"
"--\n"
"--   \"Concurrent Haskell\"\n"
"--   Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne.\n"
"--   In Proceedings of the ACM Symposium on Principles of Programming\n"
"--   Languages,St Petersburg Beach, Florida, January 1996.\n"
"--   http://www.dcs.gla.ac.uk/fp/authors/Simon_Peyton_Jones/\n"
"--     concurrent-haskell.ps\n"
"--\n"
"-- except that we have made the following name changes for compatability\n"
"-- with GHC 2.05.\n"
"--\n"
"--   newMVar  -> newEmptyMVar\n"
"--\n"
"-- There is one significant difference between this implementation and\n"
"-- GHC 2.05:\n"
"--\n"
"-- o GHC uses preemptive multitasking.\n"
"--\n"
"--   Context switches can occur at any time (except if you call a C\n"
"--   function (like \"getchar\") which blocks the entire process while\n"
"--   waiting for input.\n"
"--\n"
"-- o Hugs uses cooperative multitasking.\n"
"--\n"
"--   Context switches only occur when you use one of the primitives\n"
"--   defined in this module.  This means that programs such as:\n"
"--\n"
"--     main = forkIO (write 'a') >> write 'b'\n"
"-- 	where\n"
"-- 	 write c = putChar c >> write c\n"
"--\n"
"--   will print either \"aaaaaaaaaaaaaa...\" or \"bbbbbbbbbbbb...\"\n"
"--   instead of some random interleaving of 'a's and 'b's.\n"
"--\n"
"-- Cooperative multitasking is sufficient for writing coroutines and simple\n"
"-- graphical user interfaces but the usual assumptions of fairness don't\n"
"-- apply and Channel.getChanContents cannot be implemented.\n"
"-----------------------------------------------------------------------------\n"
"module Hugs.ConcBase(\n"
"forkIO,\n"
"MVar,\n"
"newEmptyMVar, newMVar, takeMVar, tryTakeMVar, putMVar, tryPutMVar,\n"
"isEmptyMVar,\n"
"yield\n"
") where\n"
"\n"
"import Hugs.Prelude(\n"
"IO(..), IOResult(..), threadToIOResult,\n"
"Exception(..), catchException, blockIO)\n"
"import Hugs.IORef\n"
"\n"
"----------------------------------------------------------------\n"
"-- The interface\n"
"----------------------------------------------------------------\n"
"\n"
"forkIO       :: IO () -> IO () -- Spawn a thread\n"
"yield        :: IO ()\n"
"\n"
"newEmptyMVar :: IO (MVar a)\n"
"newMVar      :: a -> IO (MVar a)\n"
"takeMVar     :: MVar a -> IO a\n"
"putMVar      :: MVar a -> a -> IO ()\n"
"tryPutMVar   :: MVar a -> a -> IO Bool\n"
"tryTakeMVar  :: MVar a -> IO (Maybe a)\n"
"\n"
"isEmptyMVar :: MVar a -> IO Bool\n"
"\n"
"----------------------------------------------------------------\n"
"-- Implementation\n"
"----------------------------------------------------------------\n"
"\n"
"kill :: IO a\n"
"kill = IO (\\ s -> Hugs_DeadThread)\n"
"\n"
"yield = IO (\\ s -> Hugs_YieldThread (s ()))\n"
"\n"
"-- add the continuation to the runnable list, and continue\n"
"continueIO :: IOResult -> IO ()\n"
"continueIO cc = IO (\\ s -> Hugs_ForkThread (s ()) cc)\n"
"\n"
"-- The thread is scheduled immediately and runs with its own success/error\n"
"-- continuations.\n"
"forkIO m = continueIO (threadToIOResult (m `catchException` forkExnHandler))\n"
"\n"
"forkExnHandler :: Exception -> IO a\n"
"forkExnHandler e = do\n"
"putStr \"\\nThread raised exception: \"\n"
"putStr (show e)\n"
"putStr \"\\n\"\n"
"kill\n"
"\n"
"newtype MVar a = MkMVar (IORef (MVarState a)) deriving Eq\n"
"data MVarState a\n"
"= Full a [(a,()->IOResult)]\n"
"-- a value and a list of value-thread pairs blocked waiting\n"
"-- to write to the MVar.\n"
"-- The ()-> part of the thread is because blocked threads have\n"
"-- to be functions. :-(\n"
"| Empty [a -> IOResult]\n"
"-- no value, just a list of threads waiting to receive a value\n"
"\n"
"newEmptyMVar = fmap MkMVar (newIORef (Empty []))\n"
"\n"
"newMVar x    = fmap MkMVar (newIORef (Full x []))\n"
"\n"
"takeMVar (MkMVar v) = do\n"
"state <- readIORef v\n"
"case state of\n"
"Full a [] -> do\n"
"writeIORef v (Empty [])\n"
"return a\n"
"Full a ((a',t):ts) -> do\n"
"writeIORef v (Full a' ts)\n"
"continueIO (t ())		-- reschedule t\n"
"return a\n"
"Empty cs ->\n"
"blockIO (\\cc -> writeIORef v (Empty (cs ++ [cc])))\n"
"\n"
"-- tryTakeMVar is a non-blocking takeMVar\n"
"tryTakeMVar (MkMVar v) = do\n"
"state <- readIORef v\n"
"case state of\n"
"Full a [] -> do\n"
"writeIORef v (Empty [])\n"
"return (Just a)\n"
"Full a ((a',t):ts) -> do\n"
"writeIORef v (Full a' ts)\n"
"continueIO (t ())		-- reschedule t\n"
"return (Just a)\n"
"Empty cs ->\n"
"return Nothing\n"
"\n"
"putMVar (MkMVar v) a = do\n"
"state <- readIORef v\n"
"case state of\n"
"Full a' ts ->\n"
"blockIO (\\cc -> writeIORef v (Full a' (ts++[(a,cc)])))\n"
"Empty [] ->\n"
"writeIORef v (Full a [])\n"
"Empty (c:cs) -> do\n"
"writeIORef v (Empty cs)\n"
"continueIO (c a)		-- reschedule the blocked thread\n"
"\n"
"tryPutMVar (MkMVar v) a = do\n"
"state <- readIORef v\n"
"case state of\n"
"Full _ _ ->\n"
"return False\n"
"Empty [] -> do\n"
"writeIORef v (Full a [])\n"
"return True\n"
"Empty (c:cs) -> do\n"
"writeIORef v (Empty cs)\n"
"continueIO (c a)		-- reschedule the blocked thread\n"
"return True\n"
"\n"
"{-\n"
"Low-level op. for checking whether an MVar is filled-in or not.\n"
"Notice that the boolean value returned  is just a snapshot of\n"
"the state of the MVar. By the time you get to react on its result,\n"
"the MVar may have been filled (or emptied) - so be extremely\n"
"careful when using this operation.\n"
"\n"
"Use tryTakeMVar instead if possible.\n"
"\n"
"If you can re-work your abstractions to avoid having to\n"
"depend on isEmptyMVar, then you're encouraged to do so,\n"
"i.e., consider yourself warned about the imprecision in\n"
"general of isEmptyMVar :-)\n"
"-}\n"
"isEmptyMVar (MkMVar v) = do\n"
"state <- readIORef v\n"
"case state of\n"
"Full _ _ -> return False\n"
"Empty _  -> return True\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n";
const char *bits_hs = "module Hugs.Bits where\n"
"\n"
"primitive primAndInt        :: Int -> Int -> Int\n"
"primitive primOrInt         :: Int -> Int -> Int\n"
"primitive primXorInt        :: Int -> Int -> Int\n"
"primitive primComplementInt :: Int -> Int\n"
"primitive primShiftInt      :: Int -> Int -> Int\n"
"primitive primBitInt        :: Int -> Int\n"
"primitive primTestInt       :: Int -> Int -> Bool\n";
const char *int_hs = "-----------------------------------------------------------------------------\n"
"-- Signed Integers\n"
"-- Suitable for use with Hugs 98 on 32 bit systems.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.Int\n"
"( Int8\n"
", Int16\n"
", Int32\n"
", Int64\n"
"-- plus Eq, Ord, Num, Bounded, Real, Integral, Ix, Enum, Read,\n"
"--  Show and Bits instances for each of Int8, Int16 and Int32\n"
") where\n"
"\n"
"import Hugs.Prelude ( Int8, Int16, Int32, Int64 )\n"
"import Hugs.Prelude ( Ix(..) )\n"
"import Hugs.Prelude ( (%) )\n"
"import Hugs.Prelude ( readDec, showInt )\n"
"import Hugs.Prelude ( Num(fromInt), Integral(toInt) )\n"
"import Hugs.Bits\n"
"import Data.Bits\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- The \"official\" coercion functions\n"
"-----------------------------------------------------------------------------\n"
"\n"
"int8ToInt  :: Int8  -> Int\n"
"intToInt8  :: Int   -> Int8\n"
"int16ToInt :: Int16 -> Int\n"
"intToInt16 :: Int   -> Int16\n"
"\n"
"int8ToInt  = int32ToInt   . int8ToInt32\n"
"intToInt8  = int32ToInt8  . intToInt32\n"
"int16ToInt = int32ToInt   . int16ToInt32\n"
"intToInt16 = int32ToInt16 . intToInt32\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Int8\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive int8ToInt32 \"primInt8ToInt32\" :: Int8 -> Int32\n"
"primitive int32ToInt8 \"primInt32ToInt8\" :: Int32 -> Int8\n"
"\n"
"instance Eq  Int8     where (==)    = binop (==)\n"
"instance Ord Int8     where compare = binop compare\n"
"\n"
"instance Num Int8 where\n"
"x + y         = to (binop (+) x y)\n"
"x - y         = to (binop (-) x y)\n"
"negate        = to . negate . from\n"
"x * y         = to (binop (*) x y)\n"
"abs           = absReal\n"
"signum        = signumReal\n"
"fromInteger   = to . fromInteger\n"
"fromInt       = intToInt8\n"
"\n"
"instance Bounded Int8 where\n"
"minBound = 0x80\n"
"maxBound = 0x7f\n"
"\n"
"instance Real Int8 where\n"
"toRational x = toInteger x % 1\n"
"\n"
"instance Integral Int8 where\n"
"x `div` y     = to  (binop div x y)\n"
"x `quot` y    = to  (binop quot x y)\n"
"x `rem` y     = to  (binop rem x y)\n"
"x `mod` y     = to  (binop mod x y)\n"
"x `quotRem` y = to2 (binop quotRem x y)\n"
"toInteger     = toInteger . from\n"
"toInt         = int8ToInt\n"
"\n"
"instance Ix Int8 where\n"
"range (m,n)          = [m..n]\n"
"index b@(m,n) i\n"
"| inRange b i = toInt (i - m)\n"
"| otherwise   = error \"index: Index out of range\"\n"
"inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Int8 where\n"
"toEnum           = fromInt\n"
"fromEnum         = toInt\n"
"enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Int8)]\n"
"enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (last::Int8)]\n"
"where last = if d < c then minBound else maxBound\n"
"\n"
"instance Read Int8 where\n"
"readsPrec p s = [ (to x,r) | (x,r) <- readsPrec p s ]\n"
"\n"
"instance Show Int8 where\n"
"showsPrec p = showsPrec p . from\n"
"\n"
"binop8 :: (Int32 -> Int32 -> a) -> (Int8 -> Int8 -> a)\n"
"binop8 op x y = int8ToInt32 x `op` int8ToInt32 y\n"
"\n"
"instance Bits Int8 where\n"
"x .&. y       = int32ToInt8 (binop8 (.&.) x y)\n"
"x .|. y       = int32ToInt8 (binop8 (.|.) x y)\n"
"x `xor` y     = int32ToInt8 (binop8 xor x y)\n"
"complement    = int32ToInt8 . complement . int8ToInt32\n"
"x `shift` i   = int32ToInt8 (int8ToInt32 x `shift` i)\n"
"rotate        = rotateSigned\n"
"bit           = int32ToInt8 . bit\n"
"setBit x i    = int32ToInt8 (setBit (int8ToInt32 x) i)\n"
"clearBit x i  = int32ToInt8 (clearBit (int8ToInt32 x) i)\n"
"complementBit x i = int32ToInt8 (complementBit (int8ToInt32 x) i)\n"
"testBit x i   = testBit (int8ToInt32 x) i\n"
"bitSize  _    = 8\n"
"isSigned _    = True\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Int16\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive int16ToInt32 \"primInt16ToInt32\" :: Int16 -> Int32\n"
"primitive int32ToInt16 \"primInt32ToInt16\" :: Int32 -> Int16\n"
"\n"
"instance Eq  Int16     where (==)    = binop (==)\n"
"instance Ord Int16     where compare = binop compare\n"
"\n"
"instance Num Int16 where\n"
"x + y         = to (binop (+) x y)\n"
"x - y         = to (binop (-) x y)\n"
"negate        = to . negate . from\n"
"x * y         = to (binop (*) x y)\n"
"abs           = absReal\n"
"signum        = signumReal\n"
"fromInteger   = to . fromInteger\n"
"fromInt       = intToInt16\n"
"\n"
"instance Bounded Int16 where\n"
"minBound = 0x8000\n"
"maxBound = 0x7fff\n"
"\n"
"instance Real Int16 where\n"
"toRational x = toInteger x % 1\n"
"\n"
"instance Integral Int16 where\n"
"x `div` y     = to  (binop div x y)\n"
"x `quot` y    = to  (binop quot x y)\n"
"x `rem` y     = to  (binop rem x y)\n"
"x `mod` y     = to  (binop mod x y)\n"
"x `quotRem` y = to2 (binop quotRem x y)\n"
"toInteger     = toInteger . from\n"
"toInt         = int16ToInt\n"
"\n"
"instance Ix Int16 where\n"
"range (m,n)          = [m..n]\n"
"index b@(m,n) i\n"
"| inRange b i = toInt (i - m)\n"
"| otherwise   = error \"index: Index out of range\"\n"
"inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Int16 where\n"
"toEnum           = fromInt\n"
"fromEnum         = toInt\n"
"enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Int16)]\n"
"enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (last::Int16)]\n"
"where last = if d < c then minBound else maxBound\n"
"\n"
"instance Read Int16 where\n"
"readsPrec p s = [ (to x,r) | (x,r) <- readsPrec p s ]\n"
"\n"
"instance Show Int16 where\n"
"showsPrec p = showsPrec p . from\n"
"\n"
"binop16 :: (Int32 -> Int32 -> a) -> (Int16 -> Int16 -> a)\n"
"binop16 op x y = int16ToInt32 x `op` int16ToInt32 y\n"
"\n"
"instance Bits Int16 where\n"
"x .&. y       = int32ToInt16 (binop16 (.&.) x y)\n"
"x .|. y       = int32ToInt16 (binop16 (.|.) x y)\n"
"x `xor` y     = int32ToInt16 (binop16 xor x y)\n"
"complement    = int32ToInt16 . complement . int16ToInt32\n"
"x `shift` i   = int32ToInt16 (int16ToInt32 x `shift` i)\n"
"rotate        = rotateSigned\n"
"bit           = int32ToInt16 . bit\n"
"setBit x i    = int32ToInt16 (setBit (int16ToInt32 x) i)\n"
"clearBit x i  = int32ToInt16 (clearBit (int16ToInt32 x) i)\n"
"complementBit x i = int32ToInt16 (complementBit (int16ToInt32 x) i)\n"
"testBit x i   = testBit (int16ToInt32 x) i\n"
"bitSize  _    = 16\n"
"isSigned _    = True\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Int32\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive int32ToInt \"primInt32ToInt\" :: Int32 -> Int\n"
"primitive intToInt32 \"primIntToInt32\" :: Int -> Int32\n"
"primitive primEqInt32  :: Int32 -> Int32 -> Bool\n"
"primitive primCmpInt32 :: Int32 -> Int32 -> Ordering\n"
"\n"
"instance Eq  Int32 where (==)    = primEqInt32\n"
"instance Ord Int32 where compare = primCmpInt32\n"
"\n"
"instance Num Int32 where\n"
"x + y         = intToInt32 (binop32 (+) x y)\n"
"x - y         = intToInt32 (binop32 (-) x y)\n"
"negate        = intToInt32 . negate . int32ToInt\n"
"x * y         = intToInt32 (binop32 (*) x y)\n"
"abs           = absReal\n"
"signum        = signumReal\n"
"fromInteger   = intToInt32 . fromInteger\n"
"fromInt       = intToInt32\n"
"\n"
"instance Bounded Int32 where\n"
"minBound = intToInt32 minBound\n"
"maxBound = intToInt32 maxBound\n"
"\n"
"instance Real Int32 where\n"
"toRational x = toInteger x % 1\n"
"\n"
"instance Integral Int32 where\n"
"x `div` y     = intToInt32 (binop32 div x y)\n"
"x `quot` y    = intToInt32 (binop32 quot x y)\n"
"x `rem` y     = intToInt32 (binop32 rem x y)\n"
"x `mod` y     = intToInt32 (binop32 mod x y)\n"
"x `quotRem` y = to2' (binop32 quotRem x y)\n"
"toInteger     = toInteger . int32ToInt\n"
"toInt         = int32ToInt\n"
"\n"
"instance Ix Int32 where\n"
"range (m,n)          = [m..n]\n"
"index b@(m,n) i\n"
"| inRange b i = toInt (i - m)\n"
"| otherwise   = error \"index: Index out of range\"\n"
"inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Int32 where\n"
"toEnum           = fromInt\n"
"fromEnum         = toInt\n"
"enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Int32)]\n"
"enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (last::Int32)]\n"
"where last = if d < c then minBound else maxBound\n"
"\n"
"instance Read Int32 where\n"
"readsPrec p s = [ (intToInt32 x,r) | (x,r) <- readsPrec p s ]\n"
"\n"
"instance Show Int32 where\n"
"showsPrec p = showsPrec p . int32ToInt\n"
"\n"
"instance Bits Int32 where\n"
"x .&. y       = intToInt32 (binop32 (.&.) x y)\n"
"x .|. y       = intToInt32 (binop32 (.|.) x y)\n"
"x `xor` y     = intToInt32 (binop32 xor x y)\n"
"complement    = intToInt32 . complement . int32ToInt\n"
"x `shift` i   = intToInt32 (int32ToInt x `shift` i)\n"
"rotate        = rotateSigned\n"
"bit           = intToInt32 . bit\n"
"setBit x i    = intToInt32 (setBit (int32ToInt x) i)\n"
"clearBit x i  = intToInt32 (clearBit (int32ToInt x) i)\n"
"complementBit x i = intToInt32 (complementBit (int32ToInt x) i)\n"
"testBit x i   = testBit (int32ToInt x) i\n"
"bitSize  _    = 32\n"
"isSigned _    = True\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Int64\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- Assume a 2s-complement representation, and that this function\n"
"-- separates the top 32 bits from the lower 32.\n"
"\n"
"primitive int64ToInt32 \"primInt64ToInt32\" :: Int64 -> (Int32,Int32)\n"
"primitive int32ToInt64 \"primInt32ToInt64\" :: Int32 -> Int32 -> Int64\n"
"\n"
"integerToI64 :: Integer -> Int64\n"
"integerToI64 x = case x `divMod` 0x100000000 of\n"
"(hi,lo) -> int32ToInt64 (fromInteger hi) (fromInteger lo)\n"
"\n"
"i64ToInteger :: Int64 -> Integer\n"
"i64ToInteger x = case int64ToInt32 x of\n"
"(hi,lo) -> (if lo<0 then toInteger hi+1 else toInteger hi)*0x100000000 +\n"
"toInteger lo\n"
"\n"
"instance Eq Int64 where\n"
"x == y = int64ToInt32 x == int64ToInt32 y\n"
"\n"
"instance Ord Int64 where\n"
"compare x y = compare (toInteger x) (toInteger y)\n"
"\n"
"instance Bounded Int64 where\n"
"minBound = int32ToInt64 minBound 0\n"
"maxBound = int32ToInt64 maxBound (-1)\n"
"\n"
"instance Show Int64 where\n"
"showsPrec p = showsPrec p . toInteger\n"
"\n"
"instance Read Int64 where\n"
"readsPrec p s = [ (fromInteger x,r) | (x,r) <- readDec s ]\n"
"\n"
"instance Num Int64 where\n"
"x + y         = fromInteger (toInteger x + toInteger y)\n"
"x - y         = fromInteger (toInteger x - toInteger y)\n"
"x * y         = fromInteger (toInteger x * toInteger y)\n"
"abs           = absReal\n"
"signum        = signumReal\n"
"fromInteger   = integerToI64\n"
"\n"
"instance Real Int64 where\n"
"toRational x = toInteger x % 1\n"
"\n"
"instance Ix Int64 where\n"
"range (m,n)          = [m..n]\n"
"index b@(m,n) i\n"
"| inRange b i = toInt (i - m)\n"
"| otherwise   = error \"index: Index out of range\"\n"
"inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Int64 where\n"
"toEnum           = fromInt\n"
"fromEnum         = toInt\n"
"\n"
"succ             = fromInteger . (+1) . toInteger\n"
"pred             = fromInteger . (subtract 1) . toInteger\n"
"enumFrom x       = map fromInteger [toInteger x ..]\n"
"enumFromTo x y   = map fromInteger [toInteger x .. toInteger y]\n"
"enumFromThen x y = map fromInteger [toInteger x, toInteger y ..]\n"
"enumFromThenTo x y z =\n"
"map fromInteger [toInteger x, toInteger y .. toInteger z]\n"
"\n"
"instance Integral Int64 where\n"
"x `quotRem` y = (fromInteger q, fromInteger r)\n"
"where (q,r) = toInteger x `quotRem` toInteger y\n"
"toInteger     = i64ToInteger\n"
"\n"
"instance Bits Int64 where\n"
"x .&. y       = liftBinary (.&.) x y\n"
"x .|. y       = liftBinary (.|.) x y\n"
"x `xor` y     = liftBinary xor x y\n"
"complement    = liftUnary complement\n"
"x `shift` i   = fromInteger (toInteger x `shift` i)\n"
"rotate        = rotateSigned\n"
"bit i | i `mod` 64 < 32 = int32ToInt64 0 (bit i)\n"
"| otherwise       = int32ToInt64 (bit i) 0\n"
"bitSize  _    = 64\n"
"isSigned _    = True\n"
"\n"
"liftBinary :: (Int32 -> Int32 -> Int32) -> Int64 -> Int64 -> Int64\n"
"liftBinary op x y = int32ToInt64 (op xhi yhi) (op xlo ylo)\n"
"where	(xhi,xlo) = int64ToInt32 x\n"
"(yhi,ylo) = int64ToInt32 y\n"
"\n"
"liftUnary :: (Int32 -> Int32) -> Int64 -> Int64\n"
"liftUnary op x = int32ToInt64 (op xhi) (op xlo)\n"
"where	(xhi,xlo) = int64ToInt32 x\n"
"\n"
"rotateSigned :: (Bits a, Ord a) => a -> Int -> a\n"
"rotateSigned x i | i<0 && x<0\n"
"= let left = i+bitSize x in\n"
"((x `shift` i) .&. complement ((-1) `shift` left))\n"
".|. (x `shift` left)\n"
"| i<0  = (x `shift` i) .|. (x `shift` (i+bitSize x))\n"
"| i==0 = x\n"
"| i>0  = (x `shift` i) .|. (x `shift` (i-bitSize x))\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- End of exported definitions\n"
"--\n"
"-- The remainder of this file consists of definitions which are only\n"
"-- used in the implementation.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Coercions - used to make the instance declarations more uniform\n"
"-----------------------------------------------------------------------------\n"
"\n"
"class Coerce a where\n"
"to   :: Int32 -> a\n"
"from :: a -> Int32\n"
"\n"
"instance Coerce Int where\n"
"from = intToInt32\n"
"to   = int32ToInt\n"
"\n"
"instance Coerce Int8 where\n"
"from = int8ToInt32\n"
"to   = int32ToInt8\n"
"\n"
"instance Coerce Int16 where\n"
"from = int16ToInt32\n"
"to   = int32ToInt16\n"
"\n"
"binop :: Coerce int => (Int32 -> Int32 -> a) -> (int -> int -> a)\n"
"binop op x y = from x `op` from y\n"
"\n"
"to2 :: Coerce int => (Int32, Int32) -> (int, int)\n"
"to2 (x,y) = (to x, to y)\n"
"\n"
"to2' :: (Int, Int) -> (Int32, Int32)\n"
"to2' (x,y) = (intToInt32 x, intToInt32 y)\n"
"\n"
"binop32 :: (Int -> Int -> a) -> (Int32 -> Int32 -> a)\n"
"binop32 op x y = int32ToInt x `op` int32ToInt y\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Code copied from the Prelude\n"
"-----------------------------------------------------------------------------\n"
"\n"
"absReal x    | x >= 0    = x\n"
"| otherwise = -x\n"
"\n"
"signumReal x | x == 0    =  0\n"
"| x > 0     =  1\n"
"| otherwise = -1\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- End\n"
"-----------------------------------------------------------------------------\n";
const char *numeric_hs = "-----------------------------------------------------------------------------\n"
"-- Standard Library: Numeric operations\n"
"--\n"
"-- Suitable for use with Hugs 98\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.Numeric\n"
"( fromRat 	-- :: (RealFloat a) => Rational -> a\n"
"\n"
", showEFloat	-- :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
", showFFloat	-- :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
", showGFloat	-- :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
", showFloat	-- :: (RealFloat a) => a -> ShowS\n"
"\n"
", floatToDigits -- :: (RealFloat a) => Integer -> a -> ([Int], Int)\n"
") where\n"
"\n"
"import Data.Char   ( intToDigit )\n"
"import Data.Ratio  ( (%), numerator, denominator )\n"
"import Hugs.Array  ( (!), Array, array )\n"
"\n"
"-- This converts a rational to a floating.  This should be used in the\n"
"-- Fractional instances of Float and Double.\n"
"\n"
"fromRat :: (RealFloat a) => Rational -> a\n"
"fromRat x\n"
"| x == 0    = encodeFloat 0 0    -- Handle exceptional cases\n"
"| x < 0     = -fromRat' (-x)     -- first.\n"
"| otherwise = fromRat' x\n"
"\n"
"-- Conversion process:\n"
"-- Scale the rational number by the RealFloat base until\n"
"-- it lies in the range of the mantissa (as used by decodeFloat/encodeFloat).\n"
"-- Then round the rational to an Integer and encode it with the exponent\n"
"-- that we got from the scaling.\n"
"-- To speed up the scaling process we compute the log2 of the number to get\n"
"-- a first guess of the exponent.\n"
"fromRat' :: (RealFloat a) => Rational -> a\n"
"fromRat' x = r\n"
"where b = floatRadix r\n"
"p = floatDigits r\n"
"(minExp0, _) = floatRange r\n"
"minExp = minExp0 - p            -- the real minimum exponent\n"
"xMin = toRational (expt b (p-1))\n"
"xMax = toRational (expt b p)\n"
"p0 = (integerLogBase b (numerator x) -\n"
"integerLogBase b (denominator x) - p) `max` minExp\n"
"f = if p0 < 0 then 1 % expt b (-p0) else expt b p0 % 1\n"
"(x', p') = scaleRat (toRational b) minExp xMin xMax p0 (x / f)\n"
"r = encodeFloat (round x') p'\n"
"\n"
"-- Scale x until xMin <= x < xMax, or p (the exponent) <= minExp.\n"
"scaleRat :: Rational -> Int -> Rational -> Rational ->\n"
"Int -> Rational -> (Rational, Int)\n"
"scaleRat b minExp xMin xMax p x\n"
"| p <= minExp = (x,p)\n"
"| x >= xMax   = scaleRat b minExp xMin xMax (p+1) (x/b)\n"
"| x <  xMin   = scaleRat b minExp xMin xMax (p-1) (x*b)\n"
"| otherwise   = (x, p)\n"
"\n"
"-- Exponentiation with a cache for the most common numbers.\n"
"minExpt = 0::Int\n"
"maxExpt = 1100::Int\n"
"expt :: Integer -> Int -> Integer\n"
"expt base n =\n"
"if base == 2 && n >= minExpt && n <= maxExpt then\n"
"expts!n\n"
"else\n"
"base^n\n"
"\n"
"expts :: Array Int Integer\n"
"expts = array (minExpt,maxExpt) [(n,2^n) | n <- [minExpt .. maxExpt]]\n"
"\n"
"-- Compute the (floor of the) log of i in base b.\n"
"-- Simplest way would be just divide i by b until it's smaller then b,\n"
"-- but that would be very slow!  We are just slightly more clever.\n"
"integerLogBase :: Integer -> Integer -> Int\n"
"integerLogBase b i =\n"
"if i < b then\n"
"0\n"
"else\n"
"-- Try squaring the base first to cut down the number of divisions.\n"
"let l = 2 * integerLogBase (b*b) i\n"
"doDiv :: Integer -> Int -> Int\n"
"doDiv i l = if i < b then l else doDiv (i `div` b) (l+1)\n"
"in  doDiv (i `div` (b^l)) l\n"
"\n"
"-- Misc utilities to show integers and floats\n"
"\n"
"showEFloat     :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
"showFFloat     :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
"showGFloat     :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
"showFloat      :: (RealFloat a) => a -> ShowS\n"
"\n"
"showEFloat d x =  showString (formatRealFloat FFExponent d x)\n"
"showFFloat d x =  showString (formatRealFloat FFFixed d x)\n"
"showGFloat d x =  showString (formatRealFloat FFGeneric d x)\n"
"showFloat      =  showGFloat Nothing\n"
"\n"
"-- These are the format types.  This type is not exported.\n"
"\n"
"data FFFormat = FFExponent | FFFixed | FFGeneric\n"
"\n"
"formatRealFloat :: (RealFloat a) => FFFormat -> Maybe Int -> a -> String\n"
"formatRealFloat fmt decs x\n"
"| isNaN      x = \"NaN\"\n"
"| isInfinite x = if x < 0 then \"-Infinity\" else \"Infinity\"\n"
"| x < 0 || isNegativeZero x = '-' : doFmt fmt (floatToDigits (toInteger base) (-x))\n"
"| otherwise    = doFmt fmt (floatToDigits (toInteger base) x)\n"
"where base = 10\n"
"\n"
"doFmt fmt (is, e) =\n"
"let ds = map intToDigit is\n"
"in  case fmt of\n"
"FFGeneric ->\n"
"doFmt (if e < 0 || e > 7 then FFExponent else FFFixed)\n"
"(is, e)\n"
"FFExponent ->\n"
"case decs of\n"
"Nothing ->\n"
"case ds of\n"
"[]    -> \"0.0e0\"\n"
"[d]   -> d : \".0e\" ++ show (e-1)\n"
"d:ds  -> d : '.' : ds ++ 'e':show (e-1)\n"
"Just dec ->\n"
"let dec' = max dec 1 in\n"
"case is of\n"
"[] -> '0':'.':take dec' (repeat '0') ++ \"e0\"\n"
"_ ->\n"
"let (ei, is') = roundTo base (dec'+1) is\n"
"d:ds = map intToDigit\n"
"(if ei > 0 then init is' else is')\n"
"in d:'.':ds  ++ \"e\" ++ show (e-1+ei)\n"
"FFFixed ->\n"
"case decs of\n"
"Nothing\n"
"| e > 0 -> take e (ds ++ repeat '0')\n"
"++ '.' : mk0 (drop e ds)\n"
"| otherwise -> '0' : '.' : mk0 (replicate (-e) '0' ++ ds)\n"
"Just dec ->\n"
"let dec' = max dec 0 in\n"
"if e >= 0 then\n"
"let (ei, is') = roundTo base (dec' + e) is\n"
"(ls, rs) = splitAt (e+ei) (map intToDigit is')\n"
"in  mk0 ls ++ mkdot0 rs\n"
"else\n"
"let (ei, is') = roundTo base dec'\n"
"(replicate (-e) 0 ++ is)\n"
"d : ds = map intToDigit\n"
"(if ei > 0 then is' else 0:is')\n"
"in  d : mkdot0 ds\n"
"where\n"
"mk0 \"\" = \"0\"     -- Used to ensure we print 34.0, not 34.\n"
"mk0 s  = s       -- and 0.34 not .34\n"
"\n"
"mkdot0 \"\" = \"\"   -- Used to ensure we print 34, not 34.\n"
"mkdot0 s  = '.' : s\n"
"\n"
"roundTo :: Int -> Int -> [Int] -> (Int, [Int])\n"
"roundTo base d is = case f d is of\n"
"v@(0, is) -> v\n"
"(1, is)   -> (1, 1 : is)\n"
"where b2 = base `div` 2\n"
"f n [] = (0, replicate n 0)\n"
"f 0 (i:_) = (if i >= b2 then 1 else 0, [])\n"
"f d (i:is) =\n"
"let (c, ds) = f (d-1) is\n"
"i' = c + i\n"
"in  if i' == base then (1, 0:ds) else (0, i':ds)\n"
"\n"
"--\n"
"-- Based on \"Printing Floating-Point Numbers Quickly and Accurately\"\n"
"-- by R.G. Burger and R. K. Dybvig, in PLDI 96.\n"
"-- This version uses a much slower logarithm estimator.  It should be improved.\n"
"\n"
"-- This function returns a list of digits (Ints in [0..base-1]) and an\n"
"-- exponent.\n"
"\n"
"floatToDigits :: (RealFloat a) => Integer -> a -> ([Int], Int)\n"
"\n"
"floatToDigits _ 0 = ([0], 0)\n"
"floatToDigits base x =\n"
"let (f0, e0) = decodeFloat x\n"
"(minExp0, _) = floatRange x\n"
"p = floatDigits x\n"
"b = floatRadix x\n"
"minExp = minExp0 - p            -- the real minimum exponent\n"
"-- Haskell requires that f be adjusted so denormalized numbers\n"
"-- will have an impossibly low exponent.  Adjust for this.\n"
"f :: Integer\n"
"e :: Int\n"
"(f, e) = let n = minExp - e0\n"
"in  if n > 0 then (f0 `div` (b^n), e0+n) else (f0, e0)\n"
"\n"
"(r, s, mUp, mDn) =\n"
"if e >= 0 then\n"
"let be = b^e in\n"
"if f == b^(p-1) then\n"
"(f*be*b*2, 2*b, be*b, b)\n"
"else\n"
"(f*be*2, 2, be, be)\n"
"else\n"
"if e > minExp && f == b^(p-1) then\n"
"(f*b*2, b^(-e+1)*2, b, 1)\n"
"else\n"
"(f*2, b^(-e)*2, 1, 1)\n"
"k =\n"
"let k0 =\n"
"if b==2 && base==10 then\n"
"-- logBase 10 2 is slightly bigger than 3/10 so\n"
"-- the following will err on the low side.  Ignoring\n"
"-- the fraction will make it err even more.\n"
"-- Haskell promises that p-1 <= logBase b f < p.\n"
"(p - 1 + e0) * 3 `div` 10\n"
"else\n"
"ceiling ((log (fromInteger (f+1)) +\n"
"fromIntegral e * log (fromInteger b)) /\n"
"log (fromInteger base))\n"
"fixup n =\n"
"if n >= 0 then\n"
"if r + mUp <= expt base n * s then n else fixup (n+1)\n"
"else\n"
"if expt base (-n) * (r + mUp) <= s then n\n"
"else fixup (n+1)\n"
"in  fixup k0\n"
"\n"
"gen ds rn sN mUpN mDnN =\n"
"let (dn, rn') = (rn * base) `divMod` sN\n"
"mUpN' = mUpN * base\n"
"mDnN' = mDnN * base\n"
"in  case (rn' < mDnN', rn' + mUpN' > sN) of\n"
"(True,  False) -> dn : ds\n"
"(False, True)  -> dn+1 : ds\n"
"(True,  True)  -> if rn' * 2 < sN then dn : ds else dn+1 : ds\n"
"(False, False) -> gen (dn:ds) rn' sN mUpN' mDnN'\n"
"rds =\n"
"if k >= 0 then\n"
"gen [] r (s * expt base k) mUp mDn\n"
"else\n"
"let bk = expt base (-k)\n"
"in  gen [] (r * bk) s (mUp * bk) (mDn * bk)\n"
"in  (map fromIntegral (reverse rds), k)\n";
const char *ptr_hs = "-----------------------------------------------------------------------------\n"
"-- Machine Addresses:\n"
"-- Suitable for use with Hugs 98 on 32 bit machines.\n"
"-----------------------------------------------------------------------------\n"
"module Hugs.Ptr\n"
"( Ptr\n"
", nullPtr          -- :: Ptr a\n"
", plusPtr          -- :: Ptr a -> Int -> Ptr b\n"
", castPtr          -- :: Ptr a -> Ptr b\n"
", alignPtr         -- :: Ptr a -> Int -> Ptr a\n"
", minusPtr         -- :: Ptr a -> Ptr b -> Int\n"
", ptrToInt         -- :: Ptr a -> Int\n"
"-- instance Eq   (Ptr a)\n"
"-- instance Ord  (Ptr a)\n"
"-- instance Show (Ptr a)\n"
"\n"
", FunPtr\n"
", nullFunPtr        -- :: FunPtr a\n"
", castFunPtr        -- :: FunPtr a -> FunPtr b\n"
", castFunPtrToPtr   -- :: FunPtr a -> Ptr b\n"
", castPtrToFunPtr   -- :: Ptr a -> FunPtr b\n"
", freeHaskellFunPtr -- :: FunPtr a -> IO ()\n"
"-- instance Eq   (FunPtr a)\n"
"-- instance Ord  (FunPtr a)\n"
"-- instance Show (FunPtr a)\n"
") where\n"
"\n"
"import Hugs.Prelude ( Ptr, FunPtr )\n"
"\n"
"-- data Ptr a -- in Hugs.Prelude\n"
"\n"
"instance Eq   (Ptr a) where (==)      = primEqPtr\n"
"instance Ord  (Ptr a) where compare   = primCmpPtr\n"
"instance Show (Ptr a) where showsPrec = primShowsPtr\n"
"\n"
"primitive nullPtr                    :: Ptr a\n"
"primitive plusPtr                    :: Ptr a -> Int -> Ptr b\n"
"primitive minusPtr                   :: Ptr a -> Ptr b -> Int\n"
"primitive castPtr \"primUnsafeCoerce\" :: Ptr a -> Ptr b\n"
"primitive primShowsPtr               :: Int -> Ptr a -> ShowS\n"
"primitive primEqPtr                  :: Ptr a -> Ptr a -> Bool\n"
"primitive primCmpPtr                 :: Ptr a -> Ptr a -> Ordering\n"
"primitive ptrToInt                   :: Ptr a -> Int\n"
"\n"
"alignPtr :: Ptr a -> Int -> Ptr a\n"
"alignPtr p n = p `plusPtr` ((n - ptrToInt p `mod` n) `mod` n)\n"
"\n"
"-- data FunPtr a -- in Hugs.Prelude\n"
"\n"
"instance Eq   (FunPtr a) where (==)      = primEqFPtr\n"
"instance Ord  (FunPtr a) where compare   = primCmpFPtr\n"
"instance Show (FunPtr a) where showsPrec = primShowsFPtr\n"
"\n"
"primitive nullFunPtr    \"nullPtr\"       :: FunPtr a\n"
"primitive primShowsFPtr \"primShowsPtr\"  :: Int -> FunPtr a -> ShowS\n"
"primitive primEqFPtr    \"primEqPtr\"     :: FunPtr a -> FunPtr a -> Bool\n"
"primitive primCmpFPtr   \"primCmpPtr\"    :: FunPtr a -> FunPtr a -> Ordering\n"
"primitive castFunPtr \"primUnsafeCoerce\" :: FunPtr a -> FunPtr b\n"
"primitive castFunPtrToPtr \"primUnsafeCoerce\" :: FunPtr a -> Ptr b\n"
"primitive castPtrToFunPtr \"primUnsafeCoerce\" :: Ptr a -> FunPtr b\n"
"primitive freeHaskellFunPtr             :: FunPtr a -> IO ()\n"
"\n"
"-----------------------------------------------------------------------------\n";
const char *genericprint_hs = "----------------------------------------------------------------\n"
"-- A \"generic\" (or \"polymorphic\") print function in Haskell\n"
"-- This is very heavily based on the code in printer.c\n"
"-- (Together with the decompiler and error catching primitives,\n"
"-- this might make a good base on which to build a debugger?)\n"
"--\n"
"-- NB This library is an _experimental_ feature which may be\n"
"--    removed in future versions of Hugs.\n"
"--    It can only be used if Hugs was configured with the\n"
"--    \"--enable-internal--prims\" flag.\n"
"----------------------------------------------------------------\n"
"\n"
"module Hugs.GenericPrint(\n"
"printError,\n"
"outputString,\n"
"print\n"
") where\n"
"\n"
"import Prelude hiding (print)\n"
"\n"
"import Hugs.Internals(\n"
"Name, nameInfo, nameString,\n"
"Cell, getCell,\n"
"CellKind(..), classifyCell,\n"
")\n"
"\n"
"import Hugs.IOExts( unsafePerformIO )\n"
"import Hugs.Array\n"
"import Data.Char( showLitChar, isAlpha )\n"
"import Data.List( intersperse )\n"
"\n"
"----------------------------------------------------------------\n"
"-- The top-level print routine\n"
"----------------------------------------------------------------\n"
"\n"
"printError   :: Cell -> IO ()\n"
"outputString :: String -> IO ()\n"
"print        :: a -> IO ()\n"
"\n"
"printError err = do\n"
"putStr \"\\nProgram error: \"\n"
"printDBadRedex err\n"
"putStr \"\\n\"\n"
"\n"
"outputString s = outputStr (getCell s)\n"
"\n"
"print x        = print' True (getCell x)\n"
"\n"
"----------------------------------------------------------------\n"
"\n"
"printBadRedex err = do\n"
"putChar '{'\n"
"print' False err\n"
"putChar '}'\n"
"\n"
"printDBadRedex err = do\n"
"kind <- classifyCell False err\n"
"case kind of\n"
"Apply fun args -> do\n"
"funkind <- classifyCell False fun\n"
"case (funkind, args) of\n"
"(Fun nm, [msg]) | nm == nameError ->\n"
"outputStr msg\n"
"_ -> printBadRedex err\n"
"_ -> printBadRedex err\n"
"\n"
"outputStr :: Cell -> IO ()\n"
"outputStr xs = do\n"
"kind <- hugsClassifyCell True xs\n"
"case kind of\n"
"Apply fun args ->\n"
"hugsClassifyCell True fun >>= \\ funkind ->\n"
"case (funkind, args) of\n"
"(Con nm, [y,ys]) | nm == nameCons ->\n"
"hugsClassifyCell True y >>= \\ ykind ->\n"
"case ykind of\n"
"Char c ->\n"
"putChar c >>\n"
"outputStr ys\n"
"Error err ->\n"
"printBadRedex err >>\n"
"outputStr ys\n"
"_ ->\n"
"printBadRedex y >>\n"
"outputStr ys\n"
"(Error err, _) ->\n"
"printBadRedex err\n"
"_ ->\n"
"printBadRedex xs\n"
"Con nm | nm == nameNil ->\n"
"return ()\n"
"Error err ->\n"
"printBadRedex err\n"
"_ ->\n"
"printBadRedex xs\n"
"\n"
"print' :: Bool -> Cell -> IO ()\n"
"print' strict x = printCell strict min_prec x\n"
"\n"
"--ToDo: combine with sprint (if possible)\n"
"lprint :: Bool -> Cell -> Cell -> IO ()\n"
"lprint strict x xs =\n"
"printCell strict min_prec x >>\n"
"hugsClassifyCell strict xs >>= \\ kind ->\n"
"case kind of\n"
"Apply fun args ->\n"
"hugsClassifyCell strict fun >>= \\ funkind ->\n"
"case (funkind, args) of\n"
"(Con nm, [y,ys]) | nm == nameCons ->\n"
"putStr \", \" >>\n"
"lprint strict y ys\n"
"(Error err, _) ->\n"
"printBadRedex err\n"
"_ ->\n"
"putStr \"] ++ \" >>\n"
"printBadRedex xs\n"
"Con nm | nm == nameNil ->\n"
"putChar ']'\n"
"Error err ->\n"
"printBadRedex err\n"
"_ ->\n"
"putStr \"] ++ \" >>\n"
"printBadRedex xs\n"
"\n"
"sprint :: Bool -> Char -> Cell -> IO ()\n"
"sprint strict c xs =\n"
"putStr (showLitChar c \"\") >>\n"
"hugsClassifyCell strict xs >>= \\ kind ->\n"
"case kind of\n"
"Apply fun args ->\n"
"hugsClassifyCell strict fun >>= \\ funkind ->\n"
"case (funkind, args) of\n"
"(Con nm, [y,ys]) | nm == nameCons ->\n"
"hugsClassifyCell strict y >>= \\ ykind ->\n"
"case ykind of\n"
"Char c -> sprint strict c ys\n"
"_      -> lprint False y ys\n"
"_ ->\n"
"putStr \"\\\" ++ \" >>\n"
"printBadRedex xs\n"
"Con nm | nm == nameNil ->\n"
"putChar '\"'\n"
"_ ->\n"
"putStr \"\\\" ++ \" >>\n"
"printBadRedex xs\n"
"\n"
"printCell :: Bool -> Int -> Cell -> IO ()\n"
"printCell strict d x =\n"
"hugsClassifyCell strict x >>= \\ kind ->\n"
"case kind of\n"
"Apply fun args ->\n"
"hugsClassifyCell strict fun >>= \\ funkind ->\n"
"case funkind of\n"
"Con nm ->\n"
"case args of\n"
"[x,xs] | nm == nameCons\n"
"-> hugsClassifyCell strict x >>= \\ xkind ->\n"
"case xkind of\n"
"Char c -> putChar '\"' >> sprint strict c xs\n"
"_      -> putChar '[' >> lprint strict x xs\n"
"\n"
"[x] | assoc /= 'A'\n"
"-> printParen True (\n"
"printCell strict (fun_prec-1) x >>\n"
"putChar ' ' >>\n"
"putStr (asOp nameStr)\n"
")\n"
"\n"
"(x1:x2:xs) | assoc /= 'A'\n"
"-> printParen (not (null xs) && d >= fun_prec) (\n"
"printParen (d <= p) (do\n"
"printCell strict lp x1\n"
"putChar ' '\n"
"putStr (asOp nameStr)\n"
"putChar ' '\n"
"printCell strict rp x2\n"
") >>\n"
"mapM_ (\\ arg ->\n"
"putChar ' ' >>\n"
"printCell strict p arg\n"
") xs\n"
")\n"
"\n"
"xs\n"
"-> printParen (not (null xs) && d >= fun_prec) (\n"
"-- test that xs is nonNull should be redundant but\n"
"-- no harm being robust\n"
"putStr (asVar nameStr)       >>\n"
"mapM_ (\\arg ->\n"
"putChar ' ' >>\n"
"printCell strict fun_prec arg\n"
") xs\n"
")\n"
"where\n"
"(arity, p, assoc) = nameInfo nm\n"
"nameStr = nameString nm\n"
"\n"
"-- from Appendix E2 of Haskell 1.2 report\n"
"lp = if assoc == 'L' then p else p+1\n"
"rp = if assoc == 'R' then p else p+1\n"
"\n"
"Fun nm ->\n"
"printParen (d >= fun_prec) (\n"
"putStr (asVar nameStr)       >>\n"
"mapM_ (\\arg ->\n"
"putChar ' ' >>\n"
"-- switch to lazy printing!\n"
"printCell False fun_prec arg\n"
") args\n"
")\n"
"where\n"
"nameStr = nameString nm\n"
"\n"
"Tuple arity ->\n"
"printParen (not (null extra) && d >= fun_prec) (\n"
"printParen True (\n"
"for__ fields (\\ field ->\n"
"printCell strict min_prec field\n"
") (putChar ',') >>\n"
"-- Haskell's syntax makes it impossible to construct an\n"
"-- incomplete tuple - but let's play safe!\n"
"mapM_ (\\_ ->\n"
"putChar ','\n"
") [numArgs+1..arity]\n"
") >>\n"
"-- Haskell's type system makes extra arguments impossible\n"
"-- - but let's play safe!\n"
"mapM_ (\\ arg ->\n"
"putChar ' ' >>\n"
"printCell strict fun_prec arg\n"
") extra\n"
")\n"
"where\n"
"(fields, extra) = splitAt arity args\n"
"\n"
"Error err ->\n"
"printBadRedex err\n"
"\n"
"_\n"
"-> printParen (not (null args) && d >= fun_prec) (\n"
"printCell strict fun_prec fun   >>\n"
"mapM_ (\\arg ->\n"
"putChar ' ' >>\n"
"printCell strict fun_prec arg\n"
") args\n"
")\n"
"where\n"
"numArgs = length args\n"
"\n"
"Fun nm ->\n"
"putStr (asVar (nameString nm))\n"
"\n"
"Con nm ->\n"
"putStr (asVar (nameString nm))\n"
"\n"
"Tuple arity ->\n"
"putStr ('(' : replicate arity ',' ++ \")\")\n"
"\n"
"Int x ->\n"
"putStr (show x)\n"
"\n"
"Integer x ->\n"
"putStr (show x)\n"
"\n"
"Float x ->\n"
"putStr (show x)\n"
"\n"
"Char x ->\n"
"putStr ('\\'' : showLitChar x \"\\'\")\n"
"\n"
"Prim prim ->\n"
"putStr prim\n"
"\n"
"Error err ->\n"
"printBadRedex err\n"
"\n"
"----------------------------------------------------------------\n"
"-- Cell/Name utilities\n"
"----------------------------------------------------------------\n"
"\n"
"nameCons    =  cellName (:)\n"
"nameNil     =  cellName []\n"
"nameError   =  cellName error\n"
"\n"
"-- Here's something VERY subtle.\n"
"-- We use classifyCell instead of hugsClassifyCell because\n"
"-- otherwise, this gets put in the same dependency class as everything\n"
"-- else and the lack of polymorphic recursion bites us.\n"
"-- (Using classifyCell is equally good here because it wont fail.)\n"
"cellName :: a -> Name\n"
"cellName x = unsafePerformIO (\n"
"classifyCell True (getCell x) >>= \\ kind ->\n"
"case kind of\n"
"Fun nm -> return nm\n"
"Con nm -> return nm\n"
")\n"
"\n"
"-- This implements the error-handling policy:\n"
"hugsClassifyCell :: Bool -> Cell -> IO CellKind\n"
"hugsClassifyCell strict obj =\n"
"classifyCell strict obj >>= \\ kind ->\n"
"case kind of\n"
"Error err ->\n"
"if failOnError then\n"
"exitWith (printError err)\n"
"else\n"
"return kind\n"
"_ ->\n"
"return kind\n"
"\n"
"----------------------------------------------------------------\n"
"-- Utilities\n"
"----------------------------------------------------------------\n"
"\n"
"for__ :: Monad m => [a] -> (a -> m ()) -> m () -> m ()\n"
"for__ xs f inc = sequence_ $ intersperse inc $ map f xs\n"
"\n"
"min_prec, max_prec, fun_prec :: Int\n"
"min_prec = 0\n"
"max_prec = 9\n"
"fun_prec = max_prec+2\n"
"\n"
"asOp str\n"
"| isOp str  = str\n"
"| otherwise = '`' : str ++ \"`\"\n"
"\n"
"asVar str\n"
"| isOp str  = '(' : str ++ \")\"\n"
"| otherwise = str\n"
"\n"
"isOp (c:_) = not (isAlpha c || c == '[')\n"
"isOp _     = False\n"
"\n"
"printParen :: Bool -> IO () -> IO ()\n"
"printParen True m  = putChar '(' >> m >> putChar ')'\n"
"printParen False m = m\n"
"\n"
"----------------------------------------------------------------\n"
"-- Missing primitives\n"
"----------------------------------------------------------------\n"
"\n"
"-- In Hugs0, this accessed the value of the :set -f\" flag\n"
"failOnError :: Bool\n"
"failOnError = True\n"
"\n"
"-- In Hugs0, this executed the action and terminated the current evaluation\n"
"exitWith :: IO () -> IO a\n"
"exitWith m = m >> error \"{exitWith}\"\n"
"\n"
"----------------------------------------------------------------\n";
const char *ioref_hs = "module Hugs.IORef\n"
"( IORef		      -- abstract, instance of: Eq\n"
", newIORef	      -- :: a -> IO (IORef a)\n"
", readIORef	      -- :: IORef a -> IO a\n"
", writeIORef	      -- :: IORef a -> a -> IO ()\n"
") where\n"
"\n"
"data IORef a        -- mutable variables containing values of type a\n"
"\n"
"primitive newIORef   \"newRef\" :: a -> IO (IORef a)\n"
"primitive readIORef  \"getRef\" :: IORef a -> IO a\n"
"primitive writeIORef \"setRef\" :: IORef a -> a -> IO ()\n"
"primitive eqIORef    \"eqRef\"  :: IORef a -> IORef a -> Bool\n"
"\n"
"instance Eq (IORef a) where\n"
"(==) = eqIORef\n";
const char *storable_hs = "module Hugs.Storable where\n"
"\n"
"import Hugs.Prelude\n"
"\n"
"foreign import ccall unsafe \"Storable_aux.h\" readIntOffPtr       :: Ptr Int           -> Int -> IO Int\n"
"foreign import ccall unsafe \"Storable_aux.h\" readCharOffPtr      :: Ptr Char          -> Int -> IO Char\n"
"-- foreign import ccall unsafe \"Storable_aux.h\" readWideCharOffPtr  :: Ptr Char          -> Int -> IO Char\n"
"-- foreign import ccall unsafe \"Storable_aux.h\" readWordOffPtr      :: Ptr Word          -> Int -> IO Word\n"
"foreign import ccall unsafe \"Storable_aux.h\" readPtrOffPtr       :: Ptr (Ptr a)       -> Int -> IO (Ptr a)\n"
"foreign import ccall unsafe \"Storable_aux.h\" readFunPtrOffPtr    :: Ptr (FunPtr a)    -> Int -> IO (FunPtr a)\n"
"foreign import ccall unsafe \"Storable_aux.h\" readFloatOffPtr     :: Ptr Float         -> Int -> IO Float\n"
"foreign import ccall unsafe \"Storable_aux.h\" readDoubleOffPtr    :: Ptr Double        -> Int -> IO Double\n"
"foreign import ccall unsafe \"Storable_aux.h\" readStablePtrOffPtr :: Ptr (StablePtr a) -> Int -> IO (StablePtr a)\n"
"foreign import ccall unsafe \"Storable_aux.h\" readInt8OffPtr      :: Ptr Int8          -> Int -> IO Int8\n"
"foreign import ccall unsafe \"Storable_aux.h\" readInt16OffPtr     :: Ptr Int16         -> Int -> IO Int16\n"
"foreign import ccall unsafe \"Storable_aux.h\" readInt32OffPtr     :: Ptr Int32         -> Int -> IO Int32\n"
"foreign import ccall unsafe \"Storable_aux.h\" readInt64OffPtr     :: Ptr Int64         -> Int -> IO Int64\n"
"foreign import ccall unsafe \"Storable_aux.h\" readWord8OffPtr     :: Ptr Word8         -> Int -> IO Word8\n"
"foreign import ccall unsafe \"Storable_aux.h\" readWord16OffPtr    :: Ptr Word16        -> Int -> IO Word16\n"
"foreign import ccall unsafe \"Storable_aux.h\" readWord32OffPtr    :: Ptr Word32        -> Int -> IO Word32\n"
"foreign import ccall unsafe \"Storable_aux.h\" readWord64OffPtr    :: Ptr Word64        -> Int -> IO Word64\n"
"\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeIntOffPtr       :: Ptr Int           -> Int -> Int         -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeCharOffPtr      :: Ptr Char          -> Int -> Char        -> IO ()\n"
"-- foreign import ccall unsafe \"Storable_aux.h\" writeWideCharOffPtr  :: Ptr Char          -> Int -> Char        -> IO ()\n"
"-- foreign import ccall unsafe \"Storable_aux.h\" writeWordOffPtr      :: Ptr Word          -> Int -> Word        -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writePtrOffPtr       :: Ptr (Ptr a)       -> Int -> Ptr a       -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeFunPtrOffPtr    :: Ptr (FunPtr a)    -> Int -> FunPtr a    -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeFloatOffPtr     :: Ptr Float         -> Int -> Float       -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeDoubleOffPtr    :: Ptr Double        -> Int -> Double      -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeStablePtrOffPtr :: Ptr (StablePtr a) -> Int -> StablePtr a -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeInt8OffPtr      :: Ptr Int8          -> Int -> Int8        -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeInt16OffPtr     :: Ptr Int16         -> Int -> Int16       -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeInt32OffPtr     :: Ptr Int32         -> Int -> Int32       -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeInt64OffPtr     :: Ptr Int64         -> Int -> Int64       -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeWord8OffPtr     :: Ptr Word8         -> Int -> Word8       -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeWord16OffPtr    :: Ptr Word16        -> Int -> Word16      -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeWord32OffPtr    :: Ptr Word32        -> Int -> Word32      -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeWord64OffPtr    :: Ptr Word64        -> Int -> Word64      -> IO ()\n"
"\n";
const char *time_hs = "--\n"
"-- Time primitives for Hugs98.\n"
"--\n"
"module Hugs.Time\n"
"( getClockTimePrim\n"
", toCalTimePrim\n"
", toClockTimePrim\n"
"\n"
", getCPUTime		-- :: IO Integer\n"
", clockTicks		-- :: Int\n"
") where\n"
"\n"
"primitive getClockTimePrim :: IO (Int,Int)\n"
"primitive toCalTimePrim ::\n"
"Int -> Int -> IO (Int,Int,Int,Int,Int,Int,Int,Int,Int,String,Int)\n"
"primitive toClockTimePrim ::\n"
"Int -> Int -> Int -> Int -> Int -> Int -> Int -> IO Int\n"
"\n"
"picoSec :: Integer\n"
"picoSec = 1000000000000 -- 10^12\n"
"\n"
"getCPUTime :: IO Integer\n"
"getCPUTime = do\n"
"(usec, unsec, ssec, snsec) <- getCPUUsage\n"
"return (picoSec * fromIntegral usec  +\n"
"1000    * fromIntegral unsec +\n"
"picoSec * fromIntegral ssec  +\n"
"1000    * fromIntegral snsec)\n"
"\n"
"primitive getCPUUsage  :: IO (Int,Int,Int,Int)\n"
"primitive clockTicks   :: Int\n";
const char *storable_aux_c = "#include \"Storable_aux.h\"\n"
"\n"
"#define DEFINE(T) \\\n"
"void write##T##OffPtr(Hs##T *arg1, HsInt arg2, Hs##T arg3) { arg1[arg2] = arg3; } \\\n"
"Hs##T read##T##OffPtr(Hs##T *arg1, HsInt arg2) { return arg1[arg2]; }\n"
"\n"
"DEFINE(Int       )\n"
"DEFINE(Char      )\n"
"/* DEFINE(WideChar  ) */\n"
"DEFINE(Word      )\n"
"DEFINE(Ptr       )\n"
"DEFINE(FunPtr    )\n"
"DEFINE(Float     )\n"
"DEFINE(Double    )\n"
"DEFINE(StablePtr )\n"
"DEFINE(Int8      )\n"
"DEFINE(Int16     )\n"
"DEFINE(Int32     )\n"
"DEFINE(Int64     )\n"
"DEFINE(Word8     )\n"
"DEFINE(Word16    )\n"
"DEFINE(Word32    )\n"
"DEFINE(Word64    )\n"
"\n"
"#undef DEFINE\n";
const char *stableptr_hs = "module Hugs.StablePtr( StablePtr, module Hugs.StablePtr ) where\n"
"\n"
"import Hugs.Prelude( StablePtr, Ptr )\n"
"\n"
"-- recently renamed\n"
"newStablePtr = makeStablePtr\n"
"\n"
"primitive makeStablePtr      :: a -> IO (StablePtr a)\n"
"primitive deRefStablePtr     :: StablePtr a -> IO a\n"
"primitive freeStablePtr      :: StablePtr a -> IO ()\n"
"primitive castStablePtrToPtr :: StablePtr a -> Ptr ()\n"
"primitive castPtrToStablePtr :: Ptr () -> StablePtr a\n"
"\n";
const char *ioexts_hs = "-----------------------------------------------------------------------------\n"
"-- IO monad extensions:\n"
"--\n"
"-- Suitable for use with Hugs 98.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.IOExts\n"
"( fixIO				-- :: (a -> IO a) -> IO a\n"
", unsafePerformIO		-- :: IO a -> a\n"
"\n"
", performGC\n"
"\n"
", IOModeEx(..)	      	-- instance (Eq, Read, Show)\n"
", openFileEx	      	-- :: FilePath -> IOModeEx -> IO Handle\n"
"\n"
", unsafePtrEq\n"
", unsafePtrToInt\n"
", unsafeCoerce\n"
"\n"
"-- backward compatibility with IOExtensions\n"
", readBinaryFile        -- :: FilePath -> IO String\n"
", writeBinaryFile       -- :: FilePath -> String -> IO ()\n"
", appendBinaryFile      -- :: FilePath -> String -> IO ()\n"
", openBinaryFile        -- :: FilePath -> IOMode -> IO Handle\n"
"\n"
"-- non-echoing getchar\n"
", getCh                 -- :: IO Char\n"
", argv                  -- :: [String]\n"
"\n"
"-- Non-standard extensions\n"
", hugsIsEOF             -- :: IO Bool\n"
", hugsHIsEOF            -- :: Handle  -> IO Bool\n"
") where\n"
"\n"
"import Hugs.Prelude\n"
"import Hugs.IO\n"
"import Hugs.IORef\n"
"import Hugs.System ( getArgs )\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive performGC \"primGC\" :: IO ()\n"
"\n"
"unsafePerformIO :: IO a -> a\n"
"unsafePerformIO m = valueOf (basicIORun m)\n"
"\n"
"primitive unsafePtrEq    :: a -> a -> Bool\n"
"primitive unsafePtrToInt :: a -> Int\n"
"\n"
"fixIO :: (a -> IO a) -> IO a\n"
"fixIO f = do\n"
"r <- newIORef (throw NonTermination)\n"
"x <- f (unsafePerformIO (readIORef r))\n"
"writeIORef r x\n"
"return x\n"
"\n"
"primitive unsafeCoerce \"primUnsafeCoerce\" :: a -> b\n"
"\n"
"valueOf :: IOFinished a -> a\n"
"valueOf (Finished_Return a) = a\n"
"valueOf _ = error \"IOExts.valueOf: thread failed\"	-- shouldn't happen\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Binary files\n"
"-----------------------------------------------------------------------------\n"
"data IOModeEx\n"
"= BinaryMode IOMode\n"
"| TextMode   IOMode\n"
"deriving (Eq, Read, Show)\n"
"\n"
"openFileEx :: FilePath -> IOModeEx -> IO Handle\n"
"openFileEx fp m =\n"
"case m of\n"
"BinaryMode m -> openBinaryFile fp m\n"
"TextMode m   -> openFile fp m\n"
"\n"
"argv :: [String]\n"
"argv = unsafePerformIO getArgs\n"
"\n"
"primitive writeBinaryFile   	 :: FilePath -> String -> IO ()\n"
"primitive appendBinaryFile  	 :: FilePath -> String -> IO ()\n"
"primitive readBinaryFile    	 :: FilePath -> IO String\n"
"primitive openBinaryFile         :: FilePath -> IOMode -> IO Handle\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Non-standard extensions\n"
"-- (likely to disappear when IO library is more complete)\n"
"--\n"
"-- keep them around for now.\n"
"\n"
"primitive getCh                  :: IO Char -- non-echoing getchar\n"
"\n"
"-- C library style test for EOF (doesn't obey Haskell semantics)\n"
"primitive hugsHIsEOF \"hugsHIsEOF\" :: Handle -> IO Bool\n"
"hugsIsEOF             :: IO Bool\n"
"hugsIsEOF              = hugsHIsEOF stdin\n";
const char *prelude_names[] = {"Exception.hs", "System.hs", "Trex.hs", "Stable.hs", "ST.hs", "ByteArray.hs", "CVHAssert.hs", "Prelude.hs", "ForeignPtr.hs", "Observe.hs", "Dynamic.hs", "Word.hs", "Quote.hs", "LazyST.hs", "Char.hs", "Internals.hs", "Memo.hs", "Storable_aux.h", "IOArray.hs", "Weak.hs", "IO.hs", "Array.hs", "Directory.hs", "ConcBase.hs", "Bits.hs", "Int.hs", "Numeric.hs", "Ptr.hs", "GenericPrint.hs", "IORef.hs", "Storable.hs", "Time.hs", "Storable_aux.c", "StablePtr.hs", "IOExts.hs"};

const char *prelude_contents[] = {exception_hs, system_hs, trex_hs, stable_hs, st_hs, bytearray_hs, cvhassert_hs, prelude_hs, foreignptr_hs, observe_hs, dynamic_hs, word_hs, quote_hs, lazyst_hs, char_hs, internals_hs, memo_hs, storable_aux_h, ioarray_hs, weak_hs, io_hs, array_hs, directory_hs, concbase_hs, bits_hs, int_hs, numeric_hs, ptr_hs, genericprint_hs, ioref_hs, storable_hs, time_hs, storable_aux_c, stableptr_hs, ioexts_hs};
