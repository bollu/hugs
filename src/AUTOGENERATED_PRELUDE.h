#pragma once
#ifndef AUTOGENERATED_PRELUDE
#define AUTOGENERATED_PRELUDE
const char *Ratio = "\n"
"module Ratio (\n"
"    Ratio, Rational, (%), numerator, denominator, approxRational\n"
"  ) where\n"
"\n"
"import Data.Ratio\n";
const char *System = "\n"
"module System (\n"
"    ExitCode(ExitSuccess,ExitFailure),\n"
"    getArgs, getProgName, getEnv, system, exitWith, exitFailure\n"
"  ) where\n"
"\n"
"import System.Exit\n"
"import System.Environment\n"
"import System.Cmd\n";
const char *Maybe = "\n"
"module Maybe (\n"
"    isJust, isNothing,\n"
"    fromJust, fromMaybe, listToMaybe, maybeToList,\n"
"    catMaybes, mapMaybe,\n"
"\n"
"    -- ...and what the Prelude exports\n"
"    Maybe(Nothing, Just),\n"
"    maybe\n"
"  ) where\n"
"\n"
"import Data.Maybe\n";
const char *CPUTime = "\n"
"module CPUTime (\n"
"    getCPUTime, cpuTimePrecision \n"
"  ) where\n"
"\n"
"import System.CPUTime\n";
const char *Network = "\n"
"{-# OPTIONS -cpp #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Network\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/core/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- The \"Network\" interface is a \\\"higher-level\\\" interface to\n"
"-- networking facilities, and it is recommended unless you need the\n"
"-- lower-level interface in \"Network.Socket\".\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Network (\n"
"\n"
"	-- * Basic data types\n"
"	Socket,\n"
"        PortID(..),\n"
"	HostName,\n"
"	PortNumber,	-- instance (Eq, Enum, Num, Real, Integral)\n"
"\n"
"	-- * Initialisation\n"
"	withSocketsDo,  -- :: IO a   -> IO a\n"
"	\n"
"	-- * Server-side connections\n"
"	listenOn,	-- :: PortID -> IO Socket\n"
"	accept,		-- :: Socket -> IO (Handle, HostName, PortNumber)\n"
"\n"
"	-- * Client-side connections\n"
"	connectTo,	-- :: HostName -> PortID -> IO Handle\n"
"\n"
"	-- * Simple sending and receiving\n"
"	sendTo,		-- :: HostName -> PortID -> String -> IO ()\n"
"	recvFrom,	-- :: HostName -> PortID -> IO String\n"
"\n"
"	-- * Miscellaneous\n"
"	socketPort,	-- :: Socket -> IO PortID\n"
"\n"
"	-- * Networking Issues\n"
"	-- ** Buffering\n"
"	{-$buffering-}\n"
"\n"
"	-- ** Improving I\\/O Performance over sockets\n"
"	{-$performance-}\n"
"\n"
"	-- ** @SIGPIPE@\n"
"	{-$sigpipe-}\n"
"\n"
"       ) where\n"
"\n"
"import Network.BSD\n"
"import Network.Socket hiding ( accept, socketPort, recvFrom, sendTo, PortNumber )\n"
"import qualified Network.Socket as Socket ( accept )\n"
"import System.IO\n"
"import Prelude\n"
"import Control.Exception as Exception\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- High Level ``Setup'' functions\n"
"\n"
"-- If the @PortID@ specifies a 1 family socket and the @Hostname@\n"
"-- differs from that returned by @getHostname@ then an error is\n"
"-- raised. Alternatively an empty string may be given to @connectTo@\n"
"-- signalling that the current hostname applies.\n"
"\n"
"data PortID = \n"
"	  Service String		-- Service Name eg \"ftp\"\n"
"	| PortNumber PortNumber		-- User defined Port Number\n"
"	| UnixSocket String		-- Unix family socket in file system\n"
"\n"
"-- | Calling 'connectTo' creates a client side socket which is\n"
"-- connected to the given host and port.  The Protocol and socket type is\n"
"-- derived from the given port identifier.  If a port number is given\n"
"-- then the result is always an internet family 'Stream' socket. \n"
"\n"
"connectTo :: HostName		-- Hostname\n"
"	  -> PortID 		-- Port Identifier\n"
"	  -> IO Handle		-- Connected Socket\n"
"\n"
"connectTo hostname (Service serv) = do\n"
"    proto <- getProtocolNumber \"tcp\"\n"
"    bracketOnError\n"
"	(socket AF_INET Stream proto)\n"
"	(sClose)  -- only done if there's an error\n"
"	(\\sock -> do\n"
"          port	<- getServicePortNumber serv\n"
"          he	<- getHostByName hostname\n"
"          connect sock (SockAddrInet port (hostAddress he))\n"
"          socketToHandle sock ReadWriteMode\n"
" 	)\n"
"\n"
"connectTo hostname (PortNumber port) = do\n"
"    proto <- getProtocolNumber \"tcp\"\n"
"    bracketOnError\n"
"	(socket AF_INET Stream proto)\n"
"	(sClose)  -- only done if there's an error\n"
"        (\\sock -> do\n"
"      	  he <- getHostByName hostname\n"
"      	  connect sock (SockAddrInet port (hostAddress he))\n"
"      	  socketToHandle sock ReadWriteMode\n"
"	)\n"
"\n"
"connectTo _ (UnixSocket path) = do\n"
"    bracketOnError\n"
"	(socket AF_UNIX Stream 0)\n"
"	(sClose)\n"
"	(\\sock -> do\n"
"          connect sock (SockAddrUnix path)\n"
"          socketToHandle sock ReadWriteMode\n"
"	)\n"
"\n"
"-- | Creates the server side socket which has been bound to the\n"
"-- specified port.  \n"
"--\n"
"-- NOTE: To avoid the \\\"Address already in use\\\"\n"
"-- problems popped up several times on the GHC-Users mailing list we\n"
"-- set the 'ReuseAddr' socket option on the listening socket.  If you\n"
"-- don't want this behaviour, please use the lower level\n"
"-- 'Network.Socket.listen' instead.\n"
"\n"
"listenOn :: PortID 	-- ^ Port Identifier\n"
"	 -> IO Socket	-- ^ Connected Socket\n"
"\n"
"listenOn (Service serv) = do\n"
"    proto <- getProtocolNumber \"tcp\"\n"
"    bracketOnError\n"
"        (socket AF_INET Stream proto)\n"
"	(sClose)\n"
"	(\\sock -> do\n"
"	    port    <- getServicePortNumber serv\n"
"	    setSocketOption sock ReuseAddr 1\n"
"	    bindSocket sock (SockAddrInet port iNADDR_ANY)\n"
"	    listen sock maxListenQueue\n"
"	    return sock\n"
"	)\n"
"\n"
"listenOn (PortNumber port) = do\n"
"    proto <- getProtocolNumber \"tcp\"\n"
"    bracketOnError\n"
"    	(socket AF_INET Stream proto)\n"
"	(sClose)\n"
"	(\\sock -> do\n"
"	    setSocketOption sock ReuseAddr 1\n"
"	    bindSocket sock (SockAddrInet port iNADDR_ANY)\n"
"	    listen sock maxListenQueue\n"
"	    return sock\n"
"	)\n"
"\n"
"listenOn (UnixSocket path) =\n"
"    bracketOnError\n"
"    	(socket AF_UNIX Stream 0)\n"
"	(sClose)\n"
"	(\\sock -> do\n"
"	    setSocketOption sock ReuseAddr 1\n"
"	    bindSocket sock (SockAddrUnix path)\n"
"	    listen sock maxListenQueue\n"
"	    return sock\n"
"	)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- accept\n"
"\n"
"-- | Accept a connection on a socket created by 'listenOn'.  Normal\n"
"-- I\\/O opertaions (see \"System.IO\") can be used on the 'Handle'\n"
"-- returned to communicate with the client.\n"
"-- Notice that although you can pass any Socket to Network.accept, only\n"
"-- sockets of either AF_UNIX or AF_INET will work (this shouldn't be a problem,\n"
"-- though). When using AF_UNIX, HostName will be set to the path of the socket\n"
"-- and PortNumber to -1.\n"
"--\n"
"accept :: Socket 		-- ^ Listening Socket\n"
"       -> IO (Handle,\n"
"	      HostName,\n"
"	      PortNumber)	-- ^ Triple of: read\\/write 'Handle' for \n"
"				-- communicating with the client,\n"
"			 	-- the 'HostName' of the peer socket, and\n"
"				-- the 'PortNumber' of the remote connection.\n"
"accept sock@(MkSocket _ AF_INET _ _ _) = do\n"
" ~(sock', (SockAddrInet port haddr)) <- Socket.accept sock\n"
" peer <- Exception.catchJust ioErrors\n"
"	  (do 	\n"
"	     (HostEntry peer _ _ _) <- getHostByAddr AF_INET haddr\n"
"	     return peer\n"
"	  )\n"
"	  (\\e -> inet_ntoa haddr)\n"
"		-- if getHostByName fails, we fall back to the IP address\n"
" handle <- socketToHandle sock' ReadWriteMode\n"
" return (handle, peer, port)\n"
"accept sock@(MkSocket _ AF_UNIX _ _ _) = do\n"
" ~(sock', (SockAddrUnix path)) <- Socket.accept sock\n"
" handle <- socketToHandle sock' ReadWriteMode\n"
" return (handle, path, -1)\n"
"accept sock@(MkSocket _ family _ _ _) =\n"
"  error $ \"Sorry, address family \" ++ (show family) ++ \" is not supported!\"\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- sendTo/recvFrom\n"
"\n"
"-- Send and recived data from/to the given host and port number.  These\n"
"-- should normally only be used where the socket will not be required for\n"
"-- further calls.\n"
"\n"
"sendTo :: HostName 	-- Hostname\n"
"       -> PortID	-- Port Number\n"
"       -> String	-- Message to send\n"
"       -> IO ()\n"
"sendTo h p msg = do\n"
"  s <- connectTo h p\n"
"  hPutStr s msg\n"
"  hClose s\n"
"\n"
"recvFrom :: HostName 	-- Hostname\n"
"	 -> PortID	-- Port Number\n"
"	 -> IO String	-- Received Data\n"
"recvFrom host port = do\n"
" ip  <- getHostByName host\n"
" let ipHs = hostAddresses ip\n"
" s   <- listenOn port\n"
" let \n"
"  waiting = do\n"
"     ~(s', SockAddrInet _ haddr)  <-  Socket.accept s\n"
"     he <- getHostByAddr AF_INET haddr\n"
"     if not (any (`elem` ipHs) (hostAddresses he))\n"
"      then do\n"
"         sClose s'\n"
"         waiting\n"
"      else do\n"
"	h <- socketToHandle s' ReadMode\n"
"        msg <- hGetContents h\n"
"        return msg\n"
"\n"
" message <- waiting\n"
" return message\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Access function returning the port type/id of socket.\n"
"\n"
"-- | Returns the 'PortID' associated with a given socket.\n"
"socketPort :: Socket -> IO PortID\n"
"socketPort s = do\n"
"    sockaddr <- getSocketName s\n"
"    return (portID sockaddr)\n"
"  where\n"
"   portID sa =\n"
"    case sa of\n"
"     SockAddrInet port _    -> PortNumber port\n"
"     SockAddrUnix path	    -> UnixSocket path\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Utils\n"
"\n"
"-- Like bracket, but only performs the final action if there was an \n"
"-- exception raised by the middle bit.\n"
"bracketOnError\n"
"	:: IO a		-- ^ computation to run first (\\\"acquire resource\\\")\n"
"	-> (a -> IO b)  -- ^ computation to run last (\\\"release resource\\\")\n"
"	-> (a -> IO c)	-- ^ computation to run in-between\n"
"	-> IO c		-- returns the value from the in-between computation\n"
"bracketOnError before after thing =\n"
"  block (do\n"
"    a <- before \n"
"    r <- Exception.catch \n"
"	   (unblock (thing a))\n"
"	   (\\e -> do { after a; throw e })\n"
"    return r\n"
" )\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Extra documentation\n"
"\n"
"{-$buffering\n"
"\n"
"The 'Handle' returned by 'connectTo' and 'accept' is block-buffered by\n"
"default.  For an interactive application you may want to set the\n"
"buffering mode on the 'Handle' to\n"
"'LineBuffering' or 'NoBuffering', like so:\n"
"\n"
"> h <- connectTo host port\n"
"> hSetBuffering h LineBuffering\n"
"-}\n"
"\n"
"{-$performance\n"
"\n"
"For really fast I\\/O, it might be worth looking at the 'hGetBuf' and\n"
"'hPutBuf' family of functions in \"System.IO\".\n"
"-}\n"
"\n"
"{-$sigpipe\n"
"\n"
"On Unix, when reading from a socket and the writing end is\n"
"closed by the remote client, the program is normally sent a\n"
"@SIGPIPE@ signal by the operating system.  The\n"
"default behaviour when a @SIGPIPE@ is received is\n"
"to terminate the program silently, which can be somewhat confusing\n"
"if you haven't encountered this before.  The solution is to\n"
"specify that @SIGPIPE@ is to be ignored, using\n"
"the POSIX library:\n"
"\n"
">  import Posix\n"
">  main = do installHandler sigPIPE Ignore Nothing; ...\n"
"-}\n";
const char *Random = "\n"
"module Random (\n"
"   RandomGen(next, split, genRange),\n"
"   StdGen, mkStdGen,\n"
"   Random( random,   randomR, randoms,  randomRs, randomIO, randomRIO ),\n"
"   getStdRandom, getStdGen, setStdGen, newStdGen\n"
"  ) where\n"
"\n"
"import System.Random\n";
const char *CString = "\n"
"module CString (module Foreign.C.String) where\n"
"import Foreign.C.String\n";
const char *Prelude = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Prelude\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- The Prelude: a standard module imported by default into all Haskell\n"
"-- modules.  For more documentation, see the Haskell 98 Report\n"
"-- <http://www.haskell.org/onlinereport/>.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Prelude (\n"
"\n"
"    -- * Standard types, classes and related functions\n"
"\n"
"    -- ** Basic data types\n"
"    Bool(False, True),\n"
"    (&&), (||), not, otherwise,\n"
"\n"
"    Maybe(Nothing, Just),\n"
"    maybe,\n"
"\n"
"    Either(Left, Right),\n"
"    either,\n"
"\n"
"    Ordering(LT, EQ, GT),\n"
"    Char, String,\n"
"\n"
"    -- *** Tuples\n"
"    fst, snd, curry, uncurry,\n"
"\n"
"    (:),		-- Not legal Haskell 98\n"
"    \n"
"    -- ** Basic type classes\n"
"    Eq((==), (/=)),\n"
"    Ord(compare, (<), (<=), (>=), (>), max, min),\n"
"    Enum(succ, pred, toEnum, fromEnum, enumFrom, enumFromThen,\n"
"         enumFromTo, enumFromThenTo),\n"
"    Bounded(minBound, maxBound),\n"
"\n"
"    -- ** Numbers\n"
"\n"
"    -- *** Numeric types\n"
"    Int, Integer, Float, Double,\n"
"    Rational,\n"
"\n"
"    -- *** Numeric type classes\n"
"    Num((+), (-), (*), negate, abs, signum, fromInteger),\n"
"    Real(toRational),\n"
"    Integral(quot, rem, div, mod, quotRem, divMod, toInteger),\n"
"    Fractional((/), recip, fromRational),\n"
"    Floating(pi, exp, log, sqrt, (**), logBase, sin, cos, tan,\n"
"             asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh),\n"
"    RealFrac(properFraction, truncate, round, ceiling, floor),\n"
"    RealFloat(floatRadix, floatDigits, floatRange, decodeFloat,\n"
"              encodeFloat, exponent, significand, scaleFloat, isNaN,\n"
"              isInfinite, isDenormalized, isIEEE, isNegativeZero, atan2),\n"
"\n"
"    -- *** Numeric functions\n"
"    subtract, even, odd, gcd, lcm, (^), (^^), \n"
"    fromIntegral, realToFrac,\n"
"\n"
"    -- ** Monads and functors\n"
"    Monad((>>=), (>>), return, fail),\n"
"    Functor(fmap),\n"
"    mapM, mapM_, sequence, sequence_, (=<<),\n"
"\n"
"    -- ** Miscellaneous functions\n"
"    id, const, (.), flip, ($), until,\n"
"    asTypeOf, error, undefined,\n"
"    seq, ($!),\n"
"\n"
"    -- * List operations\n"
"    map, (++), filter,\n"
"    head, last, tail, init, null, length, (!!), \n"
"    reverse,\n"
"    -- ** Reducing lists (folds)\n"
"    foldl, foldl1, foldr, foldr1,\n"
"    -- *** Special folds\n"
"    and, or, any, all,\n"
"    sum, product,\n"
"    concat, concatMap,\n"
"    maximum, minimum,\n"
"    -- ** Building lists\n"
"    -- *** Scans\n"
"    scanl, scanl1, scanr, scanr1,\n"
"    -- *** Infinite lists\n"
"    iterate, repeat, replicate, cycle,\n"
"    -- ** Sublists\n"
"    take, drop, splitAt, takeWhile, dropWhile, span, break,\n"
"    -- ** Searching lists\n"
"    elem, notElem, lookup,\n"
"    -- ** Zipping and unzipping lists\n"
"    zip, zip3, zipWith, zipWith3, unzip, unzip3,\n"
"    -- ** Functions on strings\n"
"    lines, words, unlines, unwords,\n"
"\n"
"    -- * Converting to and from @String@\n"
"    ReadS, ShowS,\n"
"    Read(readsPrec, readList),\n"
"    Show(showsPrec, showList, show),\n"
"    reads, shows, read, lex, \n"
"    showChar, showString, readParen, showParen,\n"
"    \n"
"    -- * Basic Input and output\n"
"    IO,\n"
"    -- ** Simple I\\/O operations\n"
"    -- All I/O functions defined here are character oriented.  The\n"
"    -- treatment of the newline character will vary on different systems.\n"
"    -- For example, two characters of input, return and linefeed, may\n"
"    -- read as a single newline character.  These functions cannot be\n"
"    -- used portably for binary I/O.\n"
"    -- *** Output functions\n"
"    putChar,\n"
"    putStr, putStrLn, print,\n"
"    -- *** Input functions\n"
"    getChar,\n"
"    getLine, getContents, interact,\n"
"    -- *** Files\n"
"    FilePath,\n"
"    readFile, writeFile, appendFile, readIO, readLn,\n"
"    -- ** Exception handling in the I\\/O monad\n"
"    IOError, ioError, userError, catch\n"
"\n"
"  ) where\n"
"\n"
"import Hugs.Prelude\n"
"\n";
const char *Foreign = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign\n"
"-- Copyright   :  (c) The FFI task force 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- A collection of data types, classes, and functions for interfacing\n"
"-- with another programming language.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign\n"
"        ( module Data.Bits\n"
"        , module Data.Int\n"
"        , module Data.Word\n"
"	, module Foreign.Ptr\n"
"        , module Foreign.ForeignPtr\n"
"        , module Foreign.StablePtr\n"
"        , module Foreign.Storable\n"
"        , module Foreign.Marshal\n"
"\n"
"        -- For compatibility with the FFI addendum only.  The recommended\n"
"        -- place to get this from is System.IO.Unsafe.\n"
"        , unsafePerformIO\n"
"        ) where\n"
"\n"
"import Data.Bits\n"
"import Data.Int\n"
"import Data.Word\n"
"import Foreign.Ptr\n"
"import Foreign.ForeignPtr\n"
"import Foreign.StablePtr\n"
"import Foreign.Storable\n"
"import Foreign.Marshal\n"
"\n"
"import System.IO.Unsafe (unsafePerformIO)\n";
const char *ForeignPtr = "\n"
"module ForeignPtr (module Foreign.ForeignPtr) where\n"
"import Foreign.ForeignPtr\n";
const char *CForeign = "\n"
"module CForeign ( module Foreign.C ) where\n"
"import Foreign.C\n";
const char *Word = "\n"
"module Word ( module Data.Word ) where\n"
"import Data.Word\n";
const char *List = "\n"
"module List (\n"
"    elemIndex, elemIndices,\n"
"    find, findIndex, findIndices,\n"
"    nub, nubBy, delete, deleteBy, (\\\\), deleteFirstsBy,\n"
"    union, unionBy, intersect, intersectBy,\n"
"    intersperse, transpose, partition, group, groupBy,\n"
"    inits, tails, isPrefixOf, isSuffixOf,\n"
"    mapAccumL, mapAccumR,\n"
"    sort, sortBy, insert, insertBy, maximumBy, minimumBy,\n"
"    genericLength, genericTake, genericDrop,\n"
"    genericSplitAt, genericIndex, genericReplicate,\n"
"    zip4, zip5, zip6, zip7,\n"
"    zipWith4, zipWith5, zipWith6, zipWith7,\n"
"    unzip4, unzip5, unzip6, unzip7, unfoldr,\n"
"\n"
"    -- ...and what the Prelude exports\n"
"    -- []((:), []), -- This is built-in syntax\n"
"    map, (++), concat, filter,\n"
"    head, last, tail, init, null, length, (!!),\n"
"    foldl, foldl1, scanl, scanl1, foldr, foldr1, scanr, scanr1,\n"
"    iterate, repeat, replicate, cycle,\n"
"    take, drop, splitAt, takeWhile, dropWhile, span, break,\n"
"    lines, words, unlines, unwords, reverse, and, or,\n"
"    any, all, elem, notElem, lookup,\n"
"    sum, product, maximum, minimum, concatMap, \n"
"    zip, zip3, zipWith, zipWith3, unzip, unzip3\n"
"  ) where\n"
"\n"
"import Data.List hiding (foldl')\n";
const char *Ix = "\n"
"module Ix (\n"
"    Ix(range, index, inRange), rangeSize\n"
"  ) where\n"
"\n"
"import Data.Ix\n";
const char *Char = "\n"
"module Char (\n"
"    isAscii, isLatin1, isControl, isPrint, isSpace, isUpper, isLower, \n"
"    isAlpha, isDigit, isOctDigit, isHexDigit, isAlphaNum, \n"
"    digitToInt, intToDigit,\n"
"    toUpper, toLower,\n"
"    ord, chr,\n"
"    readLitChar, showLitChar, lexLitChar,\n"
"\n"
"-- ...and what the Prelude exports\n"
"    Char, String\n"
"  ) where\n"
"\n"
"import Data.Char\n";
const char *Complex = "\n"
"module Complex (\n"
"    Complex((:+)), realPart, imagPart, conjugate, \n"
"    mkPolar, cis, polar, magnitude, phase \n"
"  ) where\n"
"\n"
"import Data.Complex\n";
const char *CTypes = "\n"
"module CTypes (module Foreign.C.Types) where\n"
"import Foreign.C.Types\n";
const char *Monad = "\n"
"module Monad (\n"
"    MonadPlus(mzero, mplus),\n"
"    join, guard, when, unless, ap,\n"
"    msum,\n"
"    filterM, mapAndUnzipM, zipWithM, zipWithM_, foldM, \n"
"    liftM, liftM2, liftM3, liftM4, liftM5,\n"
"\n"
"    -- ...and what the Prelude exports\n"
"    Monad((>>=), (>>), return, fail),\n"
"    Functor(fmap),\n"
"    mapM, mapM_, sequence, sequence_, (=<<), \n"
"  ) where\n"
"\n"
"import Control.Monad\n";
const char *MarshalError = "\n"
"module MarshalError (\n"
"  	module Foreign.Marshal.Error,\n"
"	IOErrorType,\n"
"	mkIOError,\n"
"	alreadyExistsErrorType,\n"
"	doesNotExistErrorType,\n"
"	alreadyInUseErrorType,\n"
"	fullErrorType,\n"
"	eofErrorType,\n"
"	illegalOperationErrorType,\n"
"	permissionErrorType,\n"
"	userErrorType,\n"
"	annotateIOError\n"
"  ) where\n"
"\n"
"import System.IO.Error\n"
"import Foreign.Marshal.Error\n";
const char *IO = "\n"
"module IO (\n"
"    Handle, HandlePosn,\n"
"    IOMode(ReadMode,WriteMode,AppendMode,ReadWriteMode),\n"
"    BufferMode(NoBuffering,LineBuffering,BlockBuffering),\n"
"    SeekMode(AbsoluteSeek,RelativeSeek,SeekFromEnd),\n"
"    stdin, stdout, stderr, \n"
"    openFile, hClose, hFileSize, hIsEOF, isEOF,\n"
"    hSetBuffering, hGetBuffering, hFlush, \n"
"    hGetPosn, hSetPosn, hSeek, \n"
"    hWaitForInput, hReady, hGetChar, hGetLine, hLookAhead, hGetContents, \n"
"    hPutChar, hPutStr, hPutStrLn, hPrint,\n"
"    hIsOpen, hIsClosed, hIsReadable, hIsWritable, hIsSeekable,\n"
"    isAlreadyExistsError, isDoesNotExistError, isAlreadyInUseError, \n"
"    isFullError, isEOFError,\n"
"    isIllegalOperation, isPermissionError, isUserError, \n"
"    ioeGetErrorString, ioeGetHandle, ioeGetFileName,\n"
"    try, bracket, bracket_,\n"
"\n"
"    -- ...and what the Prelude exports\n"
"    IO, FilePath, IOError, ioError, userError, catch, interact,\n"
"    putChar, putStr, putStrLn, print, getChar, getLine, getContents,\n"
"    readFile, writeFile, appendFile, readIO, readLn\n"
"  ) where\n"
"\n"
"import System.IO\n"
"\n"
"-- | The 'bracket' function captures a common allocate, compute, deallocate\n"
"-- idiom in which the deallocation step must occur even in the case of an\n"
"-- error during computation. This is similar to try-catch-finally in Java.\n"
"--\n"
"-- This version handles only IO errors, as defined by Haskell 98.\n"
"-- The version of @bracket@ in \"Control.Exception\" handles all exceptions,\n"
"-- and should be used instead.\n"
"\n"
"bracket        :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c\n"
"bracket before after m = do\n"
"        x  <- before\n"
"        rs <- try (m x)\n"
"        after x\n"
"        case rs of\n"
"           Right r -> return r\n"
"           Left  e -> ioError e\n"
"\n"
"-- | A variant of 'bracket' where the middle computation doesn't want @x@.\n"
"--\n"
"-- This version handles only IO errors, as defined by Haskell 98.\n"
"-- The version of @bracket_@ in \"Control.Exception\" handles all exceptions,\n"
"-- and should be used instead.\n"
"\n"
"bracket_        :: IO a -> (a -> IO b) -> IO c -> IO c\n"
"bracket_ before after m = do\n"
"         x  <- before\n"
"         rs <- try m\n"
"         after x\n"
"         case rs of\n"
"            Right r -> return r\n"
"            Left  e -> ioError e\n";
const char *Array = "\n"
"module Array (\n"
"    module Ix,  -- export all of Ix for convenience\n"
"    Array, array, listArray, (!), bounds, indices, elems, assocs, \n"
"    accumArray, (//), accum, ixmap\n"
"  ) where\n"
"\n"
"import Ix\n"
"import Data.Array\n";
const char *MarshalAlloc = "\n"
"module MarshalAlloc (module Foreign.Marshal.Alloc) where\n"
"import Foreign.Marshal.Alloc\n";
const char *CError = "\n"
"module CError (module Foreign.C.Error) where\n"
"import Foreign.C.Error\n";
const char *Directory = "\n"
"module Directory (\n"
"    Permissions( Permissions, readable, writable, executable, searchable ), \n"
"    createDirectory, removeDirectory, removeFile, \n"
"    renameDirectory, renameFile, getDirectoryContents,\n"
"    getCurrentDirectory, setCurrentDirectory,\n"
"    doesFileExist, doesDirectoryExist,\n"
"    getPermissions, setPermissions,\n"
"    getModificationTime \n"
"  ) where\n"
"\n"
"import System.Directory\n";
const char *Bits = "\n"
"module Bits (module Data.Bits) where\n"
"import Data.Bits\n"
"\n";
const char *Int = "\n"
"module Int ( module Data.Int ) where\n"
"import Data.Int\n";
const char *Numeric = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Numeric\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Odds and ends, mostly functions for reading and showing\n"
"-- RealFloat-like kind of values.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Numeric (\n"
"\n"
"        fromRat,          -- :: (RealFloat a) => Rational -> a\n"
"	showSigned,       -- :: (Real a) => (a -> ShowS) -> Int -> a -> ShowS\n"
"	readSigned,       -- :: (Real a) => ReadS a -> ReadS a\n"
"\n"
"	readInt,          -- :: (Integral a) => a -> (Char -> Bool)\n"
"			  --         -> (Char -> Int) -> ReadS a\n"
"	readDec,          -- :: (Integral a) => ReadS a\n"
"	readOct,          -- :: (Integral a) => ReadS a\n"
"	readHex,          -- :: (Integral a) => ReadS a\n"
"\n"
"	showInt,          -- :: Integral a => a -> ShowS\n"
"        showIntAtBase,    -- :: Integral a => a -> (a -> Char) -> a -> ShowS\n"
"        showHex,          -- :: Integral a => a -> ShowS\n"
"        showOct,          -- :: Integral a => a -> ShowS\n"
"\n"
"	showEFloat,       -- :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
"	showFFloat,       -- :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
"	showGFloat,       -- :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
"	showFloat,        -- :: (RealFloat a) => a -> ShowS\n"
"	readFloat,        -- :: (RealFloat a) => ReadS a\n"
"	\n"
"	floatToDigits,    -- :: (RealFloat a) => Integer -> a -> ([Int], Int)\n"
"	lexDigits,        -- :: ReadS String\n"
"\n"
"	) where\n"
"\n"
"import Data.Char\n"
"\n"
"import Hugs.Prelude\n"
"import Hugs.Numeric\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Integer printing functions\n"
"\n"
"showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS\n"
"showIntAtBase base toChr n r\n"
"  | n < 0  = error (\"Numeric.showIntAtBase: applied to negative number \" ++ show n)\n"
"  | otherwise = \n"
"    case quotRem n base of { (n', d) ->\n"
"    let c = toChr (fromIntegral d) in\n"
"    seq c $ -- stricter than necessary\n"
"    let\n"
"	r' = c : r\n"
"    in\n"
"    if n' == 0 then r' else showIntAtBase base toChr n' r'\n"
"    }\n"
"\n"
"showHex, showOct :: Integral a => a -> ShowS\n"
"showHex = showIntAtBase 16 intToDigit\n"
"showOct = showIntAtBase 8  intToDigit\n";
const char *Ptr = "\n"
"module Ptr (module Foreign.Ptr) where\n"
"import Foreign.Ptr\n";
const char *MarshalUtils = "\n"
"module MarshalUtils (module Foreign.Marshal.Utils) where\n"
"import Foreign.Marshal.Utils\n";
const char *MarshalArray = "\n"
"module MarshalArray (module Foreign.Marshal.Array) where\n"
"import Foreign.Marshal.Array\n";
const char *Storable = "\n"
"module Storable (module Foreign.Storable) where\n"
"import Foreign.Storable\n";
const char *Time = "\n"
"module Time (\n"
"    ClockTime, \n"
"    Month(January,February,March,April,May,June,\n"
"          July,August,September,October,November,December),\n"
"    Day(Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday),\n"
"    CalendarTime(CalendarTime, ctYear, ctMonth, ctDay, ctHour, ctMin,\n"
"    		 ctSec, ctPicosec, ctWDay, ctYDay, ctTZName, ctTZ, ctIsDST),\n"
"    TimeDiff(TimeDiff, tdYear, tdMonth, tdDay, tdHour,\n"
" 	     tdMin, tdSec, tdPicosec),\n"
"    getClockTime, addToClockTime, diffClockTimes,\n"
"    toCalendarTime, toUTCTime, toClockTime,\n"
"    calendarTimeToString, formatCalendarTime \n"
"  ) where\n"
"\n"
"import System.Time\n";
const char *Locale = "\n"
"module Locale (\n"
"    TimeLocale(..), defaultTimeLocale\n"
"  ) where\n"
"\n"
"import System.Locale ( \n"
"	-- just the bits that are specified by Haskell 98\n"
"	TimeLocale(TimeLocale,wDays,months,amPm,dateTimeFmt,\n"
"		   dateFmt,timeFmt,time12Fmt),\n"
"        defaultTimeLocale\n"
"    )\n";
const char *StablePtr = "\n"
"module StablePtr (module Foreign.StablePtr) where\n"
"import Foreign.StablePtr\n";
const char *Debug_Trace = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Debug.Trace\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- The 'trace' function.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Debug.Trace (\n"
"	-- * Tracing\n"
"	trace -- :: String -> a -> a\n"
"  ) where\n"
"\n"
"import Prelude\n"
"import System.IO.Unsafe\n"
"import System.IO\n"
"\n"
"{-# NOINLINE trace #-}\n"
"{-|\n"
"When called, 'trace' prints the string in its first argument to\n"
"standard error, before returning the second argument as its result.\n"
"The 'trace' function is not referentially transparent, and should only\n"
"be used for debugging, or for monitoring execution. Some\n"
"implementations of 'trace' may decorate the string that\\'s output to\n"
"indicate that you\\'re tracing.\n"
"-}\n"
"trace :: String -> a -> a\n"
"trace string expr = unsafePerformIO $ do\n"
"    hPutStr stderr string\n"
"    hPutChar stderr '\\n'\n"
"    return expr\n"
"\n";
const char *Debug_QuickCheck = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Debug.QuickCheck\n"
"-- Copyright   :  (c) Koen Claessen, John Hughes 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- QuickCheck v.0.2\n"
"-- DRAFT implementation; last update 000104.\n"
"-- Koen Claessen, John Hughes.\n"
"-- This file represents work in progress, and might change at a later date.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Debug.QuickCheck\n"
"  -- testing functions\n"
"  ( quickCheck    -- :: prop -> IO ()\n"
"  , verboseCheck  -- :: prop -> IO ()\n"
"  , test          -- :: prop -> IO ()  -- = quickCheck\n"
"  \n"
"  , Config(..)    -- :: *\n"
"  , check         -- :: Config -> prop -> IO ()\n"
" \n"
"  -- property combinators\n"
"  , forAll        -- :: Gen a -> (a -> prop) -> prop\n"
"  , (==>)         -- :: Bool -> prop -> prop\n"
"  \n"
"  -- gathering test-case information\n"
"  , label         -- :: String         -> prop -> prop\n"
"  , collect       -- :: Show a => a    -> prop -> prop\n"
"  , classify      -- :: Bool -> String -> prop -> prop\n"
"  , trivial       -- :: Bool           -> prop -> prop\n"
"  \n"
"  -- generator combinators\n"
"  , Gen           -- :: * -> * ; Functor, Monad\n"
"  \n"
"  , elements      -- :: [a] -> Gen a\n"
"  , two           -- :: Gen a -> Gen (a,a)\n"
"  , three         -- :: Gen a -> Gen (a,a,a)\n"
"  , four          -- :: Gen a -> Gen (a,a,a,a)\n"
"  \n"
"  , sized         -- :: (Int -> Gen a) -> Gen a\n"
"  , resize        -- :: Int -> Gen a -> Gen a\n"
"  , choose        -- :: Random a => (a, a) -> Gen a\n"
"  , oneof         -- :: [Gen a] -> Gen a\n"
"  , frequency     -- :: [(Int, Gen a)] -> Gen a\n"
"  \n"
"  , vector        -- :: Arbitrary a => Int -> Gen [a]\n"
"\n"
"  -- default generators\n"
"  , Arbitrary(..) -- :: class\n"
"  , rand          -- :: Gen StdGen\n"
"  , promote       -- :: (a -> Gen b) -> Gen (a -> b)\n"
"  , variant       -- :: Int -> Gen a -> Gen a\n"
"\n"
"  -- testable\n"
"  , Testable(..)  -- :: class\n"
"  , Property      -- :: *\n"
"\n"
"  -- For writing your own driver\n"
"  , Result(..)	 -- :: data\n"
"  , generate	 -- :: Int -> StdGen -> Gen a -> a\n"
"  , evaluate     -- :: Testable a => a -> Gen Result\n"
"  )\n"
" where\n"
"\n"
"import Prelude\n"
"\n"
"import System.Random\n"
"import Data.List( group, sort, intersperse )\n"
"import Control.Monad( liftM2, liftM3, liftM4 )\n"
"\n"
"infixr 0 ==>\n"
"infix  1 `classify`\n"
"\n"
"--------------------------------------------------------------------\n"
"-- Generator\n"
"\n"
"newtype Gen a\n"
"  = Gen (Int -> StdGen -> a)\n"
"\n"
"sized :: (Int -> Gen a) -> Gen a\n"
"sized fgen = Gen (\\n r -> let Gen m = fgen n in m n r)\n"
"\n"
"resize :: Int -> Gen a -> Gen a\n"
"resize n (Gen m) = Gen (\\_ r -> m n r)\n"
"\n"
"rand :: Gen StdGen\n"
"rand = Gen (\\n r -> r)\n"
"\n"
"promote :: (a -> Gen b) -> Gen (a -> b)\n"
"promote f = Gen (\\n r -> \\a -> let Gen m = f a in m n r)\n"
"\n"
"variant :: Int -> Gen a -> Gen a\n"
"variant v (Gen m) = Gen (\\n r -> m n (rands r !! (v+1)))\n"
" where\n"
"  rands r0 = r1 : rands r2 where (r1, r2) = split r0\n"
"\n"
"generate :: Int -> StdGen -> Gen a -> a\n"
"generate n rnd (Gen m) = m size rnd'\n"
" where\n"
"  (size, rnd') = randomR (0, n) rnd\n"
"\n"
"instance Functor Gen where\n"
"  fmap f m = m >>= return . f\n"
"\n"
"instance Monad Gen where\n"
"  return a    = Gen (\\n r -> a)\n"
"  Gen m >>= k =\n"
"    Gen (\\n r0 -> let (r1,r2) = split r0\n"
"                      Gen m'  = k (m n r1)\n"
"                   in m' n r2)\n"
"\n"
"-- derived\n"
"\n"
"choose :: Random a => (a, a) -> Gen a\n"
"choose bounds = (fst . randomR bounds) `fmap` rand\n"
"\n"
"elements :: [a] -> Gen a\n"
"elements xs = (xs !!) `fmap` choose (0, length xs - 1)\n"
"\n"
"vector :: Arbitrary a => Int -> Gen [a]\n"
"vector n = sequence [ arbitrary | i <- [1..n] ]\n"
"\n"
"oneof :: [Gen a] -> Gen a\n"
"oneof gens = elements gens >>= id\n"
"\n"
"frequency :: [(Int, Gen a)] -> Gen a\n"
"frequency xs = choose (1, tot) >>= (`pick` xs)\n"
" where\n"
"  tot = sum (map fst xs)\n"
"\n"
"  pick n ((k,x):xs)\n"
"    | n <= k    = x\n"
"    | otherwise = pick (n-k) xs\n"
"\n"
"-- general monadic\n"
"\n"
"two :: Monad m => m a -> m (a, a)\n"
"two m = liftM2 (,) m m\n"
"\n"
"three :: Monad m => m a -> m (a, a, a)\n"
"three m = liftM3 (,,) m m m\n"
"\n"
"four :: Monad m => m a -> m (a, a, a, a)\n"
"four m = liftM4 (,,,) m m m m\n"
"\n"
"--------------------------------------------------------------------\n"
"-- Arbitrary\n"
"\n"
"class Arbitrary a where\n"
"  arbitrary   :: Gen a\n"
"  coarbitrary :: a -> Gen b -> Gen b\n"
"\n"
"instance Arbitrary () where\n"
"  arbitrary     = return ()\n"
"  coarbitrary _ = variant 0\n"
"\n"
"instance Arbitrary Bool where\n"
"  arbitrary     = elements [True, False]\n"
"  coarbitrary b = if b then variant 0 else variant 1\n"
"\n"
"instance Arbitrary Int where\n"
"  arbitrary     = sized $ \\n -> choose (-n,n)\n"
"  coarbitrary n = variant (if n >= 0 then 2*n else 2*(-n) + 1)\n"
"\n"
"instance Arbitrary Integer where\n"
"  arbitrary     = sized $ \\n -> choose (-fromIntegral n,fromIntegral n)\n"
"  coarbitrary n = variant (fromInteger (if n >= 0 then 2*n else 2*(-n) + 1))\n"
"\n"
"instance Arbitrary Float where\n"
"  arbitrary     = liftM3 fraction arbitrary arbitrary arbitrary \n"
"  coarbitrary x = coarbitrary (decodeFloat x)\n"
"\n"
"instance Arbitrary Double where\n"
"  arbitrary     = liftM3 fraction arbitrary arbitrary arbitrary \n"
"  coarbitrary x = coarbitrary (decodeFloat x)\n"
"\n"
"fraction a b c = fromInteger a + (fromInteger b / (abs (fromInteger c) + 1))\n"
"\n"
"instance (Arbitrary a, Arbitrary b) => Arbitrary (a, b) where\n"
"  arbitrary          = liftM2 (,) arbitrary arbitrary\n"
"  coarbitrary (a, b) = coarbitrary a . coarbitrary b\n"
"\n"
"instance (Arbitrary a, Arbitrary b, Arbitrary c) => Arbitrary (a, b, c) where\n"
"  arbitrary             = liftM3 (,,) arbitrary arbitrary arbitrary\n"
"  coarbitrary (a, b, c) = coarbitrary a . coarbitrary b . coarbitrary c\n"
"\n"
"instance (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d)\n"
"      => Arbitrary (a, b, c, d)\n"
" where\n"
"  arbitrary = liftM4 (,,,) arbitrary arbitrary arbitrary arbitrary\n"
"  coarbitrary (a, b, c, d) =\n"
"    coarbitrary a . coarbitrary b . coarbitrary c . coarbitrary d\n"
"\n"
"instance Arbitrary a => Arbitrary [a] where\n"
"  arbitrary          = sized (\\n -> choose (0,n) >>= vector)\n"
"  coarbitrary []     = variant 0\n"
"  coarbitrary (a:as) = coarbitrary a . variant 1 . coarbitrary as\n"
"\n"
"instance (Arbitrary a, Arbitrary b) => Arbitrary (a -> b) where\n"
"  arbitrary         = promote (`coarbitrary` arbitrary)\n"
"  coarbitrary f gen = arbitrary >>= ((`coarbitrary` gen) . f)\n"
"\n"
"--------------------------------------------------------------------\n"
"-- Testable\n"
"\n"
"data Result\n"
"  = Result { ok :: Maybe Bool, stamp :: [String], arguments :: [String] }\n"
"\n"
"nothing :: Result\n"
"nothing = Result{ ok = Nothing, stamp = [], arguments = [] }\n"
"\n"
"newtype Property\n"
"  = Prop (Gen Result)\n"
"\n"
"result :: Result -> Property\n"
"result res = Prop (return res)\n"
"\n"
"evaluate :: Testable a => a -> Gen Result\n"
"evaluate a = gen where Prop gen = property a\n"
"\n"
"class Testable a where\n"
"  property :: a -> Property\n"
"\n"
"instance Testable () where\n"
"  property _ = result nothing\n"
"\n"
"instance Testable Bool where\n"
"  property b = result (nothing{ ok = Just b })\n"
"\n"
"instance Testable Result where\n"
"  property res = result res\n"
"\n"
"instance Testable Property where\n"
"  property prop = prop\n"
"\n"
"instance (Arbitrary a, Show a, Testable b) => Testable (a -> b) where\n"
"  property f = forAll arbitrary f\n"
"\n"
"forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property\n"
"forAll gen body = Prop $\n"
"  do a   <- gen\n"
"     res <- evaluate (body a)\n"
"     return (argument a res)\n"
" where\n"
"  argument a res = res{ arguments = show a : arguments res }\n"
"\n"
"(==>) :: Testable a => Bool -> a -> Property\n"
"True  ==> a = property a\n"
"False ==> a = property ()\n"
"\n"
"label :: Testable a => String -> a -> Property\n"
"label s a = Prop (add `fmap` evaluate a)\n"
" where\n"
"  add res = res{ stamp = s : stamp res }\n"
"\n"
"classify :: Testable a => Bool -> String -> a -> Property\n"
"classify True  name = label name\n"
"classify False _    = property\n"
"\n"
"trivial :: Testable a => Bool -> a -> Property\n"
"trivial = (`classify` \"trivial\")\n"
"\n"
"collect :: (Show a, Testable b) => a -> b -> Property\n"
"collect v = label (show v)\n"
"\n"
"--------------------------------------------------------------------\n"
"-- Testing\n"
"\n"
"data Config = Config\n"
"  { configMaxTest :: Int\n"
"  , configMaxFail :: Int\n"
"  , configSize    :: Int -> Int\n"
"  , configEvery   :: Int -> [String] -> String\n"
"  }\n"
"\n"
"quick :: Config\n"
"quick = Config\n"
"  { configMaxTest = 100\n"
"  , configMaxFail = 1000\n"
"  , configSize    = (+ 3) . (`div` 2)\n"
"  , configEvery   = \\n args -> let s = show n in s ++ [ '\\b' | _ <- s ]\n"
"  }\n"
"         \n"
"verbose :: Config\n"
"verbose = quick\n"
"  { configEvery = \\n args -> show n ++ \":\\n\" ++ unlines args\n"
"  }\n"
"\n"
"test, quickCheck, verboseCheck :: Testable a => a -> IO ()\n"
"test         = check quick\n"
"quickCheck   = check quick\n"
"verboseCheck = check verbose\n"
"         \n"
"check :: Testable a => Config -> a -> IO ()\n"
"check config a =\n"
"  do rnd <- newStdGen\n"
"     tests config (evaluate a) rnd 0 0 []\n"
"\n"
"tests :: Config -> Gen Result -> StdGen -> Int -> Int -> [[String]] -> IO () \n"
"tests config gen rnd0 ntest nfail stamps\n"
"  | ntest == configMaxTest config = do done \"OK, passed\" ntest stamps\n"
"  | nfail == configMaxFail config = do done \"Arguments exhausted after\" ntest stamps\n"
"  | otherwise               =\n"
"      do putStr (configEvery config ntest (arguments result))\n"
"         case ok result of\n"
"           Nothing    ->\n"
"             tests config gen rnd1 ntest (nfail+1) stamps\n"
"           Just True  ->\n"
"             tests config gen rnd1 (ntest+1) nfail (stamp result:stamps)\n"
"           Just False ->\n"
"             putStr ( \"Falsifiable, after \"\n"
"                   ++ show ntest\n"
"                   ++ \" tests:\\n\"\n"
"                   ++ unlines (arguments result)\n"
"                    )\n"
"     where\n"
"      result      = generate (configSize config ntest) rnd2 gen\n"
"      (rnd1,rnd2) = split rnd0\n"
"\n"
"done :: String -> Int -> [[String]] -> IO ()\n"
"done mesg ntest stamps =\n"
"  do putStr ( mesg ++ \" \" ++ show ntest ++ \" tests\" ++ table )\n"
" where\n"
"  table = display\n"
"        . map entry\n"
"        . reverse\n"
"        . sort\n"
"        . map pairLength\n"
"        . group\n"
"        . sort\n"
"        . filter (not . null)\n"
"        $ stamps\n"
"\n"
"  display []  = \".\\n\"\n"
"  display [x] = \" (\" ++ x ++ \").\\n\"\n"
"  display xs  = \".\\n\" ++ unlines (map (++ \".\") xs)\n"
"\n"
"  pairLength xss@(xs:_) = (length xss, xs)\n"
"  entry (n, xs)         = percentage n ntest\n"
"                       ++ \" \"\n"
"                       ++ concat (intersperse \", \" xs)\n"
"\n"
"  percentage n m        = show ((100 * n) `div` m) ++ \"%\"\n"
"\n"
"--------------------------------------------------------------------\n"
"-- the end.\n";
const char *Debug_QuickCheck_Utils = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Debug.QuickCheck.Utils\n"
"-- Copyright   :  (c) Andy Gill 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- These are some general purpose utilities for use with QuickCheck.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Debug.QuickCheck.Utils\n"
"  ( isAssociativeBy\n"
"  , isAssociative\n"
"  , isCommutableBy\n"
"  , isCommutable\n"
"  , isTotalOrder\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Debug.QuickCheck\n"
"\n"
"isAssociativeBy :: (Show a,Testable prop) \n"
"		=> (a -> a -> prop) -> Gen a -> (a -> a -> a) -> Property\n"
"isAssociativeBy (===) src (**) = \n"
"     	forAll src $ \\ a ->\n"
"     	forAll src $ \\ b ->\n"
"     	forAll src $ \\ c ->\n"
"	((a ** b) ** c) === (a ** (b ** c))\n"
"\n"
"isAssociative :: (Arbitrary a,Show a,Eq a) => (a -> a -> a) -> Property\n"
"isAssociative = isAssociativeBy (==) arbitrary\n"
"\n"
"isCommutableBy :: (Show a,Testable prop) \n"
"	       => (b -> b -> prop) -> Gen a -> (a -> a -> b) -> Property\n"
"isCommutableBy (===) src (**) =\n"
"	forAll src $ \\ a ->\n"
"	forAll src $ \\ b ->\n"
"	(a ** b) === (b ** a)\n"
"\n"
"isCommutable :: (Arbitrary a,Show a,Eq b) => (a -> a -> b) -> Property\n"
"isCommutable = isCommutableBy (==) arbitrary\n"
"\n"
"isTotalOrder :: (Arbitrary a,Show a,Ord a) => a -> a -> Property\n"
"isTotalOrder x y = \n"
"    classify (x > y)  \"less than\" $\n"
"    classify (x == y) \"equals\" $\n"
"    classify (x < y)  \"greater than\" $\n"
"    x < y || x == y || x > y\n";
const char *Debug_QuickCheck_Poly = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Debug.QuickCheck.Poly\n"
"-- Copyright   :  (c) Andy Gill 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (uses Control.Exception, Control.Concurrent)\n"
"--\n"
"-- This is an attempt to emulate polymorphic types for the \n"
"-- purposes of testing by using abstract monomorphic types.\n"
"-- \n"
"-- It is likely that future versions of QuickCheck will\n"
"-- include some polymorphic emulation testing facility,\n"
"-- but this module can be used for now.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Debug.QuickCheck.Poly\n"
"  ( ALPHA\n"
"  , BETA\n"
"  , GAMMA\n"
"  , OrdALPHA\n"
"  , OrdBETA\n"
"  , OrdGAMMA\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Debug.QuickCheck\n"
"import Debug.QuickCheck.Utils\n"
"\n"
"{- This is the basic pseudo-polymorphic object.\n"
" - The idea is you can't cheat, and use the integer\n"
" - directly, but need to use the abstraction.\n"
" - \n"
" - We use phantom types (ref: Domain Specific Embedded Compilers,\n"
" - Daan Leijen & Erik Meijer, 2nd Conference of Domain Specific\n"
" - Languages, Austin, TX, 1999)\n"
" -}\n"
"\n"
"newtype Poly a = Poly Int\n"
"\n"
"instance Show (Poly a) where\n"
"        show (Poly a) = \"_\" ++ show a\n"
"\n"
"instance Arbitrary (Poly a) where\n"
"    arbitrary            = sized $ \\n -> (choose (1,n) >>= return . Poly)\n"
"    coarbitrary (Poly n) = variant (if n >= 0 then 2*n else 2*(-n) + 1)\n"
"\n"
"instance Eq a => Eq (Poly a) where\n"
"        (Poly a) == (Poly b) = a == b\n"
"\n"
"instance Ord a => Ord (Poly a) where\n"
"        (Poly a) `compare` (Poly b) = a `compare` b\n"
"\n"
"{-\n"
" - These are what we export, our pseudo-polymorphic instances.\n"
" -}\n"
"\n"
"type ALPHA = Poly ALPHA_\n"
"data ALPHA_ = ALPHA_ deriving (Eq)\n"
"\n"
"type BETA = Poly BETA_\n"
"data BETA_ = BETA_ deriving (Eq)\n"
"\n"
"type GAMMA = Poly GAMMA_\n"
"data GAMMA_ = GAMMA_ deriving (Eq)\n"
"\n"
"type OrdALPHA = Poly OrdALPHA_\n"
"data OrdALPHA_ = OrdALPHA_ deriving (Eq,Ord)\n"
"\n"
"type OrdBETA = Poly OrdBETA_\n"
"data OrdBETA_ = OrdBETA_ deriving (Eq,Ord)\n"
"\n"
"type OrdGAMMA = Poly OrdGAMMA_\n"
"data OrdGAMMA_ = OrdGAMMA_ deriving (Eq,Ord)\n"
"\n"
"{-\n"
" - This is a condition on OrdALPHA, OrdBETA, etc, itself.\n"
" - It states that all OrdALPHA objects obey total ordering.\n"
" -}\n"
"\n"
"prop_OrdPOLY x y = isTotalOrder x y\n"
"    where types = (x :: OrdALPHA, y :: OrdALPHA)\n";
const char *Language_Haskell_Syntax = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Language.Haskell.Syntax\n"
"-- Copyright   :  (c) The GHC Team, 1997-2000\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- A suite of datatypes describing the abstract syntax of Haskell 98\n"
"-- <http://www.haskell.org/onlinereport/> plus a few extensions:\n"
"--\n"
"--   * multi-parameter type classes\n"
"--\n"
"--   * parameters of type class assertions are unrestricted\n"
"-- \n"
"-- This module has been changed so that show is a real show.\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Language.Haskell.Syntax (\n"
"    -- * Modules\n"
"    HsModule(..), HsExportSpec(..),\n"
"    HsImportDecl(..), HsImportSpec(..), HsAssoc(..),\n"
"    -- * Declarations\n"
"    HsDecl(..), HsConDecl(..), HsBangType(..),\n"
"    HsMatch(..), HsRhs(..), HsGuardedRhs(..),\n"
"    -- * Class Assertions and Contexts\n"
"    HsQualType(..), HsContext, HsAsst,\n"
"    -- * Types\n"
"    HsType(..),\n"
"    -- * Expressions\n"
"    HsExp(..), HsStmt(..), HsFieldUpdate(..),\n"
"    HsAlt(..), HsGuardedAlts(..), HsGuardedAlt(..),\n"
"    -- * Patterns\n"
"    HsPat(..), HsPatField(..),\n"
"    -- * Literals\n"
"    HsLiteral(..),\n"
"    -- * Variables, Constructors and Operators\n"
"    Module(..), HsQName(..), HsName(..), HsQOp(..), HsOp(..),\n"
"    HsSpecialCon(..), HsCName(..),\n"
"\n"
"    -- * Builtin names\n"
"\n"
"    -- ** Modules\n"
"    prelude_mod, main_mod,\n"
"    -- ** Main function of a program\n"
"    main_name,\n"
"    -- ** Constructors\n"
"    unit_con_name, tuple_con_name, list_cons_name,\n"
"    unit_con, tuple_con,\n"
"    -- ** Special identifiers\n"
"    as_name, qualified_name, hiding_name, minus_name, pling_name,\n"
"    -- ** Type constructors\n"
"    unit_tycon_name, fun_tycon_name, list_tycon_name, tuple_tycon_name,\n"
"    unit_tycon, fun_tycon, list_tycon, tuple_tycon,\n"
"\n"
"    -- * Source coordinates\n"
"    SrcLoc(..),\n"
"  ) where\n"
"\n"
"-- | A position in the source.\n"
"data SrcLoc = SrcLoc {\n"
"		srcFilename :: String,\n"
"		srcLine :: Int,\n"
"		srcColumn :: Int\n"
"		}\n"
"  deriving (Eq,Ord,Show)\n"
"\n"
"newtype Module = Module String\n"
"  deriving (Eq,Ord,Show)\n"
"\n"
"-- | Constructors with special syntax.\n"
"-- These names are never qualified, and always refer to builtin type or\n"
"-- data constructors.\n"
"\n"
"data HsSpecialCon\n"
"	= HsUnitCon		-- ^ Unit type and data constructor @()@\n"
"	| HsListCon		-- ^ List type constructor @[]@\n"
"	| HsFunCon		-- ^ Function type constructor @->@\n"
"	| HsTupleCon Int	-- ^ /n/-ary tuple type and data\n"
"				--   constructors @(,)@ etc\n"
"	| HsCons		-- ^ list data constructor @(:)@\n"
"  deriving (Eq,Ord,Show)\n"
"\n"
"-- | This type is used to represent qualified variables, and also\n"
"-- qualified constructors.\n"
"data HsQName\n"
"	= Qual Module HsName\n"
"	| UnQual HsName\n"
"	| Special HsSpecialCon\n"
"  deriving (Eq,Ord,Show)\n"
"\n"
"-- | This type is used to represent variables, and also constructors.\n"
"data HsName\n"
"	= HsIdent String	-- ^ /varid/ or /conid/.\n"
"	| HsSymbol String	-- ^ /varsym/ or /consym/\n"
"  deriving (Eq,Ord,Show)\n"
"\n"
"-- | Possibly qualified infix operators (/qop/), appearing in expressions.\n"
"data HsQOp\n"
"	= HsQVarOp HsQName\n"
"	| HsQConOp HsQName\n"
"  deriving (Eq,Ord,Show)\n"
"\n"
"-- | Operators, appearing in @infix@ declarations.\n"
"data HsOp\n"
"	= HsVarOp HsName\n"
"	| HsConOp HsName\n"
"  deriving (Eq,Ord,Show)\n"
"\n"
"data HsCName\n"
"	= HsVarName HsName\n"
"	| HsConName HsName\n"
"  deriving (Eq,Ord,Show)\n"
"\n"
"data HsModule = HsModule SrcLoc Module (Maybe [HsExportSpec])\n"
"                         [HsImportDecl] [HsDecl]\n"
"  deriving Show\n"
"\n"
"-- | Export specification.\n"
"data HsExportSpec\n"
"	 = HsEVar HsQName			-- ^ variable\n"
"	 | HsEAbs HsQName			-- ^ @T@:\n"
"			-- a class or datatype exported abstractly,\n"
"			-- or a type synonym.\n"
"	 | HsEThingAll HsQName			-- ^ @T(..)@:\n"
"			-- a class exported with all of its methods, or\n"
"			-- a datatype exported with all of its constructors.\n"
"	 | HsEThingWith HsQName [HsCName]	-- ^ @T(C_1,...,C_n)@:\n"
"			-- a class exported with some of its methods, or\n"
"			-- a datatype exported with some of its constructors.\n"
"	 | HsEModuleContents Module		-- ^ @module M@:\n"
"			-- re-export a module.\n"
"  deriving (Eq,Show)\n"
"\n"
"-- | Import declaration.\n"
"data HsImportDecl\n"
"	 = HsImportDecl SrcLoc Module Bool (Maybe Module)\n"
"	                (Maybe (Bool,[HsImportSpec]))\n"
"  deriving (Eq,Show)\n"
"\n"
"-- | Import specification.\n"
"data HsImportSpec\n"
"	 = HsIVar HsName			-- ^ variable\n"
"	 | HsIAbs HsName			-- ^ @T@:\n"
"			-- the name of a class, datatype or type synonym.\n"
"	 | HsIThingAll HsName			-- ^ @T(..)@:\n"
"			-- a class imported with all of its methods, or\n"
"			-- a datatype imported with all of its constructors.\n"
"	 | HsIThingWith HsName [HsCName]	-- ^ @T(C_1,...,C_n)@:\n"
"			-- a class imported with some of its methods, or\n"
"			-- a datatype imported with some of its constructors.\n"
"  deriving (Eq,Show)\n"
"\n"
"data HsAssoc\n"
"	 = HsAssocNone\n"
"	 | HsAssocLeft\n"
"	 | HsAssocRight\n"
"  deriving (Eq,Show)\n"
"\n"
"data HsDecl\n"
"	 = HsTypeDecl	 SrcLoc HsName [HsName] HsType\n"
"	 | HsDataDecl	 SrcLoc HsContext HsName [HsName] [HsConDecl] [HsQName]\n"
"	 | HsInfixDecl   SrcLoc HsAssoc Int [HsOp]\n"
"	 | HsNewTypeDecl SrcLoc HsContext HsName [HsName] HsConDecl [HsQName]\n"
"	 | HsClassDecl	 SrcLoc HsContext HsName [HsName] [HsDecl]\n"
"	 | HsInstDecl	 SrcLoc HsContext HsQName [HsType] [HsDecl]\n"
"	 | HsDefaultDecl SrcLoc [HsType]\n"
"	 | HsTypeSig	 SrcLoc [HsName] HsQualType\n"
"	 | HsFunBind     [HsMatch]\n"
"	 | HsPatBind	 SrcLoc HsPat HsRhs {-where-} [HsDecl]\n"
"  deriving (Eq,Show)\n"
"\n"
"data HsMatch\n"
"	 = HsMatch SrcLoc HsName [HsPat] HsRhs {-where-} [HsDecl]\n"
"  deriving (Eq,Show)\n"
"\n"
"data HsConDecl\n"
"	 = HsConDecl SrcLoc HsName [HsBangType]\n"
"	 | HsRecDecl SrcLoc HsName [([HsName],HsBangType)]\n"
"  deriving (Eq,Show)\n"
"\n"
"data HsBangType\n"
"	 = HsBangedTy   HsType\n"
"	 | HsUnBangedTy HsType\n"
"  deriving (Eq,Show)\n"
"\n"
"data HsRhs\n"
"	 = HsUnGuardedRhs HsExp\n"
"	 | HsGuardedRhss  [HsGuardedRhs]\n"
"  deriving (Eq,Show)\n"
"\n"
"data HsGuardedRhs\n"
"	 = HsGuardedRhs SrcLoc HsExp HsExp\n"
"  deriving (Eq,Show)\n"
"\n"
"-- | A type qualified with a context.\n"
"--   An unqualified type has an empty context.\n"
"data HsQualType\n"
"	 = HsQualType HsContext HsType\n"
"  deriving (Eq,Show)\n"
"\n"
"data HsType\n"
"	 = HsTyFun   HsType HsType\n"
"	 | HsTyTuple [HsType]\n"
"	 | HsTyApp   HsType HsType\n"
"	 | HsTyVar   HsName\n"
"	 | HsTyCon   HsQName\n"
"  deriving (Eq,Show)\n"
"\n"
"type HsContext = [HsAsst]\n"
"\n"
"-- | Class assertions.\n"
"--   In Haskell 98, the argument would be a /tyvar/, but this definition\n"
"--   allows multiple parameters, and allows them to be /type/s.\n"
"type HsAsst    = (HsQName,[HsType])\n"
"\n"
"-- | /literal/\n"
"data HsLiteral\n"
"	= HsInt		Integer\n"
"	| HsChar	Char\n"
"	| HsString	String\n"
"	| HsFrac	Rational\n"
"	| HsCharPrim	Char		-- ^ GHC unboxed character literal\n"
"	| HsStringPrim	String		-- ^ GHC unboxed string literal\n"
"	| HsIntPrim	Integer		-- ^ GHC unboxed integer literal\n"
"	| HsFloatPrim	Rational	-- ^ GHC unboxed float literal\n"
"	| HsDoublePrim	Rational	-- ^ GHC unboxed double literal\n"
"  deriving (Eq,Show)\n"
"\n"
"-- | Haskell expressions.\n"
"-- Because it is difficult for parsers to distinguish patterns from\n"
"-- expressions, they typically parse them in the same way and then check\n"
"-- that they have the appropriate form.  Hence the expression type\n"
"-- includes some forms that are found only in patterns.  After these\n"
"-- checks, these constructors should not be used.\n"
"\n"
"data HsExp\n"
"	= HsVar HsQName\n"
"	| HsCon HsQName\n"
"	| HsLit HsLiteral\n"
"	| HsInfixApp HsExp HsQOp HsExp\n"
"	| HsApp HsExp HsExp\n"
"	| HsNegApp HsExp\n"
"	| HsLambda SrcLoc [HsPat] HsExp\n"
"	| HsLet [HsDecl] HsExp\n"
"	| HsIf HsExp HsExp HsExp\n"
"	| HsCase HsExp [HsAlt]\n"
"	| HsDo [HsStmt]			-- ^ Do expression:\n"
"					-- The last statement in the list\n"
"					-- should be an expression.\n"
"	| HsTuple [HsExp]\n"
"	| HsList [HsExp]\n"
"	| HsParen HsExp\n"
"	| HsLeftSection HsExp HsQOp\n"
"	| HsRightSection HsQOp HsExp\n"
"	| HsRecConstr HsQName [HsFieldUpdate]\n"
"	| HsRecUpdate HsExp [HsFieldUpdate]\n"
"	| HsEnumFrom HsExp\n"
"	| HsEnumFromTo HsExp HsExp\n"
"	| HsEnumFromThen HsExp HsExp\n"
"	| HsEnumFromThenTo HsExp HsExp HsExp\n"
"	| HsListComp HsExp [HsStmt]\n"
"	| HsExpTypeSig SrcLoc HsExp HsQualType\n"
"	| HsAsPat HsName HsExp		-- ^ patterns only\n"
"	| HsWildCard			-- ^ patterns only\n"
"	| HsIrrPat HsExp		-- ^ patterns only\n"
" deriving (Eq,Show)\n"
"\n"
"data HsPat\n"
"	= HsPVar HsName\n"
"	| HsPLit HsLiteral\n"
"	| HsPNeg HsPat\n"
"	| HsPInfixApp HsPat HsQName HsPat\n"
"	| HsPApp HsQName [HsPat]\n"
"	| HsPTuple [HsPat]\n"
"	| HsPList [HsPat]\n"
"	| HsPParen HsPat\n"
"	| HsPRec HsQName [HsPatField]\n"
"	| HsPAsPat HsName HsPat\n"
"	| HsPWildCard\n"
"	| HsPIrrPat HsPat\n"
" deriving (Eq,Show)\n"
"\n"
"data HsPatField\n"
"	= HsPFieldPat HsQName HsPat\n"
" deriving (Eq,Show)\n"
"\n"
"-- | This type represents both /stmt/ in a @do@-expression,\n"
"--   and /qual/ in a list comprehension.\n"
"data HsStmt\n"
"	= HsGenerator SrcLoc HsPat HsExp\n"
"	| HsQualifier HsExp\n"
"	| HsLetStmt [HsDecl]\n"
" deriving (Eq,Show)\n"
"\n"
"-- | An /fbind/ in a labeled construction or update.\n"
"data HsFieldUpdate\n"
"	= HsFieldUpdate HsQName HsExp\n"
"  deriving (Eq,Show)\n"
"\n"
"data HsAlt\n"
"	= HsAlt SrcLoc HsPat HsGuardedAlts [HsDecl]\n"
"  deriving (Eq,Show)\n"
"\n"
"data HsGuardedAlts\n"
"	= HsUnGuardedAlt HsExp\n"
"	| HsGuardedAlts  [HsGuardedAlt]\n"
"  deriving (Eq,Show)\n"
"\n"
"data HsGuardedAlt\n"
"	= HsGuardedAlt SrcLoc HsExp HsExp\n"
"  deriving (Eq,Show)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Builtin names.\n"
"\n"
"prelude_mod, main_mod :: Module\n"
"prelude_mod	      = Module \"Prelude\"\n"
"main_mod	      = Module \"Main\"\n"
"\n"
"main_name :: HsName\n"
"main_name	      = HsIdent \"main\"\n"
"\n"
"unit_con_name :: HsQName\n"
"unit_con_name	      = Special HsUnitCon\n"
"\n"
"tuple_con_name :: Int -> HsQName\n"
"tuple_con_name i      = Special (HsTupleCon (i+1))\n"
"\n"
"list_cons_name :: HsQName\n"
"list_cons_name	      = Special HsCons\n"
"\n"
"unit_con :: HsExp\n"
"unit_con	      = HsCon unit_con_name\n"
"\n"
"tuple_con :: Int -> HsExp\n"
"tuple_con i	      = HsCon (tuple_con_name i)\n"
"\n"
"as_name, qualified_name, hiding_name, minus_name, pling_name :: HsName\n"
"as_name	              = HsIdent \"as\"\n"
"qualified_name        = HsIdent \"qualified\"\n"
"hiding_name	      = HsIdent \"hiding\"\n"
"minus_name	      = HsSymbol \"-\"\n"
"pling_name	      = HsSymbol \"!\"\n"
"\n"
"unit_tycon_name, fun_tycon_name, list_tycon_name :: HsQName\n"
"unit_tycon_name       = unit_con_name\n"
"fun_tycon_name        = Special HsFunCon\n"
"list_tycon_name       = Special HsListCon\n"
"\n"
"tuple_tycon_name :: Int -> HsQName\n"
"tuple_tycon_name i    = tuple_con_name i\n"
"\n"
"unit_tycon, fun_tycon, list_tycon :: HsType\n"
"unit_tycon	      = HsTyCon unit_tycon_name\n"
"fun_tycon	      = HsTyCon fun_tycon_name\n"
"list_tycon	      = HsTyCon list_tycon_name\n"
"\n"
"tuple_tycon :: Int -> HsType\n"
"tuple_tycon i	      = HsTyCon (tuple_tycon_name i)\n";
const char *Language_Haskell_Parser = "\n"
"-- parser produced by Happy Version 1.13\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Language.Haskell.Parser\n"
"-- Copyright   :  (c) Simon Marlow, Sven Panne 1997-2000\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"--\n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- Haskell parser.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"module Language.Haskell.Parser (\n"
"		parseModule, parseModuleWithMode,\n"
"		ParseMode(..), defaultParseMode, ParseResult(..)) where\n"
"\n"
"import Language.Haskell.Syntax\n"
"import Language.Haskell.ParseMonad\n"
"import Language.Haskell.Lexer\n"
"import Language.Haskell.ParseUtils\n"
"\n"
"data HappyAbsSyn \n"
"	= HappyTerminal Token\n"
"	| HappyErrorToken Int\n"
"	| HappyAbsSyn4 (HsModule)\n"
"	| HappyAbsSyn5 (([HsImportDecl],[HsDecl]))\n"
"	| HappyAbsSyn7 (())\n"
"	| HappyAbsSyn9 (Maybe [HsExportSpec])\n"
"	| HappyAbsSyn10 ([HsExportSpec])\n"
"	| HappyAbsSyn13 (HsExportSpec)\n"
"	| HappyAbsSyn14 ([HsImportDecl])\n"
"	| HappyAbsSyn15 (HsImportDecl)\n"
"	| HappyAbsSyn16 (Bool)\n"
"	| HappyAbsSyn17 (Maybe Module)\n"
"	| HappyAbsSyn18 (Maybe (Bool, [HsImportSpec]))\n"
"	| HappyAbsSyn19 ((Bool, [HsImportSpec]))\n"
"	| HappyAbsSyn21 ([HsImportSpec])\n"
"	| HappyAbsSyn22 (HsImportSpec)\n"
"	| HappyAbsSyn23 ([HsCName])\n"
"	| HappyAbsSyn24 (HsCName)\n"
"	| HappyAbsSyn25 (HsDecl)\n"
"	| HappyAbsSyn26 (Int)\n"
"	| HappyAbsSyn27 (HsAssoc)\n"
"	| HappyAbsSyn28 ([HsOp])\n"
"	| HappyAbsSyn29 ([HsDecl])\n"
"	| HappyAbsSyn32 ([HsType])\n"
"	| HappyAbsSyn38 ([HsName])\n"
"	| HappyAbsSyn39 (HsType)\n"
"	| HappyAbsSyn42 (HsQName)\n"
"	| HappyAbsSyn43 (HsQualType)\n"
"	| HappyAbsSyn44 (HsContext)\n"
"	| HappyAbsSyn46 ((HsName, [HsName]))\n"
"	| HappyAbsSyn48 ([HsConDecl])\n"
"	| HappyAbsSyn49 (HsConDecl)\n"
"	| HappyAbsSyn50 ((HsName, [HsBangType]))\n"
"	| HappyAbsSyn52 (HsBangType)\n"
"	| HappyAbsSyn54 ([([HsName],HsBangType)])\n"
"	| HappyAbsSyn55 (([HsName],HsBangType))\n"
"	| HappyAbsSyn57 ([HsQName])\n"
"	| HappyAbsSyn65 (HsRhs)\n"
"	| HappyAbsSyn66 ([HsGuardedRhs])\n"
"	| HappyAbsSyn67 (HsGuardedRhs)\n"
"	| HappyAbsSyn68 (HsExp)\n"
"	| HappyAbsSyn75 ([HsPat])\n"
"	| HappyAbsSyn76 (HsPat)\n"
"	| HappyAbsSyn81 ([HsExp])\n"
"	| HappyAbsSyn84 ([HsStmt])\n"
"	| HappyAbsSyn85 (HsStmt)\n"
"	| HappyAbsSyn86 ([HsAlt])\n"
"	| HappyAbsSyn89 (HsAlt)\n"
"	| HappyAbsSyn90 (HsGuardedAlts)\n"
"	| HappyAbsSyn91 ([HsGuardedAlt])\n"
"	| HappyAbsSyn92 (HsGuardedAlt)\n"
"	| HappyAbsSyn96 ([HsFieldUpdate])\n"
"	| HappyAbsSyn97 (HsFieldUpdate)\n"
"	| HappyAbsSyn99 (HsName)\n"
"	| HappyAbsSyn108 (HsOp)\n"
"	| HappyAbsSyn109 (HsQOp)\n"
"	| HappyAbsSyn123 (HsLiteral)\n"
"	| HappyAbsSyn124 (SrcLoc)\n"
"	| HappyAbsSyn127 (Module)\n"
"\n"
"type HappyReduction = \n"
"	   Int \n"
"	-> (Token)\n"
"	-> HappyState (Token) (HappyStk HappyAbsSyn -> P(HappyAbsSyn))\n"
"	-> [HappyState (Token) (HappyStk HappyAbsSyn -> P(HappyAbsSyn))] \n"
"	-> HappyStk HappyAbsSyn \n"
"	-> P(HappyAbsSyn)\n"
"\n"
"action_0,\n"
" action_1,\n"
" action_2,\n"
" action_3,\n"
" action_4,\n"
" action_5,\n"
" action_6,\n"
" action_7,\n"
" action_8,\n"
" action_9,\n"
" action_10,\n"
" action_11,\n"
" action_12,\n"
" action_13,\n"
" action_14,\n"
" action_15,\n"
" action_16,\n"
" action_17,\n"
" action_18,\n"
" action_19,\n"
" action_20,\n"
" action_21,\n"
" action_22,\n"
" action_23,\n"
" action_24,\n"
" action_25,\n"
" action_26,\n"
" action_27,\n"
" action_28,\n"
" action_29,\n"
" action_30,\n"
" action_31,\n"
" action_32,\n"
" action_33,\n"
" action_34,\n"
" action_35,\n"
" action_36,\n"
" action_37,\n"
" action_38,\n"
" action_39,\n"
" action_40,\n"
" action_41,\n"
" action_42,\n"
" action_43,\n"
" action_44,\n"
" action_45,\n"
" action_46,\n"
" action_47,\n"
" action_48,\n"
" action_49,\n"
" action_50,\n"
" action_51,\n"
" action_52,\n"
" action_53,\n"
" action_54,\n"
" action_55,\n"
" action_56,\n"
" action_57,\n"
" action_58,\n"
" action_59,\n"
" action_60,\n"
" action_61,\n"
" action_62,\n"
" action_63,\n"
" action_64,\n"
" action_65,\n"
" action_66,\n"
" action_67,\n"
" action_68,\n"
" action_69,\n"
" action_70,\n"
" action_71,\n"
" action_72,\n"
" action_73,\n"
" action_74,\n"
" action_75,\n"
" action_76,\n"
" action_77,\n"
" action_78,\n"
" action_79,\n"
" action_80,\n"
" action_81,\n"
" action_82,\n"
" action_83,\n"
" action_84,\n"
" action_85,\n"
" action_86,\n"
" action_87,\n"
" action_88,\n"
" action_89,\n"
" action_90,\n"
" action_91,\n"
" action_92,\n"
" action_93,\n"
" action_94,\n"
" action_95,\n"
" action_96,\n"
" action_97,\n"
" action_98,\n"
" action_99,\n"
" action_100,\n"
" action_101,\n"
" action_102,\n"
" action_103,\n"
" action_104,\n"
" action_105,\n"
" action_106,\n"
" action_107,\n"
" action_108,\n"
" action_109,\n"
" action_110,\n"
" action_111,\n"
" action_112,\n"
" action_113,\n"
" action_114,\n"
" action_115,\n"
" action_116,\n"
" action_117,\n"
" action_118,\n"
" action_119,\n"
" action_120,\n"
" action_121,\n"
" action_122,\n"
" action_123,\n"
" action_124,\n"
" action_125,\n"
" action_126,\n"
" action_127,\n"
" action_128,\n"
" action_129,\n"
" action_130,\n"
" action_131,\n"
" action_132,\n"
" action_133,\n"
" action_134,\n"
" action_135,\n"
" action_136,\n"
" action_137,\n"
" action_138,\n"
" action_139,\n"
" action_140,\n"
" action_141,\n"
" action_142,\n"
" action_143,\n"
" action_144,\n"
" action_145,\n"
" action_146,\n"
" action_147,\n"
" action_148,\n"
" action_149,\n"
" action_150,\n"
" action_151,\n"
" action_152,\n"
" action_153,\n"
" action_154,\n"
" action_155,\n"
" action_156,\n"
" action_157,\n"
" action_158,\n"
" action_159,\n"
" action_160,\n"
" action_161,\n"
" action_162,\n"
" action_163,\n"
" action_164,\n"
" action_165,\n"
" action_166,\n"
" action_167,\n"
" action_168,\n"
" action_169,\n"
" action_170,\n"
" action_171,\n"
" action_172,\n"
" action_173,\n"
" action_174,\n"
" action_175,\n"
" action_176,\n"
" action_177,\n"
" action_178,\n"
" action_179,\n"
" action_180,\n"
" action_181,\n"
" action_182,\n"
" action_183,\n"
" action_184,\n"
" action_185,\n"
" action_186,\n"
" action_187,\n"
" action_188,\n"
" action_189,\n"
" action_190,\n"
" action_191,\n"
" action_192,\n"
" action_193,\n"
" action_194,\n"
" action_195,\n"
" action_196,\n"
" action_197,\n"
" action_198,\n"
" action_199,\n"
" action_200,\n"
" action_201,\n"
" action_202,\n"
" action_203,\n"
" action_204,\n"
" action_205,\n"
" action_206,\n"
" action_207,\n"
" action_208,\n"
" action_209,\n"
" action_210,\n"
" action_211,\n"
" action_212,\n"
" action_213,\n"
" action_214,\n"
" action_215,\n"
" action_216,\n"
" action_217,\n"
" action_218,\n"
" action_219,\n"
" action_220,\n"
" action_221,\n"
" action_222,\n"
" action_223,\n"
" action_224,\n"
" action_225,\n"
" action_226,\n"
" action_227,\n"
" action_228,\n"
" action_229,\n"
" action_230,\n"
" action_231,\n"
" action_232,\n"
" action_233,\n"
" action_234,\n"
" action_235,\n"
" action_236,\n"
" action_237,\n"
" action_238,\n"
" action_239,\n"
" action_240,\n"
" action_241,\n"
" action_242,\n"
" action_243,\n"
" action_244,\n"
" action_245,\n"
" action_246,\n"
" action_247,\n"
" action_248,\n"
" action_249,\n"
" action_250,\n"
" action_251,\n"
" action_252,\n"
" action_253,\n"
" action_254,\n"
" action_255,\n"
" action_256,\n"
" action_257,\n"
" action_258,\n"
" action_259,\n"
" action_260,\n"
" action_261,\n"
" action_262,\n"
" action_263,\n"
" action_264,\n"
" action_265,\n"
" action_266,\n"
" action_267,\n"
" action_268,\n"
" action_269,\n"
" action_270,\n"
" action_271,\n"
" action_272,\n"
" action_273,\n"
" action_274,\n"
" action_275,\n"
" action_276,\n"
" action_277,\n"
" action_278,\n"
" action_279,\n"
" action_280,\n"
" action_281,\n"
" action_282,\n"
" action_283,\n"
" action_284,\n"
" action_285,\n"
" action_286,\n"
" action_287,\n"
" action_288,\n"
" action_289,\n"
" action_290,\n"
" action_291,\n"
" action_292,\n"
" action_293,\n"
" action_294,\n"
" action_295,\n"
" action_296,\n"
" action_297,\n"
" action_298,\n"
" action_299,\n"
" action_300,\n"
" action_301,\n"
" action_302,\n"
" action_303,\n"
" action_304,\n"
" action_305,\n"
" action_306,\n"
" action_307,\n"
" action_308,\n"
" action_309,\n"
" action_310,\n"
" action_311,\n"
" action_312,\n"
" action_313,\n"
" action_314,\n"
" action_315,\n"
" action_316,\n"
" action_317,\n"
" action_318,\n"
" action_319,\n"
" action_320,\n"
" action_321,\n"
" action_322,\n"
" action_323,\n"
" action_324,\n"
" action_325,\n"
" action_326,\n"
" action_327,\n"
" action_328,\n"
" action_329,\n"
" action_330,\n"
" action_331,\n"
" action_332,\n"
" action_333,\n"
" action_334,\n"
" action_335,\n"
" action_336,\n"
" action_337,\n"
" action_338,\n"
" action_339,\n"
" action_340,\n"
" action_341,\n"
" action_342,\n"
" action_343,\n"
" action_344,\n"
" action_345,\n"
" action_346,\n"
" action_347,\n"
" action_348,\n"
" action_349,\n"
" action_350,\n"
" action_351,\n"
" action_352,\n"
" action_353,\n"
" action_354,\n"
" action_355,\n"
" action_356,\n"
" action_357,\n"
" action_358,\n"
" action_359,\n"
" action_360,\n"
" action_361,\n"
" action_362,\n"
" action_363,\n"
" action_364,\n"
" action_365,\n"
" action_366,\n"
" action_367,\n"
" action_368,\n"
" action_369,\n"
" action_370,\n"
" action_371,\n"
" action_372,\n"
" action_373,\n"
" action_374,\n"
" action_375,\n"
" action_376,\n"
" action_377,\n"
" action_378,\n"
" action_379,\n"
" action_380,\n"
" action_381,\n"
" action_382,\n"
" action_383,\n"
" action_384,\n"
" action_385,\n"
" action_386,\n"
" action_387,\n"
" action_388,\n"
" action_389,\n"
" action_390,\n"
" action_391,\n"
" action_392,\n"
" action_393,\n"
" action_394,\n"
" action_395,\n"
" action_396,\n"
" action_397,\n"
" action_398,\n"
" action_399,\n"
" action_400,\n"
" action_401,\n"
" action_402,\n"
" action_403,\n"
" action_404,\n"
" action_405,\n"
" action_406,\n"
" action_407,\n"
" action_408,\n"
" action_409,\n"
" action_410,\n"
" action_411,\n"
" action_412,\n"
" action_413,\n"
" action_414,\n"
" action_415,\n"
" action_416,\n"
" action_417,\n"
" action_418,\n"
" action_419,\n"
" action_420,\n"
" action_421,\n"
" action_422,\n"
" action_423,\n"
" action_424,\n"
" action_425,\n"
" action_426,\n"
" action_427,\n"
" action_428,\n"
" action_429,\n"
" action_430,\n"
" action_431,\n"
" action_432,\n"
" action_433,\n"
" action_434,\n"
" action_435,\n"
" action_436,\n"
" action_437,\n"
" action_438,\n"
" action_439,\n"
" action_440,\n"
" action_441,\n"
" action_442,\n"
" action_443,\n"
" action_444,\n"
" action_445,\n"
" action_446,\n"
" action_447,\n"
" action_448,\n"
" action_449,\n"
" action_450,\n"
" action_451,\n"
" action_452,\n"
" action_453,\n"
" action_454,\n"
" action_455,\n"
" action_456,\n"
" action_457,\n"
" action_458,\n"
" action_459,\n"
" action_460,\n"
" action_461,\n"
" action_462,\n"
" action_463,\n"
" action_464,\n"
" action_465,\n"
" action_466,\n"
" action_467,\n"
" action_468,\n"
" action_469,\n"
" action_470,\n"
" action_471,\n"
" action_472,\n"
" action_473,\n"
" action_474,\n"
" action_475,\n"
" action_476,\n"
" action_477,\n"
" action_478,\n"
" action_479,\n"
" action_480,\n"
" action_481,\n"
" action_482,\n"
" action_483,\n"
" action_484,\n"
" action_485,\n"
" action_486,\n"
" action_487,\n"
" action_488,\n"
" action_489,\n"
" action_490,\n"
" action_491,\n"
" action_492 :: Int -> HappyReduction\n"
"\n"
"happyReduce_1,\n"
" happyReduce_2,\n"
" happyReduce_3,\n"
" happyReduce_4,\n"
" happyReduce_5,\n"
" happyReduce_6,\n"
" happyReduce_7,\n"
" happyReduce_8,\n"
" happyReduce_9,\n"
" happyReduce_10,\n"
" happyReduce_11,\n"
" happyReduce_12,\n"
" happyReduce_13,\n"
" happyReduce_14,\n"
" happyReduce_15,\n"
" happyReduce_16,\n"
" happyReduce_17,\n"
" happyReduce_18,\n"
" happyReduce_19,\n"
" happyReduce_20,\n"
" happyReduce_21,\n"
" happyReduce_22,\n"
" happyReduce_23,\n"
" happyReduce_24,\n"
" happyReduce_25,\n"
" happyReduce_26,\n"
" happyReduce_27,\n"
" happyReduce_28,\n"
" happyReduce_29,\n"
" happyReduce_30,\n"
" happyReduce_31,\n"
" happyReduce_32,\n"
" happyReduce_33,\n"
" happyReduce_34,\n"
" happyReduce_35,\n"
" happyReduce_36,\n"
" happyReduce_37,\n"
" happyReduce_38,\n"
" happyReduce_39,\n"
" happyReduce_40,\n"
" happyReduce_41,\n"
" happyReduce_42,\n"
" happyReduce_43,\n"
" happyReduce_44,\n"
" happyReduce_45,\n"
" happyReduce_46,\n"
" happyReduce_47,\n"
" happyReduce_48,\n"
" happyReduce_49,\n"
" happyReduce_50,\n"
" happyReduce_51,\n"
" happyReduce_52,\n"
" happyReduce_53,\n"
" happyReduce_54,\n"
" happyReduce_55,\n"
" happyReduce_56,\n"
" happyReduce_57,\n"
" happyReduce_58,\n"
" happyReduce_59,\n"
" happyReduce_60,\n"
" happyReduce_61,\n"
" happyReduce_62,\n"
" happyReduce_63,\n"
" happyReduce_64,\n"
" happyReduce_65,\n"
" happyReduce_66,\n"
" happyReduce_67,\n"
" happyReduce_68,\n"
" happyReduce_69,\n"
" happyReduce_70,\n"
" happyReduce_71,\n"
" happyReduce_72,\n"
" happyReduce_73,\n"
" happyReduce_74,\n"
" happyReduce_75,\n"
" happyReduce_76,\n"
" happyReduce_77,\n"
" happyReduce_78,\n"
" happyReduce_79,\n"
" happyReduce_80,\n"
" happyReduce_81,\n"
" happyReduce_82,\n"
" happyReduce_83,\n"
" happyReduce_84,\n"
" happyReduce_85,\n"
" happyReduce_86,\n"
" happyReduce_87,\n"
" happyReduce_88,\n"
" happyReduce_89,\n"
" happyReduce_90,\n"
" happyReduce_91,\n"
" happyReduce_92,\n"
" happyReduce_93,\n"
" happyReduce_94,\n"
" happyReduce_95,\n"
" happyReduce_96,\n"
" happyReduce_97,\n"
" happyReduce_98,\n"
" happyReduce_99,\n"
" happyReduce_100,\n"
" happyReduce_101,\n"
" happyReduce_102,\n"
" happyReduce_103,\n"
" happyReduce_104,\n"
" happyReduce_105,\n"
" happyReduce_106,\n"
" happyReduce_107,\n"
" happyReduce_108,\n"
" happyReduce_109,\n"
" happyReduce_110,\n"
" happyReduce_111,\n"
" happyReduce_112,\n"
" happyReduce_113,\n"
" happyReduce_114,\n"
" happyReduce_115,\n"
" happyReduce_116,\n"
" happyReduce_117,\n"
" happyReduce_118,\n"
" happyReduce_119,\n"
" happyReduce_120,\n"
" happyReduce_121,\n"
" happyReduce_122,\n"
" happyReduce_123,\n"
" happyReduce_124,\n"
" happyReduce_125,\n"
" happyReduce_126,\n"
" happyReduce_127,\n"
" happyReduce_128,\n"
" happyReduce_129,\n"
" happyReduce_130,\n"
" happyReduce_131,\n"
" happyReduce_132,\n"
" happyReduce_133,\n"
" happyReduce_134,\n"
" happyReduce_135,\n"
" happyReduce_136,\n"
" happyReduce_137,\n"
" happyReduce_138,\n"
" happyReduce_139,\n"
" happyReduce_140,\n"
" happyReduce_141,\n"
" happyReduce_142,\n"
" happyReduce_143,\n"
" happyReduce_144,\n"
" happyReduce_145,\n"
" happyReduce_146,\n"
" happyReduce_147,\n"
" happyReduce_148,\n"
" happyReduce_149,\n"
" happyReduce_150,\n"
" happyReduce_151,\n"
" happyReduce_152,\n"
" happyReduce_153,\n"
" happyReduce_154,\n"
" happyReduce_155,\n"
" happyReduce_156,\n"
" happyReduce_157,\n"
" happyReduce_158,\n"
" happyReduce_159,\n"
" happyReduce_160,\n"
" happyReduce_161,\n"
" happyReduce_162,\n"
" happyReduce_163,\n"
" happyReduce_164,\n"
" happyReduce_165,\n"
" happyReduce_166,\n"
" happyReduce_167,\n"
" happyReduce_168,\n"
" happyReduce_169,\n"
" happyReduce_170,\n"
" happyReduce_171,\n"
" happyReduce_172,\n"
" happyReduce_173,\n"
" happyReduce_174,\n"
" happyReduce_175,\n"
" happyReduce_176,\n"
" happyReduce_177,\n"
" happyReduce_178,\n"
" happyReduce_179,\n"
" happyReduce_180,\n"
" happyReduce_181,\n"
" happyReduce_182,\n"
" happyReduce_183,\n"
" happyReduce_184,\n"
" happyReduce_185,\n"
" happyReduce_186,\n"
" happyReduce_187,\n"
" happyReduce_188,\n"
" happyReduce_189,\n"
" happyReduce_190,\n"
" happyReduce_191,\n"
" happyReduce_192,\n"
" happyReduce_193,\n"
" happyReduce_194,\n"
" happyReduce_195,\n"
" happyReduce_196,\n"
" happyReduce_197,\n"
" happyReduce_198,\n"
" happyReduce_199,\n"
" happyReduce_200,\n"
" happyReduce_201,\n"
" happyReduce_202,\n"
" happyReduce_203,\n"
" happyReduce_204,\n"
" happyReduce_205,\n"
" happyReduce_206,\n"
" happyReduce_207,\n"
" happyReduce_208,\n"
" happyReduce_209,\n"
" happyReduce_210,\n"
" happyReduce_211,\n"
" happyReduce_212,\n"
" happyReduce_213,\n"
" happyReduce_214,\n"
" happyReduce_215,\n"
" happyReduce_216,\n"
" happyReduce_217,\n"
" happyReduce_218,\n"
" happyReduce_219,\n"
" happyReduce_220,\n"
" happyReduce_221,\n"
" happyReduce_222,\n"
" happyReduce_223,\n"
" happyReduce_224,\n"
" happyReduce_225,\n"
" happyReduce_226,\n"
" happyReduce_227,\n"
" happyReduce_228,\n"
" happyReduce_229,\n"
" happyReduce_230,\n"
" happyReduce_231,\n"
" happyReduce_232,\n"
" happyReduce_233,\n"
" happyReduce_234,\n"
" happyReduce_235,\n"
" happyReduce_236,\n"
" happyReduce_237,\n"
" happyReduce_238,\n"
" happyReduce_239,\n"
" happyReduce_240,\n"
" happyReduce_241,\n"
" happyReduce_242,\n"
" happyReduce_243,\n"
" happyReduce_244,\n"
" happyReduce_245,\n"
" happyReduce_246,\n"
" happyReduce_247,\n"
" happyReduce_248,\n"
" happyReduce_249,\n"
" happyReduce_250,\n"
" happyReduce_251,\n"
" happyReduce_252,\n"
" happyReduce_253,\n"
" happyReduce_254,\n"
" happyReduce_255,\n"
" happyReduce_256,\n"
" happyReduce_257,\n"
" happyReduce_258,\n"
" happyReduce_259,\n"
" happyReduce_260,\n"
" happyReduce_261,\n"
" happyReduce_262,\n"
" happyReduce_263,\n"
" happyReduce_264,\n"
" happyReduce_265,\n"
" happyReduce_266,\n"
" happyReduce_267,\n"
" happyReduce_268,\n"
" happyReduce_269,\n"
" happyReduce_270,\n"
" happyReduce_271,\n"
" happyReduce_272,\n"
" happyReduce_273,\n"
" happyReduce_274,\n"
" happyReduce_275,\n"
" happyReduce_276,\n"
" happyReduce_277,\n"
" happyReduce_278,\n"
" happyReduce_279,\n"
" happyReduce_280,\n"
" happyReduce_281,\n"
" happyReduce_282,\n"
" happyReduce_283,\n"
" happyReduce_284,\n"
" happyReduce_285,\n"
" happyReduce_286,\n"
" happyReduce_287,\n"
" happyReduce_288,\n"
" happyReduce_289 :: HappyReduction\n"
"\n"
"action_0 (4) = happyGoto action_3\n"
"action_0 (124) = happyGoto action_4\n"
"action_0 _ = happyReduce_279\n"
"\n"
"action_1 (124) = happyGoto action_2\n"
"action_1 _ = happyFail\n"
"\n"
"action_2 (186) = happyShift action_8\n"
"action_2 _ = happyFail\n"
"\n"
"action_3 (193) = happyAccept\n"
"action_3 _ = happyFail\n"
"\n"
"action_4 (148) = happyShift action_7\n"
"action_4 (186) = happyShift action_8\n"
"action_4 (5) = happyGoto action_5\n"
"action_4 (125) = happyGoto action_6\n"
"action_4 _ = happyReduce_280\n"
"\n"
"action_5 _ = happyReduce_2\n"
"\n"
"action_6 (6) = happyGoto action_15\n"
"action_6 (7) = happyGoto action_13\n"
"action_6 (8) = happyGoto action_14\n"
"action_6 _ = happyReduce_11\n"
"\n"
"action_7 (6) = happyGoto action_12\n"
"action_7 (7) = happyGoto action_13\n"
"action_7 (8) = happyGoto action_14\n"
"action_7 _ = happyReduce_11\n"
"\n"
"action_8 (135) = happyShift action_10\n"
"action_8 (136) = happyShift action_11\n"
"action_8 (127) = happyGoto action_9\n"
"action_8 _ = happyFail\n"
"\n"
"action_9 (145) = happyShift action_33\n"
"action_9 (9) = happyGoto action_31\n"
"action_9 (10) = happyGoto action_32\n"
"action_9 _ = happyReduce_13\n"
"\n"
"action_10 _ = happyReduce_283\n"
"\n"
"action_11 _ = happyReduce_284\n"
"\n"
"action_12 (149) = happyShift action_30\n"
"action_12 _ = happyFail\n"
"\n"
"action_13 _ = happyReduce_10\n"
"\n"
"action_14 (133) = happyReduce_279\n"
"action_14 (134) = happyReduce_279\n"
"action_14 (135) = happyReduce_279\n"
"action_14 (136) = happyReduce_279\n"
"action_14 (141) = happyReduce_279\n"
"action_14 (142) = happyReduce_279\n"
"action_14 (143) = happyReduce_279\n"
"action_14 (144) = happyReduce_279\n"
"action_14 (145) = happyReduce_279\n"
"action_14 (147) = happyShift action_29\n"
"action_14 (151) = happyReduce_279\n"
"action_14 (154) = happyReduce_279\n"
"action_14 (165) = happyReduce_279\n"
"action_14 (167) = happyReduce_279\n"
"action_14 (169) = happyReduce_279\n"
"action_14 (170) = happyReduce_279\n"
"action_14 (171) = happyReduce_279\n"
"action_14 (172) = happyReduce_279\n"
"action_14 (173) = happyReduce_279\n"
"action_14 (175) = happyReduce_279\n"
"action_14 (177) = happyReduce_279\n"
"action_14 (179) = happyReduce_279\n"
"action_14 (181) = happyReduce_279\n"
"action_14 (182) = happyReduce_279\n"
"action_14 (183) = happyReduce_279\n"
"action_14 (184) = happyReduce_279\n"
"action_14 (187) = happyReduce_279\n"
"action_14 (190) = happyReduce_279\n"
"action_14 (192) = happyReduce_279\n"
"action_14 (14) = happyGoto action_19\n"
"action_14 (15) = happyGoto action_20\n"
"action_14 (25) = happyGoto action_21\n"
"action_14 (29) = happyGoto action_22\n"
"action_14 (30) = happyGoto action_23\n"
"action_14 (31) = happyGoto action_24\n"
"action_14 (35) = happyGoto action_25\n"
"action_14 (37) = happyGoto action_26\n"
"action_14 (63) = happyGoto action_27\n"
"action_14 (124) = happyGoto action_28\n"
"action_14 _ = happyReduce_8\n"
"\n"
"action_15 (1) = happyShift action_17\n"
"action_15 (150) = happyShift action_18\n"
"action_15 (126) = happyGoto action_16\n"
"action_15 _ = happyFail\n"
"\n"
"action_16 _ = happyReduce_4\n"
"\n"
"action_17 _ = happyReduce_282\n"
"\n"
"action_18 _ = happyReduce_281\n"
"\n"
"action_19 (7) = happyGoto action_90\n"
"action_19 (8) = happyGoto action_91\n"
"action_19 _ = happyReduce_11\n"
"\n"
"action_20 _ = happyReduce_27\n"
"\n"
"action_21 _ = happyReduce_76\n"
"\n"
"action_22 _ = happyReduce_6\n"
"\n"
"action_23 (7) = happyGoto action_88\n"
"action_23 (8) = happyGoto action_89\n"
"action_23 _ = happyReduce_11\n"
"\n"
"action_24 _ = happyReduce_60\n"
"\n"
"action_25 _ = happyReduce_67\n"
"\n"
"action_26 _ = happyReduce_75\n"
"\n"
"action_27 _ = happyReduce_77\n"
"\n"
"action_28 (133) = happyShift action_43\n"
"action_28 (134) = happyShift action_44\n"
"action_28 (135) = happyShift action_45\n"
"action_28 (136) = happyShift action_46\n"
"action_28 (141) = happyShift action_67\n"
"action_28 (142) = happyShift action_68\n"
"action_28 (143) = happyShift action_69\n"
"action_28 (144) = happyShift action_70\n"
"action_28 (145) = happyShift action_71\n"
"action_28 (151) = happyShift action_72\n"
"action_28 (154) = happyShift action_73\n"
"action_28 (165) = happyShift action_74\n"
"action_28 (167) = happyShift action_75\n"
"action_28 (169) = happyShift action_49\n"
"action_28 (170) = happyShift action_76\n"
"action_28 (171) = happyShift action_77\n"
"action_28 (172) = happyShift action_78\n"
"action_28 (173) = happyShift action_79\n"
"action_28 (175) = happyShift action_80\n"
"action_28 (177) = happyShift action_50\n"
"action_28 (179) = happyShift action_81\n"
"action_28 (181) = happyShift action_82\n"
"action_28 (182) = happyShift action_83\n"
"action_28 (183) = happyShift action_84\n"
"action_28 (184) = happyShift action_85\n"
"action_28 (187) = happyShift action_86\n"
"action_28 (190) = happyShift action_87\n"
"action_28 (192) = happyShift action_52\n"
"action_28 (27) = happyGoto action_54\n"
"action_28 (38) = happyGoto action_55\n"
"action_28 (71) = happyGoto action_56\n"
"action_28 (73) = happyGoto action_57\n"
"action_28 (74) = happyGoto action_58\n"
"action_28 (77) = happyGoto action_59\n"
"action_28 (78) = happyGoto action_60\n"
"action_28 (79) = happyGoto action_61\n"
"action_28 (98) = happyGoto action_62\n"
"action_28 (100) = happyGoto action_63\n"
"action_28 (102) = happyGoto action_64\n"
"action_28 (112) = happyGoto action_38\n"
"action_28 (113) = happyGoto action_39\n"
"action_28 (114) = happyGoto action_65\n"
"action_28 (115) = happyGoto action_41\n"
"action_28 (123) = happyGoto action_66\n"
"action_28 _ = happyFail\n"
"\n"
"action_29 _ = happyReduce_9\n"
"\n"
"action_30 _ = happyReduce_3\n"
"\n"
"action_31 (191) = happyShift action_53\n"
"action_31 _ = happyFail\n"
"\n"
"action_32 _ = happyReduce_12\n"
"\n"
"action_33 (133) = happyShift action_43\n"
"action_33 (134) = happyShift action_44\n"
"action_33 (135) = happyShift action_45\n"
"action_33 (136) = happyShift action_46\n"
"action_33 (145) = happyShift action_47\n"
"action_33 (153) = happyShift action_48\n"
"action_33 (169) = happyShift action_49\n"
"action_33 (177) = happyShift action_50\n"
"action_33 (186) = happyShift action_51\n"
"action_33 (192) = happyShift action_52\n"
"action_33 (11) = happyGoto action_34\n"
"action_33 (12) = happyGoto action_35\n"
"action_33 (13) = happyGoto action_36\n"
"action_33 (100) = happyGoto action_37\n"
"action_33 (112) = happyGoto action_38\n"
"action_33 (113) = happyGoto action_39\n"
"action_33 (114) = happyGoto action_40\n"
"action_33 (115) = happyGoto action_41\n"
"action_33 (130) = happyGoto action_42\n"
"action_33 _ = happyReduce_17\n"
"\n"
"action_34 (146) = happyShift action_186\n"
"action_34 _ = happyFail\n"
"\n"
"action_35 (153) = happyShift action_185\n"
"action_35 (11) = happyGoto action_184\n"
"action_35 _ = happyReduce_17\n"
"\n"
"action_36 _ = happyReduce_19\n"
"\n"
"action_37 _ = happyReduce_20\n"
"\n"
"action_38 _ = happyReduce_229\n"
"\n"
"action_39 _ = happyReduce_253\n"
"\n"
"action_40 _ = happyReduce_287\n"
"\n"
"action_41 _ = happyReduce_259\n"
"\n"
"action_42 (145) = happyShift action_183\n"
"action_42 _ = happyReduce_21\n"
"\n"
"action_43 _ = happyReduce_255\n"
"\n"
"action_44 _ = happyReduce_254\n"
"\n"
"action_45 _ = happyReduce_261\n"
"\n"
"action_46 _ = happyReduce_260\n"
"\n"
"action_47 (137) = happyShift action_172\n"
"action_47 (139) = happyShift action_151\n"
"action_47 (167) = happyShift action_175\n"
"action_47 (168) = happyShift action_176\n"
"action_47 (118) = happyGoto action_144\n"
"action_47 (120) = happyGoto action_146\n"
"action_47 (122) = happyGoto action_170\n"
"action_47 _ = happyFail\n"
"\n"
"action_48 _ = happyReduce_16\n"
"\n"
"action_49 _ = happyReduce_256\n"
"\n"
"action_50 _ = happyReduce_258\n"
"\n"
"action_51 (135) = happyShift action_10\n"
"action_51 (136) = happyShift action_11\n"
"action_51 (127) = happyGoto action_182\n"
"action_51 _ = happyFail\n"
"\n"
"action_52 _ = happyReduce_257\n"
"\n"
"action_53 (148) = happyShift action_7\n"
"action_53 (5) = happyGoto action_181\n"
"action_53 (125) = happyGoto action_6\n"
"action_53 _ = happyReduce_280\n"
"\n"
"action_54 (141) = happyShift action_180\n"
"action_54 (26) = happyGoto action_179\n"
"action_54 _ = happyReduce_51\n"
"\n"
"action_55 (153) = happyShift action_177\n"
"action_55 (158) = happyShift action_178\n"
"action_55 _ = happyFail\n"
"\n"
"action_56 (137) = happyShift action_172\n"
"action_56 (138) = happyShift action_150\n"
"action_56 (139) = happyShift action_151\n"
"action_56 (140) = happyShift action_152\n"
"action_56 (155) = happyShift action_173\n"
"action_56 (157) = happyShift action_156\n"
"action_56 (159) = happyShift action_174\n"
"action_56 (167) = happyShift action_175\n"
"action_56 (168) = happyShift action_176\n"
"action_56 (65) = happyGoto action_162\n"
"action_56 (66) = happyGoto action_163\n"
"action_56 (67) = happyGoto action_164\n"
"action_56 (104) = happyGoto action_165\n"
"action_56 (107) = happyGoto action_166\n"
"action_56 (109) = happyGoto action_167\n"
"action_56 (111) = happyGoto action_168\n"
"action_56 (116) = happyGoto action_142\n"
"action_56 (117) = happyGoto action_143\n"
"action_56 (118) = happyGoto action_169\n"
"action_56 (120) = happyGoto action_146\n"
"action_56 (122) = happyGoto action_170\n"
"action_56 (124) = happyGoto action_171\n"
"action_56 _ = happyReduce_279\n"
"\n"
"action_57 _ = happyReduce_154\n"
"\n"
"action_58 (133) = happyShift action_43\n"
"action_58 (134) = happyShift action_44\n"
"action_58 (135) = happyShift action_45\n"
"action_58 (136) = happyShift action_46\n"
"action_58 (141) = happyShift action_67\n"
"action_58 (142) = happyShift action_68\n"
"action_58 (143) = happyShift action_69\n"
"action_58 (144) = happyShift action_70\n"
"action_58 (145) = happyShift action_71\n"
"action_58 (151) = happyShift action_72\n"
"action_58 (154) = happyShift action_73\n"
"action_58 (165) = happyShift action_74\n"
"action_58 (169) = happyShift action_49\n"
"action_58 (177) = happyShift action_50\n"
"action_58 (192) = happyShift action_52\n"
"action_58 (77) = happyGoto action_161\n"
"action_58 (78) = happyGoto action_60\n"
"action_58 (79) = happyGoto action_61\n"
"action_58 (98) = happyGoto action_62\n"
"action_58 (100) = happyGoto action_124\n"
"action_58 (102) = happyGoto action_64\n"
"action_58 (112) = happyGoto action_38\n"
"action_58 (113) = happyGoto action_39\n"
"action_58 (114) = happyGoto action_65\n"
"action_58 (115) = happyGoto action_41\n"
"action_58 (123) = happyGoto action_66\n"
"action_58 _ = happyReduce_161\n"
"\n"
"action_59 _ = happyReduce_163\n"
"\n"
"action_60 (148) = happyShift action_160\n"
"action_60 _ = happyReduce_169\n"
"\n"
"action_61 _ = happyReduce_172\n"
"\n"
"action_62 _ = happyReduce_174\n"
"\n"
"action_63 (153) = happyReduce_82\n"
"action_63 (158) = happyReduce_82\n"
"action_63 (164) = happyShift action_159\n"
"action_63 _ = happyReduce_173\n"
"\n"
"action_64 _ = happyReduce_226\n"
"\n"
"action_65 _ = happyReduce_233\n"
"\n"
"action_66 _ = happyReduce_175\n"
"\n"
"action_67 _ = happyReduce_275\n"
"\n"
"action_68 _ = happyReduce_277\n"
"\n"
"action_69 _ = happyReduce_276\n"
"\n"
"action_70 _ = happyReduce_278\n"
"\n"
"action_71 (133) = happyShift action_43\n"
"action_71 (134) = happyShift action_44\n"
"action_71 (135) = happyShift action_45\n"
"action_71 (136) = happyShift action_46\n"
"action_71 (137) = happyShift action_149\n"
"action_71 (138) = happyShift action_150\n"
"action_71 (139) = happyShift action_151\n"
"action_71 (140) = happyShift action_152\n"
"action_71 (141) = happyShift action_67\n"
"action_71 (142) = happyShift action_68\n"
"action_71 (143) = happyShift action_69\n"
"action_71 (144) = happyShift action_70\n"
"action_71 (145) = happyShift action_71\n"
"action_71 (146) = happyShift action_153\n"
"action_71 (151) = happyShift action_72\n"
"action_71 (153) = happyShift action_154\n"
"action_71 (154) = happyShift action_73\n"
"action_71 (155) = happyShift action_155\n"
"action_71 (157) = happyShift action_156\n"
"action_71 (160) = happyShift action_125\n"
"action_71 (165) = happyShift action_74\n"
"action_71 (167) = happyShift action_157\n"
"action_71 (168) = happyShift action_158\n"
"action_71 (169) = happyShift action_49\n"
"action_71 (170) = happyShift action_76\n"
"action_71 (175) = happyShift action_80\n"
"action_71 (177) = happyShift action_50\n"
"action_71 (178) = happyShift action_126\n"
"action_71 (185) = happyShift action_127\n"
"action_71 (192) = happyShift action_52\n"
"action_71 (68) = happyGoto action_134\n"
"action_71 (69) = happyGoto action_120\n"
"action_71 (70) = happyGoto action_121\n"
"action_71 (71) = happyGoto action_135\n"
"action_71 (72) = happyGoto action_123\n"
"action_71 (73) = happyGoto action_57\n"
"action_71 (74) = happyGoto action_58\n"
"action_71 (77) = happyGoto action_59\n"
"action_71 (78) = happyGoto action_60\n"
"action_71 (79) = happyGoto action_61\n"
"action_71 (80) = happyGoto action_136\n"
"action_71 (81) = happyGoto action_137\n"
"action_71 (98) = happyGoto action_62\n"
"action_71 (100) = happyGoto action_124\n"
"action_71 (102) = happyGoto action_64\n"
"action_71 (105) = happyGoto action_138\n"
"action_71 (107) = happyGoto action_139\n"
"action_71 (110) = happyGoto action_140\n"
"action_71 (111) = happyGoto action_141\n"
"action_71 (112) = happyGoto action_38\n"
"action_71 (113) = happyGoto action_39\n"
"action_71 (114) = happyGoto action_65\n"
"action_71 (115) = happyGoto action_41\n"
"action_71 (116) = happyGoto action_142\n"
"action_71 (117) = happyGoto action_143\n"
"action_71 (118) = happyGoto action_144\n"
"action_71 (119) = happyGoto action_145\n"
"action_71 (120) = happyGoto action_146\n"
"action_71 (121) = happyGoto action_147\n"
"action_71 (122) = happyGoto action_148\n"
"action_71 (123) = happyGoto action_66\n"
"action_71 _ = happyFail\n"
"\n"
"action_72 (133) = happyShift action_43\n"
"action_72 (134) = happyShift action_44\n"
"action_72 (135) = happyShift action_45\n"
"action_72 (136) = happyShift action_46\n"
"action_72 (141) = happyShift action_67\n"
"action_72 (142) = happyShift action_68\n"
"action_72 (143) = happyShift action_69\n"
"action_72 (144) = happyShift action_70\n"
"action_72 (145) = happyShift action_71\n"
"action_72 (151) = happyShift action_72\n"
"action_72 (152) = happyShift action_133\n"
"action_72 (154) = happyShift action_73\n"
"action_72 (160) = happyShift action_125\n"
"action_72 (165) = happyShift action_74\n"
"action_72 (167) = happyShift action_75\n"
"action_72 (169) = happyShift action_49\n"
"action_72 (170) = happyShift action_76\n"
"action_72 (175) = happyShift action_80\n"
"action_72 (177) = happyShift action_50\n"
"action_72 (178) = happyShift action_126\n"
"action_72 (185) = happyShift action_127\n"
"action_72 (192) = happyShift action_52\n"
"action_72 (68) = happyGoto action_130\n"
"action_72 (69) = happyGoto action_120\n"
"action_72 (70) = happyGoto action_121\n"
"action_72 (71) = happyGoto action_122\n"
"action_72 (72) = happyGoto action_123\n"
"action_72 (73) = happyGoto action_57\n"
"action_72 (74) = happyGoto action_58\n"
"action_72 (77) = happyGoto action_59\n"
"action_72 (78) = happyGoto action_60\n"
"action_72 (79) = happyGoto action_61\n"
"action_72 (82) = happyGoto action_131\n"
"action_72 (83) = happyGoto action_132\n"
"action_72 (98) = happyGoto action_62\n"
"action_72 (100) = happyGoto action_124\n"
"action_72 (102) = happyGoto action_64\n"
"action_72 (112) = happyGoto action_38\n"
"action_72 (113) = happyGoto action_39\n"
"action_72 (114) = happyGoto action_65\n"
"action_72 (115) = happyGoto action_41\n"
"action_72 (123) = happyGoto action_66\n"
"action_72 _ = happyFail\n"
"\n"
"action_73 _ = happyReduce_181\n"
"\n"
"action_74 (133) = happyShift action_43\n"
"action_74 (134) = happyShift action_44\n"
"action_74 (135) = happyShift action_45\n"
"action_74 (136) = happyShift action_46\n"
"action_74 (141) = happyShift action_67\n"
"action_74 (142) = happyShift action_68\n"
"action_74 (143) = happyShift action_69\n"
"action_74 (144) = happyShift action_70\n"
"action_74 (145) = happyShift action_71\n"
"action_74 (151) = happyShift action_72\n"
"action_74 (154) = happyShift action_73\n"
"action_74 (165) = happyShift action_74\n"
"action_74 (169) = happyShift action_49\n"
"action_74 (177) = happyShift action_50\n"
"action_74 (192) = happyShift action_52\n"
"action_74 (77) = happyGoto action_129\n"
"action_74 (78) = happyGoto action_60\n"
"action_74 (79) = happyGoto action_61\n"
"action_74 (98) = happyGoto action_62\n"
"action_74 (100) = happyGoto action_124\n"
"action_74 (102) = happyGoto action_64\n"
"action_74 (112) = happyGoto action_38\n"
"action_74 (113) = happyGoto action_39\n"
"action_74 (114) = happyGoto action_65\n"
"action_74 (115) = happyGoto action_41\n"
"action_74 (123) = happyGoto action_66\n"
"action_74 _ = happyFail\n"
"\n"
"action_75 (133) = happyShift action_43\n"
"action_75 (134) = happyShift action_44\n"
"action_75 (135) = happyShift action_45\n"
"action_75 (136) = happyShift action_46\n"
"action_75 (141) = happyShift action_67\n"
"action_75 (142) = happyShift action_68\n"
"action_75 (143) = happyShift action_69\n"
"action_75 (144) = happyShift action_70\n"
"action_75 (145) = happyShift action_71\n"
"action_75 (151) = happyShift action_72\n"
"action_75 (154) = happyShift action_73\n"
"action_75 (165) = happyShift action_74\n"
"action_75 (169) = happyShift action_49\n"
"action_75 (177) = happyShift action_50\n"
"action_75 (192) = happyShift action_52\n"
"action_75 (74) = happyGoto action_128\n"
"action_75 (77) = happyGoto action_59\n"
"action_75 (78) = happyGoto action_60\n"
"action_75 (79) = happyGoto action_61\n"
"action_75 (98) = happyGoto action_62\n"
"action_75 (100) = happyGoto action_124\n"
"action_75 (102) = happyGoto action_64\n"
"action_75 (112) = happyGoto action_38\n"
"action_75 (113) = happyGoto action_39\n"
"action_75 (114) = happyGoto action_65\n"
"action_75 (115) = happyGoto action_41\n"
"action_75 (123) = happyGoto action_66\n"
"action_75 _ = happyFail\n"
"\n"
"action_76 (133) = happyShift action_43\n"
"action_76 (134) = happyShift action_44\n"
"action_76 (135) = happyShift action_45\n"
"action_76 (136) = happyShift action_46\n"
"action_76 (141) = happyShift action_67\n"
"action_76 (142) = happyShift action_68\n"
"action_76 (143) = happyShift action_69\n"
"action_76 (144) = happyShift action_70\n"
"action_76 (145) = happyShift action_71\n"
"action_76 (151) = happyShift action_72\n"
"action_76 (154) = happyShift action_73\n"
"action_76 (160) = happyShift action_125\n"
"action_76 (165) = happyShift action_74\n"
"action_76 (167) = happyShift action_75\n"
"action_76 (169) = happyShift action_49\n"
"action_76 (170) = happyShift action_76\n"
"action_76 (175) = happyShift action_80\n"
"action_76 (177) = happyShift action_50\n"
"action_76 (178) = happyShift action_126\n"
"action_76 (185) = happyShift action_127\n"
"action_76 (192) = happyShift action_52\n"
"action_76 (68) = happyGoto action_119\n"
"action_76 (69) = happyGoto action_120\n"
"action_76 (70) = happyGoto action_121\n"
"action_76 (71) = happyGoto action_122\n"
"action_76 (72) = happyGoto action_123\n"
"action_76 (73) = happyGoto action_57\n"
"action_76 (74) = happyGoto action_58\n"
"action_76 (77) = happyGoto action_59\n"
"action_76 (78) = happyGoto action_60\n"
"action_76 (79) = happyGoto action_61\n"
"action_76 (98) = happyGoto action_62\n"
"action_76 (100) = happyGoto action_124\n"
"action_76 (102) = happyGoto action_64\n"
"action_76 (112) = happyGoto action_38\n"
"action_76 (113) = happyGoto action_39\n"
"action_76 (114) = happyGoto action_65\n"
"action_76 (115) = happyGoto action_41\n"
"action_76 (123) = happyGoto action_66\n"
"action_76 _ = happyFail\n"
"\n"
"action_77 (133) = happyShift action_43\n"
"action_77 (135) = happyShift action_45\n"
"action_77 (136) = happyShift action_46\n"
"action_77 (145) = happyShift action_108\n"
"action_77 (151) = happyShift action_109\n"
"action_77 (169) = happyShift action_49\n"
"action_77 (177) = happyShift action_50\n"
"action_77 (192) = happyShift action_52\n"
"action_77 (39) = happyGoto action_99\n"
"action_77 (40) = happyGoto action_100\n"
"action_77 (41) = happyGoto action_101\n"
"action_77 (42) = happyGoto action_102\n"
"action_77 (43) = happyGoto action_118\n"
"action_77 (44) = happyGoto action_104\n"
"action_77 (113) = happyGoto action_105\n"
"action_77 (114) = happyGoto action_106\n"
"action_77 (115) = happyGoto action_41\n"
"action_77 (132) = happyGoto action_107\n"
"action_77 _ = happyFail\n"
"\n"
"action_78 (133) = happyShift action_43\n"
"action_78 (135) = happyShift action_45\n"
"action_78 (136) = happyShift action_46\n"
"action_78 (145) = happyShift action_108\n"
"action_78 (151) = happyShift action_109\n"
"action_78 (169) = happyShift action_49\n"
"action_78 (177) = happyShift action_50\n"
"action_78 (192) = happyShift action_52\n"
"action_78 (39) = happyGoto action_99\n"
"action_78 (40) = happyGoto action_100\n"
"action_78 (41) = happyGoto action_101\n"
"action_78 (42) = happyGoto action_102\n"
"action_78 (43) = happyGoto action_117\n"
"action_78 (44) = happyGoto action_104\n"
"action_78 (113) = happyGoto action_105\n"
"action_78 (114) = happyGoto action_106\n"
"action_78 (115) = happyGoto action_41\n"
"action_78 (132) = happyGoto action_107\n"
"action_78 _ = happyFail\n"
"\n"
"action_79 (145) = happyShift action_116\n"
"action_79 _ = happyFail\n"
"\n"
"action_80 (148) = happyShift action_115\n"
"action_80 (94) = happyGoto action_113\n"
"action_80 (125) = happyGoto action_114\n"
"action_80 _ = happyReduce_280\n"
"\n"
"action_81 (192) = happyShift action_112\n"
"action_81 (16) = happyGoto action_111\n"
"action_81 _ = happyReduce_30\n"
"\n"
"action_82 _ = happyReduce_53\n"
"\n"
"action_83 _ = happyReduce_54\n"
"\n"
"action_84 _ = happyReduce_55\n"
"\n"
"action_85 (133) = happyShift action_43\n"
"action_85 (135) = happyShift action_45\n"
"action_85 (136) = happyShift action_46\n"
"action_85 (145) = happyShift action_108\n"
"action_85 (151) = happyShift action_109\n"
"action_85 (169) = happyShift action_49\n"
"action_85 (177) = happyShift action_50\n"
"action_85 (192) = happyShift action_52\n"
"action_85 (39) = happyGoto action_99\n"
"action_85 (40) = happyGoto action_100\n"
"action_85 (41) = happyGoto action_101\n"
"action_85 (42) = happyGoto action_102\n"
"action_85 (43) = happyGoto action_110\n"
"action_85 (44) = happyGoto action_104\n"
"action_85 (113) = happyGoto action_105\n"
"action_85 (114) = happyGoto action_106\n"
"action_85 (115) = happyGoto action_41\n"
"action_85 (132) = happyGoto action_107\n"
"action_85 _ = happyFail\n"
"\n"
"action_86 (133) = happyShift action_43\n"
"action_86 (135) = happyShift action_45\n"
"action_86 (136) = happyShift action_46\n"
"action_86 (145) = happyShift action_108\n"
"action_86 (151) = happyShift action_109\n"
"action_86 (169) = happyShift action_49\n"
"action_86 (177) = happyShift action_50\n"
"action_86 (192) = happyShift action_52\n"
"action_86 (39) = happyGoto action_99\n"
"action_86 (40) = happyGoto action_100\n"
"action_86 (41) = happyGoto action_101\n"
"action_86 (42) = happyGoto action_102\n"
"action_86 (43) = happyGoto action_103\n"
"action_86 (44) = happyGoto action_104\n"
"action_86 (113) = happyGoto action_105\n"
"action_86 (114) = happyGoto action_106\n"
"action_86 (115) = happyGoto action_41\n"
"action_86 (132) = happyGoto action_107\n"
"action_86 _ = happyFail\n"
"\n"
"action_87 (135) = happyShift action_45\n"
"action_87 (46) = happyGoto action_96\n"
"action_87 (115) = happyGoto action_97\n"
"action_87 (129) = happyGoto action_98\n"
"action_87 _ = happyFail\n"
"\n"
"action_88 (133) = happyReduce_279\n"
"action_88 (134) = happyReduce_279\n"
"action_88 (135) = happyReduce_279\n"
"action_88 (136) = happyReduce_279\n"
"action_88 (141) = happyReduce_279\n"
"action_88 (142) = happyReduce_279\n"
"action_88 (143) = happyReduce_279\n"
"action_88 (144) = happyReduce_279\n"
"action_88 (145) = happyReduce_279\n"
"action_88 (151) = happyReduce_279\n"
"action_88 (154) = happyReduce_279\n"
"action_88 (165) = happyReduce_279\n"
"action_88 (167) = happyReduce_279\n"
"action_88 (169) = happyReduce_279\n"
"action_88 (170) = happyReduce_279\n"
"action_88 (171) = happyReduce_279\n"
"action_88 (172) = happyReduce_279\n"
"action_88 (173) = happyReduce_279\n"
"action_88 (175) = happyReduce_279\n"
"action_88 (177) = happyReduce_279\n"
"action_88 (181) = happyReduce_279\n"
"action_88 (182) = happyReduce_279\n"
"action_88 (183) = happyReduce_279\n"
"action_88 (184) = happyReduce_279\n"
"action_88 (187) = happyReduce_279\n"
"action_88 (190) = happyReduce_279\n"
"action_88 (192) = happyReduce_279\n"
"action_88 (25) = happyGoto action_21\n"
"action_88 (31) = happyGoto action_94\n"
"action_88 (35) = happyGoto action_25\n"
"action_88 (37) = happyGoto action_26\n"
"action_88 (63) = happyGoto action_27\n"
"action_88 (124) = happyGoto action_95\n"
"action_88 _ = happyReduce_10\n"
"\n"
"action_89 (147) = happyShift action_29\n"
"action_89 _ = happyReduce_58\n"
"\n"
"action_90 (133) = happyReduce_279\n"
"action_90 (134) = happyReduce_279\n"
"action_90 (135) = happyReduce_279\n"
"action_90 (136) = happyReduce_279\n"
"action_90 (141) = happyReduce_279\n"
"action_90 (142) = happyReduce_279\n"
"action_90 (143) = happyReduce_279\n"
"action_90 (144) = happyReduce_279\n"
"action_90 (145) = happyReduce_279\n"
"action_90 (151) = happyReduce_279\n"
"action_90 (154) = happyReduce_279\n"
"action_90 (165) = happyReduce_279\n"
"action_90 (167) = happyReduce_279\n"
"action_90 (169) = happyReduce_279\n"
"action_90 (170) = happyReduce_279\n"
"action_90 (171) = happyReduce_279\n"
"action_90 (172) = happyReduce_279\n"
"action_90 (173) = happyReduce_279\n"
"action_90 (175) = happyReduce_279\n"
"action_90 (177) = happyReduce_279\n"
"action_90 (179) = happyReduce_279\n"
"action_90 (181) = happyReduce_279\n"
"action_90 (182) = happyReduce_279\n"
"action_90 (183) = happyReduce_279\n"
"action_90 (184) = happyReduce_279\n"
"action_90 (187) = happyReduce_279\n"
"action_90 (190) = happyReduce_279\n"
"action_90 (192) = happyReduce_279\n"
"action_90 (15) = happyGoto action_92\n"
"action_90 (25) = happyGoto action_21\n"
"action_90 (29) = happyGoto action_93\n"
"action_90 (30) = happyGoto action_23\n"
"action_90 (31) = happyGoto action_24\n"
"action_90 (35) = happyGoto action_25\n"
"action_90 (37) = happyGoto action_26\n"
"action_90 (63) = happyGoto action_27\n"
"action_90 (124) = happyGoto action_28\n"
"action_90 _ = happyReduce_10\n"
"\n"
"action_91 (147) = happyShift action_29\n"
"action_91 _ = happyReduce_7\n"
"\n"
"action_92 _ = happyReduce_26\n"
"\n"
"action_93 _ = happyReduce_5\n"
"\n"
"action_94 _ = happyReduce_59\n"
"\n"
"action_95 (133) = happyShift action_43\n"
"action_95 (134) = happyShift action_44\n"
"action_95 (135) = happyShift action_45\n"
"action_95 (136) = happyShift action_46\n"
"action_95 (141) = happyShift action_67\n"
"action_95 (142) = happyShift action_68\n"
"action_95 (143) = happyShift action_69\n"
"action_95 (144) = happyShift action_70\n"
"action_95 (145) = happyShift action_71\n"
"action_95 (151) = happyShift action_72\n"
"action_95 (154) = happyShift action_73\n"
"action_95 (165) = happyShift action_74\n"
"action_95 (167) = happyShift action_75\n"
"action_95 (169) = happyShift action_49\n"
"action_95 (170) = happyShift action_76\n"
"action_95 (171) = happyShift action_77\n"
"action_95 (172) = happyShift action_78\n"
"action_95 (173) = happyShift action_79\n"
"action_95 (175) = happyShift action_80\n"
"action_95 (177) = happyShift action_50\n"
"action_95 (181) = happyShift action_82\n"
"action_95 (182) = happyShift action_83\n"
"action_95 (183) = happyShift action_84\n"
"action_95 (184) = happyShift action_85\n"
"action_95 (187) = happyShift action_86\n"
"action_95 (190) = happyShift action_87\n"
"action_95 (192) = happyShift action_52\n"
"action_95 (27) = happyGoto action_54\n"
"action_95 (38) = happyGoto action_55\n"
"action_95 (71) = happyGoto action_56\n"
"action_95 (73) = happyGoto action_57\n"
"action_95 (74) = happyGoto action_58\n"
"action_95 (77) = happyGoto action_59\n"
"action_95 (78) = happyGoto action_60\n"
"action_95 (79) = happyGoto action_61\n"
"action_95 (98) = happyGoto action_62\n"
"action_95 (100) = happyGoto action_63\n"
"action_95 (102) = happyGoto action_64\n"
"action_95 (112) = happyGoto action_38\n"
"action_95 (113) = happyGoto action_39\n"
"action_95 (114) = happyGoto action_65\n"
"action_95 (115) = happyGoto action_41\n"
"action_95 (123) = happyGoto action_66\n"
"action_95 _ = happyFail\n"
"\n"
"action_96 (159) = happyShift action_275\n"
"action_96 _ = happyFail\n"
"\n"
"action_97 _ = happyReduce_286\n"
"\n"
"action_98 (47) = happyGoto action_274\n"
"action_98 _ = happyReduce_104\n"
"\n"
"action_99 _ = happyReduce_98\n"
"\n"
"action_100 (133) = happyShift action_43\n"
"action_100 (135) = happyShift action_45\n"
"action_100 (136) = happyShift action_46\n"
"action_100 (145) = happyShift action_108\n"
"action_100 (151) = happyShift action_109\n"
"action_100 (163) = happyShift action_273\n"
"action_100 (166) = happyReduce_99\n"
"action_100 (169) = happyShift action_49\n"
"action_100 (177) = happyShift action_50\n"
"action_100 (192) = happyShift action_52\n"
"action_100 (41) = happyGoto action_272\n"
"action_100 (42) = happyGoto action_102\n"
"action_100 (113) = happyGoto action_105\n"
"action_100 (114) = happyGoto action_106\n"
"action_100 (115) = happyGoto action_41\n"
"action_100 (132) = happyGoto action_107\n"
"action_100 _ = happyReduce_84\n"
"\n"
"action_101 _ = happyReduce_86\n"
"\n"
"action_102 _ = happyReduce_87\n"
"\n"
"action_103 (159) = happyShift action_271\n"
"action_103 _ = happyFail\n"
"\n"
"action_104 (166) = happyShift action_270\n"
"action_104 _ = happyFail\n"
"\n"
"action_105 _ = happyReduce_289\n"
"\n"
"action_106 _ = happyReduce_92\n"
"\n"
"action_107 _ = happyReduce_88\n"
"\n"
"action_108 (133) = happyShift action_43\n"
"action_108 (135) = happyShift action_45\n"
"action_108 (136) = happyShift action_46\n"
"action_108 (145) = happyShift action_108\n"
"action_108 (146) = happyShift action_268\n"
"action_108 (151) = happyShift action_109\n"
"action_108 (153) = happyShift action_154\n"
"action_108 (163) = happyShift action_269\n"
"action_108 (169) = happyShift action_49\n"
"action_108 (177) = happyShift action_50\n"
"action_108 (192) = happyShift action_52\n"
"action_108 (39) = happyGoto action_265\n"
"action_108 (40) = happyGoto action_251\n"
"action_108 (41) = happyGoto action_101\n"
"action_108 (42) = happyGoto action_102\n"
"action_108 (45) = happyGoto action_266\n"
"action_108 (80) = happyGoto action_267\n"
"action_108 (113) = happyGoto action_105\n"
"action_108 (114) = happyGoto action_106\n"
"action_108 (115) = happyGoto action_41\n"
"action_108 (132) = happyGoto action_107\n"
"action_108 _ = happyFail\n"
"\n"
"action_109 (133) = happyShift action_43\n"
"action_109 (135) = happyShift action_45\n"
"action_109 (136) = happyShift action_46\n"
"action_109 (145) = happyShift action_108\n"
"action_109 (151) = happyShift action_109\n"
"action_109 (152) = happyShift action_264\n"
"action_109 (169) = happyShift action_49\n"
"action_109 (177) = happyShift action_50\n"
"action_109 (192) = happyShift action_52\n"
"action_109 (39) = happyGoto action_263\n"
"action_109 (40) = happyGoto action_251\n"
"action_109 (41) = happyGoto action_101\n"
"action_109 (42) = happyGoto action_102\n"
"action_109 (113) = happyGoto action_105\n"
"action_109 (114) = happyGoto action_106\n"
"action_109 (115) = happyGoto action_41\n"
"action_109 (132) = happyGoto action_107\n"
"action_109 _ = happyFail\n"
"\n"
"action_110 (191) = happyShift action_262\n"
"action_110 (60) = happyGoto action_261\n"
"action_110 _ = happyReduce_134\n"
"\n"
"action_111 (135) = happyShift action_10\n"
"action_111 (136) = happyShift action_11\n"
"action_111 (127) = happyGoto action_260\n"
"action_111 _ = happyFail\n"
"\n"
"action_112 _ = happyReduce_29\n"
"\n"
"action_113 _ = happyReduce_160\n"
"\n"
"action_114 (133) = happyShift action_43\n"
"action_114 (134) = happyShift action_44\n"
"action_114 (135) = happyShift action_45\n"
"action_114 (136) = happyShift action_46\n"
"action_114 (141) = happyShift action_67\n"
"action_114 (142) = happyShift action_68\n"
"action_114 (143) = happyShift action_69\n"
"action_114 (144) = happyShift action_70\n"
"action_114 (145) = happyShift action_71\n"
"action_114 (147) = happyShift action_257\n"
"action_114 (151) = happyShift action_72\n"
"action_114 (154) = happyShift action_73\n"
"action_114 (160) = happyShift action_125\n"
"action_114 (165) = happyShift action_74\n"
"action_114 (167) = happyShift action_75\n"
"action_114 (169) = happyShift action_49\n"
"action_114 (170) = happyShift action_76\n"
"action_114 (175) = happyShift action_80\n"
"action_114 (177) = happyShift action_50\n"
"action_114 (178) = happyShift action_126\n"
"action_114 (185) = happyShift action_258\n"
"action_114 (192) = happyShift action_52\n"
"action_114 (68) = happyGoto action_253\n"
"action_114 (69) = happyGoto action_120\n"
"action_114 (70) = happyGoto action_121\n"
"action_114 (71) = happyGoto action_254\n"
"action_114 (72) = happyGoto action_123\n"
"action_114 (73) = happyGoto action_57\n"
"action_114 (74) = happyGoto action_58\n"
"action_114 (77) = happyGoto action_59\n"
"action_114 (78) = happyGoto action_60\n"
"action_114 (79) = happyGoto action_61\n"
"action_114 (93) = happyGoto action_255\n"
"action_114 (95) = happyGoto action_259\n"
"action_114 (98) = happyGoto action_62\n"
"action_114 (100) = happyGoto action_124\n"
"action_114 (102) = happyGoto action_64\n"
"action_114 (112) = happyGoto action_38\n"
"action_114 (113) = happyGoto action_39\n"
"action_114 (114) = happyGoto action_65\n"
"action_114 (115) = happyGoto action_41\n"
"action_114 (123) = happyGoto action_66\n"
"action_114 _ = happyFail\n"
"\n"
"action_115 (133) = happyShift action_43\n"
"action_115 (134) = happyShift action_44\n"
"action_115 (135) = happyShift action_45\n"
"action_115 (136) = happyShift action_46\n"
"action_115 (141) = happyShift action_67\n"
"action_115 (142) = happyShift action_68\n"
"action_115 (143) = happyShift action_69\n"
"action_115 (144) = happyShift action_70\n"
"action_115 (145) = happyShift action_71\n"
"action_115 (147) = happyShift action_257\n"
"action_115 (151) = happyShift action_72\n"
"action_115 (154) = happyShift action_73\n"
"action_115 (160) = happyShift action_125\n"
"action_115 (165) = happyShift action_74\n"
"action_115 (167) = happyShift action_75\n"
"action_115 (169) = happyShift action_49\n"
"action_115 (170) = happyShift action_76\n"
"action_115 (175) = happyShift action_80\n"
"action_115 (177) = happyShift action_50\n"
"action_115 (178) = happyShift action_126\n"
"action_115 (185) = happyShift action_258\n"
"action_115 (192) = happyShift action_52\n"
"action_115 (68) = happyGoto action_253\n"
"action_115 (69) = happyGoto action_120\n"
"action_115 (70) = happyGoto action_121\n"
"action_115 (71) = happyGoto action_254\n"
"action_115 (72) = happyGoto action_123\n"
"action_115 (73) = happyGoto action_57\n"
"action_115 (74) = happyGoto action_58\n"
"action_115 (77) = happyGoto action_59\n"
"action_115 (78) = happyGoto action_60\n"
"action_115 (79) = happyGoto action_61\n"
"action_115 (93) = happyGoto action_255\n"
"action_115 (95) = happyGoto action_256\n"
"action_115 (98) = happyGoto action_62\n"
"action_115 (100) = happyGoto action_124\n"
"action_115 (102) = happyGoto action_64\n"
"action_115 (112) = happyGoto action_38\n"
"action_115 (113) = happyGoto action_39\n"
"action_115 (114) = happyGoto action_65\n"
"action_115 (115) = happyGoto action_41\n"
"action_115 (123) = happyGoto action_66\n"
"action_115 _ = happyFail\n"
"\n"
"action_116 (133) = happyShift action_43\n"
"action_116 (135) = happyShift action_45\n"
"action_116 (136) = happyShift action_46\n"
"action_116 (145) = happyShift action_108\n"
"action_116 (151) = happyShift action_109\n"
"action_116 (169) = happyShift action_49\n"
"action_116 (177) = happyShift action_50\n"
"action_116 (192) = happyShift action_52\n"
"action_116 (32) = happyGoto action_249\n"
"action_116 (39) = happyGoto action_250\n"
"action_116 (40) = happyGoto action_251\n"
"action_116 (41) = happyGoto action_101\n"
"action_116 (42) = happyGoto action_102\n"
"action_116 (45) = happyGoto action_252\n"
"action_116 (113) = happyGoto action_105\n"
"action_116 (114) = happyGoto action_106\n"
"action_116 (115) = happyGoto action_41\n"
"action_116 (132) = happyGoto action_107\n"
"action_116 _ = happyReduce_70\n"
"\n"
"action_117 (159) = happyShift action_248\n"
"action_117 _ = happyFail\n"
"\n"
"action_118 (191) = happyShift action_247\n"
"action_118 (59) = happyGoto action_246\n"
"action_118 _ = happyReduce_131\n"
"\n"
"action_119 (188) = happyShift action_245\n"
"action_119 _ = happyFail\n"
"\n"
"action_120 _ = happyReduce_148\n"
"\n"
"action_121 _ = happyReduce_149\n"
"\n"
"action_122 (137) = happyShift action_172\n"
"action_122 (138) = happyShift action_150\n"
"action_122 (139) = happyShift action_151\n"
"action_122 (140) = happyShift action_152\n"
"action_122 (155) = happyShift action_173\n"
"action_122 (157) = happyShift action_156\n"
"action_122 (158) = happyShift action_231\n"
"action_122 (167) = happyShift action_175\n"
"action_122 (168) = happyShift action_176\n"
"action_122 (104) = happyGoto action_165\n"
"action_122 (107) = happyGoto action_166\n"
"action_122 (109) = happyGoto action_244\n"
"action_122 (111) = happyGoto action_168\n"
"action_122 (116) = happyGoto action_142\n"
"action_122 (117) = happyGoto action_143\n"
"action_122 (118) = happyGoto action_169\n"
"action_122 (120) = happyGoto action_146\n"
"action_122 (122) = happyGoto action_170\n"
"action_122 _ = happyReduce_150\n"
"\n"
"action_123 _ = happyReduce_152\n"
"\n"
"action_124 (164) = happyShift action_159\n"
"action_124 _ = happyReduce_173\n"
"\n"
"action_125 (124) = happyGoto action_243\n"
"action_125 _ = happyReduce_279\n"
"\n"
"action_126 (133) = happyShift action_43\n"
"action_126 (134) = happyShift action_44\n"
"action_126 (135) = happyShift action_45\n"
"action_126 (136) = happyShift action_46\n"
"action_126 (141) = happyShift action_67\n"
"action_126 (142) = happyShift action_68\n"
"action_126 (143) = happyShift action_69\n"
"action_126 (144) = happyShift action_70\n"
"action_126 (145) = happyShift action_71\n"
"action_126 (151) = happyShift action_72\n"
"action_126 (154) = happyShift action_73\n"
"action_126 (160) = happyShift action_125\n"
"action_126 (165) = happyShift action_74\n"
"action_126 (167) = happyShift action_75\n"
"action_126 (169) = happyShift action_49\n"
"action_126 (170) = happyShift action_76\n"
"action_126 (175) = happyShift action_80\n"
"action_126 (177) = happyShift action_50\n"
"action_126 (178) = happyShift action_126\n"
"action_126 (185) = happyShift action_127\n"
"action_126 (192) = happyShift action_52\n"
"action_126 (68) = happyGoto action_242\n"
"action_126 (69) = happyGoto action_120\n"
"action_126 (70) = happyGoto action_121\n"
"action_126 (71) = happyGoto action_122\n"
"action_126 (72) = happyGoto action_123\n"
"action_126 (73) = happyGoto action_57\n"
"action_126 (74) = happyGoto action_58\n"
"action_126 (77) = happyGoto action_59\n"
"action_126 (78) = happyGoto action_60\n"
"action_126 (79) = happyGoto action_61\n"
"action_126 (98) = happyGoto action_62\n"
"action_126 (100) = happyGoto action_124\n"
"action_126 (102) = happyGoto action_64\n"
"action_126 (112) = happyGoto action_38\n"
"action_126 (113) = happyGoto action_39\n"
"action_126 (114) = happyGoto action_65\n"
"action_126 (115) = happyGoto action_41\n"
"action_126 (123) = happyGoto action_66\n"
"action_126 _ = happyFail\n"
"\n"
"action_127 (148) = happyShift action_241\n"
"action_127 (36) = happyGoto action_239\n"
"action_127 (125) = happyGoto action_240\n"
"action_127 _ = happyReduce_280\n"
"\n"
"action_128 (133) = happyShift action_43\n"
"action_128 (134) = happyShift action_44\n"
"action_128 (135) = happyShift action_45\n"
"action_128 (136) = happyShift action_46\n"
"action_128 (141) = happyShift action_67\n"
"action_128 (142) = happyShift action_68\n"
"action_128 (143) = happyShift action_69\n"
"action_128 (144) = happyShift action_70\n"
"action_128 (145) = happyShift action_71\n"
"action_128 (151) = happyShift action_72\n"
"action_128 (154) = happyShift action_73\n"
"action_128 (165) = happyShift action_74\n"
"action_128 (169) = happyShift action_49\n"
"action_128 (177) = happyShift action_50\n"
"action_128 (192) = happyShift action_52\n"
"action_128 (77) = happyGoto action_161\n"
"action_128 (78) = happyGoto action_60\n"
"action_128 (79) = happyGoto action_61\n"
"action_128 (98) = happyGoto action_62\n"
"action_128 (100) = happyGoto action_124\n"
"action_128 (102) = happyGoto action_64\n"
"action_128 (112) = happyGoto action_38\n"
"action_128 (113) = happyGoto action_39\n"
"action_128 (114) = happyGoto action_65\n"
"action_128 (115) = happyGoto action_41\n"
"action_128 (123) = happyGoto action_66\n"
"action_128 _ = happyReduce_159\n"
"\n"
"action_129 _ = happyReduce_168\n"
"\n"
"action_130 (153) = happyShift action_236\n"
"action_130 (156) = happyShift action_237\n"
"action_130 (161) = happyShift action_238\n"
"action_130 _ = happyReduce_186\n"
"\n"
"action_131 (152) = happyShift action_235\n"
"action_131 _ = happyFail\n"
"\n"
"action_132 (153) = happyShift action_234\n"
"action_132 _ = happyReduce_187\n"
"\n"
"action_133 _ = happyReduce_224\n"
"\n"
"action_134 (146) = happyShift action_232\n"
"action_134 (153) = happyShift action_233\n"
"action_134 _ = happyFail\n"
"\n"
"action_135 (137) = happyShift action_172\n"
"action_135 (138) = happyShift action_150\n"
"action_135 (139) = happyShift action_151\n"
"action_135 (140) = happyShift action_152\n"
"action_135 (155) = happyShift action_173\n"
"action_135 (157) = happyShift action_156\n"
"action_135 (158) = happyShift action_231\n"
"action_135 (167) = happyShift action_175\n"
"action_135 (168) = happyShift action_176\n"
"action_135 (104) = happyGoto action_165\n"
"action_135 (107) = happyGoto action_166\n"
"action_135 (109) = happyGoto action_230\n"
"action_135 (111) = happyGoto action_168\n"
"action_135 (116) = happyGoto action_142\n"
"action_135 (117) = happyGoto action_143\n"
"action_135 (118) = happyGoto action_169\n"
"action_135 (120) = happyGoto action_146\n"
"action_135 (122) = happyGoto action_170\n"
"action_135 _ = happyReduce_150\n"
"\n"
"action_136 (146) = happyShift action_228\n"
"action_136 (153) = happyShift action_229\n"
"action_136 _ = happyFail\n"
"\n"
"action_137 (146) = happyShift action_226\n"
"action_137 (153) = happyShift action_227\n"
"action_137 _ = happyFail\n"
"\n"
"action_138 _ = happyReduce_249\n"
"\n"
"action_139 _ = happyReduce_250\n"
"\n"
"action_140 (133) = happyShift action_43\n"
"action_140 (134) = happyShift action_44\n"
"action_140 (135) = happyShift action_45\n"
"action_140 (136) = happyShift action_46\n"
"action_140 (141) = happyShift action_67\n"
"action_140 (142) = happyShift action_68\n"
"action_140 (143) = happyShift action_69\n"
"action_140 (144) = happyShift action_70\n"
"action_140 (145) = happyShift action_71\n"
"action_140 (151) = happyShift action_72\n"
"action_140 (154) = happyShift action_73\n"
"action_140 (160) = happyShift action_125\n"
"action_140 (165) = happyShift action_74\n"
"action_140 (167) = happyShift action_75\n"
"action_140 (169) = happyShift action_49\n"
"action_140 (170) = happyShift action_76\n"
"action_140 (175) = happyShift action_80\n"
"action_140 (177) = happyShift action_50\n"
"action_140 (178) = happyShift action_126\n"
"action_140 (185) = happyShift action_127\n"
"action_140 (192) = happyShift action_52\n"
"action_140 (69) = happyGoto action_224\n"
"action_140 (70) = happyGoto action_121\n"
"action_140 (71) = happyGoto action_225\n"
"action_140 (72) = happyGoto action_123\n"
"action_140 (73) = happyGoto action_57\n"
"action_140 (74) = happyGoto action_58\n"
"action_140 (77) = happyGoto action_59\n"
"action_140 (78) = happyGoto action_60\n"
"action_140 (79) = happyGoto action_61\n"
"action_140 (98) = happyGoto action_62\n"
"action_140 (100) = happyGoto action_124\n"
"action_140 (102) = happyGoto action_64\n"
"action_140 (112) = happyGoto action_38\n"
"action_140 (113) = happyGoto action_39\n"
"action_140 (114) = happyGoto action_65\n"
"action_140 (115) = happyGoto action_41\n"
"action_140 (123) = happyGoto action_66\n"
"action_140 _ = happyFail\n"
"\n"
"action_141 (146) = happyShift action_223\n"
"action_141 _ = happyReduce_243\n"
"\n"
"action_142 _ = happyReduce_252\n"
"\n"
"action_143 _ = happyReduce_262\n"
"\n"
"action_144 (146) = happyShift action_222\n"
"action_144 _ = happyFail\n"
"\n"
"action_145 _ = happyReduce_239\n"
"\n"
"action_146 _ = happyReduce_265\n"
"\n"
"action_147 _ = happyReduce_267\n"
"\n"
"action_148 (146) = happyReduce_266\n"
"action_148 _ = happyReduce_268\n"
"\n"
"action_149 (146) = happyReduce_269\n"
"action_149 _ = happyReduce_272\n"
"\n"
"action_150 _ = happyReduce_264\n"
"\n"
"action_151 _ = happyReduce_274\n"
"\n"
"action_152 _ = happyReduce_263\n"
"\n"
"action_153 _ = happyReduce_223\n"
"\n"
"action_154 _ = happyReduce_183\n"
"\n"
"action_155 (133) = happyShift action_43\n"
"action_155 (134) = happyShift action_44\n"
"action_155 (135) = happyShift action_45\n"
"action_155 (136) = happyShift action_46\n"
"action_155 (169) = happyShift action_49\n"
"action_155 (177) = happyShift action_50\n"
"action_155 (192) = happyShift action_52\n"
"action_155 (112) = happyGoto action_221\n"
"action_155 (113) = happyGoto action_39\n"
"action_155 (114) = happyGoto action_210\n"
"action_155 (115) = happyGoto action_41\n"
"action_155 _ = happyFail\n"
"\n"
"action_156 _ = happyReduce_251\n"
"\n"
"action_157 (133) = happyShift action_43\n"
"action_157 (134) = happyShift action_44\n"
"action_157 (135) = happyShift action_45\n"
"action_157 (136) = happyShift action_46\n"
"action_157 (141) = happyShift action_67\n"
"action_157 (142) = happyShift action_68\n"
"action_157 (143) = happyShift action_69\n"
"action_157 (144) = happyShift action_70\n"
"action_157 (145) = happyShift action_71\n"
"action_157 (151) = happyShift action_72\n"
"action_157 (154) = happyShift action_73\n"
"action_157 (165) = happyShift action_74\n"
"action_157 (169) = happyShift action_49\n"
"action_157 (177) = happyShift action_50\n"
"action_157 (192) = happyShift action_52\n"
"action_157 (74) = happyGoto action_128\n"
"action_157 (77) = happyGoto action_59\n"
"action_157 (78) = happyGoto action_60\n"
"action_157 (79) = happyGoto action_61\n"
"action_157 (98) = happyGoto action_62\n"
"action_157 (100) = happyGoto action_124\n"
"action_157 (102) = happyGoto action_64\n"
"action_157 (112) = happyGoto action_38\n"
"action_157 (113) = happyGoto action_39\n"
"action_157 (114) = happyGoto action_65\n"
"action_157 (115) = happyGoto action_41\n"
"action_157 (123) = happyGoto action_66\n"
"action_157 _ = happyReduce_270\n"
"\n"
"action_158 (146) = happyReduce_271\n"
"action_158 _ = happyReduce_273\n"
"\n"
"action_159 (133) = happyShift action_43\n"
"action_159 (134) = happyShift action_44\n"
"action_159 (135) = happyShift action_45\n"
"action_159 (136) = happyShift action_46\n"
"action_159 (141) = happyShift action_67\n"
"action_159 (142) = happyShift action_68\n"
"action_159 (143) = happyShift action_69\n"
"action_159 (144) = happyShift action_70\n"
"action_159 (145) = happyShift action_71\n"
"action_159 (151) = happyShift action_72\n"
"action_159 (154) = happyShift action_73\n"
"action_159 (165) = happyShift action_74\n"
"action_159 (169) = happyShift action_49\n"
"action_159 (177) = happyShift action_50\n"
"action_159 (192) = happyShift action_52\n"
"action_159 (77) = happyGoto action_220\n"
"action_159 (78) = happyGoto action_60\n"
"action_159 (79) = happyGoto action_61\n"
"action_159 (98) = happyGoto action_62\n"
"action_159 (100) = happyGoto action_124\n"
"action_159 (102) = happyGoto action_64\n"
"action_159 (112) = happyGoto action_38\n"
"action_159 (113) = happyGoto action_39\n"
"action_159 (114) = happyGoto action_65\n"
"action_159 (115) = happyGoto action_41\n"
"action_159 (123) = happyGoto action_66\n"
"action_159 _ = happyFail\n"
"\n"
"action_160 (133) = happyShift action_43\n"
"action_160 (134) = happyShift action_44\n"
"action_160 (145) = happyShift action_47\n"
"action_160 (149) = happyShift action_219\n"
"action_160 (169) = happyShift action_49\n"
"action_160 (177) = happyShift action_50\n"
"action_160 (192) = happyShift action_52\n"
"action_160 (96) = happyGoto action_216\n"
"action_160 (97) = happyGoto action_217\n"
"action_160 (100) = happyGoto action_218\n"
"action_160 (112) = happyGoto action_38\n"
"action_160 (113) = happyGoto action_39\n"
"action_160 _ = happyFail\n"
"\n"
"action_161 _ = happyReduce_162\n"
"\n"
"action_162 (191) = happyShift action_215\n"
"action_162 (64) = happyGoto action_214\n"
"action_162 _ = happyReduce_141\n"
"\n"
"action_163 (161) = happyReduce_279\n"
"action_163 (67) = happyGoto action_213\n"
"action_163 (124) = happyGoto action_171\n"
"action_163 _ = happyReduce_143\n"
"\n"
"action_164 _ = happyReduce_145\n"
"\n"
"action_165 _ = happyReduce_247\n"
"\n"
"action_166 _ = happyReduce_248\n"
"\n"
"action_167 (133) = happyShift action_43\n"
"action_167 (134) = happyShift action_44\n"
"action_167 (135) = happyShift action_45\n"
"action_167 (136) = happyShift action_46\n"
"action_167 (141) = happyShift action_67\n"
"action_167 (142) = happyShift action_68\n"
"action_167 (143) = happyShift action_69\n"
"action_167 (144) = happyShift action_70\n"
"action_167 (145) = happyShift action_71\n"
"action_167 (151) = happyShift action_72\n"
"action_167 (154) = happyShift action_73\n"
"action_167 (165) = happyShift action_74\n"
"action_167 (167) = happyShift action_75\n"
"action_167 (169) = happyShift action_49\n"
"action_167 (170) = happyShift action_76\n"
"action_167 (175) = happyShift action_80\n"
"action_167 (177) = happyShift action_50\n"
"action_167 (192) = happyShift action_52\n"
"action_167 (73) = happyGoto action_212\n"
"action_167 (74) = happyGoto action_58\n"
"action_167 (77) = happyGoto action_59\n"
"action_167 (78) = happyGoto action_60\n"
"action_167 (79) = happyGoto action_61\n"
"action_167 (98) = happyGoto action_62\n"
"action_167 (100) = happyGoto action_124\n"
"action_167 (102) = happyGoto action_64\n"
"action_167 (112) = happyGoto action_38\n"
"action_167 (113) = happyGoto action_39\n"
"action_167 (114) = happyGoto action_65\n"
"action_167 (115) = happyGoto action_41\n"
"action_167 (123) = happyGoto action_66\n"
"action_167 _ = happyFail\n"
"\n"
"action_168 _ = happyReduce_243\n"
"\n"
"action_169 _ = happyReduce_237\n"
"\n"
"action_170 _ = happyReduce_266\n"
"\n"
"action_171 (161) = happyShift action_211\n"
"action_171 _ = happyFail\n"
"\n"
"action_172 _ = happyReduce_269\n"
"\n"
"action_173 (133) = happyShift action_43\n"
"action_173 (134) = happyShift action_44\n"
"action_173 (135) = happyShift action_45\n"
"action_173 (136) = happyShift action_46\n"
"action_173 (169) = happyShift action_49\n"
"action_173 (177) = happyShift action_50\n"
"action_173 (192) = happyShift action_52\n"
"action_173 (112) = happyGoto action_209\n"
"action_173 (113) = happyGoto action_39\n"
"action_173 (114) = happyGoto action_210\n"
"action_173 (115) = happyGoto action_41\n"
"action_173 _ = happyFail\n"
"\n"
"action_174 (133) = happyShift action_43\n"
"action_174 (134) = happyShift action_44\n"
"action_174 (135) = happyShift action_45\n"
"action_174 (136) = happyShift action_46\n"
"action_174 (141) = happyShift action_67\n"
"action_174 (142) = happyShift action_68\n"
"action_174 (143) = happyShift action_69\n"
"action_174 (144) = happyShift action_70\n"
"action_174 (145) = happyShift action_71\n"
"action_174 (151) = happyShift action_72\n"
"action_174 (154) = happyShift action_73\n"
"action_174 (160) = happyShift action_125\n"
"action_174 (165) = happyShift action_74\n"
"action_174 (167) = happyShift action_75\n"
"action_174 (169) = happyShift action_49\n"
"action_174 (170) = happyShift action_76\n"
"action_174 (175) = happyShift action_80\n"
"action_174 (177) = happyShift action_50\n"
"action_174 (178) = happyShift action_126\n"
"action_174 (185) = happyShift action_127\n"
"action_174 (192) = happyShift action_52\n"
"action_174 (68) = happyGoto action_208\n"
"action_174 (69) = happyGoto action_120\n"
"action_174 (70) = happyGoto action_121\n"
"action_174 (71) = happyGoto action_122\n"
"action_174 (72) = happyGoto action_123\n"
"action_174 (73) = happyGoto action_57\n"
"action_174 (74) = happyGoto action_58\n"
"action_174 (77) = happyGoto action_59\n"
"action_174 (78) = happyGoto action_60\n"
"action_174 (79) = happyGoto action_61\n"
"action_174 (98) = happyGoto action_62\n"
"action_174 (100) = happyGoto action_124\n"
"action_174 (102) = happyGoto action_64\n"
"action_174 (112) = happyGoto action_38\n"
"action_174 (113) = happyGoto action_39\n"
"action_174 (114) = happyGoto action_65\n"
"action_174 (115) = happyGoto action_41\n"
"action_174 (123) = happyGoto action_66\n"
"action_174 _ = happyFail\n"
"\n"
"action_175 _ = happyReduce_270\n"
"\n"
"action_176 _ = happyReduce_271\n"
"\n"
"action_177 (133) = happyShift action_43\n"
"action_177 (145) = happyShift action_207\n"
"action_177 (169) = happyShift action_49\n"
"action_177 (177) = happyShift action_50\n"
"action_177 (192) = happyShift action_52\n"
"action_177 (99) = happyGoto action_206\n"
"action_177 (113) = happyGoto action_193\n"
"action_177 _ = happyFail\n"
"\n"
"action_178 (133) = happyShift action_43\n"
"action_178 (135) = happyShift action_45\n"
"action_178 (136) = happyShift action_46\n"
"action_178 (145) = happyShift action_108\n"
"action_178 (151) = happyShift action_109\n"
"action_178 (169) = happyShift action_49\n"
"action_178 (177) = happyShift action_50\n"
"action_178 (192) = happyShift action_52\n"
"action_178 (39) = happyGoto action_99\n"
"action_178 (40) = happyGoto action_100\n"
"action_178 (41) = happyGoto action_101\n"
"action_178 (42) = happyGoto action_102\n"
"action_178 (43) = happyGoto action_205\n"
"action_178 (44) = happyGoto action_104\n"
"action_178 (113) = happyGoto action_105\n"
"action_178 (114) = happyGoto action_106\n"
"action_178 (115) = happyGoto action_41\n"
"action_178 (132) = happyGoto action_107\n"
"action_178 _ = happyFail\n"
"\n"
"action_179 (137) = happyShift action_172\n"
"action_179 (138) = happyShift action_150\n"
"action_179 (155) = happyShift action_204\n"
"action_179 (167) = happyShift action_175\n"
"action_179 (168) = happyShift action_176\n"
"action_179 (28) = happyGoto action_198\n"
"action_179 (103) = happyGoto action_199\n"
"action_179 (106) = happyGoto action_200\n"
"action_179 (108) = happyGoto action_201\n"
"action_179 (117) = happyGoto action_202\n"
"action_179 (120) = happyGoto action_203\n"
"action_179 _ = happyFail\n"
"\n"
"action_180 _ = happyReduce_52\n"
"\n"
"action_181 _ = happyReduce_1\n"
"\n"
"action_182 _ = happyReduce_25\n"
"\n"
"action_183 (133) = happyShift action_43\n"
"action_183 (135) = happyShift action_45\n"
"action_183 (145) = happyShift action_195\n"
"action_183 (146) = happyShift action_196\n"
"action_183 (156) = happyShift action_197\n"
"action_183 (169) = happyShift action_49\n"
"action_183 (177) = happyShift action_50\n"
"action_183 (192) = happyShift action_52\n"
"action_183 (23) = happyGoto action_189\n"
"action_183 (24) = happyGoto action_190\n"
"action_183 (99) = happyGoto action_191\n"
"action_183 (101) = happyGoto action_192\n"
"action_183 (113) = happyGoto action_193\n"
"action_183 (115) = happyGoto action_194\n"
"action_183 _ = happyFail\n"
"\n"
"action_184 (146) = happyShift action_188\n"
"action_184 _ = happyFail\n"
"\n"
"action_185 (133) = happyShift action_43\n"
"action_185 (134) = happyShift action_44\n"
"action_185 (135) = happyShift action_45\n"
"action_185 (136) = happyShift action_46\n"
"action_185 (145) = happyShift action_47\n"
"action_185 (169) = happyShift action_49\n"
"action_185 (177) = happyShift action_50\n"
"action_185 (186) = happyShift action_51\n"
"action_185 (192) = happyShift action_52\n"
"action_185 (13) = happyGoto action_187\n"
"action_185 (100) = happyGoto action_37\n"
"action_185 (112) = happyGoto action_38\n"
"action_185 (113) = happyGoto action_39\n"
"action_185 (114) = happyGoto action_40\n"
"action_185 (115) = happyGoto action_41\n"
"action_185 (130) = happyGoto action_42\n"
"action_185 _ = happyReduce_16\n"
"\n"
"action_186 _ = happyReduce_15\n"
"\n"
"action_187 _ = happyReduce_18\n"
"\n"
"action_188 _ = happyReduce_14\n"
"\n"
"action_189 (146) = happyShift action_342\n"
"action_189 (153) = happyShift action_343\n"
"action_189 _ = happyFail\n"
"\n"
"action_190 _ = happyReduce_47\n"
"\n"
"action_191 _ = happyReduce_48\n"
"\n"
"action_192 _ = happyReduce_49\n"
"\n"
"action_193 _ = happyReduce_227\n"
"\n"
"action_194 _ = happyReduce_231\n"
"\n"
"action_195 (137) = happyShift action_172\n"
"action_195 (138) = happyShift action_150\n"
"action_195 (167) = happyShift action_175\n"
"action_195 (168) = happyShift action_176\n"
"action_195 (117) = happyGoto action_341\n"
"action_195 (120) = happyGoto action_336\n"
"action_195 _ = happyFail\n"
"\n"
"action_196 _ = happyReduce_23\n"
"\n"
"action_197 (146) = happyShift action_340\n"
"action_197 _ = happyFail\n"
"\n"
"action_198 (153) = happyShift action_339\n"
"action_198 _ = happyReduce_50\n"
"\n"
"action_199 _ = happyReduce_245\n"
"\n"
"action_200 _ = happyReduce_246\n"
"\n"
"action_201 _ = happyReduce_57\n"
"\n"
"action_202 _ = happyReduce_241\n"
"\n"
"action_203 _ = happyReduce_235\n"
"\n"
"action_204 (133) = happyShift action_43\n"
"action_204 (135) = happyShift action_45\n"
"action_204 (169) = happyShift action_49\n"
"action_204 (177) = happyShift action_50\n"
"action_204 (192) = happyShift action_52\n"
"action_204 (113) = happyGoto action_337\n"
"action_204 (115) = happyGoto action_338\n"
"action_204 _ = happyFail\n"
"\n"
"action_205 _ = happyReduce_80\n"
"\n"
"action_206 _ = happyReduce_81\n"
"\n"
"action_207 (137) = happyShift action_172\n"
"action_207 (167) = happyShift action_175\n"
"action_207 (168) = happyShift action_176\n"
"action_207 (120) = happyGoto action_336\n"
"action_207 _ = happyFail\n"
"\n"
"action_208 _ = happyReduce_142\n"
"\n"
"action_209 (155) = happyShift action_335\n"
"action_209 _ = happyFail\n"
"\n"
"action_210 (155) = happyShift action_334\n"
"action_210 _ = happyFail\n"
"\n"
"action_211 (133) = happyShift action_43\n"
"action_211 (134) = happyShift action_44\n"
"action_211 (135) = happyShift action_45\n"
"action_211 (136) = happyShift action_46\n"
"action_211 (141) = happyShift action_67\n"
"action_211 (142) = happyShift action_68\n"
"action_211 (143) = happyShift action_69\n"
"action_211 (144) = happyShift action_70\n"
"action_211 (145) = happyShift action_71\n"
"action_211 (151) = happyShift action_72\n"
"action_211 (154) = happyShift action_73\n"
"action_211 (160) = happyShift action_125\n"
"action_211 (165) = happyShift action_74\n"
"action_211 (167) = happyShift action_75\n"
"action_211 (169) = happyShift action_49\n"
"action_211 (170) = happyShift action_76\n"
"action_211 (175) = happyShift action_80\n"
"action_211 (177) = happyShift action_50\n"
"action_211 (178) = happyShift action_126\n"
"action_211 (185) = happyShift action_127\n"
"action_211 (192) = happyShift action_52\n"
"action_211 (69) = happyGoto action_333\n"
"action_211 (70) = happyGoto action_121\n"
"action_211 (71) = happyGoto action_225\n"
"action_211 (72) = happyGoto action_123\n"
"action_211 (73) = happyGoto action_57\n"
"action_211 (74) = happyGoto action_58\n"
"action_211 (77) = happyGoto action_59\n"
"action_211 (78) = happyGoto action_60\n"
"action_211 (79) = happyGoto action_61\n"
"action_211 (98) = happyGoto action_62\n"
"action_211 (100) = happyGoto action_124\n"
"action_211 (102) = happyGoto action_64\n"
"action_211 (112) = happyGoto action_38\n"
"action_211 (113) = happyGoto action_39\n"
"action_211 (114) = happyGoto action_65\n"
"action_211 (115) = happyGoto action_41\n"
"action_211 (123) = happyGoto action_66\n"
"action_211 _ = happyFail\n"
"\n"
"action_212 _ = happyReduce_153\n"
"\n"
"action_213 _ = happyReduce_144\n"
"\n"
"action_214 _ = happyReduce_139\n"
"\n"
"action_215 (148) = happyShift action_241\n"
"action_215 (36) = happyGoto action_332\n"
"action_215 (125) = happyGoto action_240\n"
"action_215 _ = happyReduce_280\n"
"\n"
"action_216 (149) = happyShift action_330\n"
"action_216 (153) = happyShift action_331\n"
"action_216 _ = happyFail\n"
"\n"
"action_217 _ = happyReduce_221\n"
"\n"
"action_218 (159) = happyShift action_329\n"
"action_218 _ = happyFail\n"
"\n"
"action_219 _ = happyReduce_170\n"
"\n"
"action_220 _ = happyReduce_167\n"
"\n"
"action_221 (155) = happyShift action_328\n"
"action_221 _ = happyFail\n"
"\n"
"action_222 _ = happyReduce_230\n"
"\n"
"action_223 _ = happyReduce_234\n"
"\n"
"action_224 (146) = happyShift action_327\n"
"action_224 _ = happyFail\n"
"\n"
"action_225 (137) = happyShift action_172\n"
"action_225 (138) = happyShift action_150\n"
"action_225 (139) = happyShift action_151\n"
"action_225 (140) = happyShift action_152\n"
"action_225 (155) = happyShift action_173\n"
"action_225 (157) = happyShift action_156\n"
"action_225 (167) = happyShift action_175\n"
"action_225 (168) = happyShift action_176\n"
"action_225 (104) = happyGoto action_165\n"
"action_225 (107) = happyGoto action_166\n"
"action_225 (109) = happyGoto action_244\n"
"action_225 (111) = happyGoto action_168\n"
"action_225 (116) = happyGoto action_142\n"
"action_225 (117) = happyGoto action_143\n"
"action_225 (118) = happyGoto action_169\n"
"action_225 (120) = happyGoto action_146\n"
"action_225 (122) = happyGoto action_170\n"
"action_225 _ = happyReduce_150\n"
"\n"
"action_226 _ = happyReduce_177\n"
"\n"
"action_227 (133) = happyShift action_43\n"
"action_227 (134) = happyShift action_44\n"
"action_227 (135) = happyShift action_45\n"
"action_227 (136) = happyShift action_46\n"
"action_227 (141) = happyShift action_67\n"
"action_227 (142) = happyShift action_68\n"
"action_227 (143) = happyShift action_69\n"
"action_227 (144) = happyShift action_70\n"
"action_227 (145) = happyShift action_71\n"
"action_227 (151) = happyShift action_72\n"
"action_227 (154) = happyShift action_73\n"
"action_227 (160) = happyShift action_125\n"
"action_227 (165) = happyShift action_74\n"
"action_227 (167) = happyShift action_75\n"
"action_227 (169) = happyShift action_49\n"
"action_227 (170) = happyShift action_76\n"
"action_227 (175) = happyShift action_80\n"
"action_227 (177) = happyShift action_50\n"
"action_227 (178) = happyShift action_126\n"
"action_227 (185) = happyShift action_127\n"
"action_227 (192) = happyShift action_52\n"
"action_227 (68) = happyGoto action_326\n"
"action_227 (69) = happyGoto action_120\n"
"action_227 (70) = happyGoto action_121\n"
"action_227 (71) = happyGoto action_122\n"
"action_227 (72) = happyGoto action_123\n"
"action_227 (73) = happyGoto action_57\n"
"action_227 (74) = happyGoto action_58\n"
"action_227 (77) = happyGoto action_59\n"
"action_227 (78) = happyGoto action_60\n"
"action_227 (79) = happyGoto action_61\n"
"action_227 (98) = happyGoto action_62\n"
"action_227 (100) = happyGoto action_124\n"
"action_227 (102) = happyGoto action_64\n"
"action_227 (112) = happyGoto action_38\n"
"action_227 (113) = happyGoto action_39\n"
"action_227 (114) = happyGoto action_65\n"
"action_227 (115) = happyGoto action_41\n"
"action_227 (123) = happyGoto action_66\n"
"action_227 _ = happyFail\n"
"\n"
"action_228 _ = happyReduce_225\n"
"\n"
"action_229 _ = happyReduce_182\n"
"\n"
"action_230 (133) = happyShift action_43\n"
"action_230 (134) = happyShift action_44\n"
"action_230 (135) = happyShift action_45\n"
"action_230 (136) = happyShift action_46\n"
"action_230 (141) = happyShift action_67\n"
"action_230 (142) = happyShift action_68\n"
"action_230 (143) = happyShift action_69\n"
"action_230 (144) = happyShift action_70\n"
"action_230 (145) = happyShift action_71\n"
"action_230 (146) = happyShift action_325\n"
"action_230 (151) = happyShift action_72\n"
"action_230 (154) = happyShift action_73\n"
"action_230 (160) = happyShift action_125\n"
"action_230 (165) = happyShift action_74\n"
"action_230 (167) = happyShift action_75\n"
"action_230 (169) = happyShift action_49\n"
"action_230 (170) = happyShift action_76\n"
"action_230 (175) = happyShift action_80\n"
"action_230 (177) = happyShift action_50\n"
"action_230 (178) = happyShift action_126\n"
"action_230 (185) = happyShift action_127\n"
"action_230 (192) = happyShift action_52\n"
"action_230 (72) = happyGoto action_306\n"
"action_230 (73) = happyGoto action_212\n"
"action_230 (74) = happyGoto action_58\n"
"action_230 (77) = happyGoto action_59\n"
"action_230 (78) = happyGoto action_60\n"
"action_230 (79) = happyGoto action_61\n"
"action_230 (98) = happyGoto action_62\n"
"action_230 (100) = happyGoto action_124\n"
"action_230 (102) = happyGoto action_64\n"
"action_230 (112) = happyGoto action_38\n"
"action_230 (113) = happyGoto action_39\n"
"action_230 (114) = happyGoto action_65\n"
"action_230 (115) = happyGoto action_41\n"
"action_230 (123) = happyGoto action_66\n"
"action_230 _ = happyFail\n"
"\n"
"action_231 (124) = happyGoto action_324\n"
"action_231 _ = happyReduce_279\n"
"\n"
"action_232 _ = happyReduce_176\n"
"\n"
"action_233 (133) = happyShift action_43\n"
"action_233 (134) = happyShift action_44\n"
"action_233 (135) = happyShift action_45\n"
"action_233 (136) = happyShift action_46\n"
"action_233 (141) = happyShift action_67\n"
"action_233 (142) = happyShift action_68\n"
"action_233 (143) = happyShift action_69\n"
"action_233 (144) = happyShift action_70\n"
"action_233 (145) = happyShift action_71\n"
"action_233 (151) = happyShift action_72\n"
"action_233 (154) = happyShift action_73\n"
"action_233 (160) = happyShift action_125\n"
"action_233 (165) = happyShift action_74\n"
"action_233 (167) = happyShift action_75\n"
"action_233 (169) = happyShift action_49\n"
"action_233 (170) = happyShift action_76\n"
"action_233 (175) = happyShift action_80\n"
"action_233 (177) = happyShift action_50\n"
"action_233 (178) = happyShift action_126\n"
"action_233 (185) = happyShift action_127\n"
"action_233 (192) = happyShift action_52\n"
"action_233 (68) = happyGoto action_323\n"
"action_233 (69) = happyGoto action_120\n"
"action_233 (70) = happyGoto action_121\n"
"action_233 (71) = happyGoto action_122\n"
"action_233 (72) = happyGoto action_123\n"
"action_233 (73) = happyGoto action_57\n"
"action_233 (74) = happyGoto action_58\n"
"action_233 (77) = happyGoto action_59\n"
"action_233 (78) = happyGoto action_60\n"
"action_233 (79) = happyGoto action_61\n"
"action_233 (98) = happyGoto action_62\n"
"action_233 (100) = happyGoto action_124\n"
"action_233 (102) = happyGoto action_64\n"
"action_233 (112) = happyGoto action_38\n"
"action_233 (113) = happyGoto action_39\n"
"action_233 (114) = happyGoto action_65\n"
"action_233 (115) = happyGoto action_41\n"
"action_233 (123) = happyGoto action_66\n"
"action_233 _ = happyFail\n"
"\n"
"action_234 (133) = happyShift action_43\n"
"action_234 (134) = happyShift action_44\n"
"action_234 (135) = happyShift action_45\n"
"action_234 (136) = happyShift action_46\n"
"action_234 (141) = happyShift action_67\n"
"action_234 (142) = happyShift action_68\n"
"action_234 (143) = happyShift action_69\n"
"action_234 (144) = happyShift action_70\n"
"action_234 (145) = happyShift action_71\n"
"action_234 (151) = happyShift action_72\n"
"action_234 (154) = happyShift action_73\n"
"action_234 (160) = happyShift action_125\n"
"action_234 (165) = happyShift action_74\n"
"action_234 (167) = happyShift action_75\n"
"action_234 (169) = happyShift action_49\n"
"action_234 (170) = happyShift action_76\n"
"action_234 (175) = happyShift action_80\n"
"action_234 (177) = happyShift action_50\n"
"action_234 (178) = happyShift action_126\n"
"action_234 (185) = happyShift action_127\n"
"action_234 (192) = happyShift action_52\n"
"action_234 (68) = happyGoto action_322\n"
"action_234 (69) = happyGoto action_120\n"
"action_234 (70) = happyGoto action_121\n"
"action_234 (71) = happyGoto action_122\n"
"action_234 (72) = happyGoto action_123\n"
"action_234 (73) = happyGoto action_57\n"
"action_234 (74) = happyGoto action_58\n"
"action_234 (77) = happyGoto action_59\n"
"action_234 (78) = happyGoto action_60\n"
"action_234 (79) = happyGoto action_61\n"
"action_234 (98) = happyGoto action_62\n"
"action_234 (100) = happyGoto action_124\n"
"action_234 (102) = happyGoto action_64\n"
"action_234 (112) = happyGoto action_38\n"
"action_234 (113) = happyGoto action_39\n"
"action_234 (114) = happyGoto action_65\n"
"action_234 (115) = happyGoto action_41\n"
"action_234 (123) = happyGoto action_66\n"
"action_234 _ = happyFail\n"
"\n"
"action_235 _ = happyReduce_178\n"
"\n"
"action_236 (133) = happyShift action_43\n"
"action_236 (134) = happyShift action_44\n"
"action_236 (135) = happyShift action_45\n"
"action_236 (136) = happyShift action_46\n"
"action_236 (141) = happyShift action_67\n"
"action_236 (142) = happyShift action_68\n"
"action_236 (143) = happyShift action_69\n"
"action_236 (144) = happyShift action_70\n"
"action_236 (145) = happyShift action_71\n"
"action_236 (151) = happyShift action_72\n"
"action_236 (154) = happyShift action_73\n"
"action_236 (160) = happyShift action_125\n"
"action_236 (165) = happyShift action_74\n"
"action_236 (167) = happyShift action_75\n"
"action_236 (169) = happyShift action_49\n"
"action_236 (170) = happyShift action_76\n"
"action_236 (175) = happyShift action_80\n"
"action_236 (177) = happyShift action_50\n"
"action_236 (178) = happyShift action_126\n"
"action_236 (185) = happyShift action_127\n"
"action_236 (192) = happyShift action_52\n"
"action_236 (68) = happyGoto action_321\n"
"action_236 (69) = happyGoto action_120\n"
"action_236 (70) = happyGoto action_121\n"
"action_236 (71) = happyGoto action_122\n"
"action_236 (72) = happyGoto action_123\n"
"action_236 (73) = happyGoto action_57\n"
"action_236 (74) = happyGoto action_58\n"
"action_236 (77) = happyGoto action_59\n"
"action_236 (78) = happyGoto action_60\n"
"action_236 (79) = happyGoto action_61\n"
"action_236 (98) = happyGoto action_62\n"
"action_236 (100) = happyGoto action_124\n"
"action_236 (102) = happyGoto action_64\n"
"action_236 (112) = happyGoto action_38\n"
"action_236 (113) = happyGoto action_39\n"
"action_236 (114) = happyGoto action_65\n"
"action_236 (115) = happyGoto action_41\n"
"action_236 (123) = happyGoto action_66\n"
"action_236 _ = happyFail\n"
"\n"
"action_237 (133) = happyShift action_43\n"
"action_237 (134) = happyShift action_44\n"
"action_237 (135) = happyShift action_45\n"
"action_237 (136) = happyShift action_46\n"
"action_237 (141) = happyShift action_67\n"
"action_237 (142) = happyShift action_68\n"
"action_237 (143) = happyShift action_69\n"
"action_237 (144) = happyShift action_70\n"
"action_237 (145) = happyShift action_71\n"
"action_237 (151) = happyShift action_72\n"
"action_237 (154) = happyShift action_73\n"
"action_237 (160) = happyShift action_125\n"
"action_237 (165) = happyShift action_74\n"
"action_237 (167) = happyShift action_75\n"
"action_237 (169) = happyShift action_49\n"
"action_237 (170) = happyShift action_76\n"
"action_237 (175) = happyShift action_80\n"
"action_237 (177) = happyShift action_50\n"
"action_237 (178) = happyShift action_126\n"
"action_237 (185) = happyShift action_127\n"
"action_237 (192) = happyShift action_52\n"
"action_237 (68) = happyGoto action_320\n"
"action_237 (69) = happyGoto action_120\n"
"action_237 (70) = happyGoto action_121\n"
"action_237 (71) = happyGoto action_122\n"
"action_237 (72) = happyGoto action_123\n"
"action_237 (73) = happyGoto action_57\n"
"action_237 (74) = happyGoto action_58\n"
"action_237 (77) = happyGoto action_59\n"
"action_237 (78) = happyGoto action_60\n"
"action_237 (79) = happyGoto action_61\n"
"action_237 (98) = happyGoto action_62\n"
"action_237 (100) = happyGoto action_124\n"
"action_237 (102) = happyGoto action_64\n"
"action_237 (112) = happyGoto action_38\n"
"action_237 (113) = happyGoto action_39\n"
"action_237 (114) = happyGoto action_65\n"
"action_237 (115) = happyGoto action_41\n"
"action_237 (123) = happyGoto action_66\n"
"action_237 _ = happyReduce_188\n"
"\n"
"action_238 (133) = happyShift action_43\n"
"action_238 (134) = happyShift action_44\n"
"action_238 (135) = happyShift action_45\n"
"action_238 (136) = happyShift action_46\n"
"action_238 (141) = happyShift action_67\n"
"action_238 (142) = happyShift action_68\n"
"action_238 (143) = happyShift action_69\n"
"action_238 (144) = happyShift action_70\n"
"action_238 (145) = happyShift action_71\n"
"action_238 (151) = happyShift action_72\n"
"action_238 (154) = happyShift action_73\n"
"action_238 (160) = happyShift action_125\n"
"action_238 (165) = happyShift action_74\n"
"action_238 (167) = happyShift action_75\n"
"action_238 (169) = happyShift action_49\n"
"action_238 (170) = happyShift action_76\n"
"action_238 (175) = happyShift action_80\n"
"action_238 (177) = happyShift action_50\n"
"action_238 (178) = happyShift action_126\n"
"action_238 (185) = happyShift action_319\n"
"action_238 (192) = happyShift action_52\n"
"action_238 (68) = happyGoto action_315\n"
"action_238 (69) = happyGoto action_120\n"
"action_238 (70) = happyGoto action_121\n"
"action_238 (71) = happyGoto action_254\n"
"action_238 (72) = happyGoto action_123\n"
"action_238 (73) = happyGoto action_57\n"
"action_238 (74) = happyGoto action_58\n"
"action_238 (77) = happyGoto action_59\n"
"action_238 (78) = happyGoto action_60\n"
"action_238 (79) = happyGoto action_61\n"
"action_238 (84) = happyGoto action_316\n"
"action_238 (85) = happyGoto action_317\n"
"action_238 (93) = happyGoto action_318\n"
"action_238 (98) = happyGoto action_62\n"
"action_238 (100) = happyGoto action_124\n"
"action_238 (102) = happyGoto action_64\n"
"action_238 (112) = happyGoto action_38\n"
"action_238 (113) = happyGoto action_39\n"
"action_238 (114) = happyGoto action_65\n"
"action_238 (115) = happyGoto action_41\n"
"action_238 (123) = happyGoto action_66\n"
"action_238 _ = happyFail\n"
"\n"
"action_239 (180) = happyShift action_314\n"
"action_239 _ = happyFail\n"
"\n"
"action_240 (7) = happyGoto action_13\n"
"action_240 (8) = happyGoto action_311\n"
"action_240 (33) = happyGoto action_313\n"
"action_240 _ = happyReduce_11\n"
"\n"
"action_241 (7) = happyGoto action_13\n"
"action_241 (8) = happyGoto action_311\n"
"action_241 (33) = happyGoto action_312\n"
"action_241 _ = happyReduce_11\n"
"\n"
"action_242 (189) = happyShift action_310\n"
"action_242 _ = happyFail\n"
"\n"
"action_243 (133) = happyShift action_43\n"
"action_243 (134) = happyShift action_44\n"
"action_243 (135) = happyShift action_45\n"
"action_243 (136) = happyShift action_46\n"
"action_243 (141) = happyShift action_67\n"
"action_243 (142) = happyShift action_68\n"
"action_243 (143) = happyShift action_69\n"
"action_243 (144) = happyShift action_70\n"
"action_243 (145) = happyShift action_71\n"
"action_243 (151) = happyShift action_72\n"
"action_243 (154) = happyShift action_73\n"
"action_243 (165) = happyShift action_74\n"
"action_243 (169) = happyShift action_49\n"
"action_243 (177) = happyShift action_50\n"
"action_243 (192) = happyShift action_52\n"
"action_243 (75) = happyGoto action_307\n"
"action_243 (76) = happyGoto action_308\n"
"action_243 (77) = happyGoto action_309\n"
"action_243 (78) = happyGoto action_60\n"
"action_243 (79) = happyGoto action_61\n"
"action_243 (98) = happyGoto action_62\n"
"action_243 (100) = happyGoto action_124\n"
"action_243 (102) = happyGoto action_64\n"
"action_243 (112) = happyGoto action_38\n"
"action_243 (113) = happyGoto action_39\n"
"action_243 (114) = happyGoto action_65\n"
"action_243 (115) = happyGoto action_41\n"
"action_243 (123) = happyGoto action_66\n"
"action_243 _ = happyFail\n"
"\n"
"action_244 (133) = happyShift action_43\n"
"action_244 (134) = happyShift action_44\n"
"action_244 (135) = happyShift action_45\n"
"action_244 (136) = happyShift action_46\n"
"action_244 (141) = happyShift action_67\n"
"action_244 (142) = happyShift action_68\n"
"action_244 (143) = happyShift action_69\n"
"action_244 (144) = happyShift action_70\n"
"action_244 (145) = happyShift action_71\n"
"action_244 (151) = happyShift action_72\n"
"action_244 (154) = happyShift action_73\n"
"action_244 (160) = happyShift action_125\n"
"action_244 (165) = happyShift action_74\n"
"action_244 (167) = happyShift action_75\n"
"action_244 (169) = happyShift action_49\n"
"action_244 (170) = happyShift action_76\n"
"action_244 (175) = happyShift action_80\n"
"action_244 (177) = happyShift action_50\n"
"action_244 (178) = happyShift action_126\n"
"action_244 (185) = happyShift action_127\n"
"action_244 (192) = happyShift action_52\n"
"action_244 (72) = happyGoto action_306\n"
"action_244 (73) = happyGoto action_212\n"
"action_244 (74) = happyGoto action_58\n"
"action_244 (77) = happyGoto action_59\n"
"action_244 (78) = happyGoto action_60\n"
"action_244 (79) = happyGoto action_61\n"
"action_244 (98) = happyGoto action_62\n"
"action_244 (100) = happyGoto action_124\n"
"action_244 (102) = happyGoto action_64\n"
"action_244 (112) = happyGoto action_38\n"
"action_244 (113) = happyGoto action_39\n"
"action_244 (114) = happyGoto action_65\n"
"action_244 (115) = happyGoto action_41\n"
"action_244 (123) = happyGoto action_66\n"
"action_244 _ = happyFail\n"
"\n"
"action_245 (148) = happyShift action_305\n"
"action_245 (86) = happyGoto action_303\n"
"action_245 (125) = happyGoto action_304\n"
"action_245 _ = happyReduce_280\n"
"\n"
"action_246 _ = happyReduce_64\n"
"\n"
"action_247 (148) = happyShift action_241\n"
"action_247 (36) = happyGoto action_302\n"
"action_247 (125) = happyGoto action_240\n"
"action_247 _ = happyReduce_280\n"
"\n"
"action_248 (48) = happyGoto action_300\n"
"action_248 (49) = happyGoto action_301\n"
"action_248 (124) = happyGoto action_280\n"
"action_248 _ = happyReduce_279\n"
"\n"
"action_249 (146) = happyShift action_299\n"
"action_249 _ = happyFail\n"
"\n"
"action_250 (153) = happyShift action_287\n"
"action_250 _ = happyReduce_69\n"
"\n"
"action_251 (133) = happyShift action_43\n"
"action_251 (135) = happyShift action_45\n"
"action_251 (136) = happyShift action_46\n"
"action_251 (145) = happyShift action_108\n"
"action_251 (151) = happyShift action_109\n"
"action_251 (163) = happyShift action_273\n"
"action_251 (169) = happyShift action_49\n"
"action_251 (177) = happyShift action_50\n"
"action_251 (192) = happyShift action_52\n"
"action_251 (41) = happyGoto action_272\n"
"action_251 (42) = happyGoto action_102\n"
"action_251 (113) = happyGoto action_105\n"
"action_251 (114) = happyGoto action_106\n"
"action_251 (115) = happyGoto action_41\n"
"action_251 (132) = happyGoto action_107\n"
"action_251 _ = happyReduce_84\n"
"\n"
"action_252 (153) = happyShift action_285\n"
"action_252 _ = happyReduce_68\n"
"\n"
"action_253 (147) = happyShift action_298\n"
"action_253 _ = happyReduce_219\n"
"\n"
"action_254 (137) = happyShift action_172\n"
"action_254 (138) = happyShift action_150\n"
"action_254 (139) = happyShift action_151\n"
"action_254 (140) = happyShift action_152\n"
"action_254 (155) = happyShift action_173\n"
"action_254 (157) = happyShift action_156\n"
"action_254 (158) = happyShift action_231\n"
"action_254 (162) = happyReduce_211\n"
"action_254 (167) = happyShift action_175\n"
"action_254 (168) = happyShift action_176\n"
"action_254 (104) = happyGoto action_165\n"
"action_254 (107) = happyGoto action_166\n"
"action_254 (109) = happyGoto action_244\n"
"action_254 (111) = happyGoto action_168\n"
"action_254 (116) = happyGoto action_142\n"
"action_254 (117) = happyGoto action_143\n"
"action_254 (118) = happyGoto action_169\n"
"action_254 (120) = happyGoto action_146\n"
"action_254 (122) = happyGoto action_170\n"
"action_254 _ = happyReduce_150\n"
"\n"
"action_255 (124) = happyGoto action_297\n"
"action_255 _ = happyReduce_279\n"
"\n"
"action_256 (149) = happyShift action_296\n"
"action_256 _ = happyFail\n"
"\n"
"action_257 (133) = happyShift action_43\n"
"action_257 (134) = happyShift action_44\n"
"action_257 (135) = happyShift action_45\n"
"action_257 (136) = happyShift action_46\n"
"action_257 (141) = happyShift action_67\n"
"action_257 (142) = happyShift action_68\n"
"action_257 (143) = happyShift action_69\n"
"action_257 (144) = happyShift action_70\n"
"action_257 (145) = happyShift action_71\n"
"action_257 (147) = happyShift action_257\n"
"action_257 (151) = happyShift action_72\n"
"action_257 (154) = happyShift action_73\n"
"action_257 (160) = happyShift action_125\n"
"action_257 (165) = happyShift action_74\n"
"action_257 (167) = happyShift action_75\n"
"action_257 (169) = happyShift action_49\n"
"action_257 (170) = happyShift action_76\n"
"action_257 (175) = happyShift action_80\n"
"action_257 (177) = happyShift action_50\n"
"action_257 (178) = happyShift action_126\n"
"action_257 (185) = happyShift action_258\n"
"action_257 (192) = happyShift action_52\n"
"action_257 (68) = happyGoto action_253\n"
"action_257 (69) = happyGoto action_120\n"
"action_257 (70) = happyGoto action_121\n"
"action_257 (71) = happyGoto action_254\n"
"action_257 (72) = happyGoto action_123\n"
"action_257 (73) = happyGoto action_57\n"
"action_257 (74) = happyGoto action_58\n"
"action_257 (77) = happyGoto action_59\n"
"action_257 (78) = happyGoto action_60\n"
"action_257 (79) = happyGoto action_61\n"
"action_257 (93) = happyGoto action_255\n"
"action_257 (95) = happyGoto action_295\n"
"action_257 (98) = happyGoto action_62\n"
"action_257 (100) = happyGoto action_124\n"
"action_257 (102) = happyGoto action_64\n"
"action_257 (112) = happyGoto action_38\n"
"action_257 (113) = happyGoto action_39\n"
"action_257 (114) = happyGoto action_65\n"
"action_257 (115) = happyGoto action_41\n"
"action_257 (123) = happyGoto action_66\n"
"action_257 _ = happyFail\n"
"\n"
"action_258 (148) = happyShift action_241\n"
"action_258 (36) = happyGoto action_294\n"
"action_258 (125) = happyGoto action_240\n"
"action_258 _ = happyReduce_280\n"
"\n"
"action_259 (1) = happyShift action_17\n"
"action_259 (150) = happyShift action_18\n"
"action_259 (126) = happyGoto action_293\n"
"action_259 _ = happyFail\n"
"\n"
"action_260 (169) = happyShift action_292\n"
"action_260 (17) = happyGoto action_291\n"
"action_260 _ = happyReduce_32\n"
"\n"
"action_261 _ = happyReduce_65\n"
"\n"
"action_262 (148) = happyShift action_290\n"
"action_262 (125) = happyGoto action_289\n"
"action_262 _ = happyReduce_280\n"
"\n"
"action_263 (152) = happyShift action_288\n"
"action_263 _ = happyFail\n"
"\n"
"action_264 _ = happyReduce_95\n"
"\n"
"action_265 (146) = happyShift action_286\n"
"action_265 (153) = happyShift action_287\n"
"action_265 _ = happyFail\n"
"\n"
"action_266 (146) = happyShift action_284\n"
"action_266 (153) = happyShift action_285\n"
"action_266 _ = happyFail\n"
"\n"
"action_267 (146) = happyShift action_283\n"
"action_267 (153) = happyShift action_229\n"
"action_267 _ = happyFail\n"
"\n"
"action_268 _ = happyReduce_93\n"
"\n"
"action_269 (146) = happyShift action_282\n"
"action_269 _ = happyFail\n"
"\n"
"action_270 (133) = happyShift action_43\n"
"action_270 (135) = happyShift action_45\n"
"action_270 (136) = happyShift action_46\n"
"action_270 (145) = happyShift action_108\n"
"action_270 (151) = happyShift action_109\n"
"action_270 (169) = happyShift action_49\n"
"action_270 (177) = happyShift action_50\n"
"action_270 (192) = happyShift action_52\n"
"action_270 (39) = happyGoto action_281\n"
"action_270 (40) = happyGoto action_251\n"
"action_270 (41) = happyGoto action_101\n"
"action_270 (42) = happyGoto action_102\n"
"action_270 (113) = happyGoto action_105\n"
"action_270 (114) = happyGoto action_106\n"
"action_270 (115) = happyGoto action_41\n"
"action_270 (132) = happyGoto action_107\n"
"action_270 _ = happyFail\n"
"\n"
"action_271 (49) = happyGoto action_279\n"
"action_271 (124) = happyGoto action_280\n"
"action_271 _ = happyReduce_279\n"
"\n"
"action_272 _ = happyReduce_85\n"
"\n"
"action_273 (133) = happyShift action_43\n"
"action_273 (135) = happyShift action_45\n"
"action_273 (136) = happyShift action_46\n"
"action_273 (145) = happyShift action_108\n"
"action_273 (151) = happyShift action_109\n"
"action_273 (169) = happyShift action_49\n"
"action_273 (177) = happyShift action_50\n"
"action_273 (192) = happyShift action_52\n"
"action_273 (39) = happyGoto action_278\n"
"action_273 (40) = happyGoto action_251\n"
"action_273 (41) = happyGoto action_101\n"
"action_273 (42) = happyGoto action_102\n"
"action_273 (113) = happyGoto action_105\n"
"action_273 (114) = happyGoto action_106\n"
"action_273 (115) = happyGoto action_41\n"
"action_273 (132) = happyGoto action_107\n"
"action_273 _ = happyFail\n"
"\n"
"action_274 (133) = happyShift action_43\n"
"action_274 (169) = happyShift action_49\n"
"action_274 (177) = happyShift action_50\n"
"action_274 (192) = happyShift action_52\n"
"action_274 (113) = happyGoto action_105\n"
"action_274 (132) = happyGoto action_277\n"
"action_274 _ = happyReduce_102\n"
"\n"
"action_275 (133) = happyShift action_43\n"
"action_275 (135) = happyShift action_45\n"
"action_275 (136) = happyShift action_46\n"
"action_275 (145) = happyShift action_108\n"
"action_275 (151) = happyShift action_109\n"
"action_275 (169) = happyShift action_49\n"
"action_275 (177) = happyShift action_50\n"
"action_275 (192) = happyShift action_52\n"
"action_275 (39) = happyGoto action_276\n"
"action_275 (40) = happyGoto action_251\n"
"action_275 (41) = happyGoto action_101\n"
"action_275 (42) = happyGoto action_102\n"
"action_275 (113) = happyGoto action_105\n"
"action_275 (114) = happyGoto action_106\n"
"action_275 (115) = happyGoto action_41\n"
"action_275 (132) = happyGoto action_107\n"
"action_275 _ = happyFail\n"
"\n"
"action_276 _ = happyReduce_61\n"
"\n"
"action_277 _ = happyReduce_103\n"
"\n"
"action_278 _ = happyReduce_83\n"
"\n"
"action_279 (174) = happyShift action_372\n"
"action_279 (57) = happyGoto action_394\n"
"action_279 _ = happyReduce_124\n"
"\n"
"action_280 (133) = happyShift action_43\n"
"action_280 (135) = happyShift action_45\n"
"action_280 (136) = happyShift action_46\n"
"action_280 (145) = happyShift action_392\n"
"action_280 (151) = happyShift action_109\n"
"action_280 (168) = happyShift action_393\n"
"action_280 (169) = happyShift action_49\n"
"action_280 (177) = happyShift action_50\n"
"action_280 (192) = happyShift action_52\n"
"action_280 (40) = happyGoto action_386\n"
"action_280 (41) = happyGoto action_101\n"
"action_280 (42) = happyGoto action_102\n"
"action_280 (50) = happyGoto action_387\n"
"action_280 (51) = happyGoto action_388\n"
"action_280 (53) = happyGoto action_389\n"
"action_280 (101) = happyGoto action_390\n"
"action_280 (113) = happyGoto action_105\n"
"action_280 (114) = happyGoto action_106\n"
"action_280 (115) = happyGoto action_391\n"
"action_280 (132) = happyGoto action_107\n"
"action_280 _ = happyFail\n"
"\n"
"action_281 _ = happyReduce_97\n"
"\n"
"action_282 _ = happyReduce_94\n"
"\n"
"action_283 _ = happyReduce_96\n"
"\n"
"action_284 _ = happyReduce_89\n"
"\n"
"action_285 (133) = happyShift action_43\n"
"action_285 (135) = happyShift action_45\n"
"action_285 (136) = happyShift action_46\n"
"action_285 (145) = happyShift action_108\n"
"action_285 (151) = happyShift action_109\n"
"action_285 (169) = happyShift action_49\n"
"action_285 (177) = happyShift action_50\n"
"action_285 (192) = happyShift action_52\n"
"action_285 (39) = happyGoto action_385\n"
"action_285 (40) = happyGoto action_251\n"
"action_285 (41) = happyGoto action_101\n"
"action_285 (42) = happyGoto action_102\n"
"action_285 (113) = happyGoto action_105\n"
"action_285 (114) = happyGoto action_106\n"
"action_285 (115) = happyGoto action_41\n"
"action_285 (132) = happyGoto action_107\n"
"action_285 _ = happyFail\n"
"\n"
"action_286 _ = happyReduce_91\n"
"\n"
"action_287 (133) = happyShift action_43\n"
"action_287 (135) = happyShift action_45\n"
"action_287 (136) = happyShift action_46\n"
"action_287 (145) = happyShift action_108\n"
"action_287 (151) = happyShift action_109\n"
"action_287 (169) = happyShift action_49\n"
"action_287 (177) = happyShift action_50\n"
"action_287 (192) = happyShift action_52\n"
"action_287 (39) = happyGoto action_384\n"
"action_287 (40) = happyGoto action_251\n"
"action_287 (41) = happyGoto action_101\n"
"action_287 (42) = happyGoto action_102\n"
"action_287 (113) = happyGoto action_105\n"
"action_287 (114) = happyGoto action_106\n"
"action_287 (115) = happyGoto action_41\n"
"action_287 (132) = happyGoto action_107\n"
"action_287 _ = happyFail\n"
"\n"
"action_288 _ = happyReduce_90\n"
"\n"
"action_289 (7) = happyGoto action_13\n"
"action_289 (8) = happyGoto action_381\n"
"action_289 (61) = happyGoto action_383\n"
"action_289 _ = happyReduce_11\n"
"\n"
"action_290 (7) = happyGoto action_13\n"
"action_290 (8) = happyGoto action_381\n"
"action_290 (61) = happyGoto action_382\n"
"action_290 _ = happyReduce_11\n"
"\n"
"action_291 (145) = happyReduce_38\n"
"action_291 (177) = happyShift action_380\n"
"action_291 (18) = happyGoto action_377\n"
"action_291 (19) = happyGoto action_378\n"
"action_291 (20) = happyGoto action_379\n"
"action_291 _ = happyReduce_34\n"
"\n"
"action_292 (135) = happyShift action_10\n"
"action_292 (136) = happyShift action_11\n"
"action_292 (127) = happyGoto action_376\n"
"action_292 _ = happyFail\n"
"\n"
"action_293 _ = happyReduce_213\n"
"\n"
"action_294 (147) = happyShift action_375\n"
"action_294 (180) = happyShift action_314\n"
"action_294 _ = happyFail\n"
"\n"
"action_295 _ = happyReduce_217\n"
"\n"
"action_296 _ = happyReduce_212\n"
"\n"
"action_297 (162) = happyShift action_374\n"
"action_297 _ = happyFail\n"
"\n"
"action_298 (133) = happyShift action_43\n"
"action_298 (134) = happyShift action_44\n"
"action_298 (135) = happyShift action_45\n"
"action_298 (136) = happyShift action_46\n"
"action_298 (141) = happyShift action_67\n"
"action_298 (142) = happyShift action_68\n"
"action_298 (143) = happyShift action_69\n"
"action_298 (144) = happyShift action_70\n"
"action_298 (145) = happyShift action_71\n"
"action_298 (147) = happyShift action_257\n"
"action_298 (151) = happyShift action_72\n"
"action_298 (154) = happyShift action_73\n"
"action_298 (160) = happyShift action_125\n"
"action_298 (165) = happyShift action_74\n"
"action_298 (167) = happyShift action_75\n"
"action_298 (169) = happyShift action_49\n"
"action_298 (170) = happyShift action_76\n"
"action_298 (175) = happyShift action_80\n"
"action_298 (177) = happyShift action_50\n"
"action_298 (178) = happyShift action_126\n"
"action_298 (185) = happyShift action_258\n"
"action_298 (192) = happyShift action_52\n"
"action_298 (68) = happyGoto action_253\n"
"action_298 (69) = happyGoto action_120\n"
"action_298 (70) = happyGoto action_121\n"
"action_298 (71) = happyGoto action_254\n"
"action_298 (72) = happyGoto action_123\n"
"action_298 (73) = happyGoto action_57\n"
"action_298 (74) = happyGoto action_58\n"
"action_298 (77) = happyGoto action_59\n"
"action_298 (78) = happyGoto action_60\n"
"action_298 (79) = happyGoto action_61\n"
"action_298 (93) = happyGoto action_255\n"
"action_298 (95) = happyGoto action_373\n"
"action_298 (98) = happyGoto action_62\n"
"action_298 (100) = happyGoto action_124\n"
"action_298 (102) = happyGoto action_64\n"
"action_298 (112) = happyGoto action_38\n"
"action_298 (113) = happyGoto action_39\n"
"action_298 (114) = happyGoto action_65\n"
"action_298 (115) = happyGoto action_41\n"
"action_298 (123) = happyGoto action_66\n"
"action_298 _ = happyReduce_218\n"
"\n"
"action_299 _ = happyReduce_66\n"
"\n"
"action_300 (161) = happyShift action_371\n"
"action_300 (174) = happyShift action_372\n"
"action_300 (57) = happyGoto action_370\n"
"action_300 _ = happyReduce_124\n"
"\n"
"action_301 _ = happyReduce_106\n"
"\n"
"action_302 _ = happyReduce_130\n"
"\n"
"action_303 _ = happyReduce_158\n"
"\n"
"action_304 (7) = happyGoto action_13\n"
"action_304 (8) = happyGoto action_367\n"
"action_304 (87) = happyGoto action_369\n"
"action_304 _ = happyReduce_11\n"
"\n"
"action_305 (7) = happyGoto action_13\n"
"action_305 (8) = happyGoto action_367\n"
"action_305 (87) = happyGoto action_368\n"
"action_305 _ = happyReduce_11\n"
"\n"
"action_306 _ = happyReduce_151\n"
"\n"
"action_307 (133) = happyShift action_43\n"
"action_307 (134) = happyShift action_44\n"
"action_307 (135) = happyShift action_45\n"
"action_307 (136) = happyShift action_46\n"
"action_307 (141) = happyShift action_67\n"
"action_307 (142) = happyShift action_68\n"
"action_307 (143) = happyShift action_69\n"
"action_307 (144) = happyShift action_70\n"
"action_307 (145) = happyShift action_71\n"
"action_307 (151) = happyShift action_72\n"
"action_307 (154) = happyShift action_73\n"
"action_307 (163) = happyShift action_366\n"
"action_307 (165) = happyShift action_74\n"
"action_307 (169) = happyShift action_49\n"
"action_307 (177) = happyShift action_50\n"
"action_307 (192) = happyShift action_52\n"
"action_307 (76) = happyGoto action_365\n"
"action_307 (77) = happyGoto action_309\n"
"action_307 (78) = happyGoto action_60\n"
"action_307 (79) = happyGoto action_61\n"
"action_307 (98) = happyGoto action_62\n"
"action_307 (100) = happyGoto action_124\n"
"action_307 (102) = happyGoto action_64\n"
"action_307 (112) = happyGoto action_38\n"
"action_307 (113) = happyGoto action_39\n"
"action_307 (114) = happyGoto action_65\n"
"action_307 (115) = happyGoto action_41\n"
"action_307 (123) = happyGoto action_66\n"
"action_307 _ = happyFail\n"
"\n"
"action_308 _ = happyReduce_165\n"
"\n"
"action_309 _ = happyReduce_166\n"
"\n"
"action_310 (133) = happyShift action_43\n"
"action_310 (134) = happyShift action_44\n"
"action_310 (135) = happyShift action_45\n"
"action_310 (136) = happyShift action_46\n"
"action_310 (141) = happyShift action_67\n"
"action_310 (142) = happyShift action_68\n"
"action_310 (143) = happyShift action_69\n"
"action_310 (144) = happyShift action_70\n"
"action_310 (145) = happyShift action_71\n"
"action_310 (151) = happyShift action_72\n"
"action_310 (154) = happyShift action_73\n"
"action_310 (160) = happyShift action_125\n"
"action_310 (165) = happyShift action_74\n"
"action_310 (167) = happyShift action_75\n"
"action_310 (169) = happyShift action_49\n"
"action_310 (170) = happyShift action_76\n"
"action_310 (175) = happyShift action_80\n"
"action_310 (177) = happyShift action_50\n"
"action_310 (178) = happyShift action_126\n"
"action_310 (185) = happyShift action_127\n"
"action_310 (192) = happyShift action_52\n"
"action_310 (68) = happyGoto action_364\n"
"action_310 (69) = happyGoto action_120\n"
"action_310 (70) = happyGoto action_121\n"
"action_310 (71) = happyGoto action_122\n"
"action_310 (72) = happyGoto action_123\n"
"action_310 (73) = happyGoto action_57\n"
"action_310 (74) = happyGoto action_58\n"
"action_310 (77) = happyGoto action_59\n"
"action_310 (78) = happyGoto action_60\n"
"action_310 (79) = happyGoto action_61\n"
"action_310 (98) = happyGoto action_62\n"
"action_310 (100) = happyGoto action_124\n"
"action_310 (102) = happyGoto action_64\n"
"action_310 (112) = happyGoto action_38\n"
"action_310 (113) = happyGoto action_39\n"
"action_310 (114) = happyGoto action_65\n"
"action_310 (115) = happyGoto action_41\n"
"action_310 (123) = happyGoto action_66\n"
"action_310 _ = happyFail\n"
"\n"
"action_311 (133) = happyReduce_279\n"
"action_311 (134) = happyReduce_279\n"
"action_311 (135) = happyReduce_279\n"
"action_311 (136) = happyReduce_279\n"
"action_311 (141) = happyReduce_279\n"
"action_311 (142) = happyReduce_279\n"
"action_311 (143) = happyReduce_279\n"
"action_311 (144) = happyReduce_279\n"
"action_311 (145) = happyReduce_279\n"
"action_311 (147) = happyShift action_29\n"
"action_311 (151) = happyReduce_279\n"
"action_311 (154) = happyReduce_279\n"
"action_311 (165) = happyReduce_279\n"
"action_311 (167) = happyReduce_279\n"
"action_311 (169) = happyReduce_279\n"
"action_311 (170) = happyReduce_279\n"
"action_311 (175) = happyReduce_279\n"
"action_311 (177) = happyReduce_279\n"
"action_311 (181) = happyReduce_279\n"
"action_311 (182) = happyReduce_279\n"
"action_311 (183) = happyReduce_279\n"
"action_311 (192) = happyReduce_279\n"
"action_311 (25) = happyGoto action_21\n"
"action_311 (34) = happyGoto action_361\n"
"action_311 (35) = happyGoto action_362\n"
"action_311 (37) = happyGoto action_26\n"
"action_311 (63) = happyGoto action_27\n"
"action_311 (124) = happyGoto action_363\n"
"action_311 _ = happyReduce_72\n"
"\n"
"action_312 (149) = happyShift action_360\n"
"action_312 _ = happyFail\n"
"\n"
"action_313 (1) = happyShift action_17\n"
"action_313 (150) = happyShift action_18\n"
"action_313 (126) = happyGoto action_359\n"
"action_313 _ = happyFail\n"
"\n"
"action_314 (133) = happyShift action_43\n"
"action_314 (134) = happyShift action_44\n"
"action_314 (135) = happyShift action_45\n"
"action_314 (136) = happyShift action_46\n"
"action_314 (141) = happyShift action_67\n"
"action_314 (142) = happyShift action_68\n"
"action_314 (143) = happyShift action_69\n"
"action_314 (144) = happyShift action_70\n"
"action_314 (145) = happyShift action_71\n"
"action_314 (151) = happyShift action_72\n"
"action_314 (154) = happyShift action_73\n"
"action_314 (160) = happyShift action_125\n"
"action_314 (165) = happyShift action_74\n"
"action_314 (167) = happyShift action_75\n"
"action_314 (169) = happyShift action_49\n"
"action_314 (170) = happyShift action_76\n"
"action_314 (175) = happyShift action_80\n"
"action_314 (177) = happyShift action_50\n"
"action_314 (178) = happyShift action_126\n"
"action_314 (185) = happyShift action_127\n"
"action_314 (192) = happyShift action_52\n"
"action_314 (68) = happyGoto action_358\n"
"action_314 (69) = happyGoto action_120\n"
"action_314 (70) = happyGoto action_121\n"
"action_314 (71) = happyGoto action_122\n"
"action_314 (72) = happyGoto action_123\n"
"action_314 (73) = happyGoto action_57\n"
"action_314 (74) = happyGoto action_58\n"
"action_314 (77) = happyGoto action_59\n"
"action_314 (78) = happyGoto action_60\n"
"action_314 (79) = happyGoto action_61\n"
"action_314 (98) = happyGoto action_62\n"
"action_314 (100) = happyGoto action_124\n"
"action_314 (102) = happyGoto action_64\n"
"action_314 (112) = happyGoto action_38\n"
"action_314 (113) = happyGoto action_39\n"
"action_314 (114) = happyGoto action_65\n"
"action_314 (115) = happyGoto action_41\n"
"action_314 (123) = happyGoto action_66\n"
"action_314 _ = happyFail\n"
"\n"
"action_315 _ = happyReduce_198\n"
"\n"
"action_316 (153) = happyShift action_357\n"
"action_316 _ = happyReduce_192\n"
"\n"
"action_317 _ = happyReduce_196\n"
"\n"
"action_318 (124) = happyGoto action_356\n"
"action_318 _ = happyReduce_279\n"
"\n"
"action_319 (148) = happyShift action_241\n"
"action_319 (36) = happyGoto action_355\n"
"action_319 (125) = happyGoto action_240\n"
"action_319 _ = happyReduce_280\n"
"\n"
"action_320 _ = happyReduce_190\n"
"\n"
"action_321 (156) = happyShift action_354\n"
"action_321 _ = happyReduce_194\n"
"\n"
"action_322 _ = happyReduce_193\n"
"\n"
"action_323 _ = happyReduce_185\n"
"\n"
"action_324 (133) = happyShift action_43\n"
"action_324 (135) = happyShift action_45\n"
"action_324 (136) = happyShift action_46\n"
"action_324 (145) = happyShift action_108\n"
"action_324 (151) = happyShift action_109\n"
"action_324 (169) = happyShift action_49\n"
"action_324 (177) = happyShift action_50\n"
"action_324 (192) = happyShift action_52\n"
"action_324 (39) = happyGoto action_99\n"
"action_324 (40) = happyGoto action_100\n"
"action_324 (41) = happyGoto action_101\n"
"action_324 (42) = happyGoto action_102\n"
"action_324 (43) = happyGoto action_353\n"
"action_324 (44) = happyGoto action_104\n"
"action_324 (113) = happyGoto action_105\n"
"action_324 (114) = happyGoto action_106\n"
"action_324 (115) = happyGoto action_41\n"
"action_324 (132) = happyGoto action_107\n"
"action_324 _ = happyFail\n"
"\n"
"action_325 _ = happyReduce_179\n"
"\n"
"action_326 _ = happyReduce_184\n"
"\n"
"action_327 _ = happyReduce_180\n"
"\n"
"action_328 _ = happyReduce_240\n"
"\n"
"action_329 (133) = happyShift action_43\n"
"action_329 (134) = happyShift action_44\n"
"action_329 (135) = happyShift action_45\n"
"action_329 (136) = happyShift action_46\n"
"action_329 (141) = happyShift action_67\n"
"action_329 (142) = happyShift action_68\n"
"action_329 (143) = happyShift action_69\n"
"action_329 (144) = happyShift action_70\n"
"action_329 (145) = happyShift action_71\n"
"action_329 (151) = happyShift action_72\n"
"action_329 (154) = happyShift action_73\n"
"action_329 (160) = happyShift action_125\n"
"action_329 (165) = happyShift action_74\n"
"action_329 (167) = happyShift action_75\n"
"action_329 (169) = happyShift action_49\n"
"action_329 (170) = happyShift action_76\n"
"action_329 (175) = happyShift action_80\n"
"action_329 (177) = happyShift action_50\n"
"action_329 (178) = happyShift action_126\n"
"action_329 (185) = happyShift action_127\n"
"action_329 (192) = happyShift action_52\n"
"action_329 (68) = happyGoto action_352\n"
"action_329 (69) = happyGoto action_120\n"
"action_329 (70) = happyGoto action_121\n"
"action_329 (71) = happyGoto action_122\n"
"action_329 (72) = happyGoto action_123\n"
"action_329 (73) = happyGoto action_57\n"
"action_329 (74) = happyGoto action_58\n"
"action_329 (77) = happyGoto action_59\n"
"action_329 (78) = happyGoto action_60\n"
"action_329 (79) = happyGoto action_61\n"
"action_329 (98) = happyGoto action_62\n"
"action_329 (100) = happyGoto action_124\n"
"action_329 (102) = happyGoto action_64\n"
"action_329 (112) = happyGoto action_38\n"
"action_329 (113) = happyGoto action_39\n"
"action_329 (114) = happyGoto action_65\n"
"action_329 (115) = happyGoto action_41\n"
"action_329 (123) = happyGoto action_66\n"
"action_329 _ = happyFail\n"
"\n"
"action_330 _ = happyReduce_171\n"
"\n"
"action_331 (133) = happyShift action_43\n"
"action_331 (134) = happyShift action_44\n"
"action_331 (145) = happyShift action_47\n"
"action_331 (169) = happyShift action_49\n"
"action_331 (177) = happyShift action_50\n"
"action_331 (192) = happyShift action_52\n"
"action_331 (97) = happyGoto action_351\n"
"action_331 (100) = happyGoto action_218\n"
"action_331 (112) = happyGoto action_38\n"
"action_331 (113) = happyGoto action_39\n"
"action_331 _ = happyFail\n"
"\n"
"action_332 _ = happyReduce_140\n"
"\n"
"action_333 (159) = happyShift action_350\n"
"action_333 _ = happyFail\n"
"\n"
"action_334 _ = happyReduce_244\n"
"\n"
"action_335 _ = happyReduce_238\n"
"\n"
"action_336 (146) = happyShift action_349\n"
"action_336 _ = happyFail\n"
"\n"
"action_337 (155) = happyShift action_348\n"
"action_337 _ = happyFail\n"
"\n"
"action_338 (155) = happyShift action_347\n"
"action_338 _ = happyFail\n"
"\n"
"action_339 (137) = happyShift action_172\n"
"action_339 (138) = happyShift action_150\n"
"action_339 (155) = happyShift action_204\n"
"action_339 (167) = happyShift action_175\n"
"action_339 (168) = happyShift action_176\n"
"action_339 (103) = happyGoto action_199\n"
"action_339 (106) = happyGoto action_200\n"
"action_339 (108) = happyGoto action_346\n"
"action_339 (117) = happyGoto action_202\n"
"action_339 (120) = happyGoto action_203\n"
"action_339 _ = happyFail\n"
"\n"
"action_340 _ = happyReduce_22\n"
"\n"
"action_341 (146) = happyShift action_345\n"
"action_341 _ = happyFail\n"
"\n"
"action_342 _ = happyReduce_24\n"
"\n"
"action_343 (133) = happyShift action_43\n"
"action_343 (135) = happyShift action_45\n"
"action_343 (145) = happyShift action_195\n"
"action_343 (169) = happyShift action_49\n"
"action_343 (177) = happyShift action_50\n"
"action_343 (192) = happyShift action_52\n"
"action_343 (24) = happyGoto action_344\n"
"action_343 (99) = happyGoto action_191\n"
"action_343 (101) = happyGoto action_192\n"
"action_343 (113) = happyGoto action_193\n"
"action_343 (115) = happyGoto action_194\n"
"action_343 _ = happyFail\n"
"\n"
"action_344 _ = happyReduce_46\n"
"\n"
"action_345 _ = happyReduce_232\n"
"\n"
"action_346 _ = happyReduce_56\n"
"\n"
"action_347 _ = happyReduce_242\n"
"\n"
"action_348 _ = happyReduce_236\n"
"\n"
"action_349 _ = happyReduce_228\n"
"\n"
"action_350 (133) = happyShift action_43\n"
"action_350 (134) = happyShift action_44\n"
"action_350 (135) = happyShift action_45\n"
"action_350 (136) = happyShift action_46\n"
"action_350 (141) = happyShift action_67\n"
"action_350 (142) = happyShift action_68\n"
"action_350 (143) = happyShift action_69\n"
"action_350 (144) = happyShift action_70\n"
"action_350 (145) = happyShift action_71\n"
"action_350 (151) = happyShift action_72\n"
"action_350 (154) = happyShift action_73\n"
"action_350 (160) = happyShift action_125\n"
"action_350 (165) = happyShift action_74\n"
"action_350 (167) = happyShift action_75\n"
"action_350 (169) = happyShift action_49\n"
"action_350 (170) = happyShift action_76\n"
"action_350 (175) = happyShift action_80\n"
"action_350 (177) = happyShift action_50\n"
"action_350 (178) = happyShift action_126\n"
"action_350 (185) = happyShift action_127\n"
"action_350 (192) = happyShift action_52\n"
"action_350 (68) = happyGoto action_427\n"
"action_350 (69) = happyGoto action_120\n"
"action_350 (70) = happyGoto action_121\n"
"action_350 (71) = happyGoto action_122\n"
"action_350 (72) = happyGoto action_123\n"
"action_350 (73) = happyGoto action_57\n"
"action_350 (74) = happyGoto action_58\n"
"action_350 (77) = happyGoto action_59\n"
"action_350 (78) = happyGoto action_60\n"
"action_350 (79) = happyGoto action_61\n"
"action_350 (98) = happyGoto action_62\n"
"action_350 (100) = happyGoto action_124\n"
"action_350 (102) = happyGoto action_64\n"
"action_350 (112) = happyGoto action_38\n"
"action_350 (113) = happyGoto action_39\n"
"action_350 (114) = happyGoto action_65\n"
"action_350 (115) = happyGoto action_41\n"
"action_350 (123) = happyGoto action_66\n"
"action_350 _ = happyFail\n"
"\n"
"action_351 _ = happyReduce_220\n"
"\n"
"action_352 _ = happyReduce_222\n"
"\n"
"action_353 _ = happyReduce_147\n"
"\n"
"action_354 (133) = happyShift action_43\n"
"action_354 (134) = happyShift action_44\n"
"action_354 (135) = happyShift action_45\n"
"action_354 (136) = happyShift action_46\n"
"action_354 (141) = happyShift action_67\n"
"action_354 (142) = happyShift action_68\n"
"action_354 (143) = happyShift action_69\n"
"action_354 (144) = happyShift action_70\n"
"action_354 (145) = happyShift action_71\n"
"action_354 (151) = happyShift action_72\n"
"action_354 (154) = happyShift action_73\n"
"action_354 (160) = happyShift action_125\n"
"action_354 (165) = happyShift action_74\n"
"action_354 (167) = happyShift action_75\n"
"action_354 (169) = happyShift action_49\n"
"action_354 (170) = happyShift action_76\n"
"action_354 (175) = happyShift action_80\n"
"action_354 (177) = happyShift action_50\n"
"action_354 (178) = happyShift action_126\n"
"action_354 (185) = happyShift action_127\n"
"action_354 (192) = happyShift action_52\n"
"action_354 (68) = happyGoto action_426\n"
"action_354 (69) = happyGoto action_120\n"
"action_354 (70) = happyGoto action_121\n"
"action_354 (71) = happyGoto action_122\n"
"action_354 (72) = happyGoto action_123\n"
"action_354 (73) = happyGoto action_57\n"
"action_354 (74) = happyGoto action_58\n"
"action_354 (77) = happyGoto action_59\n"
"action_354 (78) = happyGoto action_60\n"
"action_354 (79) = happyGoto action_61\n"
"action_354 (98) = happyGoto action_62\n"
"action_354 (100) = happyGoto action_124\n"
"action_354 (102) = happyGoto action_64\n"
"action_354 (112) = happyGoto action_38\n"
"action_354 (113) = happyGoto action_39\n"
"action_354 (114) = happyGoto action_65\n"
"action_354 (115) = happyGoto action_41\n"
"action_354 (123) = happyGoto action_66\n"
"action_354 _ = happyReduce_189\n"
"\n"
"action_355 (180) = happyShift action_314\n"
"action_355 _ = happyReduce_199\n"
"\n"
"action_356 (162) = happyShift action_425\n"
"action_356 _ = happyFail\n"
"\n"
"action_357 (133) = happyShift action_43\n"
"action_357 (134) = happyShift action_44\n"
"action_357 (135) = happyShift action_45\n"
"action_357 (136) = happyShift action_46\n"
"action_357 (141) = happyShift action_67\n"
"action_357 (142) = happyShift action_68\n"
"action_357 (143) = happyShift action_69\n"
"action_357 (144) = happyShift action_70\n"
"action_357 (145) = happyShift action_71\n"
"action_357 (151) = happyShift action_72\n"
"action_357 (154) = happyShift action_73\n"
"action_357 (160) = happyShift action_125\n"
"action_357 (165) = happyShift action_74\n"
"action_357 (167) = happyShift action_75\n"
"action_357 (169) = happyShift action_49\n"
"action_357 (170) = happyShift action_76\n"
"action_357 (175) = happyShift action_80\n"
"action_357 (177) = happyShift action_50\n"
"action_357 (178) = happyShift action_126\n"
"action_357 (185) = happyShift action_319\n"
"action_357 (192) = happyShift action_52\n"
"action_357 (68) = happyGoto action_315\n"
"action_357 (69) = happyGoto action_120\n"
"action_357 (70) = happyGoto action_121\n"
"action_357 (71) = happyGoto action_254\n"
"action_357 (72) = happyGoto action_123\n"
"action_357 (73) = happyGoto action_57\n"
"action_357 (74) = happyGoto action_58\n"
"action_357 (77) = happyGoto action_59\n"
"action_357 (78) = happyGoto action_60\n"
"action_357 (79) = happyGoto action_61\n"
"action_357 (85) = happyGoto action_424\n"
"action_357 (93) = happyGoto action_318\n"
"action_357 (98) = happyGoto action_62\n"
"action_357 (100) = happyGoto action_124\n"
"action_357 (102) = happyGoto action_64\n"
"action_357 (112) = happyGoto action_38\n"
"action_357 (113) = happyGoto action_39\n"
"action_357 (114) = happyGoto action_65\n"
"action_357 (115) = happyGoto action_41\n"
"action_357 (123) = happyGoto action_66\n"
"action_357 _ = happyFail\n"
"\n"
"action_358 _ = happyReduce_156\n"
"\n"
"action_359 _ = happyReduce_79\n"
"\n"
"action_360 _ = happyReduce_78\n"
"\n"
"action_361 (7) = happyGoto action_422\n"
"action_361 (8) = happyGoto action_423\n"
"action_361 _ = happyReduce_11\n"
"\n"
"action_362 _ = happyReduce_74\n"
"\n"
"action_363 (133) = happyShift action_43\n"
"action_363 (134) = happyShift action_44\n"
"action_363 (135) = happyShift action_45\n"
"action_363 (136) = happyShift action_46\n"
"action_363 (141) = happyShift action_67\n"
"action_363 (142) = happyShift action_68\n"
"action_363 (143) = happyShift action_69\n"
"action_363 (144) = happyShift action_70\n"
"action_363 (145) = happyShift action_71\n"
"action_363 (151) = happyShift action_72\n"
"action_363 (154) = happyShift action_73\n"
"action_363 (165) = happyShift action_74\n"
"action_363 (167) = happyShift action_75\n"
"action_363 (169) = happyShift action_49\n"
"action_363 (170) = happyShift action_76\n"
"action_363 (175) = happyShift action_80\n"
"action_363 (177) = happyShift action_50\n"
"action_363 (181) = happyShift action_82\n"
"action_363 (182) = happyShift action_83\n"
"action_363 (183) = happyShift action_84\n"
"action_363 (192) = happyShift action_52\n"
"action_363 (27) = happyGoto action_54\n"
"action_363 (38) = happyGoto action_55\n"
"action_363 (71) = happyGoto action_56\n"
"action_363 (73) = happyGoto action_57\n"
"action_363 (74) = happyGoto action_58\n"
"action_363 (77) = happyGoto action_59\n"
"action_363 (78) = happyGoto action_60\n"
"action_363 (79) = happyGoto action_61\n"
"action_363 (98) = happyGoto action_62\n"
"action_363 (100) = happyGoto action_63\n"
"action_363 (102) = happyGoto action_64\n"
"action_363 (112) = happyGoto action_38\n"
"action_363 (113) = happyGoto action_39\n"
"action_363 (114) = happyGoto action_65\n"
"action_363 (115) = happyGoto action_41\n"
"action_363 (123) = happyGoto action_66\n"
"action_363 _ = happyFail\n"
"\n"
"action_364 (176) = happyShift action_421\n"
"action_364 _ = happyFail\n"
"\n"
"action_365 _ = happyReduce_164\n"
"\n"
"action_366 (133) = happyShift action_43\n"
"action_366 (134) = happyShift action_44\n"
"action_366 (135) = happyShift action_45\n"
"action_366 (136) = happyShift action_46\n"
"action_366 (141) = happyShift action_67\n"
"action_366 (142) = happyShift action_68\n"
"action_366 (143) = happyShift action_69\n"
"action_366 (144) = happyShift action_70\n"
"action_366 (145) = happyShift action_71\n"
"action_366 (151) = happyShift action_72\n"
"action_366 (154) = happyShift action_73\n"
"action_366 (160) = happyShift action_125\n"
"action_366 (165) = happyShift action_74\n"
"action_366 (167) = happyShift action_75\n"
"action_366 (169) = happyShift action_49\n"
"action_366 (170) = happyShift action_76\n"
"action_366 (175) = happyShift action_80\n"
"action_366 (177) = happyShift action_50\n"
"action_366 (178) = happyShift action_126\n"
"action_366 (185) = happyShift action_127\n"
"action_366 (192) = happyShift action_52\n"
"action_366 (68) = happyGoto action_420\n"
"action_366 (69) = happyGoto action_120\n"
"action_366 (70) = happyGoto action_121\n"
"action_366 (71) = happyGoto action_122\n"
"action_366 (72) = happyGoto action_123\n"
"action_366 (73) = happyGoto action_57\n"
"action_366 (74) = happyGoto action_58\n"
"action_366 (77) = happyGoto action_59\n"
"action_366 (78) = happyGoto action_60\n"
"action_366 (79) = happyGoto action_61\n"
"action_366 (98) = happyGoto action_62\n"
"action_366 (100) = happyGoto action_124\n"
"action_366 (102) = happyGoto action_64\n"
"action_366 (112) = happyGoto action_38\n"
"action_366 (113) = happyGoto action_39\n"
"action_366 (114) = happyGoto action_65\n"
"action_366 (115) = happyGoto action_41\n"
"action_366 (123) = happyGoto action_66\n"
"action_366 _ = happyFail\n"
"\n"
"action_367 (147) = happyShift action_29\n"
"action_367 (88) = happyGoto action_417\n"
"action_367 (89) = happyGoto action_418\n"
"action_367 (124) = happyGoto action_419\n"
"action_367 _ = happyReduce_279\n"
"\n"
"action_368 (149) = happyShift action_416\n"
"action_368 _ = happyFail\n"
"\n"
"action_369 (1) = happyShift action_17\n"
"action_369 (150) = happyShift action_18\n"
"action_369 (126) = happyGoto action_415\n"
"action_369 _ = happyFail\n"
"\n"
"action_370 _ = happyReduce_62\n"
"\n"
"action_371 (49) = happyGoto action_414\n"
"action_371 (124) = happyGoto action_280\n"
"action_371 _ = happyReduce_279\n"
"\n"
"action_372 (135) = happyShift action_45\n"
"action_372 (136) = happyShift action_46\n"
"action_372 (145) = happyShift action_413\n"
"action_372 (114) = happyGoto action_411\n"
"action_372 (115) = happyGoto action_41\n"
"action_372 (131) = happyGoto action_412\n"
"action_372 _ = happyFail\n"
"\n"
"action_373 _ = happyReduce_216\n"
"\n"
"action_374 (133) = happyShift action_43\n"
"action_374 (134) = happyShift action_44\n"
"action_374 (135) = happyShift action_45\n"
"action_374 (136) = happyShift action_46\n"
"action_374 (141) = happyShift action_67\n"
"action_374 (142) = happyShift action_68\n"
"action_374 (143) = happyShift action_69\n"
"action_374 (144) = happyShift action_70\n"
"action_374 (145) = happyShift action_71\n"
"action_374 (151) = happyShift action_72\n"
"action_374 (154) = happyShift action_73\n"
"action_374 (160) = happyShift action_125\n"
"action_374 (165) = happyShift action_74\n"
"action_374 (167) = happyShift action_75\n"
"action_374 (169) = happyShift action_49\n"
"action_374 (170) = happyShift action_76\n"
"action_374 (175) = happyShift action_80\n"
"action_374 (177) = happyShift action_50\n"
"action_374 (178) = happyShift action_126\n"
"action_374 (185) = happyShift action_127\n"
"action_374 (192) = happyShift action_52\n"
"action_374 (68) = happyGoto action_410\n"
"action_374 (69) = happyGoto action_120\n"
"action_374 (70) = happyGoto action_121\n"
"action_374 (71) = happyGoto action_122\n"
"action_374 (72) = happyGoto action_123\n"
"action_374 (73) = happyGoto action_57\n"
"action_374 (74) = happyGoto action_58\n"
"action_374 (77) = happyGoto action_59\n"
"action_374 (78) = happyGoto action_60\n"
"action_374 (79) = happyGoto action_61\n"
"action_374 (98) = happyGoto action_62\n"
"action_374 (100) = happyGoto action_124\n"
"action_374 (102) = happyGoto action_64\n"
"action_374 (112) = happyGoto action_38\n"
"action_374 (113) = happyGoto action_39\n"
"action_374 (114) = happyGoto action_65\n"
"action_374 (115) = happyGoto action_41\n"
"action_374 (123) = happyGoto action_66\n"
"action_374 _ = happyFail\n"
"\n"
"action_375 (133) = happyShift action_43\n"
"action_375 (134) = happyShift action_44\n"
"action_375 (135) = happyShift action_45\n"
"action_375 (136) = happyShift action_46\n"
"action_375 (141) = happyShift action_67\n"
"action_375 (142) = happyShift action_68\n"
"action_375 (143) = happyShift action_69\n"
"action_375 (144) = happyShift action_70\n"
"action_375 (145) = happyShift action_71\n"
"action_375 (147) = happyShift action_257\n"
"action_375 (151) = happyShift action_72\n"
"action_375 (154) = happyShift action_73\n"
"action_375 (160) = happyShift action_125\n"
"action_375 (165) = happyShift action_74\n"
"action_375 (167) = happyShift action_75\n"
"action_375 (169) = happyShift action_49\n"
"action_375 (170) = happyShift action_76\n"
"action_375 (175) = happyShift action_80\n"
"action_375 (177) = happyShift action_50\n"
"action_375 (178) = happyShift action_126\n"
"action_375 (185) = happyShift action_258\n"
"action_375 (192) = happyShift action_52\n"
"action_375 (68) = happyGoto action_253\n"
"action_375 (69) = happyGoto action_120\n"
"action_375 (70) = happyGoto action_121\n"
"action_375 (71) = happyGoto action_254\n"
"action_375 (72) = happyGoto action_123\n"
"action_375 (73) = happyGoto action_57\n"
"action_375 (74) = happyGoto action_58\n"
"action_375 (77) = happyGoto action_59\n"
"action_375 (78) = happyGoto action_60\n"
"action_375 (79) = happyGoto action_61\n"
"action_375 (93) = happyGoto action_255\n"
"action_375 (95) = happyGoto action_409\n"
"action_375 (98) = happyGoto action_62\n"
"action_375 (100) = happyGoto action_124\n"
"action_375 (102) = happyGoto action_64\n"
"action_375 (112) = happyGoto action_38\n"
"action_375 (113) = happyGoto action_39\n"
"action_375 (114) = happyGoto action_65\n"
"action_375 (115) = happyGoto action_41\n"
"action_375 (123) = happyGoto action_66\n"
"action_375 _ = happyFail\n"
"\n"
"action_376 _ = happyReduce_31\n"
"\n"
"action_377 _ = happyReduce_28\n"
"\n"
"action_378 _ = happyReduce_33\n"
"\n"
"action_379 (145) = happyShift action_408\n"
"action_379 _ = happyFail\n"
"\n"
"action_380 _ = happyReduce_37\n"
"\n"
"action_381 (133) = happyReduce_279\n"
"action_381 (134) = happyReduce_279\n"
"action_381 (135) = happyReduce_279\n"
"action_381 (136) = happyReduce_279\n"
"action_381 (141) = happyReduce_279\n"
"action_381 (142) = happyReduce_279\n"
"action_381 (143) = happyReduce_279\n"
"action_381 (144) = happyReduce_279\n"
"action_381 (145) = happyReduce_279\n"
"action_381 (147) = happyShift action_29\n"
"action_381 (151) = happyReduce_279\n"
"action_381 (154) = happyReduce_279\n"
"action_381 (165) = happyReduce_279\n"
"action_381 (167) = happyReduce_279\n"
"action_381 (169) = happyReduce_279\n"
"action_381 (170) = happyReduce_279\n"
"action_381 (175) = happyReduce_279\n"
"action_381 (177) = happyReduce_279\n"
"action_381 (192) = happyReduce_279\n"
"action_381 (62) = happyGoto action_405\n"
"action_381 (63) = happyGoto action_406\n"
"action_381 (124) = happyGoto action_407\n"
"action_381 _ = happyReduce_136\n"
"\n"
"action_382 (149) = happyShift action_404\n"
"action_382 _ = happyFail\n"
"\n"
"action_383 (1) = happyShift action_17\n"
"action_383 (150) = happyShift action_18\n"
"action_383 (126) = happyGoto action_403\n"
"action_383 _ = happyFail\n"
"\n"
"action_384 _ = happyReduce_101\n"
"\n"
"action_385 _ = happyReduce_100\n"
"\n"
"action_386 (133) = happyShift action_43\n"
"action_386 (135) = happyShift action_45\n"
"action_386 (136) = happyShift action_46\n"
"action_386 (138) = happyReduce_117\n"
"action_386 (145) = happyShift action_108\n"
"action_386 (151) = happyShift action_109\n"
"action_386 (155) = happyReduce_117\n"
"action_386 (168) = happyShift action_402\n"
"action_386 (169) = happyShift action_49\n"
"action_386 (177) = happyShift action_50\n"
"action_386 (192) = happyShift action_52\n"
"action_386 (41) = happyGoto action_272\n"
"action_386 (42) = happyGoto action_102\n"
"action_386 (113) = happyGoto action_105\n"
"action_386 (114) = happyGoto action_106\n"
"action_386 (115) = happyGoto action_41\n"
"action_386 (132) = happyGoto action_107\n"
"action_386 _ = happyReduce_111\n"
"\n"
"action_387 _ = happyReduce_107\n"
"\n"
"action_388 (133) = happyShift action_43\n"
"action_388 (135) = happyShift action_45\n"
"action_388 (136) = happyShift action_46\n"
"action_388 (145) = happyShift action_108\n"
"action_388 (151) = happyShift action_109\n"
"action_388 (168) = happyShift action_401\n"
"action_388 (169) = happyShift action_49\n"
"action_388 (177) = happyShift action_50\n"
"action_388 (192) = happyShift action_52\n"
"action_388 (41) = happyGoto action_399\n"
"action_388 (42) = happyGoto action_102\n"
"action_388 (52) = happyGoto action_400\n"
"action_388 (113) = happyGoto action_105\n"
"action_388 (114) = happyGoto action_106\n"
"action_388 (115) = happyGoto action_41\n"
"action_388 (132) = happyGoto action_107\n"
"action_388 _ = happyReduce_112\n"
"\n"
"action_389 (138) = happyShift action_150\n"
"action_389 (155) = happyShift action_398\n"
"action_389 (106) = happyGoto action_397\n"
"action_389 (117) = happyGoto action_202\n"
"action_389 _ = happyFail\n"
"\n"
"action_390 (148) = happyShift action_396\n"
"action_390 _ = happyFail\n"
"\n"
"action_391 (148) = happyReduce_231\n"
"action_391 _ = happyReduce_259\n"
"\n"
"action_392 (133) = happyShift action_43\n"
"action_392 (135) = happyShift action_45\n"
"action_392 (136) = happyShift action_46\n"
"action_392 (138) = happyShift action_150\n"
"action_392 (145) = happyShift action_108\n"
"action_392 (146) = happyShift action_268\n"
"action_392 (151) = happyShift action_109\n"
"action_392 (153) = happyShift action_154\n"
"action_392 (163) = happyShift action_269\n"
"action_392 (169) = happyShift action_49\n"
"action_392 (177) = happyShift action_50\n"
"action_392 (192) = happyShift action_52\n"
"action_392 (39) = happyGoto action_265\n"
"action_392 (40) = happyGoto action_251\n"
"action_392 (41) = happyGoto action_101\n"
"action_392 (42) = happyGoto action_102\n"
"action_392 (45) = happyGoto action_266\n"
"action_392 (80) = happyGoto action_267\n"
"action_392 (113) = happyGoto action_105\n"
"action_392 (114) = happyGoto action_106\n"
"action_392 (115) = happyGoto action_41\n"
"action_392 (117) = happyGoto action_341\n"
"action_392 (132) = happyGoto action_107\n"
"action_392 _ = happyFail\n"
"\n"
"action_393 (133) = happyShift action_43\n"
"action_393 (135) = happyShift action_45\n"
"action_393 (136) = happyShift action_46\n"
"action_393 (145) = happyShift action_108\n"
"action_393 (151) = happyShift action_109\n"
"action_393 (169) = happyShift action_49\n"
"action_393 (177) = happyShift action_50\n"
"action_393 (192) = happyShift action_52\n"
"action_393 (41) = happyGoto action_395\n"
"action_393 (42) = happyGoto action_102\n"
"action_393 (113) = happyGoto action_105\n"
"action_393 (114) = happyGoto action_106\n"
"action_393 (115) = happyGoto action_41\n"
"action_393 (132) = happyGoto action_107\n"
"action_393 _ = happyFail\n"
"\n"
"action_394 _ = happyReduce_63\n"
"\n"
"action_395 _ = happyReduce_118\n"
"\n"
"action_396 (133) = happyShift action_43\n"
"action_396 (134) = happyShift action_44\n"
"action_396 (145) = happyShift action_47\n"
"action_396 (149) = happyShift action_455\n"
"action_396 (169) = happyShift action_49\n"
"action_396 (177) = happyShift action_50\n"
"action_396 (192) = happyShift action_52\n"
"action_396 (38) = happyGoto action_451\n"
"action_396 (54) = happyGoto action_452\n"
"action_396 (55) = happyGoto action_453\n"
"action_396 (100) = happyGoto action_454\n"
"action_396 (112) = happyGoto action_38\n"
"action_396 (113) = happyGoto action_39\n"
"action_396 _ = happyFail\n"
"\n"
"action_397 (133) = happyShift action_43\n"
"action_397 (135) = happyShift action_45\n"
"action_397 (136) = happyShift action_46\n"
"action_397 (145) = happyShift action_108\n"
"action_397 (151) = happyShift action_109\n"
"action_397 (168) = happyShift action_393\n"
"action_397 (169) = happyShift action_49\n"
"action_397 (177) = happyShift action_50\n"
"action_397 (192) = happyShift action_52\n"
"action_397 (40) = happyGoto action_449\n"
"action_397 (41) = happyGoto action_101\n"
"action_397 (42) = happyGoto action_102\n"
"action_397 (53) = happyGoto action_450\n"
"action_397 (113) = happyGoto action_105\n"
"action_397 (114) = happyGoto action_106\n"
"action_397 (115) = happyGoto action_41\n"
"action_397 (132) = happyGoto action_107\n"
"action_397 _ = happyFail\n"
"\n"
"action_398 (135) = happyShift action_45\n"
"action_398 (115) = happyGoto action_338\n"
"action_398 _ = happyFail\n"
"\n"
"action_399 _ = happyReduce_115\n"
"\n"
"action_400 _ = happyReduce_114\n"
"\n"
"action_401 (133) = happyShift action_43\n"
"action_401 (135) = happyShift action_45\n"
"action_401 (136) = happyShift action_46\n"
"action_401 (145) = happyShift action_108\n"
"action_401 (151) = happyShift action_109\n"
"action_401 (169) = happyShift action_49\n"
"action_401 (177) = happyShift action_50\n"
"action_401 (192) = happyShift action_52\n"
"action_401 (41) = happyGoto action_448\n"
"action_401 (42) = happyGoto action_102\n"
"action_401 (113) = happyGoto action_105\n"
"action_401 (114) = happyGoto action_106\n"
"action_401 (115) = happyGoto action_41\n"
"action_401 (132) = happyGoto action_107\n"
"action_401 _ = happyFail\n"
"\n"
"action_402 (133) = happyShift action_43\n"
"action_402 (135) = happyShift action_45\n"
"action_402 (136) = happyShift action_46\n"
"action_402 (145) = happyShift action_108\n"
"action_402 (151) = happyShift action_109\n"
"action_402 (169) = happyShift action_49\n"
"action_402 (177) = happyShift action_50\n"
"action_402 (192) = happyShift action_52\n"
"action_402 (41) = happyGoto action_447\n"
"action_402 (42) = happyGoto action_102\n"
"action_402 (113) = happyGoto action_105\n"
"action_402 (114) = happyGoto action_106\n"
"action_402 (115) = happyGoto action_41\n"
"action_402 (132) = happyGoto action_107\n"
"action_402 _ = happyFail\n"
"\n"
"action_403 _ = happyReduce_133\n"
"\n"
"action_404 _ = happyReduce_132\n"
"\n"
"action_405 (7) = happyGoto action_445\n"
"action_405 (8) = happyGoto action_446\n"
"action_405 _ = happyReduce_11\n"
"\n"
"action_406 _ = happyReduce_138\n"
"\n"
"action_407 (133) = happyShift action_43\n"
"action_407 (134) = happyShift action_44\n"
"action_407 (135) = happyShift action_45\n"
"action_407 (136) = happyShift action_46\n"
"action_407 (141) = happyShift action_67\n"
"action_407 (142) = happyShift action_68\n"
"action_407 (143) = happyShift action_69\n"
"action_407 (144) = happyShift action_70\n"
"action_407 (145) = happyShift action_71\n"
"action_407 (151) = happyShift action_72\n"
"action_407 (154) = happyShift action_73\n"
"action_407 (165) = happyShift action_74\n"
"action_407 (167) = happyShift action_75\n"
"action_407 (169) = happyShift action_49\n"
"action_407 (170) = happyShift action_76\n"
"action_407 (175) = happyShift action_80\n"
"action_407 (177) = happyShift action_50\n"
"action_407 (192) = happyShift action_52\n"
"action_407 (71) = happyGoto action_56\n"
"action_407 (73) = happyGoto action_57\n"
"action_407 (74) = happyGoto action_58\n"
"action_407 (77) = happyGoto action_59\n"
"action_407 (78) = happyGoto action_60\n"
"action_407 (79) = happyGoto action_61\n"
"action_407 (98) = happyGoto action_62\n"
"action_407 (100) = happyGoto action_124\n"
"action_407 (102) = happyGoto action_64\n"
"action_407 (112) = happyGoto action_38\n"
"action_407 (113) = happyGoto action_39\n"
"action_407 (114) = happyGoto action_65\n"
"action_407 (115) = happyGoto action_41\n"
"action_407 (123) = happyGoto action_66\n"
"action_407 _ = happyFail\n"
"\n"
"action_408 (133) = happyShift action_43\n"
"action_408 (135) = happyShift action_45\n"
"action_408 (145) = happyShift action_207\n"
"action_408 (153) = happyShift action_48\n"
"action_408 (169) = happyShift action_49\n"
"action_408 (177) = happyShift action_50\n"
"action_408 (192) = happyShift action_52\n"
"action_408 (11) = happyGoto action_439\n"
"action_408 (21) = happyGoto action_440\n"
"action_408 (22) = happyGoto action_441\n"
"action_408 (99) = happyGoto action_442\n"
"action_408 (113) = happyGoto action_193\n"
"action_408 (115) = happyGoto action_443\n"
"action_408 (128) = happyGoto action_444\n"
"action_408 _ = happyReduce_17\n"
"\n"
"action_409 _ = happyReduce_214\n"
"\n"
"action_410 (147) = happyShift action_438\n"
"action_410 _ = happyFail\n"
"\n"
"action_411 _ = happyReduce_288\n"
"\n"
"action_412 _ = happyReduce_125\n"
"\n"
"action_413 (135) = happyShift action_45\n"
"action_413 (136) = happyShift action_46\n"
"action_413 (146) = happyShift action_437\n"
"action_413 (58) = happyGoto action_435\n"
"action_413 (114) = happyGoto action_411\n"
"action_413 (115) = happyGoto action_41\n"
"action_413 (131) = happyGoto action_436\n"
"action_413 _ = happyFail\n"
"\n"
"action_414 _ = happyReduce_105\n"
"\n"
"action_415 _ = happyReduce_201\n"
"\n"
"action_416 _ = happyReduce_200\n"
"\n"
"action_417 (7) = happyGoto action_433\n"
"action_417 (8) = happyGoto action_434\n"
"action_417 _ = happyReduce_11\n"
"\n"
"action_418 _ = happyReduce_204\n"
"\n"
"action_419 (133) = happyShift action_43\n"
"action_419 (134) = happyShift action_44\n"
"action_419 (135) = happyShift action_45\n"
"action_419 (136) = happyShift action_46\n"
"action_419 (141) = happyShift action_67\n"
"action_419 (142) = happyShift action_68\n"
"action_419 (143) = happyShift action_69\n"
"action_419 (144) = happyShift action_70\n"
"action_419 (145) = happyShift action_71\n"
"action_419 (151) = happyShift action_72\n"
"action_419 (154) = happyShift action_73\n"
"action_419 (165) = happyShift action_74\n"
"action_419 (167) = happyShift action_75\n"
"action_419 (169) = happyShift action_49\n"
"action_419 (170) = happyShift action_76\n"
"action_419 (175) = happyShift action_80\n"
"action_419 (177) = happyShift action_50\n"
"action_419 (192) = happyShift action_52\n"
"action_419 (71) = happyGoto action_431\n"
"action_419 (73) = happyGoto action_57\n"
"action_419 (74) = happyGoto action_58\n"
"action_419 (77) = happyGoto action_59\n"
"action_419 (78) = happyGoto action_60\n"
"action_419 (79) = happyGoto action_61\n"
"action_419 (93) = happyGoto action_432\n"
"action_419 (98) = happyGoto action_62\n"
"action_419 (100) = happyGoto action_124\n"
"action_419 (102) = happyGoto action_64\n"
"action_419 (112) = happyGoto action_38\n"
"action_419 (113) = happyGoto action_39\n"
"action_419 (114) = happyGoto action_65\n"
"action_419 (115) = happyGoto action_41\n"
"action_419 (123) = happyGoto action_66\n"
"action_419 _ = happyFail\n"
"\n"
"action_420 _ = happyReduce_155\n"
"\n"
"action_421 (133) = happyShift action_43\n"
"action_421 (134) = happyShift action_44\n"
"action_421 (135) = happyShift action_45\n"
"action_421 (136) = happyShift action_46\n"
"action_421 (141) = happyShift action_67\n"
"action_421 (142) = happyShift action_68\n"
"action_421 (143) = happyShift action_69\n"
"action_421 (144) = happyShift action_70\n"
"action_421 (145) = happyShift action_71\n"
"action_421 (151) = happyShift action_72\n"
"action_421 (154) = happyShift action_73\n"
"action_421 (160) = happyShift action_125\n"
"action_421 (165) = happyShift action_74\n"
"action_421 (167) = happyShift action_75\n"
"action_421 (169) = happyShift action_49\n"
"action_421 (170) = happyShift action_76\n"
"action_421 (175) = happyShift action_80\n"
"action_421 (177) = happyShift action_50\n"
"action_421 (178) = happyShift action_126\n"
"action_421 (185) = happyShift action_127\n"
"action_421 (192) = happyShift action_52\n"
"action_421 (68) = happyGoto action_430\n"
"action_421 (69) = happyGoto action_120\n"
"action_421 (70) = happyGoto action_121\n"
"action_421 (71) = happyGoto action_122\n"
"action_421 (72) = happyGoto action_123\n"
"action_421 (73) = happyGoto action_57\n"
"action_421 (74) = happyGoto action_58\n"
"action_421 (77) = happyGoto action_59\n"
"action_421 (78) = happyGoto action_60\n"
"action_421 (79) = happyGoto action_61\n"
"action_421 (98) = happyGoto action_62\n"
"action_421 (100) = happyGoto action_124\n"
"action_421 (102) = happyGoto action_64\n"
"action_421 (112) = happyGoto action_38\n"
"action_421 (113) = happyGoto action_39\n"
"action_421 (114) = happyGoto action_65\n"
"action_421 (115) = happyGoto action_41\n"
"action_421 (123) = happyGoto action_66\n"
"action_421 _ = happyFail\n"
"\n"
"action_422 (133) = happyReduce_279\n"
"action_422 (134) = happyReduce_279\n"
"action_422 (135) = happyReduce_279\n"
"action_422 (136) = happyReduce_279\n"
"action_422 (141) = happyReduce_279\n"
"action_422 (142) = happyReduce_279\n"
"action_422 (143) = happyReduce_279\n"
"action_422 (144) = happyReduce_279\n"
"action_422 (145) = happyReduce_279\n"
"action_422 (151) = happyReduce_279\n"
"action_422 (154) = happyReduce_279\n"
"action_422 (165) = happyReduce_279\n"
"action_422 (167) = happyReduce_279\n"
"action_422 (169) = happyReduce_279\n"
"action_422 (170) = happyReduce_279\n"
"action_422 (175) = happyReduce_279\n"
"action_422 (177) = happyReduce_279\n"
"action_422 (181) = happyReduce_279\n"
"action_422 (182) = happyReduce_279\n"
"action_422 (183) = happyReduce_279\n"
"action_422 (192) = happyReduce_279\n"
"action_422 (25) = happyGoto action_21\n"
"action_422 (35) = happyGoto action_429\n"
"action_422 (37) = happyGoto action_26\n"
"action_422 (63) = happyGoto action_27\n"
"action_422 (124) = happyGoto action_363\n"
"action_422 _ = happyReduce_10\n"
"\n"
"action_423 (147) = happyShift action_29\n"
"action_423 _ = happyReduce_71\n"
"\n"
"action_424 _ = happyReduce_195\n"
"\n"
"action_425 (133) = happyShift action_43\n"
"action_425 (134) = happyShift action_44\n"
"action_425 (135) = happyShift action_45\n"
"action_425 (136) = happyShift action_46\n"
"action_425 (141) = happyShift action_67\n"
"action_425 (142) = happyShift action_68\n"
"action_425 (143) = happyShift action_69\n"
"action_425 (144) = happyShift action_70\n"
"action_425 (145) = happyShift action_71\n"
"action_425 (151) = happyShift action_72\n"
"action_425 (154) = happyShift action_73\n"
"action_425 (160) = happyShift action_125\n"
"action_425 (165) = happyShift action_74\n"
"action_425 (167) = happyShift action_75\n"
"action_425 (169) = happyShift action_49\n"
"action_425 (170) = happyShift action_76\n"
"action_425 (175) = happyShift action_80\n"
"action_425 (177) = happyShift action_50\n"
"action_425 (178) = happyShift action_126\n"
"action_425 (185) = happyShift action_127\n"
"action_425 (192) = happyShift action_52\n"
"action_425 (68) = happyGoto action_428\n"
"action_425 (69) = happyGoto action_120\n"
"action_425 (70) = happyGoto action_121\n"
"action_425 (71) = happyGoto action_122\n"
"action_425 (72) = happyGoto action_123\n"
"action_425 (73) = happyGoto action_57\n"
"action_425 (74) = happyGoto action_58\n"
"action_425 (77) = happyGoto action_59\n"
"action_425 (78) = happyGoto action_60\n"
"action_425 (79) = happyGoto action_61\n"
"action_425 (98) = happyGoto action_62\n"
"action_425 (100) = happyGoto action_124\n"
"action_425 (102) = happyGoto action_64\n"
"action_425 (112) = happyGoto action_38\n"
"action_425 (113) = happyGoto action_39\n"
"action_425 (114) = happyGoto action_65\n"
"action_425 (115) = happyGoto action_41\n"
"action_425 (123) = happyGoto action_66\n"
"action_425 _ = happyFail\n"
"\n"
"action_426 _ = happyReduce_191\n"
"\n"
"action_427 _ = happyReduce_146\n"
"\n"
"action_428 _ = happyReduce_197\n"
"\n"
"action_429 _ = happyReduce_73\n"
"\n"
"action_430 _ = happyReduce_157\n"
"\n"
"action_431 (137) = happyShift action_172\n"
"action_431 (138) = happyShift action_150\n"
"action_431 (139) = happyShift action_151\n"
"action_431 (140) = happyShift action_152\n"
"action_431 (155) = happyShift action_173\n"
"action_431 (157) = happyShift action_156\n"
"action_431 (167) = happyShift action_175\n"
"action_431 (168) = happyShift action_176\n"
"action_431 (104) = happyGoto action_165\n"
"action_431 (107) = happyGoto action_166\n"
"action_431 (109) = happyGoto action_167\n"
"action_431 (111) = happyGoto action_168\n"
"action_431 (116) = happyGoto action_142\n"
"action_431 (117) = happyGoto action_143\n"
"action_431 (118) = happyGoto action_169\n"
"action_431 (120) = happyGoto action_146\n"
"action_431 (122) = happyGoto action_170\n"
"action_431 _ = happyReduce_211\n"
"\n"
"action_432 (163) = happyShift action_472\n"
"action_432 (90) = happyGoto action_468\n"
"action_432 (91) = happyGoto action_469\n"
"action_432 (92) = happyGoto action_470\n"
"action_432 (124) = happyGoto action_471\n"
"action_432 _ = happyReduce_279\n"
"\n"
"action_433 (133) = happyReduce_279\n"
"action_433 (134) = happyReduce_279\n"
"action_433 (135) = happyReduce_279\n"
"action_433 (136) = happyReduce_279\n"
"action_433 (141) = happyReduce_279\n"
"action_433 (142) = happyReduce_279\n"
"action_433 (143) = happyReduce_279\n"
"action_433 (144) = happyReduce_279\n"
"action_433 (145) = happyReduce_279\n"
"action_433 (151) = happyReduce_279\n"
"action_433 (154) = happyReduce_279\n"
"action_433 (165) = happyReduce_279\n"
"action_433 (167) = happyReduce_279\n"
"action_433 (169) = happyReduce_279\n"
"action_433 (170) = happyReduce_279\n"
"action_433 (175) = happyReduce_279\n"
"action_433 (177) = happyReduce_279\n"
"action_433 (192) = happyReduce_279\n"
"action_433 (89) = happyGoto action_467\n"
"action_433 (124) = happyGoto action_419\n"
"action_433 _ = happyReduce_10\n"
"\n"
"action_434 (147) = happyShift action_29\n"
"action_434 _ = happyReduce_202\n"
"\n"
"action_435 (146) = happyShift action_465\n"
"action_435 (153) = happyShift action_466\n"
"action_435 _ = happyFail\n"
"\n"
"action_436 _ = happyReduce_129\n"
"\n"
"action_437 _ = happyReduce_126\n"
"\n"
"action_438 (133) = happyShift action_43\n"
"action_438 (134) = happyShift action_44\n"
"action_438 (135) = happyShift action_45\n"
"action_438 (136) = happyShift action_46\n"
"action_438 (141) = happyShift action_67\n"
"action_438 (142) = happyShift action_68\n"
"action_438 (143) = happyShift action_69\n"
"action_438 (144) = happyShift action_70\n"
"action_438 (145) = happyShift action_71\n"
"action_438 (147) = happyShift action_257\n"
"action_438 (151) = happyShift action_72\n"
"action_438 (154) = happyShift action_73\n"
"action_438 (160) = happyShift action_125\n"
"action_438 (165) = happyShift action_74\n"
"action_438 (167) = happyShift action_75\n"
"action_438 (169) = happyShift action_49\n"
"action_438 (170) = happyShift action_76\n"
"action_438 (175) = happyShift action_80\n"
"action_438 (177) = happyShift action_50\n"
"action_438 (178) = happyShift action_126\n"
"action_438 (185) = happyShift action_258\n"
"action_438 (192) = happyShift action_52\n"
"action_438 (68) = happyGoto action_253\n"
"action_438 (69) = happyGoto action_120\n"
"action_438 (70) = happyGoto action_121\n"
"action_438 (71) = happyGoto action_254\n"
"action_438 (72) = happyGoto action_123\n"
"action_438 (73) = happyGoto action_57\n"
"action_438 (74) = happyGoto action_58\n"
"action_438 (77) = happyGoto action_59\n"
"action_438 (78) = happyGoto action_60\n"
"action_438 (79) = happyGoto action_61\n"
"action_438 (93) = happyGoto action_255\n"
"action_438 (95) = happyGoto action_464\n"
"action_438 (98) = happyGoto action_62\n"
"action_438 (100) = happyGoto action_124\n"
"action_438 (102) = happyGoto action_64\n"
"action_438 (112) = happyGoto action_38\n"
"action_438 (113) = happyGoto action_39\n"
"action_438 (114) = happyGoto action_65\n"
"action_438 (115) = happyGoto action_41\n"
"action_438 (123) = happyGoto action_66\n"
"action_438 _ = happyFail\n"
"\n"
"action_439 (146) = happyShift action_463\n"
"action_439 _ = happyFail\n"
"\n"
"action_440 (153) = happyShift action_462\n"
"action_440 (11) = happyGoto action_461\n"
"action_440 _ = happyReduce_17\n"
"\n"
"action_441 _ = happyReduce_40\n"
"\n"
"action_442 _ = happyReduce_41\n"
"\n"
"action_443 _ = happyReduce_285\n"
"\n"
"action_444 (145) = happyShift action_460\n"
"action_444 _ = happyReduce_42\n"
"\n"
"action_445 (133) = happyReduce_279\n"
"action_445 (134) = happyReduce_279\n"
"action_445 (135) = happyReduce_279\n"
"action_445 (136) = happyReduce_279\n"
"action_445 (141) = happyReduce_279\n"
"action_445 (142) = happyReduce_279\n"
"action_445 (143) = happyReduce_279\n"
"action_445 (144) = happyReduce_279\n"
"action_445 (145) = happyReduce_279\n"
"action_445 (151) = happyReduce_279\n"
"action_445 (154) = happyReduce_279\n"
"action_445 (165) = happyReduce_279\n"
"action_445 (167) = happyReduce_279\n"
"action_445 (169) = happyReduce_279\n"
"action_445 (170) = happyReduce_279\n"
"action_445 (175) = happyReduce_279\n"
"action_445 (177) = happyReduce_279\n"
"action_445 (192) = happyReduce_279\n"
"action_445 (63) = happyGoto action_459\n"
"action_445 (124) = happyGoto action_407\n"
"action_445 _ = happyReduce_10\n"
"\n"
"action_446 (147) = happyShift action_29\n"
"action_446 _ = happyReduce_135\n"
"\n"
"action_447 _ = happyReduce_113\n"
"\n"
"action_448 _ = happyReduce_116\n"
"\n"
"action_449 (133) = happyShift action_43\n"
"action_449 (135) = happyShift action_45\n"
"action_449 (136) = happyShift action_46\n"
"action_449 (145) = happyShift action_108\n"
"action_449 (151) = happyShift action_109\n"
"action_449 (169) = happyShift action_49\n"
"action_449 (177) = happyShift action_50\n"
"action_449 (192) = happyShift action_52\n"
"action_449 (41) = happyGoto action_272\n"
"action_449 (42) = happyGoto action_102\n"
"action_449 (113) = happyGoto action_105\n"
"action_449 (114) = happyGoto action_106\n"
"action_449 (115) = happyGoto action_41\n"
"action_449 (132) = happyGoto action_107\n"
"action_449 _ = happyReduce_117\n"
"\n"
"action_450 _ = happyReduce_108\n"
"\n"
"action_451 (153) = happyShift action_177\n"
"action_451 (158) = happyShift action_458\n"
"action_451 _ = happyFail\n"
"\n"
"action_452 (149) = happyShift action_456\n"
"action_452 (153) = happyShift action_457\n"
"action_452 _ = happyFail\n"
"\n"
"action_453 _ = happyReduce_120\n"
"\n"
"action_454 _ = happyReduce_82\n"
"\n"
"action_455 _ = happyReduce_109\n"
"\n"
"action_456 _ = happyReduce_110\n"
"\n"
"action_457 (133) = happyShift action_43\n"
"action_457 (134) = happyShift action_44\n"
"action_457 (145) = happyShift action_47\n"
"action_457 (169) = happyShift action_49\n"
"action_457 (177) = happyShift action_50\n"
"action_457 (192) = happyShift action_52\n"
"action_457 (38) = happyGoto action_451\n"
"action_457 (55) = happyGoto action_486\n"
"action_457 (100) = happyGoto action_454\n"
"action_457 (112) = happyGoto action_38\n"
"action_457 (113) = happyGoto action_39\n"
"action_457 _ = happyFail\n"
"\n"
"action_458 (133) = happyShift action_43\n"
"action_458 (135) = happyShift action_45\n"
"action_458 (136) = happyShift action_46\n"
"action_458 (145) = happyShift action_108\n"
"action_458 (151) = happyShift action_109\n"
"action_458 (168) = happyShift action_485\n"
"action_458 (169) = happyShift action_49\n"
"action_458 (177) = happyShift action_50\n"
"action_458 (192) = happyShift action_52\n"
"action_458 (39) = happyGoto action_483\n"
"action_458 (40) = happyGoto action_251\n"
"action_458 (41) = happyGoto action_101\n"
"action_458 (42) = happyGoto action_102\n"
"action_458 (56) = happyGoto action_484\n"
"action_458 (113) = happyGoto action_105\n"
"action_458 (114) = happyGoto action_106\n"
"action_458 (115) = happyGoto action_41\n"
"action_458 (132) = happyGoto action_107\n"
"action_458 _ = happyFail\n"
"\n"
"action_459 _ = happyReduce_137\n"
"\n"
"action_460 (133) = happyShift action_43\n"
"action_460 (135) = happyShift action_45\n"
"action_460 (145) = happyShift action_195\n"
"action_460 (146) = happyShift action_481\n"
"action_460 (156) = happyShift action_482\n"
"action_460 (169) = happyShift action_49\n"
"action_460 (177) = happyShift action_50\n"
"action_460 (192) = happyShift action_52\n"
"action_460 (23) = happyGoto action_480\n"
"action_460 (24) = happyGoto action_190\n"
"action_460 (99) = happyGoto action_191\n"
"action_460 (101) = happyGoto action_192\n"
"action_460 (113) = happyGoto action_193\n"
"action_460 (115) = happyGoto action_194\n"
"action_460 _ = happyFail\n"
"\n"
"action_461 (146) = happyShift action_479\n"
"action_461 _ = happyFail\n"
"\n"
"action_462 (133) = happyShift action_43\n"
"action_462 (135) = happyShift action_45\n"
"action_462 (145) = happyShift action_207\n"
"action_462 (169) = happyShift action_49\n"
"action_462 (177) = happyShift action_50\n"
"action_462 (192) = happyShift action_52\n"
"action_462 (22) = happyGoto action_478\n"
"action_462 (99) = happyGoto action_442\n"
"action_462 (113) = happyGoto action_193\n"
"action_462 (115) = happyGoto action_443\n"
"action_462 (128) = happyGoto action_444\n"
"action_462 _ = happyReduce_16\n"
"\n"
"action_463 _ = happyReduce_36\n"
"\n"
"action_464 _ = happyReduce_215\n"
"\n"
"action_465 _ = happyReduce_127\n"
"\n"
"action_466 (135) = happyShift action_45\n"
"action_466 (136) = happyShift action_46\n"
"action_466 (114) = happyGoto action_411\n"
"action_466 (115) = happyGoto action_41\n"
"action_466 (131) = happyGoto action_477\n"
"action_466 _ = happyFail\n"
"\n"
"action_467 _ = happyReduce_203\n"
"\n"
"action_468 (191) = happyShift action_215\n"
"action_468 (64) = happyGoto action_476\n"
"action_468 _ = happyReduce_141\n"
"\n"
"action_469 (161) = happyReduce_279\n"
"action_469 (92) = happyGoto action_475\n"
"action_469 (124) = happyGoto action_471\n"
"action_469 _ = happyReduce_207\n"
"\n"
"action_470 _ = happyReduce_209\n"
"\n"
"action_471 (161) = happyShift action_474\n"
"action_471 _ = happyFail\n"
"\n"
"action_472 (133) = happyShift action_43\n"
"action_472 (134) = happyShift action_44\n"
"action_472 (135) = happyShift action_45\n"
"action_472 (136) = happyShift action_46\n"
"action_472 (141) = happyShift action_67\n"
"action_472 (142) = happyShift action_68\n"
"action_472 (143) = happyShift action_69\n"
"action_472 (144) = happyShift action_70\n"
"action_472 (145) = happyShift action_71\n"
"action_472 (151) = happyShift action_72\n"
"action_472 (154) = happyShift action_73\n"
"action_472 (160) = happyShift action_125\n"
"action_472 (165) = happyShift action_74\n"
"action_472 (167) = happyShift action_75\n"
"action_472 (169) = happyShift action_49\n"
"action_472 (170) = happyShift action_76\n"
"action_472 (175) = happyShift action_80\n"
"action_472 (177) = happyShift action_50\n"
"action_472 (178) = happyShift action_126\n"
"action_472 (185) = happyShift action_127\n"
"action_472 (192) = happyShift action_52\n"
"action_472 (68) = happyGoto action_473\n"
"action_472 (69) = happyGoto action_120\n"
"action_472 (70) = happyGoto action_121\n"
"action_472 (71) = happyGoto action_122\n"
"action_472 (72) = happyGoto action_123\n"
"action_472 (73) = happyGoto action_57\n"
"action_472 (74) = happyGoto action_58\n"
"action_472 (77) = happyGoto action_59\n"
"action_472 (78) = happyGoto action_60\n"
"action_472 (79) = happyGoto action_61\n"
"action_472 (98) = happyGoto action_62\n"
"action_472 (100) = happyGoto action_124\n"
"action_472 (102) = happyGoto action_64\n"
"action_472 (112) = happyGoto action_38\n"
"action_472 (113) = happyGoto action_39\n"
"action_472 (114) = happyGoto action_65\n"
"action_472 (115) = happyGoto action_41\n"
"action_472 (123) = happyGoto action_66\n"
"action_472 _ = happyFail\n"
"\n"
"action_473 _ = happyReduce_206\n"
"\n"
"action_474 (133) = happyShift action_43\n"
"action_474 (134) = happyShift action_44\n"
"action_474 (135) = happyShift action_45\n"
"action_474 (136) = happyShift action_46\n"
"action_474 (141) = happyShift action_67\n"
"action_474 (142) = happyShift action_68\n"
"action_474 (143) = happyShift action_69\n"
"action_474 (144) = happyShift action_70\n"
"action_474 (145) = happyShift action_71\n"
"action_474 (151) = happyShift action_72\n"
"action_474 (154) = happyShift action_73\n"
"action_474 (160) = happyShift action_125\n"
"action_474 (165) = happyShift action_74\n"
"action_474 (167) = happyShift action_75\n"
"action_474 (169) = happyShift action_49\n"
"action_474 (170) = happyShift action_76\n"
"action_474 (175) = happyShift action_80\n"
"action_474 (177) = happyShift action_50\n"
"action_474 (178) = happyShift action_126\n"
"action_474 (185) = happyShift action_127\n"
"action_474 (192) = happyShift action_52\n"
"action_474 (69) = happyGoto action_490\n"
"action_474 (70) = happyGoto action_121\n"
"action_474 (71) = happyGoto action_225\n"
"action_474 (72) = happyGoto action_123\n"
"action_474 (73) = happyGoto action_57\n"
"action_474 (74) = happyGoto action_58\n"
"action_474 (77) = happyGoto action_59\n"
"action_474 (78) = happyGoto action_60\n"
"action_474 (79) = happyGoto action_61\n"
"action_474 (98) = happyGoto action_62\n"
"action_474 (100) = happyGoto action_124\n"
"action_474 (102) = happyGoto action_64\n"
"action_474 (112) = happyGoto action_38\n"
"action_474 (113) = happyGoto action_39\n"
"action_474 (114) = happyGoto action_65\n"
"action_474 (115) = happyGoto action_41\n"
"action_474 (123) = happyGoto action_66\n"
"action_474 _ = happyFail\n"
"\n"
"action_475 _ = happyReduce_208\n"
"\n"
"action_476 _ = happyReduce_205\n"
"\n"
"action_477 _ = happyReduce_128\n"
"\n"
"action_478 _ = happyReduce_39\n"
"\n"
"action_479 _ = happyReduce_35\n"
"\n"
"action_480 (146) = happyShift action_489\n"
"action_480 (153) = happyShift action_343\n"
"action_480 _ = happyFail\n"
"\n"
"action_481 _ = happyReduce_44\n"
"\n"
"action_482 (146) = happyShift action_488\n"
"action_482 _ = happyFail\n"
"\n"
"action_483 _ = happyReduce_122\n"
"\n"
"action_484 _ = happyReduce_121\n"
"\n"
"action_485 (133) = happyShift action_43\n"
"action_485 (135) = happyShift action_45\n"
"action_485 (136) = happyShift action_46\n"
"action_485 (145) = happyShift action_108\n"
"action_485 (151) = happyShift action_109\n"
"action_485 (169) = happyShift action_49\n"
"action_485 (177) = happyShift action_50\n"
"action_485 (192) = happyShift action_52\n"
"action_485 (41) = happyGoto action_487\n"
"action_485 (42) = happyGoto action_102\n"
"action_485 (113) = happyGoto action_105\n"
"action_485 (114) = happyGoto action_106\n"
"action_485 (115) = happyGoto action_41\n"
"action_485 (132) = happyGoto action_107\n"
"action_485 _ = happyFail\n"
"\n"
"action_486 _ = happyReduce_119\n"
"\n"
"action_487 _ = happyReduce_123\n"
"\n"
"action_488 _ = happyReduce_43\n"
"\n"
"action_489 _ = happyReduce_45\n"
"\n"
"action_490 (163) = happyShift action_491\n"
"action_490 _ = happyFail\n"
"\n"
"action_491 (133) = happyShift action_43\n"
"action_491 (134) = happyShift action_44\n"
"action_491 (135) = happyShift action_45\n"
"action_491 (136) = happyShift action_46\n"
"action_491 (141) = happyShift action_67\n"
"action_491 (142) = happyShift action_68\n"
"action_491 (143) = happyShift action_69\n"
"action_491 (144) = happyShift action_70\n"
"action_491 (145) = happyShift action_71\n"
"action_491 (151) = happyShift action_72\n"
"action_491 (154) = happyShift action_73\n"
"action_491 (160) = happyShift action_125\n"
"action_491 (165) = happyShift action_74\n"
"action_491 (167) = happyShift action_75\n"
"action_491 (169) = happyShift action_49\n"
"action_491 (170) = happyShift action_76\n"
"action_491 (175) = happyShift action_80\n"
"action_491 (177) = happyShift action_50\n"
"action_491 (178) = happyShift action_126\n"
"action_491 (185) = happyShift action_127\n"
"action_491 (192) = happyShift action_52\n"
"action_491 (68) = happyGoto action_492\n"
"action_491 (69) = happyGoto action_120\n"
"action_491 (70) = happyGoto action_121\n"
"action_491 (71) = happyGoto action_122\n"
"action_491 (72) = happyGoto action_123\n"
"action_491 (73) = happyGoto action_57\n"
"action_491 (74) = happyGoto action_58\n"
"action_491 (77) = happyGoto action_59\n"
"action_491 (78) = happyGoto action_60\n"
"action_491 (79) = happyGoto action_61\n"
"action_491 (98) = happyGoto action_62\n"
"action_491 (100) = happyGoto action_124\n"
"action_491 (102) = happyGoto action_64\n"
"action_491 (112) = happyGoto action_38\n"
"action_491 (113) = happyGoto action_39\n"
"action_491 (114) = happyGoto action_65\n"
"action_491 (115) = happyGoto action_41\n"
"action_491 (123) = happyGoto action_66\n"
"action_491 _ = happyFail\n"
"\n"
"action_492 _ = happyReduce_210\n"
"\n"
"happyReduce_1 = happyReduce 6 4 happyReduction_1\n"
"happyReduction_1 ((HappyAbsSyn5  happy_var_6) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn9  happy_var_4) `HappyStk`\n"
"	(HappyAbsSyn127  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn4\n"
"		 (HsModule happy_var_1 happy_var_3 happy_var_4 (fst happy_var_6) (snd happy_var_6)\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_2 = happySpecReduce_2 4 happyReduction_2\n"
"happyReduction_2 (HappyAbsSyn5  happy_var_2)\n"
"	(HappyAbsSyn124  happy_var_1)\n"
"	 =  HappyAbsSyn4\n"
"		 (HsModule happy_var_1 main_mod (Just [HsEVar (UnQual main_name)])\n"
"							(fst happy_var_2) (snd happy_var_2)\n"
"	)\n"
"happyReduction_2 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_3 = happySpecReduce_3 5 happyReduction_3\n"
"happyReduction_3 _\n"
"	(HappyAbsSyn5  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn5\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_3 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_4 = happySpecReduce_3 5 happyReduction_4\n"
"happyReduction_4 _\n"
"	(HappyAbsSyn5  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn5\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_4 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_5 = happyReduce 4 6 happyReduction_5\n"
"happyReduction_5 ((HappyAbsSyn29  happy_var_4) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn14  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn5\n"
"		 ((reverse happy_var_2, happy_var_4)\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_6 = happySpecReduce_2 6 happyReduction_6\n"
"happyReduction_6 (HappyAbsSyn29  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn5\n"
"		 (([], happy_var_2)\n"
"	)\n"
"happyReduction_6 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_7 = happySpecReduce_3 6 happyReduction_7\n"
"happyReduction_7 _\n"
"	(HappyAbsSyn14  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn5\n"
"		 ((reverse happy_var_2, [])\n"
"	)\n"
"happyReduction_7 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_8 = happySpecReduce_1 6 happyReduction_8\n"
"happyReduction_8 _\n"
"	 =  HappyAbsSyn5\n"
"		 (([], [])\n"
"	)\n"
"\n"
"happyReduce_9 = happySpecReduce_2 7 happyReduction_9\n"
"happyReduction_9 _\n"
"	_\n"
"	 =  HappyAbsSyn7\n"
"		 (()\n"
"	)\n"
"\n"
"happyReduce_10 = happySpecReduce_1 8 happyReduction_10\n"
"happyReduction_10 _\n"
"	 =  HappyAbsSyn7\n"
"		 (()\n"
"	)\n"
"\n"
"happyReduce_11 = happySpecReduce_0 8 happyReduction_11\n"
"happyReduction_11  =  HappyAbsSyn7\n"
"		 (()\n"
"	)\n"
"\n"
"happyReduce_12 = happySpecReduce_1 9 happyReduction_12\n"
"happyReduction_12 (HappyAbsSyn10  happy_var_1)\n"
"	 =  HappyAbsSyn9\n"
"		 (Just happy_var_1\n"
"	)\n"
"happyReduction_12 _  = notHappyAtAll \n"
"\n"
"happyReduce_13 = happySpecReduce_0 9 happyReduction_13\n"
"happyReduction_13  =  HappyAbsSyn9\n"
"		 (Nothing\n"
"	)\n"
"\n"
"happyReduce_14 = happyReduce 4 10 happyReduction_14\n"
"happyReduction_14 (_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn10  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn10\n"
"		 (reverse happy_var_2\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_15 = happySpecReduce_3 10 happyReduction_15\n"
"happyReduction_15 _\n"
"	_\n"
"	_\n"
"	 =  HappyAbsSyn10\n"
"		 ([]\n"
"	)\n"
"\n"
"happyReduce_16 = happySpecReduce_1 11 happyReduction_16\n"
"happyReduction_16 _\n"
"	 =  HappyAbsSyn7\n"
"		 (()\n"
"	)\n"
"\n"
"happyReduce_17 = happySpecReduce_0 11 happyReduction_17\n"
"happyReduction_17  =  HappyAbsSyn7\n"
"		 (()\n"
"	)\n"
"\n"
"happyReduce_18 = happySpecReduce_3 12 happyReduction_18\n"
"happyReduction_18 (HappyAbsSyn13  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn10  happy_var_1)\n"
"	 =  HappyAbsSyn10\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_18 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_19 = happySpecReduce_1 12 happyReduction_19\n"
"happyReduction_19 (HappyAbsSyn13  happy_var_1)\n"
"	 =  HappyAbsSyn10\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_19 _  = notHappyAtAll \n"
"\n"
"happyReduce_20 = happySpecReduce_1 13 happyReduction_20\n"
"happyReduction_20 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn13\n"
"		 (HsEVar happy_var_1\n"
"	)\n"
"happyReduction_20 _  = notHappyAtAll \n"
"\n"
"happyReduce_21 = happySpecReduce_1 13 happyReduction_21\n"
"happyReduction_21 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn13\n"
"		 (HsEAbs happy_var_1\n"
"	)\n"
"happyReduction_21 _  = notHappyAtAll \n"
"\n"
"happyReduce_22 = happyReduce 4 13 happyReduction_22\n"
"happyReduction_22 (_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn42  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn13\n"
"		 (HsEThingAll happy_var_1\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_23 = happySpecReduce_3 13 happyReduction_23\n"
"happyReduction_23 _\n"
"	_\n"
"	(HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn13\n"
"		 (HsEThingWith happy_var_1 []\n"
"	)\n"
"happyReduction_23 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_24 = happyReduce 4 13 happyReduction_24\n"
"happyReduction_24 (_ `HappyStk`\n"
"	(HappyAbsSyn23  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn42  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn13\n"
"		 (HsEThingWith happy_var_1 (reverse happy_var_3)\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_25 = happySpecReduce_2 13 happyReduction_25\n"
"happyReduction_25 (HappyAbsSyn127  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn13\n"
"		 (HsEModuleContents happy_var_2\n"
"	)\n"
"happyReduction_25 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_26 = happySpecReduce_3 14 happyReduction_26\n"
"happyReduction_26 (HappyAbsSyn15  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn14  happy_var_1)\n"
"	 =  HappyAbsSyn14\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_26 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_27 = happySpecReduce_1 14 happyReduction_27\n"
"happyReduction_27 (HappyAbsSyn15  happy_var_1)\n"
"	 =  HappyAbsSyn14\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_27 _  = notHappyAtAll \n"
"\n"
"happyReduce_28 = happyReduce 6 15 happyReduction_28\n"
"happyReduction_28 ((HappyAbsSyn18  happy_var_6) `HappyStk`\n"
"	(HappyAbsSyn17  happy_var_5) `HappyStk`\n"
"	(HappyAbsSyn127  happy_var_4) `HappyStk`\n"
"	(HappyAbsSyn16  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn15\n"
"		 (HsImportDecl happy_var_1 happy_var_4 happy_var_3 happy_var_5 happy_var_6\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_29 = happySpecReduce_1 16 happyReduction_29\n"
"happyReduction_29 _\n"
"	 =  HappyAbsSyn16\n"
"		 (True\n"
"	)\n"
"\n"
"happyReduce_30 = happySpecReduce_0 16 happyReduction_30\n"
"happyReduction_30  =  HappyAbsSyn16\n"
"		 (False\n"
"	)\n"
"\n"
"happyReduce_31 = happySpecReduce_2 17 happyReduction_31\n"
"happyReduction_31 (HappyAbsSyn127  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn17\n"
"		 (Just happy_var_2\n"
"	)\n"
"happyReduction_31 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_32 = happySpecReduce_0 17 happyReduction_32\n"
"happyReduction_32  =  HappyAbsSyn17\n"
"		 (Nothing\n"
"	)\n"
"\n"
"happyReduce_33 = happySpecReduce_1 18 happyReduction_33\n"
"happyReduction_33 (HappyAbsSyn19  happy_var_1)\n"
"	 =  HappyAbsSyn18\n"
"		 (Just happy_var_1\n"
"	)\n"
"happyReduction_33 _  = notHappyAtAll \n"
"\n"
"happyReduce_34 = happySpecReduce_0 18 happyReduction_34\n"
"happyReduction_34  =  HappyAbsSyn18\n"
"		 (Nothing\n"
"	)\n"
"\n"
"happyReduce_35 = happyReduce 5 19 happyReduction_35\n"
"happyReduction_35 (_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn21  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn16  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn19\n"
"		 ((happy_var_1, reverse happy_var_3)\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_36 = happyReduce 4 19 happyReduction_36\n"
"happyReduction_36 (_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn16  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn19\n"
"		 ((happy_var_1, [])\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_37 = happySpecReduce_1 20 happyReduction_37\n"
"happyReduction_37 _\n"
"	 =  HappyAbsSyn16\n"
"		 (True\n"
"	)\n"
"\n"
"happyReduce_38 = happySpecReduce_0 20 happyReduction_38\n"
"happyReduction_38  =  HappyAbsSyn16\n"
"		 (False\n"
"	)\n"
"\n"
"happyReduce_39 = happySpecReduce_3 21 happyReduction_39\n"
"happyReduction_39 (HappyAbsSyn22  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn21  happy_var_1)\n"
"	 =  HappyAbsSyn21\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_39 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_40 = happySpecReduce_1 21 happyReduction_40\n"
"happyReduction_40 (HappyAbsSyn22  happy_var_1)\n"
"	 =  HappyAbsSyn21\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_40 _  = notHappyAtAll \n"
"\n"
"happyReduce_41 = happySpecReduce_1 22 happyReduction_41\n"
"happyReduction_41 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn22\n"
"		 (HsIVar happy_var_1\n"
"	)\n"
"happyReduction_41 _  = notHappyAtAll \n"
"\n"
"happyReduce_42 = happySpecReduce_1 22 happyReduction_42\n"
"happyReduction_42 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn22\n"
"		 (HsIAbs happy_var_1\n"
"	)\n"
"happyReduction_42 _  = notHappyAtAll \n"
"\n"
"happyReduce_43 = happyReduce 4 22 happyReduction_43\n"
"happyReduction_43 (_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn99  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn22\n"
"		 (HsIThingAll happy_var_1\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_44 = happySpecReduce_3 22 happyReduction_44\n"
"happyReduction_44 _\n"
"	_\n"
"	(HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn22\n"
"		 (HsIThingWith happy_var_1 []\n"
"	)\n"
"happyReduction_44 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_45 = happyReduce 4 22 happyReduction_45\n"
"happyReduction_45 (_ `HappyStk`\n"
"	(HappyAbsSyn23  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn99  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn22\n"
"		 (HsIThingWith happy_var_1 (reverse happy_var_3)\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_46 = happySpecReduce_3 23 happyReduction_46\n"
"happyReduction_46 (HappyAbsSyn24  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn23  happy_var_1)\n"
"	 =  HappyAbsSyn23\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_46 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_47 = happySpecReduce_1 23 happyReduction_47\n"
"happyReduction_47 (HappyAbsSyn24  happy_var_1)\n"
"	 =  HappyAbsSyn23\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_47 _  = notHappyAtAll \n"
"\n"
"happyReduce_48 = happySpecReduce_1 24 happyReduction_48\n"
"happyReduction_48 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn24\n"
"		 (HsVarName happy_var_1\n"
"	)\n"
"happyReduction_48 _  = notHappyAtAll \n"
"\n"
"happyReduce_49 = happySpecReduce_1 24 happyReduction_49\n"
"happyReduction_49 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn24\n"
"		 (HsConName happy_var_1\n"
"	)\n"
"happyReduction_49 _  = notHappyAtAll \n"
"\n"
"happyReduce_50 = happyReduce 4 25 happyReduction_50\n"
"happyReduction_50 ((HappyAbsSyn28  happy_var_4) `HappyStk`\n"
"	(HappyAbsSyn26  happy_var_3) `HappyStk`\n"
"	(HappyAbsSyn27  happy_var_2) `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn25\n"
"		 (HsInfixDecl happy_var_1 happy_var_2 happy_var_3 (reverse happy_var_4)\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_51 = happySpecReduce_0 26 happyReduction_51\n"
"happyReduction_51  =  HappyAbsSyn26\n"
"		 (9\n"
"	)\n"
"\n"
"happyReduce_52 = happyMonadReduce 1 26 happyReduction_52\n"
"happyReduction_52 ((HappyTerminal (IntTok happy_var_1)) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( checkPrec happy_var_1\n"
"	) (\\r -> happyReturn (HappyAbsSyn26 r))\n"
"\n"
"happyReduce_53 = happySpecReduce_1 27 happyReduction_53\n"
"happyReduction_53 _\n"
"	 =  HappyAbsSyn27\n"
"		 (HsAssocNone\n"
"	)\n"
"\n"
"happyReduce_54 = happySpecReduce_1 27 happyReduction_54\n"
"happyReduction_54 _\n"
"	 =  HappyAbsSyn27\n"
"		 (HsAssocLeft\n"
"	)\n"
"\n"
"happyReduce_55 = happySpecReduce_1 27 happyReduction_55\n"
"happyReduction_55 _\n"
"	 =  HappyAbsSyn27\n"
"		 (HsAssocRight\n"
"	)\n"
"\n"
"happyReduce_56 = happySpecReduce_3 28 happyReduction_56\n"
"happyReduction_56 (HappyAbsSyn108  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn28  happy_var_1)\n"
"	 =  HappyAbsSyn28\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_56 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_57 = happySpecReduce_1 28 happyReduction_57\n"
"happyReduction_57 (HappyAbsSyn108  happy_var_1)\n"
"	 =  HappyAbsSyn28\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_57 _  = notHappyAtAll \n"
"\n"
"happyReduce_58 = happyMonadReduce 2 29 happyReduction_58\n"
"happyReduction_58 (_ `HappyStk`\n"
"	(HappyAbsSyn29  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( checkRevDecls happy_var_1\n"
"	) (\\r -> happyReturn (HappyAbsSyn29 r))\n"
"\n"
"happyReduce_59 = happySpecReduce_3 30 happyReduction_59\n"
"happyReduction_59 (HappyAbsSyn25  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn29  happy_var_1)\n"
"	 =  HappyAbsSyn29\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_59 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_60 = happySpecReduce_1 30 happyReduction_60\n"
"happyReduction_60 (HappyAbsSyn25  happy_var_1)\n"
"	 =  HappyAbsSyn29\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_60 _  = notHappyAtAll \n"
"\n"
"happyReduce_61 = happyReduce 5 31 happyReduction_61\n"
"happyReduction_61 ((HappyAbsSyn39  happy_var_5) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn46  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn25\n"
"		 (HsTypeDecl happy_var_1 (fst happy_var_3) (snd happy_var_3) happy_var_5\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_62 = happyMonadReduce 6 31 happyReduction_62\n"
"happyReduction_62 ((HappyAbsSyn57  happy_var_6) `HappyStk`\n"
"	(HappyAbsSyn48  happy_var_5) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn43  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( do { (cs,c,t) <- checkDataHeader happy_var_3;\n"
"				return (HsDataDecl happy_var_1 cs c t (reverse happy_var_5) happy_var_6) }\n"
"	) (\\r -> happyReturn (HappyAbsSyn25 r))\n"
"\n"
"happyReduce_63 = happyMonadReduce 6 31 happyReduction_63\n"
"happyReduction_63 ((HappyAbsSyn57  happy_var_6) `HappyStk`\n"
"	(HappyAbsSyn49  happy_var_5) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn43  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( do { (cs,c,t) <- checkDataHeader happy_var_3;\n"
"				return (HsNewTypeDecl happy_var_1 cs c t happy_var_5 happy_var_6) }\n"
"	) (\\r -> happyReturn (HappyAbsSyn25 r))\n"
"\n"
"happyReduce_64 = happyMonadReduce 4 31 happyReduction_64\n"
"happyReduction_64 ((HappyAbsSyn29  happy_var_4) `HappyStk`\n"
"	(HappyAbsSyn43  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( do { (cs,c,vs) <- checkClassHeader happy_var_3;\n"
"				return (HsClassDecl happy_var_1 cs c vs happy_var_4) }\n"
"	) (\\r -> happyReturn (HappyAbsSyn25 r))\n"
"\n"
"happyReduce_65 = happyMonadReduce 4 31 happyReduction_65\n"
"happyReduction_65 ((HappyAbsSyn29  happy_var_4) `HappyStk`\n"
"	(HappyAbsSyn43  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( do { (cs,c,ts) <- checkInstHeader happy_var_3;\n"
"				return (HsInstDecl happy_var_1 cs c ts happy_var_4) }\n"
"	) (\\r -> happyReturn (HappyAbsSyn25 r))\n"
"\n"
"happyReduce_66 = happyReduce 5 31 happyReduction_66\n"
"happyReduction_66 (_ `HappyStk`\n"
"	(HappyAbsSyn32  happy_var_4) `HappyStk`\n"
"	_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn25\n"
"		 (HsDefaultDecl happy_var_1 happy_var_4\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_67 = happySpecReduce_1 31 happyReduction_67\n"
"happyReduction_67 (HappyAbsSyn25  happy_var_1)\n"
"	 =  HappyAbsSyn25\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_67 _  = notHappyAtAll \n"
"\n"
"happyReduce_68 = happySpecReduce_1 32 happyReduction_68\n"
"happyReduction_68 (HappyAbsSyn32  happy_var_1)\n"
"	 =  HappyAbsSyn32\n"
"		 (reverse happy_var_1\n"
"	)\n"
"happyReduction_68 _  = notHappyAtAll \n"
"\n"
"happyReduce_69 = happySpecReduce_1 32 happyReduction_69\n"
"happyReduction_69 (HappyAbsSyn39  happy_var_1)\n"
"	 =  HappyAbsSyn32\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_69 _  = notHappyAtAll \n"
"\n"
"happyReduce_70 = happySpecReduce_0 32 happyReduction_70\n"
"happyReduction_70  =  HappyAbsSyn32\n"
"		 ([]\n"
"	)\n"
"\n"
"happyReduce_71 = happyMonadReduce 3 33 happyReduction_71\n"
"happyReduction_71 (_ `HappyStk`\n"
"	(HappyAbsSyn29  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( checkRevDecls happy_var_2\n"
"	) (\\r -> happyReturn (HappyAbsSyn29 r))\n"
"\n"
"happyReduce_72 = happySpecReduce_1 33 happyReduction_72\n"
"happyReduction_72 _\n"
"	 =  HappyAbsSyn29\n"
"		 ([]\n"
"	)\n"
"\n"
"happyReduce_73 = happySpecReduce_3 34 happyReduction_73\n"
"happyReduction_73 (HappyAbsSyn25  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn29  happy_var_1)\n"
"	 =  HappyAbsSyn29\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_73 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_74 = happySpecReduce_1 34 happyReduction_74\n"
"happyReduction_74 (HappyAbsSyn25  happy_var_1)\n"
"	 =  HappyAbsSyn29\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_74 _  = notHappyAtAll \n"
"\n"
"happyReduce_75 = happySpecReduce_1 35 happyReduction_75\n"
"happyReduction_75 (HappyAbsSyn25  happy_var_1)\n"
"	 =  HappyAbsSyn25\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_75 _  = notHappyAtAll \n"
"\n"
"happyReduce_76 = happySpecReduce_1 35 happyReduction_76\n"
"happyReduction_76 (HappyAbsSyn25  happy_var_1)\n"
"	 =  HappyAbsSyn25\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_76 _  = notHappyAtAll \n"
"\n"
"happyReduce_77 = happySpecReduce_1 35 happyReduction_77\n"
"happyReduction_77 (HappyAbsSyn25  happy_var_1)\n"
"	 =  HappyAbsSyn25\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_77 _  = notHappyAtAll \n"
"\n"
"happyReduce_78 = happySpecReduce_3 36 happyReduction_78\n"
"happyReduction_78 _\n"
"	(HappyAbsSyn29  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn29\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_78 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_79 = happySpecReduce_3 36 happyReduction_79\n"
"happyReduction_79 _\n"
"	(HappyAbsSyn29  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn29\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_79 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_80 = happyReduce 4 37 happyReduction_80\n"
"happyReduction_80 ((HappyAbsSyn43  happy_var_4) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn38  happy_var_2) `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn25\n"
"		 (HsTypeSig happy_var_1 (reverse happy_var_2) happy_var_4\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_81 = happySpecReduce_3 38 happyReduction_81\n"
"happyReduction_81 (HappyAbsSyn99  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn38  happy_var_1)\n"
"	 =  HappyAbsSyn38\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_81 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_82 = happyMonadReduce 1 38 happyReduction_82\n"
"happyReduction_82 ((HappyAbsSyn42  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( do { n <- checkUnQual happy_var_1;\n"
"						return [n] }\n"
"	) (\\r -> happyReturn (HappyAbsSyn38 r))\n"
"\n"
"happyReduce_83 = happySpecReduce_3 39 happyReduction_83\n"
"happyReduction_83 (HappyAbsSyn39  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn39  happy_var_1)\n"
"	 =  HappyAbsSyn39\n"
"		 (HsTyFun happy_var_1 happy_var_3\n"
"	)\n"
"happyReduction_83 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_84 = happySpecReduce_1 39 happyReduction_84\n"
"happyReduction_84 (HappyAbsSyn39  happy_var_1)\n"
"	 =  HappyAbsSyn39\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_84 _  = notHappyAtAll \n"
"\n"
"happyReduce_85 = happySpecReduce_2 40 happyReduction_85\n"
"happyReduction_85 (HappyAbsSyn39  happy_var_2)\n"
"	(HappyAbsSyn39  happy_var_1)\n"
"	 =  HappyAbsSyn39\n"
"		 (HsTyApp happy_var_1 happy_var_2\n"
"	)\n"
"happyReduction_85 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_86 = happySpecReduce_1 40 happyReduction_86\n"
"happyReduction_86 (HappyAbsSyn39  happy_var_1)\n"
"	 =  HappyAbsSyn39\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_86 _  = notHappyAtAll \n"
"\n"
"happyReduce_87 = happySpecReduce_1 41 happyReduction_87\n"
"happyReduction_87 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn39\n"
"		 (HsTyCon happy_var_1\n"
"	)\n"
"happyReduction_87 _  = notHappyAtAll \n"
"\n"
"happyReduce_88 = happySpecReduce_1 41 happyReduction_88\n"
"happyReduction_88 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn39\n"
"		 (HsTyVar happy_var_1\n"
"	)\n"
"happyReduction_88 _  = notHappyAtAll \n"
"\n"
"happyReduce_89 = happySpecReduce_3 41 happyReduction_89\n"
"happyReduction_89 _\n"
"	(HappyAbsSyn32  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn39\n"
"		 (HsTyTuple (reverse happy_var_2)\n"
"	)\n"
"happyReduction_89 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_90 = happySpecReduce_3 41 happyReduction_90\n"
"happyReduction_90 _\n"
"	(HappyAbsSyn39  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn39\n"
"		 (HsTyApp list_tycon happy_var_2\n"
"	)\n"
"happyReduction_90 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_91 = happySpecReduce_3 41 happyReduction_91\n"
"happyReduction_91 _\n"
"	(HappyAbsSyn39  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn39\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_91 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_92 = happySpecReduce_1 42 happyReduction_92\n"
"happyReduction_92 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_92 _  = notHappyAtAll \n"
"\n"
"happyReduce_93 = happySpecReduce_2 42 happyReduction_93\n"
"happyReduction_93 _\n"
"	_\n"
"	 =  HappyAbsSyn42\n"
"		 (unit_tycon_name\n"
"	)\n"
"\n"
"happyReduce_94 = happySpecReduce_3 42 happyReduction_94\n"
"happyReduction_94 _\n"
"	_\n"
"	_\n"
"	 =  HappyAbsSyn42\n"
"		 (fun_tycon_name\n"
"	)\n"
"\n"
"happyReduce_95 = happySpecReduce_2 42 happyReduction_95\n"
"happyReduction_95 _\n"
"	_\n"
"	 =  HappyAbsSyn42\n"
"		 (list_tycon_name\n"
"	)\n"
"\n"
"happyReduce_96 = happySpecReduce_3 42 happyReduction_96\n"
"happyReduction_96 _\n"
"	(HappyAbsSyn26  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn42\n"
"		 (tuple_tycon_name happy_var_2\n"
"	)\n"
"happyReduction_96 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_97 = happySpecReduce_3 43 happyReduction_97\n"
"happyReduction_97 (HappyAbsSyn39  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn44  happy_var_1)\n"
"	 =  HappyAbsSyn43\n"
"		 (HsQualType happy_var_1 happy_var_3\n"
"	)\n"
"happyReduction_97 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_98 = happySpecReduce_1 43 happyReduction_98\n"
"happyReduction_98 (HappyAbsSyn39  happy_var_1)\n"
"	 =  HappyAbsSyn43\n"
"		 (HsQualType [] happy_var_1\n"
"	)\n"
"happyReduction_98 _  = notHappyAtAll \n"
"\n"
"happyReduce_99 = happyMonadReduce 1 44 happyReduction_99\n"
"happyReduction_99 ((HappyAbsSyn39  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( checkContext happy_var_1\n"
"	) (\\r -> happyReturn (HappyAbsSyn44 r))\n"
"\n"
"happyReduce_100 = happySpecReduce_3 45 happyReduction_100\n"
"happyReduction_100 (HappyAbsSyn39  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn32  happy_var_1)\n"
"	 =  HappyAbsSyn32\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_100 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_101 = happySpecReduce_3 45 happyReduction_101\n"
"happyReduction_101 (HappyAbsSyn39  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn39  happy_var_1)\n"
"	 =  HappyAbsSyn32\n"
"		 ([happy_var_3, happy_var_1]\n"
"	)\n"
"happyReduction_101 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_102 = happySpecReduce_2 46 happyReduction_102\n"
"happyReduction_102 (HappyAbsSyn38  happy_var_2)\n"
"	(HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn46\n"
"		 ((happy_var_1,reverse happy_var_2)\n"
"	)\n"
"happyReduction_102 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_103 = happySpecReduce_2 47 happyReduction_103\n"
"happyReduction_103 (HappyAbsSyn99  happy_var_2)\n"
"	(HappyAbsSyn38  happy_var_1)\n"
"	 =  HappyAbsSyn38\n"
"		 (happy_var_2 : happy_var_1\n"
"	)\n"
"happyReduction_103 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_104 = happySpecReduce_0 47 happyReduction_104\n"
"happyReduction_104  =  HappyAbsSyn38\n"
"		 ([]\n"
"	)\n"
"\n"
"happyReduce_105 = happySpecReduce_3 48 happyReduction_105\n"
"happyReduction_105 (HappyAbsSyn49  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn48  happy_var_1)\n"
"	 =  HappyAbsSyn48\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_105 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_106 = happySpecReduce_1 48 happyReduction_106\n"
"happyReduction_106 (HappyAbsSyn49  happy_var_1)\n"
"	 =  HappyAbsSyn48\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_106 _  = notHappyAtAll \n"
"\n"
"happyReduce_107 = happySpecReduce_2 49 happyReduction_107\n"
"happyReduction_107 (HappyAbsSyn50  happy_var_2)\n"
"	(HappyAbsSyn124  happy_var_1)\n"
"	 =  HappyAbsSyn49\n"
"		 (HsConDecl happy_var_1 (fst happy_var_2) (snd happy_var_2)\n"
"	)\n"
"happyReduction_107 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_108 = happyReduce 4 49 happyReduction_108\n"
"happyReduction_108 ((HappyAbsSyn52  happy_var_4) `HappyStk`\n"
"	(HappyAbsSyn99  happy_var_3) `HappyStk`\n"
"	(HappyAbsSyn52  happy_var_2) `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn49\n"
"		 (HsConDecl happy_var_1 happy_var_3 [happy_var_2,happy_var_4]\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_109 = happyReduce 4 49 happyReduction_109\n"
"happyReduction_109 (_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn99  happy_var_2) `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn49\n"
"		 (HsRecDecl happy_var_1 happy_var_2 []\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_110 = happyReduce 5 49 happyReduction_110\n"
"happyReduction_110 (_ `HappyStk`\n"
"	(HappyAbsSyn54  happy_var_4) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn99  happy_var_2) `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn49\n"
"		 (HsRecDecl happy_var_1 happy_var_2 (reverse happy_var_4)\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_111 = happyMonadReduce 1 50 happyReduction_111\n"
"happyReduction_111 ((HappyAbsSyn39  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( do { (c,ts) <- splitTyConApp happy_var_1;\n"
"						return (c,map HsUnBangedTy ts) }\n"
"	) (\\r -> happyReturn (HappyAbsSyn50 r))\n"
"\n"
"happyReduce_112 = happySpecReduce_1 50 happyReduction_112\n"
"happyReduction_112 (HappyAbsSyn50  happy_var_1)\n"
"	 =  HappyAbsSyn50\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_112 _  = notHappyAtAll \n"
"\n"
"happyReduce_113 = happyMonadReduce 3 51 happyReduction_113\n"
"happyReduction_113 ((HappyAbsSyn39  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn39  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( do { (c,ts) <- splitTyConApp happy_var_1;\n"
"						return (c,map HsUnBangedTy ts++\n"
"							[HsBangedTy happy_var_3]) }\n"
"	) (\\r -> happyReturn (HappyAbsSyn50 r))\n"
"\n"
"happyReduce_114 = happySpecReduce_2 51 happyReduction_114\n"
"happyReduction_114 (HappyAbsSyn52  happy_var_2)\n"
"	(HappyAbsSyn50  happy_var_1)\n"
"	 =  HappyAbsSyn50\n"
"		 ((fst happy_var_1, snd happy_var_1 ++ [happy_var_2] )\n"
"	)\n"
"happyReduction_114 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_115 = happySpecReduce_1 52 happyReduction_115\n"
"happyReduction_115 (HappyAbsSyn39  happy_var_1)\n"
"	 =  HappyAbsSyn52\n"
"		 (HsUnBangedTy happy_var_1\n"
"	)\n"
"happyReduction_115 _  = notHappyAtAll \n"
"\n"
"happyReduce_116 = happySpecReduce_2 52 happyReduction_116\n"
"happyReduction_116 (HappyAbsSyn39  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn52\n"
"		 (HsBangedTy   happy_var_2\n"
"	)\n"
"happyReduction_116 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_117 = happySpecReduce_1 53 happyReduction_117\n"
"happyReduction_117 (HappyAbsSyn39  happy_var_1)\n"
"	 =  HappyAbsSyn52\n"
"		 (HsUnBangedTy happy_var_1\n"
"	)\n"
"happyReduction_117 _  = notHappyAtAll \n"
"\n"
"happyReduce_118 = happySpecReduce_2 53 happyReduction_118\n"
"happyReduction_118 (HappyAbsSyn39  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn52\n"
"		 (HsBangedTy   happy_var_2\n"
"	)\n"
"happyReduction_118 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_119 = happySpecReduce_3 54 happyReduction_119\n"
"happyReduction_119 (HappyAbsSyn55  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn54  happy_var_1)\n"
"	 =  HappyAbsSyn54\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_119 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_120 = happySpecReduce_1 54 happyReduction_120\n"
"happyReduction_120 (HappyAbsSyn55  happy_var_1)\n"
"	 =  HappyAbsSyn54\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_120 _  = notHappyAtAll \n"
"\n"
"happyReduce_121 = happySpecReduce_3 55 happyReduction_121\n"
"happyReduction_121 (HappyAbsSyn52  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn38  happy_var_1)\n"
"	 =  HappyAbsSyn55\n"
"		 ((reverse happy_var_1, happy_var_3)\n"
"	)\n"
"happyReduction_121 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_122 = happySpecReduce_1 56 happyReduction_122\n"
"happyReduction_122 (HappyAbsSyn39  happy_var_1)\n"
"	 =  HappyAbsSyn52\n"
"		 (HsUnBangedTy happy_var_1\n"
"	)\n"
"happyReduction_122 _  = notHappyAtAll \n"
"\n"
"happyReduce_123 = happySpecReduce_2 56 happyReduction_123\n"
"happyReduction_123 (HappyAbsSyn39  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn52\n"
"		 (HsBangedTy   happy_var_2\n"
"	)\n"
"happyReduction_123 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_124 = happySpecReduce_0 57 happyReduction_124\n"
"happyReduction_124  =  HappyAbsSyn57\n"
"		 ([]\n"
"	)\n"
"\n"
"happyReduce_125 = happySpecReduce_2 57 happyReduction_125\n"
"happyReduction_125 (HappyAbsSyn42  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn57\n"
"		 ([happy_var_2]\n"
"	)\n"
"happyReduction_125 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_126 = happySpecReduce_3 57 happyReduction_126\n"
"happyReduction_126 _\n"
"	_\n"
"	_\n"
"	 =  HappyAbsSyn57\n"
"		 ([]\n"
"	)\n"
"\n"
"happyReduce_127 = happyReduce 4 57 happyReduction_127\n"
"happyReduction_127 (_ `HappyStk`\n"
"	(HappyAbsSyn57  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn57\n"
"		 (reverse happy_var_3\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_128 = happySpecReduce_3 58 happyReduction_128\n"
"happyReduction_128 (HappyAbsSyn42  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn57  happy_var_1)\n"
"	 =  HappyAbsSyn57\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_128 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_129 = happySpecReduce_1 58 happyReduction_129\n"
"happyReduction_129 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn57\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_129 _  = notHappyAtAll \n"
"\n"
"happyReduce_130 = happyMonadReduce 2 59 happyReduction_130\n"
"happyReduction_130 ((HappyAbsSyn29  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( checkClassBody happy_var_2\n"
"	) (\\r -> happyReturn (HappyAbsSyn29 r))\n"
"\n"
"happyReduce_131 = happySpecReduce_0 59 happyReduction_131\n"
"happyReduction_131  =  HappyAbsSyn29\n"
"		 ([]\n"
"	)\n"
"\n"
"happyReduce_132 = happyMonadReduce 4 60 happyReduction_132\n"
"happyReduction_132 (_ `HappyStk`\n"
"	(HappyAbsSyn29  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( checkClassBody happy_var_3\n"
"	) (\\r -> happyReturn (HappyAbsSyn29 r))\n"
"\n"
"happyReduce_133 = happyMonadReduce 4 60 happyReduction_133\n"
"happyReduction_133 (_ `HappyStk`\n"
"	(HappyAbsSyn29  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( checkClassBody happy_var_3\n"
"	) (\\r -> happyReturn (HappyAbsSyn29 r))\n"
"\n"
"happyReduce_134 = happySpecReduce_0 60 happyReduction_134\n"
"happyReduction_134  =  HappyAbsSyn29\n"
"		 ([]\n"
"	)\n"
"\n"
"happyReduce_135 = happyMonadReduce 3 61 happyReduction_135\n"
"happyReduction_135 (_ `HappyStk`\n"
"	(HappyAbsSyn29  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( checkRevDecls happy_var_2\n"
"	) (\\r -> happyReturn (HappyAbsSyn29 r))\n"
"\n"
"happyReduce_136 = happySpecReduce_1 61 happyReduction_136\n"
"happyReduction_136 _\n"
"	 =  HappyAbsSyn29\n"
"		 ([]\n"
"	)\n"
"\n"
"happyReduce_137 = happySpecReduce_3 62 happyReduction_137\n"
"happyReduction_137 (HappyAbsSyn25  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn29  happy_var_1)\n"
"	 =  HappyAbsSyn29\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_137 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_138 = happySpecReduce_1 62 happyReduction_138\n"
"happyReduction_138 (HappyAbsSyn25  happy_var_1)\n"
"	 =  HappyAbsSyn29\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_138 _  = notHappyAtAll \n"
"\n"
"happyReduce_139 = happyMonadReduce 4 63 happyReduction_139\n"
"happyReduction_139 ((HappyAbsSyn29  happy_var_4) `HappyStk`\n"
"	(HappyAbsSyn65  happy_var_3) `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_2) `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( checkValDef happy_var_1 happy_var_2 happy_var_3 happy_var_4\n"
"	) (\\r -> happyReturn (HappyAbsSyn25 r))\n"
"\n"
"happyReduce_140 = happySpecReduce_2 64 happyReduction_140\n"
"happyReduction_140 (HappyAbsSyn29  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn29\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_140 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_141 = happySpecReduce_0 64 happyReduction_141\n"
"happyReduction_141  =  HappyAbsSyn29\n"
"		 ([]\n"
"	)\n"
"\n"
"happyReduce_142 = happyMonadReduce 2 65 happyReduction_142\n"
"happyReduction_142 ((HappyAbsSyn68  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( do { e <- checkExpr happy_var_2;\n"
"						return (HsUnGuardedRhs e) }\n"
"	) (\\r -> happyReturn (HappyAbsSyn65 r))\n"
"\n"
"happyReduce_143 = happySpecReduce_1 65 happyReduction_143\n"
"happyReduction_143 (HappyAbsSyn66  happy_var_1)\n"
"	 =  HappyAbsSyn65\n"
"		 (HsGuardedRhss  (reverse happy_var_1)\n"
"	)\n"
"happyReduction_143 _  = notHappyAtAll \n"
"\n"
"happyReduce_144 = happySpecReduce_2 66 happyReduction_144\n"
"happyReduction_144 (HappyAbsSyn67  happy_var_2)\n"
"	(HappyAbsSyn66  happy_var_1)\n"
"	 =  HappyAbsSyn66\n"
"		 (happy_var_2 : happy_var_1\n"
"	)\n"
"happyReduction_144 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_145 = happySpecReduce_1 66 happyReduction_145\n"
"happyReduction_145 (HappyAbsSyn67  happy_var_1)\n"
"	 =  HappyAbsSyn66\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_145 _  = notHappyAtAll \n"
"\n"
"happyReduce_146 = happyMonadReduce 5 67 happyReduction_146\n"
"happyReduction_146 ((HappyAbsSyn68  happy_var_5) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( do { g <- checkExpr happy_var_3;\n"
"						e <- checkExpr happy_var_5;\n"
"						return (HsGuardedRhs happy_var_1 g e) }\n"
"	) (\\r -> happyReturn (HappyAbsSyn67 r))\n"
"\n"
"happyReduce_147 = happyReduce 4 68 happyReduction_147\n"
"happyReduction_147 ((HappyAbsSyn43  happy_var_4) `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn68\n"
"		 (HsExpTypeSig happy_var_3 happy_var_1 happy_var_4\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_148 = happySpecReduce_1 68 happyReduction_148\n"
"happyReduction_148 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_148 _  = notHappyAtAll \n"
"\n"
"happyReduce_149 = happySpecReduce_1 69 happyReduction_149\n"
"happyReduction_149 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_149 _  = notHappyAtAll \n"
"\n"
"happyReduce_150 = happySpecReduce_1 69 happyReduction_150\n"
"happyReduction_150 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_150 _  = notHappyAtAll \n"
"\n"
"happyReduce_151 = happySpecReduce_3 70 happyReduction_151\n"
"happyReduction_151 (HappyAbsSyn68  happy_var_3)\n"
"	(HappyAbsSyn109  happy_var_2)\n"
"	(HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (HsInfixApp happy_var_1 happy_var_2 happy_var_3\n"
"	)\n"
"happyReduction_151 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_152 = happySpecReduce_1 70 happyReduction_152\n"
"happyReduction_152 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_152 _  = notHappyAtAll \n"
"\n"
"happyReduce_153 = happySpecReduce_3 71 happyReduction_153\n"
"happyReduction_153 (HappyAbsSyn68  happy_var_3)\n"
"	(HappyAbsSyn109  happy_var_2)\n"
"	(HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (HsInfixApp happy_var_1 happy_var_2 happy_var_3\n"
"	)\n"
"happyReduction_153 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_154 = happySpecReduce_1 71 happyReduction_154\n"
"happyReduction_154 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_154 _  = notHappyAtAll \n"
"\n"
"happyReduce_155 = happyReduce 5 72 happyReduction_155\n"
"happyReduction_155 ((HappyAbsSyn68  happy_var_5) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn75  happy_var_3) `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn68\n"
"		 (HsLambda happy_var_2 (reverse happy_var_3) happy_var_5\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_156 = happyReduce 4 72 happyReduction_156\n"
"happyReduction_156 ((HappyAbsSyn68  happy_var_4) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn29  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn68\n"
"		 (HsLet happy_var_2 happy_var_4\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_157 = happyReduce 6 72 happyReduction_157\n"
"happyReduction_157 ((HappyAbsSyn68  happy_var_6) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_4) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn68\n"
"		 (HsIf happy_var_2 happy_var_4 happy_var_6\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_158 = happyReduce 4 73 happyReduction_158\n"
"happyReduction_158 ((HappyAbsSyn86  happy_var_4) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn68\n"
"		 (HsCase happy_var_2 happy_var_4\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_159 = happySpecReduce_2 73 happyReduction_159\n"
"happyReduction_159 (HappyAbsSyn68  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn68\n"
"		 (HsNegApp happy_var_2\n"
"	)\n"
"happyReduction_159 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_160 = happySpecReduce_2 73 happyReduction_160\n"
"happyReduction_160 (HappyAbsSyn84  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn68\n"
"		 (HsDo happy_var_2\n"
"	)\n"
"happyReduction_160 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_161 = happySpecReduce_1 73 happyReduction_161\n"
"happyReduction_161 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_161 _  = notHappyAtAll \n"
"\n"
"happyReduce_162 = happySpecReduce_2 74 happyReduction_162\n"
"happyReduction_162 (HappyAbsSyn68  happy_var_2)\n"
"	(HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (HsApp happy_var_1 happy_var_2\n"
"	)\n"
"happyReduction_162 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_163 = happySpecReduce_1 74 happyReduction_163\n"
"happyReduction_163 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_163 _  = notHappyAtAll \n"
"\n"
"happyReduce_164 = happySpecReduce_2 75 happyReduction_164\n"
"happyReduction_164 (HappyAbsSyn76  happy_var_2)\n"
"	(HappyAbsSyn75  happy_var_1)\n"
"	 =  HappyAbsSyn75\n"
"		 (happy_var_2 : happy_var_1\n"
"	)\n"
"happyReduction_164 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_165 = happySpecReduce_1 75 happyReduction_165\n"
"happyReduction_165 (HappyAbsSyn76  happy_var_1)\n"
"	 =  HappyAbsSyn75\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_165 _  = notHappyAtAll \n"
"\n"
"happyReduce_166 = happyMonadReduce 1 76 happyReduction_166\n"
"happyReduction_166 ((HappyAbsSyn68  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( checkPattern happy_var_1\n"
"	) (\\r -> happyReturn (HappyAbsSyn76 r))\n"
"\n"
"happyReduce_167 = happyMonadReduce 3 77 happyReduction_167\n"
"happyReduction_167 ((HappyAbsSyn68  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn42  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( do { n <- checkUnQual happy_var_1;\n"
"						return (HsAsPat n happy_var_3) }\n"
"	) (\\r -> happyReturn (HappyAbsSyn68 r))\n"
"\n"
"happyReduce_168 = happySpecReduce_2 77 happyReduction_168\n"
"happyReduction_168 (HappyAbsSyn68  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn68\n"
"		 (HsIrrPat happy_var_2\n"
"	)\n"
"happyReduction_168 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_169 = happySpecReduce_1 77 happyReduction_169\n"
"happyReduction_169 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_169 _  = notHappyAtAll \n"
"\n"
"happyReduce_170 = happyMonadReduce 3 78 happyReduction_170\n"
"happyReduction_170 (_ `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( mkRecConstrOrUpdate happy_var_1 []\n"
"	) (\\r -> happyReturn (HappyAbsSyn68 r))\n"
"\n"
"happyReduce_171 = happyMonadReduce 4 78 happyReduction_171\n"
"happyReduction_171 (_ `HappyStk`\n"
"	(HappyAbsSyn96  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( mkRecConstrOrUpdate happy_var_1 (reverse happy_var_3)\n"
"	) (\\r -> happyReturn (HappyAbsSyn68 r))\n"
"\n"
"happyReduce_172 = happySpecReduce_1 78 happyReduction_172\n"
"happyReduction_172 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_172 _  = notHappyAtAll \n"
"\n"
"happyReduce_173 = happySpecReduce_1 79 happyReduction_173\n"
"happyReduction_173 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (HsVar happy_var_1\n"
"	)\n"
"happyReduction_173 _  = notHappyAtAll \n"
"\n"
"happyReduce_174 = happySpecReduce_1 79 happyReduction_174\n"
"happyReduction_174 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_174 _  = notHappyAtAll \n"
"\n"
"happyReduce_175 = happySpecReduce_1 79 happyReduction_175\n"
"happyReduction_175 (HappyAbsSyn123  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (HsLit happy_var_1\n"
"	)\n"
"happyReduction_175 _  = notHappyAtAll \n"
"\n"
"happyReduce_176 = happySpecReduce_3 79 happyReduction_176\n"
"happyReduction_176 _\n"
"	(HappyAbsSyn68  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn68\n"
"		 (HsParen happy_var_2\n"
"	)\n"
"happyReduction_176 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_177 = happySpecReduce_3 79 happyReduction_177\n"
"happyReduction_177 _\n"
"	(HappyAbsSyn81  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn68\n"
"		 (HsTuple (reverse happy_var_2)\n"
"	)\n"
"happyReduction_177 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_178 = happySpecReduce_3 79 happyReduction_178\n"
"happyReduction_178 _\n"
"	(HappyAbsSyn68  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn68\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_178 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_179 = happyReduce 4 79 happyReduction_179\n"
"happyReduction_179 (_ `HappyStk`\n"
"	(HappyAbsSyn109  happy_var_3) `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn68\n"
"		 (HsLeftSection happy_var_2 happy_var_3\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_180 = happyReduce 4 79 happyReduction_180\n"
"happyReduction_180 (_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_3) `HappyStk`\n"
"	(HappyAbsSyn109  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn68\n"
"		 (HsRightSection happy_var_2 happy_var_3\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_181 = happySpecReduce_1 79 happyReduction_181\n"
"happyReduction_181 _\n"
"	 =  HappyAbsSyn68\n"
"		 (HsWildCard\n"
"	)\n"
"\n"
"happyReduce_182 = happySpecReduce_2 80 happyReduction_182\n"
"happyReduction_182 _\n"
"	(HappyAbsSyn26  happy_var_1)\n"
"	 =  HappyAbsSyn26\n"
"		 (happy_var_1 + 1\n"
"	)\n"
"happyReduction_182 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_183 = happySpecReduce_1 80 happyReduction_183\n"
"happyReduction_183 _\n"
"	 =  HappyAbsSyn26\n"
"		 (1\n"
"	)\n"
"\n"
"happyReduce_184 = happySpecReduce_3 81 happyReduction_184\n"
"happyReduction_184 (HappyAbsSyn68  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn81  happy_var_1)\n"
"	 =  HappyAbsSyn81\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_184 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_185 = happySpecReduce_3 81 happyReduction_185\n"
"happyReduction_185 (HappyAbsSyn68  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn81\n"
"		 ([happy_var_3,happy_var_1]\n"
"	)\n"
"happyReduction_185 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_186 = happySpecReduce_1 82 happyReduction_186\n"
"happyReduction_186 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (HsList [happy_var_1]\n"
"	)\n"
"happyReduction_186 _  = notHappyAtAll \n"
"\n"
"happyReduce_187 = happySpecReduce_1 82 happyReduction_187\n"
"happyReduction_187 (HappyAbsSyn81  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (HsList (reverse happy_var_1)\n"
"	)\n"
"happyReduction_187 _  = notHappyAtAll \n"
"\n"
"happyReduce_188 = happySpecReduce_2 82 happyReduction_188\n"
"happyReduction_188 _\n"
"	(HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (HsEnumFrom happy_var_1\n"
"	)\n"
"happyReduction_188 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_189 = happyReduce 4 82 happyReduction_189\n"
"happyReduction_189 (_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn68\n"
"		 (HsEnumFromThen happy_var_1 happy_var_3\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_190 = happySpecReduce_3 82 happyReduction_190\n"
"happyReduction_190 (HappyAbsSyn68  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (HsEnumFromTo happy_var_1 happy_var_3\n"
"	)\n"
"happyReduction_190 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_191 = happyReduce 5 82 happyReduction_191\n"
"happyReduction_191 ((HappyAbsSyn68  happy_var_5) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn68\n"
"		 (HsEnumFromThenTo happy_var_1 happy_var_3 happy_var_5\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_192 = happySpecReduce_3 82 happyReduction_192\n"
"happyReduction_192 (HappyAbsSyn84  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (HsListComp happy_var_1 (reverse happy_var_3)\n"
"	)\n"
"happyReduction_192 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_193 = happySpecReduce_3 83 happyReduction_193\n"
"happyReduction_193 (HappyAbsSyn68  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn81  happy_var_1)\n"
"	 =  HappyAbsSyn81\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_193 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_194 = happySpecReduce_3 83 happyReduction_194\n"
"happyReduction_194 (HappyAbsSyn68  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn81\n"
"		 ([happy_var_3,happy_var_1]\n"
"	)\n"
"happyReduction_194 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_195 = happySpecReduce_3 84 happyReduction_195\n"
"happyReduction_195 (HappyAbsSyn85  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn84  happy_var_1)\n"
"	 =  HappyAbsSyn84\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_195 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_196 = happySpecReduce_1 84 happyReduction_196\n"
"happyReduction_196 (HappyAbsSyn85  happy_var_1)\n"
"	 =  HappyAbsSyn84\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_196 _  = notHappyAtAll \n"
"\n"
"happyReduce_197 = happyReduce 4 85 happyReduction_197\n"
"happyReduction_197 ((HappyAbsSyn68  happy_var_4) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_2) `HappyStk`\n"
"	(HappyAbsSyn76  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn85\n"
"		 (HsGenerator happy_var_2 happy_var_1 happy_var_4\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_198 = happySpecReduce_1 85 happyReduction_198\n"
"happyReduction_198 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn85\n"
"		 (HsQualifier happy_var_1\n"
"	)\n"
"happyReduction_198 _  = notHappyAtAll \n"
"\n"
"happyReduce_199 = happySpecReduce_2 85 happyReduction_199\n"
"happyReduction_199 (HappyAbsSyn29  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn85\n"
"		 (HsLetStmt happy_var_2\n"
"	)\n"
"happyReduction_199 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_200 = happySpecReduce_3 86 happyReduction_200\n"
"happyReduction_200 _\n"
"	(HappyAbsSyn86  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn86\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_200 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_201 = happySpecReduce_3 86 happyReduction_201\n"
"happyReduction_201 _\n"
"	(HappyAbsSyn86  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn86\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_201 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_202 = happySpecReduce_3 87 happyReduction_202\n"
"happyReduction_202 _\n"
"	(HappyAbsSyn86  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn86\n"
"		 (reverse happy_var_2\n"
"	)\n"
"happyReduction_202 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_203 = happySpecReduce_3 88 happyReduction_203\n"
"happyReduction_203 (HappyAbsSyn89  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn86  happy_var_1)\n"
"	 =  HappyAbsSyn86\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_203 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_204 = happySpecReduce_1 88 happyReduction_204\n"
"happyReduction_204 (HappyAbsSyn89  happy_var_1)\n"
"	 =  HappyAbsSyn86\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_204 _  = notHappyAtAll \n"
"\n"
"happyReduce_205 = happyReduce 4 89 happyReduction_205\n"
"happyReduction_205 ((HappyAbsSyn29  happy_var_4) `HappyStk`\n"
"	(HappyAbsSyn90  happy_var_3) `HappyStk`\n"
"	(HappyAbsSyn76  happy_var_2) `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn89\n"
"		 (HsAlt happy_var_1 happy_var_2 happy_var_3 happy_var_4\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_206 = happySpecReduce_2 90 happyReduction_206\n"
"happyReduction_206 (HappyAbsSyn68  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn90\n"
"		 (HsUnGuardedAlt happy_var_2\n"
"	)\n"
"happyReduction_206 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_207 = happySpecReduce_1 90 happyReduction_207\n"
"happyReduction_207 (HappyAbsSyn91  happy_var_1)\n"
"	 =  HappyAbsSyn90\n"
"		 (HsGuardedAlts (reverse happy_var_1)\n"
"	)\n"
"happyReduction_207 _  = notHappyAtAll \n"
"\n"
"happyReduce_208 = happySpecReduce_2 91 happyReduction_208\n"
"happyReduction_208 (HappyAbsSyn92  happy_var_2)\n"
"	(HappyAbsSyn91  happy_var_1)\n"
"	 =  HappyAbsSyn91\n"
"		 (happy_var_2 : happy_var_1\n"
"	)\n"
"happyReduction_208 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_209 = happySpecReduce_1 91 happyReduction_209\n"
"happyReduction_209 (HappyAbsSyn92  happy_var_1)\n"
"	 =  HappyAbsSyn91\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_209 _  = notHappyAtAll \n"
"\n"
"happyReduce_210 = happyReduce 5 92 happyReduction_210\n"
"happyReduction_210 ((HappyAbsSyn68  happy_var_5) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_3) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn92\n"
"		 (HsGuardedAlt happy_var_1 happy_var_3 happy_var_5\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_211 = happyMonadReduce 1 93 happyReduction_211\n"
"happyReduction_211 ((HappyAbsSyn68  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( checkPattern happy_var_1\n"
"	) (\\r -> happyReturn (HappyAbsSyn76 r))\n"
"\n"
"happyReduce_212 = happySpecReduce_3 94 happyReduction_212\n"
"happyReduction_212 _\n"
"	(HappyAbsSyn84  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn84\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_212 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_213 = happySpecReduce_3 94 happyReduction_213\n"
"happyReduction_213 _\n"
"	(HappyAbsSyn84  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn84\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_213 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_214 = happyReduce 4 95 happyReduction_214\n"
"happyReduction_214 ((HappyAbsSyn84  happy_var_4) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn29  happy_var_2) `HappyStk`\n"
"	_ `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn84\n"
"		 (HsLetStmt happy_var_2 : happy_var_4\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_215 = happyReduce 6 95 happyReduction_215\n"
"happyReduction_215 ((HappyAbsSyn84  happy_var_6) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn68  happy_var_4) `HappyStk`\n"
"	_ `HappyStk`\n"
"	(HappyAbsSyn124  happy_var_2) `HappyStk`\n"
"	(HappyAbsSyn76  happy_var_1) `HappyStk`\n"
"	happyRest)\n"
"	 = HappyAbsSyn84\n"
"		 (HsGenerator happy_var_2 happy_var_1 happy_var_4 : happy_var_6\n"
"	) `HappyStk` happyRest\n"
"\n"
"happyReduce_216 = happySpecReduce_3 95 happyReduction_216\n"
"happyReduction_216 (HappyAbsSyn84  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn84\n"
"		 (HsQualifier happy_var_1 : happy_var_3\n"
"	)\n"
"happyReduction_216 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_217 = happySpecReduce_2 95 happyReduction_217\n"
"happyReduction_217 (HappyAbsSyn84  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn84\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_217 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_218 = happySpecReduce_2 95 happyReduction_218\n"
"happyReduction_218 _\n"
"	(HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn84\n"
"		 ([HsQualifier happy_var_1]\n"
"	)\n"
"happyReduction_218 _ _  = notHappyAtAll \n"
"\n"
"happyReduce_219 = happySpecReduce_1 95 happyReduction_219\n"
"happyReduction_219 (HappyAbsSyn68  happy_var_1)\n"
"	 =  HappyAbsSyn84\n"
"		 ([HsQualifier happy_var_1]\n"
"	)\n"
"happyReduction_219 _  = notHappyAtAll \n"
"\n"
"happyReduce_220 = happySpecReduce_3 96 happyReduction_220\n"
"happyReduction_220 (HappyAbsSyn97  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn96  happy_var_1)\n"
"	 =  HappyAbsSyn96\n"
"		 (happy_var_3 : happy_var_1\n"
"	)\n"
"happyReduction_220 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_221 = happySpecReduce_1 96 happyReduction_221\n"
"happyReduction_221 (HappyAbsSyn97  happy_var_1)\n"
"	 =  HappyAbsSyn96\n"
"		 ([happy_var_1]\n"
"	)\n"
"happyReduction_221 _  = notHappyAtAll \n"
"\n"
"happyReduce_222 = happySpecReduce_3 97 happyReduction_222\n"
"happyReduction_222 (HappyAbsSyn68  happy_var_3)\n"
"	_\n"
"	(HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn97\n"
"		 (HsFieldUpdate happy_var_1 happy_var_3\n"
"	)\n"
"happyReduction_222 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_223 = happySpecReduce_2 98 happyReduction_223\n"
"happyReduction_223 _\n"
"	_\n"
"	 =  HappyAbsSyn68\n"
"		 (unit_con\n"
"	)\n"
"\n"
"happyReduce_224 = happySpecReduce_2 98 happyReduction_224\n"
"happyReduction_224 _\n"
"	_\n"
"	 =  HappyAbsSyn68\n"
"		 (HsList []\n"
"	)\n"
"\n"
"happyReduce_225 = happySpecReduce_3 98 happyReduction_225\n"
"happyReduction_225 _\n"
"	(HappyAbsSyn26  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn68\n"
"		 (tuple_con happy_var_2\n"
"	)\n"
"happyReduction_225 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_226 = happySpecReduce_1 98 happyReduction_226\n"
"happyReduction_226 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn68\n"
"		 (HsCon happy_var_1\n"
"	)\n"
"happyReduction_226 _  = notHappyAtAll \n"
"\n"
"happyReduce_227 = happySpecReduce_1 99 happyReduction_227\n"
"happyReduction_227 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn99\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_227 _  = notHappyAtAll \n"
"\n"
"happyReduce_228 = happySpecReduce_3 99 happyReduction_228\n"
"happyReduction_228 _\n"
"	(HappyAbsSyn99  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn99\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_228 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_229 = happySpecReduce_1 100 happyReduction_229\n"
"happyReduction_229 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_229 _  = notHappyAtAll \n"
"\n"
"happyReduce_230 = happySpecReduce_3 100 happyReduction_230\n"
"happyReduction_230 _\n"
"	(HappyAbsSyn42  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_230 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_231 = happySpecReduce_1 101 happyReduction_231\n"
"happyReduction_231 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn99\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_231 _  = notHappyAtAll \n"
"\n"
"happyReduce_232 = happySpecReduce_3 101 happyReduction_232\n"
"happyReduction_232 _\n"
"	(HappyAbsSyn99  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn99\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_232 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_233 = happySpecReduce_1 102 happyReduction_233\n"
"happyReduction_233 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_233 _  = notHappyAtAll \n"
"\n"
"happyReduce_234 = happySpecReduce_3 102 happyReduction_234\n"
"happyReduction_234 _\n"
"	(HappyAbsSyn42  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_234 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_235 = happySpecReduce_1 103 happyReduction_235\n"
"happyReduction_235 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn99\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_235 _  = notHappyAtAll \n"
"\n"
"happyReduce_236 = happySpecReduce_3 103 happyReduction_236\n"
"happyReduction_236 _\n"
"	(HappyAbsSyn99  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn99\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_236 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_237 = happySpecReduce_1 104 happyReduction_237\n"
"happyReduction_237 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_237 _  = notHappyAtAll \n"
"\n"
"happyReduce_238 = happySpecReduce_3 104 happyReduction_238\n"
"happyReduction_238 _\n"
"	(HappyAbsSyn42  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_238 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_239 = happySpecReduce_1 105 happyReduction_239\n"
"happyReduction_239 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_239 _  = notHappyAtAll \n"
"\n"
"happyReduce_240 = happySpecReduce_3 105 happyReduction_240\n"
"happyReduction_240 _\n"
"	(HappyAbsSyn42  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_240 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_241 = happySpecReduce_1 106 happyReduction_241\n"
"happyReduction_241 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn99\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_241 _  = notHappyAtAll \n"
"\n"
"happyReduce_242 = happySpecReduce_3 106 happyReduction_242\n"
"happyReduction_242 _\n"
"	(HappyAbsSyn99  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn99\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_242 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_243 = happySpecReduce_1 107 happyReduction_243\n"
"happyReduction_243 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_243 _  = notHappyAtAll \n"
"\n"
"happyReduce_244 = happySpecReduce_3 107 happyReduction_244\n"
"happyReduction_244 _\n"
"	(HappyAbsSyn42  happy_var_2)\n"
"	_\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_2\n"
"	)\n"
"happyReduction_244 _ _ _  = notHappyAtAll \n"
"\n"
"happyReduce_245 = happySpecReduce_1 108 happyReduction_245\n"
"happyReduction_245 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn108\n"
"		 (HsVarOp happy_var_1\n"
"	)\n"
"happyReduction_245 _  = notHappyAtAll \n"
"\n"
"happyReduce_246 = happySpecReduce_1 108 happyReduction_246\n"
"happyReduction_246 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn108\n"
"		 (HsConOp happy_var_1\n"
"	)\n"
"happyReduction_246 _  = notHappyAtAll \n"
"\n"
"happyReduce_247 = happySpecReduce_1 109 happyReduction_247\n"
"happyReduction_247 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn109\n"
"		 (HsQVarOp happy_var_1\n"
"	)\n"
"happyReduction_247 _  = notHappyAtAll \n"
"\n"
"happyReduce_248 = happySpecReduce_1 109 happyReduction_248\n"
"happyReduction_248 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn109\n"
"		 (HsQConOp happy_var_1\n"
"	)\n"
"happyReduction_248 _  = notHappyAtAll \n"
"\n"
"happyReduce_249 = happySpecReduce_1 110 happyReduction_249\n"
"happyReduction_249 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn109\n"
"		 (HsQVarOp happy_var_1\n"
"	)\n"
"happyReduction_249 _  = notHappyAtAll \n"
"\n"
"happyReduce_250 = happySpecReduce_1 110 happyReduction_250\n"
"happyReduction_250 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn109\n"
"		 (HsQConOp happy_var_1\n"
"	)\n"
"happyReduction_250 _  = notHappyAtAll \n"
"\n"
"happyReduce_251 = happySpecReduce_1 111 happyReduction_251\n"
"happyReduction_251 _\n"
"	 =  HappyAbsSyn42\n"
"		 (list_cons_name\n"
"	)\n"
"\n"
"happyReduce_252 = happySpecReduce_1 111 happyReduction_252\n"
"happyReduction_252 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_252 _  = notHappyAtAll \n"
"\n"
"happyReduce_253 = happySpecReduce_1 112 happyReduction_253\n"
"happyReduction_253 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (UnQual happy_var_1\n"
"	)\n"
"happyReduction_253 _  = notHappyAtAll \n"
"\n"
"happyReduce_254 = happySpecReduce_1 112 happyReduction_254\n"
"happyReduction_254 (HappyTerminal (QVarId happy_var_1))\n"
"	 =  HappyAbsSyn42\n"
"		 (Qual (Module (fst happy_var_1)) (HsIdent (snd happy_var_1))\n"
"	)\n"
"happyReduction_254 _  = notHappyAtAll \n"
"\n"
"happyReduce_255 = happySpecReduce_1 113 happyReduction_255\n"
"happyReduction_255 (HappyTerminal (VarId happy_var_1))\n"
"	 =  HappyAbsSyn99\n"
"		 (HsIdent happy_var_1\n"
"	)\n"
"happyReduction_255 _  = notHappyAtAll \n"
"\n"
"happyReduce_256 = happySpecReduce_1 113 happyReduction_256\n"
"happyReduction_256 _\n"
"	 =  HappyAbsSyn99\n"
"		 (as_name\n"
"	)\n"
"\n"
"happyReduce_257 = happySpecReduce_1 113 happyReduction_257\n"
"happyReduction_257 _\n"
"	 =  HappyAbsSyn99\n"
"		 (qualified_name\n"
"	)\n"
"\n"
"happyReduce_258 = happySpecReduce_1 113 happyReduction_258\n"
"happyReduction_258 _\n"
"	 =  HappyAbsSyn99\n"
"		 (hiding_name\n"
"	)\n"
"\n"
"happyReduce_259 = happySpecReduce_1 114 happyReduction_259\n"
"happyReduction_259 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (UnQual happy_var_1\n"
"	)\n"
"happyReduction_259 _  = notHappyAtAll \n"
"\n"
"happyReduce_260 = happySpecReduce_1 114 happyReduction_260\n"
"happyReduction_260 (HappyTerminal (QConId happy_var_1))\n"
"	 =  HappyAbsSyn42\n"
"		 (Qual (Module (fst happy_var_1)) (HsIdent (snd happy_var_1))\n"
"	)\n"
"happyReduction_260 _  = notHappyAtAll \n"
"\n"
"happyReduce_261 = happySpecReduce_1 115 happyReduction_261\n"
"happyReduction_261 (HappyTerminal (ConId happy_var_1))\n"
"	 =  HappyAbsSyn99\n"
"		 (HsIdent happy_var_1\n"
"	)\n"
"happyReduction_261 _  = notHappyAtAll \n"
"\n"
"happyReduce_262 = happySpecReduce_1 116 happyReduction_262\n"
"happyReduction_262 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (UnQual happy_var_1\n"
"	)\n"
"happyReduction_262 _  = notHappyAtAll \n"
"\n"
"happyReduce_263 = happySpecReduce_1 116 happyReduction_263\n"
"happyReduction_263 (HappyTerminal (QConSym happy_var_1))\n"
"	 =  HappyAbsSyn42\n"
"		 (Qual (Module (fst happy_var_1)) (HsSymbol (snd happy_var_1))\n"
"	)\n"
"happyReduction_263 _  = notHappyAtAll \n"
"\n"
"happyReduce_264 = happySpecReduce_1 117 happyReduction_264\n"
"happyReduction_264 (HappyTerminal (ConSym happy_var_1))\n"
"	 =  HappyAbsSyn99\n"
"		 (HsSymbol happy_var_1\n"
"	)\n"
"happyReduction_264 _  = notHappyAtAll \n"
"\n"
"happyReduce_265 = happySpecReduce_1 118 happyReduction_265\n"
"happyReduction_265 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (UnQual happy_var_1\n"
"	)\n"
"happyReduction_265 _  = notHappyAtAll \n"
"\n"
"happyReduce_266 = happySpecReduce_1 118 happyReduction_266\n"
"happyReduction_266 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_266 _  = notHappyAtAll \n"
"\n"
"happyReduce_267 = happySpecReduce_1 119 happyReduction_267\n"
"happyReduction_267 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (UnQual happy_var_1\n"
"	)\n"
"happyReduction_267 _  = notHappyAtAll \n"
"\n"
"happyReduce_268 = happySpecReduce_1 119 happyReduction_268\n"
"happyReduction_268 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_268 _  = notHappyAtAll \n"
"\n"
"happyReduce_269 = happySpecReduce_1 120 happyReduction_269\n"
"happyReduction_269 (HappyTerminal (VarSym happy_var_1))\n"
"	 =  HappyAbsSyn99\n"
"		 (HsSymbol happy_var_1\n"
"	)\n"
"happyReduction_269 _  = notHappyAtAll \n"
"\n"
"happyReduce_270 = happySpecReduce_1 120 happyReduction_270\n"
"happyReduction_270 _\n"
"	 =  HappyAbsSyn99\n"
"		 (minus_name\n"
"	)\n"
"\n"
"happyReduce_271 = happySpecReduce_1 120 happyReduction_271\n"
"happyReduction_271 _\n"
"	 =  HappyAbsSyn99\n"
"		 (pling_name\n"
"	)\n"
"\n"
"happyReduce_272 = happySpecReduce_1 121 happyReduction_272\n"
"happyReduction_272 (HappyTerminal (VarSym happy_var_1))\n"
"	 =  HappyAbsSyn99\n"
"		 (HsSymbol happy_var_1\n"
"	)\n"
"happyReduction_272 _  = notHappyAtAll \n"
"\n"
"happyReduce_273 = happySpecReduce_1 121 happyReduction_273\n"
"happyReduction_273 _\n"
"	 =  HappyAbsSyn99\n"
"		 (pling_name\n"
"	)\n"
"\n"
"happyReduce_274 = happySpecReduce_1 122 happyReduction_274\n"
"happyReduction_274 (HappyTerminal (QVarSym happy_var_1))\n"
"	 =  HappyAbsSyn42\n"
"		 (Qual (Module (fst happy_var_1)) (HsSymbol (snd happy_var_1))\n"
"	)\n"
"happyReduction_274 _  = notHappyAtAll \n"
"\n"
"happyReduce_275 = happySpecReduce_1 123 happyReduction_275\n"
"happyReduction_275 (HappyTerminal (IntTok happy_var_1))\n"
"	 =  HappyAbsSyn123\n"
"		 (HsInt happy_var_1\n"
"	)\n"
"happyReduction_275 _  = notHappyAtAll \n"
"\n"
"happyReduce_276 = happySpecReduce_1 123 happyReduction_276\n"
"happyReduction_276 (HappyTerminal (Character happy_var_1))\n"
"	 =  HappyAbsSyn123\n"
"		 (HsChar happy_var_1\n"
"	)\n"
"happyReduction_276 _  = notHappyAtAll \n"
"\n"
"happyReduce_277 = happySpecReduce_1 123 happyReduction_277\n"
"happyReduction_277 (HappyTerminal (FloatTok happy_var_1))\n"
"	 =  HappyAbsSyn123\n"
"		 (HsFrac happy_var_1\n"
"	)\n"
"happyReduction_277 _  = notHappyAtAll \n"
"\n"
"happyReduce_278 = happySpecReduce_1 123 happyReduction_278\n"
"happyReduction_278 (HappyTerminal (StringTok happy_var_1))\n"
"	 =  HappyAbsSyn123\n"
"		 (HsString happy_var_1\n"
"	)\n"
"happyReduction_278 _  = notHappyAtAll \n"
"\n"
"happyReduce_279 = happyMonadReduce 0 124 happyReduction_279\n"
"happyReduction_279 (happyRest)\n"
"	 = happyThen ( getSrcLoc\n"
"	) (\\r -> happyReturn (HappyAbsSyn124 r))\n"
"\n"
"happyReduce_280 = happyMonadReduce 0 125 happyReduction_280\n"
"happyReduction_280 (happyRest)\n"
"	 = happyThen ( pushCurrentContext\n"
"	) (\\r -> happyReturn (HappyAbsSyn7 r))\n"
"\n"
"happyReduce_281 = happySpecReduce_1 126 happyReduction_281\n"
"happyReduction_281 _\n"
"	 =  HappyAbsSyn7\n"
"		 (()\n"
"	)\n"
"\n"
"happyReduce_282 = happyMonadReduce 1 126 happyReduction_282\n"
"happyReduction_282 (_ `HappyStk`\n"
"	happyRest)\n"
"	 = happyThen ( popContext\n"
"	) (\\r -> happyReturn (HappyAbsSyn7 r))\n"
"\n"
"happyReduce_283 = happySpecReduce_1 127 happyReduction_283\n"
"happyReduction_283 (HappyTerminal (ConId happy_var_1))\n"
"	 =  HappyAbsSyn127\n"
"		 (Module happy_var_1\n"
"	)\n"
"happyReduction_283 _  = notHappyAtAll \n"
"\n"
"happyReduce_284 = happySpecReduce_1 127 happyReduction_284\n"
"happyReduction_284 (HappyTerminal (QConId happy_var_1))\n"
"	 =  HappyAbsSyn127\n"
"		 (Module (fst happy_var_1 ++ '.':snd happy_var_1)\n"
"	)\n"
"happyReduction_284 _  = notHappyAtAll \n"
"\n"
"happyReduce_285 = happySpecReduce_1 128 happyReduction_285\n"
"happyReduction_285 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn99\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_285 _  = notHappyAtAll \n"
"\n"
"happyReduce_286 = happySpecReduce_1 129 happyReduction_286\n"
"happyReduction_286 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn99\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_286 _  = notHappyAtAll \n"
"\n"
"happyReduce_287 = happySpecReduce_1 130 happyReduction_287\n"
"happyReduction_287 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_287 _  = notHappyAtAll \n"
"\n"
"happyReduce_288 = happySpecReduce_1 131 happyReduction_288\n"
"happyReduction_288 (HappyAbsSyn42  happy_var_1)\n"
"	 =  HappyAbsSyn42\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_288 _  = notHappyAtAll \n"
"\n"
"happyReduce_289 = happySpecReduce_1 132 happyReduction_289\n"
"happyReduction_289 (HappyAbsSyn99  happy_var_1)\n"
"	 =  HappyAbsSyn99\n"
"		 (happy_var_1\n"
"	)\n"
"happyReduction_289 _  = notHappyAtAll \n"
"\n"
"happyNewToken action sts stk\n"
"	= lexer(\\tk -> \n"
"	let cont i = action i i tk (HappyState action) sts stk in\n"
"	case tk of {\n"
"	EOF -> action 193 193 (error \"reading EOF!\") (HappyState action) sts stk;\n"
"	VarId happy_dollar_dollar -> cont 133;\n"
"	QVarId happy_dollar_dollar -> cont 134;\n"
"	ConId happy_dollar_dollar -> cont 135;\n"
"	QConId happy_dollar_dollar -> cont 136;\n"
"	VarSym happy_dollar_dollar -> cont 137;\n"
"	ConSym happy_dollar_dollar -> cont 138;\n"
"	QVarSym happy_dollar_dollar -> cont 139;\n"
"	QConSym happy_dollar_dollar -> cont 140;\n"
"	IntTok happy_dollar_dollar -> cont 141;\n"
"	FloatTok happy_dollar_dollar -> cont 142;\n"
"	Character happy_dollar_dollar -> cont 143;\n"
"	StringTok happy_dollar_dollar -> cont 144;\n"
"	LeftParen -> cont 145;\n"
"	RightParen -> cont 146;\n"
"	SemiColon -> cont 147;\n"
"	LeftCurly -> cont 148;\n"
"	RightCurly -> cont 149;\n"
"	VRightCurly -> cont 150;\n"
"	LeftSquare -> cont 151;\n"
"	RightSquare -> cont 152;\n"
"	Comma -> cont 153;\n"
"	Underscore -> cont 154;\n"
"	BackQuote -> cont 155;\n"
"	DotDot -> cont 156;\n"
"	Colon -> cont 157;\n"
"	DoubleColon -> cont 158;\n"
"	Equals -> cont 159;\n"
"	Backslash -> cont 160;\n"
"	Bar -> cont 161;\n"
"	LeftArrow -> cont 162;\n"
"	RightArrow -> cont 163;\n"
"	At -> cont 164;\n"
"	Tilde -> cont 165;\n"
"	DoubleArrow -> cont 166;\n"
"	Minus -> cont 167;\n"
"	Exclamation -> cont 168;\n"
"	KW_As -> cont 169;\n"
"	KW_Case -> cont 170;\n"
"	KW_Class -> cont 171;\n"
"	KW_Data -> cont 172;\n"
"	KW_Default -> cont 173;\n"
"	KW_Deriving -> cont 174;\n"
"	KW_Do -> cont 175;\n"
"	KW_Else -> cont 176;\n"
"	KW_Hiding -> cont 177;\n"
"	KW_If -> cont 178;\n"
"	KW_Import -> cont 179;\n"
"	KW_In -> cont 180;\n"
"	KW_Infix -> cont 181;\n"
"	KW_InfixL -> cont 182;\n"
"	KW_InfixR -> cont 183;\n"
"	KW_Instance -> cont 184;\n"
"	KW_Let -> cont 185;\n"
"	KW_Module -> cont 186;\n"
"	KW_NewType -> cont 187;\n"
"	KW_Of -> cont 188;\n"
"	KW_Then -> cont 189;\n"
"	KW_Type -> cont 190;\n"
"	KW_Where -> cont 191;\n"
"	KW_Qualified -> cont 192;\n"
"	_ -> happyError\n"
"	})\n"
"\n"
"happyThen :: P a -> (a -> P b) -> P b\n"
"happyThen = (>>=)\n"
"happyReturn :: a -> P a\n"
"happyReturn = (return)\n"
"happyThen1 = happyThen\n"
"happyReturn1 = happyReturn\n"
"\n"
"parse = happyThen (happyParse action_0) (\\x -> case x of {HappyAbsSyn4 z -> happyReturn z; _other -> notHappyAtAll })\n"
"\n"
"happySeq = happyDontSeq\n"
"\n"
"happyError :: P a\n"
"happyError = fail \"Parse error\"\n"
"\n"
"-- | Parse of a string, which should contain a complete Haskell 98 module.\n"
"parseModule :: String -> ParseResult HsModule\n"
"parseModule = runParser parse\n"
"\n"
"-- | Parse of a string, which should contain a complete Haskell 98 module.\n"
"parseModuleWithMode :: ParseMode -> String -> ParseResult HsModule\n"
"parseModuleWithMode mode = runParserWithMode mode parse\n"
"{-# LINE 1 \"GenericTemplate.hs\" #-}\n"
"{-# LINE 1 \"<built-in>\" #-}\n"
"{-# LINE 1 \"<command line>\" #-}\n"
"{-# LINE 1 \"GenericTemplate.hs\" #-}\n"
"-- Id: GenericTemplate.hs,v 1.24 2003/06/03 09:41:51 ross Exp \n"
"\n"
"{-# LINE 16 \"GenericTemplate.hs\" #-}\n"
"{-# LINE 28 \"GenericTemplate.hs\" #-}\n"
"\n"
"infixr 9 `HappyStk`\n"
"data HappyStk a = HappyStk a (HappyStk a)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- starting the parse\n"
"\n"
"happyParse start_state = happyNewToken start_state notHappyAtAll notHappyAtAll\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Accepting the parse\n"
"\n"
"happyAccept j tk st sts (HappyStk ans _) = \n"
"\n"
"					   (happyReturn1 ans)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Arrays only: do the next action\n"
"\n"
"{-# LINE 151 \"GenericTemplate.hs\" #-}\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- HappyState data type (not arrays)\n"
"\n"
"newtype HappyState b c = HappyState\n"
"        (Int ->                    -- token number\n"
"         Int ->                    -- token number (yes, again)\n"
"         b ->                           -- token semantic value\n"
"         HappyState b c ->              -- current state\n"
"         [HappyState b c] ->            -- state stack\n"
"         c)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Shifting a token\n"
"\n"
"happyShift new_state (1) tk st sts stk@(x `HappyStk` _) =\n"
"     let i = (case x of { HappyErrorToken (i) -> i }) in\n"
"--     trace \"shifting the error token\" $\n"
"     new_state i i tk (HappyState (new_state)) ((st):(sts)) (stk)\n"
"\n"
"happyShift new_state i tk st sts stk =\n"
"     happyNewToken new_state ((st):(sts)) ((HappyTerminal (tk))`HappyStk`stk)\n"
"\n"
"-- happyReduce is specialised for the common cases.\n"
"\n"
"happySpecReduce_0 i fn (1) tk st sts stk\n"
"     = happyFail (1) tk st sts stk\n"
"happySpecReduce_0 nt fn j tk st@((HappyState (action))) sts stk\n"
"     = action nt j tk st ((st):(sts)) (fn `HappyStk` stk)\n"
"\n"
"happySpecReduce_1 i fn (1) tk st sts stk\n"
"     = happyFail (1) tk st sts stk\n"
"happySpecReduce_1 nt fn j tk _ sts@(((st@(HappyState (action))):(_))) (v1`HappyStk`stk')\n"
"     = let r = fn v1 in\n"
"       happySeq r (action nt j tk st sts (r `HappyStk` stk'))\n"
"\n"
"happySpecReduce_2 i fn (1) tk st sts stk\n"
"     = happyFail (1) tk st sts stk\n"
"happySpecReduce_2 nt fn j tk _ ((_):(sts@(((st@(HappyState (action))):(_))))) (v1`HappyStk`v2`HappyStk`stk')\n"
"     = let r = fn v1 v2 in\n"
"       happySeq r (action nt j tk st sts (r `HappyStk` stk'))\n"
"\n"
"happySpecReduce_3 i fn (1) tk st sts stk\n"
"     = happyFail (1) tk st sts stk\n"
"happySpecReduce_3 nt fn j tk _ ((_):(((_):(sts@(((st@(HappyState (action))):(_))))))) (v1`HappyStk`v2`HappyStk`v3`HappyStk`stk')\n"
"     = let r = fn v1 v2 v3 in\n"
"       happySeq r (action nt j tk st sts (r `HappyStk` stk'))\n"
"\n"
"happyReduce k i fn (1) tk st sts stk\n"
"     = happyFail (1) tk st sts stk\n"
"happyReduce k nt fn j tk st sts stk\n"
"     = case happyDrop (k - ((1) :: Int)) sts of\n"
"	 sts1@(((st1@(HappyState (action))):(_))) ->\n"
"        	let r = fn stk in  -- it doesn't hurt to always seq here...\n"
"       		happyDoSeq r (action nt j tk st1 sts1 r)\n"
"\n"
"happyMonadReduce k nt fn (1) tk st sts stk\n"
"     = happyFail (1) tk st sts stk\n"
"happyMonadReduce k nt fn j tk st sts stk =\n"
"        happyThen1 (fn stk) (\\r -> action nt j tk st1 sts1 (r `HappyStk` drop_stk))\n"
"       where sts1@(((st1@(HappyState (action))):(_))) = happyDrop k ((st):(sts))\n"
"             drop_stk = happyDropStk k stk\n"
"\n"
"happyDrop (0) l = l\n"
"happyDrop n ((_):(t)) = happyDrop (n - ((1) :: Int)) t\n"
"\n"
"happyDropStk (0) l = l\n"
"happyDropStk n (x `HappyStk` xs) = happyDropStk (n - ((1)::Int)) xs\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Moving to a new state after a reduction\n"
"\n"
"{-# LINE 235 \"GenericTemplate.hs\" #-}\n"
"happyGoto action j tk st = action j j tk (HappyState action)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Error recovery ((1) is the error token)\n"
"\n"
"-- parse error if we are in recovery and we fail again\n"
"happyFail  (1) tk old_st _ stk =\n"
"--	trace \"failing\" $ \n"
"    	happyError\n"
"\n"
"{-  We don't need state discarding for our restricted implementation of\n"
"    \"error\".  In fact, it can cause some bogus parses, so I've disabled it\n"
"    for now --SDM\n"
"\n"
"-- discard a state\n"
"happyFail  (1) tk old_st (((HappyState (action))):(sts)) \n"
"						(saved_tok `HappyStk` _ `HappyStk` stk) =\n"
"--	trace (\"discarding state, depth \" ++ show (length stk))  $\n"
"	action (1) (1) tk (HappyState (action)) sts ((saved_tok`HappyStk`stk))\n"
"-}\n"
"\n"
"-- Enter error recovery: generate an error token,\n"
"--                       save the old token and carry on.\n"
"happyFail  i tk (HappyState (action)) sts stk =\n"
"--      trace \"entering error recovery\" $\n"
"	action (1) (1) tk (HappyState (action)) sts ( (HappyErrorToken (i)) `HappyStk` stk)\n"
"\n"
"-- Internal happy errors:\n"
"\n"
"notHappyAtAll = error \"Internal Happy error\\n\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Hack to get the typechecker to accept our action functions\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Seq-ing.  If the --strict flag is given, then Happy emits \n"
"--	happySeq = happyDoSeq\n"
"-- otherwise it emits\n"
"-- 	happySeq = happyDontSeq\n"
"\n"
"happyDoSeq, happyDontSeq :: a -> b -> b\n"
"happyDoSeq   a b = a `seq` b\n"
"happyDontSeq a b = b\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Don't inline any functions from the template.  GHC has a nasty habit\n"
"-- of deciding to inline happyGoto everywhere, which increases the size of\n"
"-- the generated parser quite a bit.\n"
"\n"
"{-# LINE 300 \"GenericTemplate.hs\" #-}\n"
"{-# NOINLINE happyShift #-}\n"
"{-# NOINLINE happySpecReduce_0 #-}\n"
"{-# NOINLINE happySpecReduce_1 #-}\n"
"{-# NOINLINE happySpecReduce_2 #-}\n"
"{-# NOINLINE happySpecReduce_3 #-}\n"
"{-# NOINLINE happyReduce #-}\n"
"{-# NOINLINE happyMonadReduce #-}\n"
"{-# NOINLINE happyGoto #-}\n"
"{-# NOINLINE happyFail #-}\n"
"\n"
"-- end of Happy Template.\n";
const char *Language_Haskell_ParseUtils = "\n"
"-- #hide\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Language.Haskell.ParseUtils\n"
"-- Copyright   :  (c) The GHC Team, 1997-2000\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- Utilities for the Haskell parser.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Language.Haskell.ParseUtils (\n"
"	  splitTyConApp		-- HsType -> P (HsName,[HsType])\n"
"	, mkRecConstrOrUpdate	-- HsExp -> [HsFieldUpdate] -> P HsExp\n"
"	, checkPrec		-- Integer -> P Int\n"
"	, checkContext		-- HsType -> P HsContext\n"
"	, checkAssertion	-- HsType -> P HsAsst\n"
"	, checkDataHeader	-- HsQualType -> P (HsContext,HsName,[HsName])\n"
"	, checkClassHeader	-- HsQualType -> P (HsContext,HsName,[HsName])\n"
"	, checkInstHeader	-- HsQualType -> P (HsContext,HsQName,[HsType])\n"
"	, checkPattern		-- HsExp -> P HsPat\n"
"	, checkExpr		-- HsExp -> P HsExp\n"
"	, checkValDef		-- SrcLoc -> HsExp -> HsRhs -> [HsDecl] -> P HsDecl\n"
"	, checkClassBody	-- [HsDecl] -> P [HsDecl]\n"
"	, checkUnQual		-- HsQName -> P HsName\n"
"	, checkRevDecls		-- [HsDecl] -> P [HsDecl]\n"
" ) where\n"
"\n"
"import Language.Haskell.Syntax\n"
"import Language.Haskell.ParseMonad\n"
"import Language.Haskell.Pretty\n"
"\n"
"splitTyConApp :: HsType -> P (HsName,[HsType])\n"
"splitTyConApp t0 = split t0 []\n"
" where\n"
"	split :: HsType -> [HsType] -> P (HsName,[HsType])\n"
"	split (HsTyApp t u) ts = split t (u:ts)\n"
"	split (HsTyCon (UnQual t)) ts = return (t,ts)\n"
"	split _ _ = fail \"Illegal data/newtype declaration\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Various Syntactic Checks\n"
"\n"
"checkContext :: HsType -> P HsContext\n"
"checkContext (HsTyTuple ts) =\n"
"	mapM checkAssertion ts\n"
"checkContext t = do\n"
"	c <- checkAssertion t\n"
"	return [c]\n"
"\n"
"-- Changed for multi-parameter type classes\n"
"\n"
"checkAssertion :: HsType -> P HsAsst\n"
"checkAssertion = checkAssertion' []\n"
"	where	checkAssertion' ts (HsTyCon c) = return (c,ts)\n"
"		checkAssertion' ts (HsTyApp a t) = checkAssertion' (t:ts) a\n"
"		checkAssertion' _ _ = fail \"Illegal class assertion\"\n"
"\n"
"checkDataHeader :: HsQualType -> P (HsContext,HsName,[HsName])\n"
"checkDataHeader (HsQualType cs t) = do\n"
"	(c,ts) <- checkSimple \"data/newtype\" t []\n"
"	return (cs,c,ts)\n"
"\n"
"checkClassHeader :: HsQualType -> P (HsContext,HsName,[HsName])\n"
"checkClassHeader (HsQualType cs t) = do\n"
"	(c,ts) <- checkSimple \"class\" t []\n"
"	return (cs,c,ts)\n"
"\n"
"checkSimple :: String -> HsType -> [HsName] -> P ((HsName,[HsName]))\n"
"checkSimple kw (HsTyApp l (HsTyVar a)) xs = checkSimple kw l (a:xs)\n"
"checkSimple _kw (HsTyCon (UnQual t))   xs = return (t,xs)\n"
"checkSimple kw _ _ = fail (\"Illegal \" ++ kw ++ \" declaration\")\n"
"\n"
"checkInstHeader :: HsQualType -> P (HsContext,HsQName,[HsType])\n"
"checkInstHeader (HsQualType cs t) = do\n"
"	(c,ts) <- checkInsts t []\n"
"	return (cs,c,ts)\n"
"\n"
"checkInsts :: HsType -> [HsType] -> P ((HsQName,[HsType]))\n"
"checkInsts (HsTyApp l t) ts = checkInsts l (t:ts)\n"
"checkInsts (HsTyCon c)   ts = return (c,ts)\n"
"checkInsts _ _ = fail \"Illegal instance declaration\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Checking Patterns.\n"
"\n"
"-- We parse patterns as expressions and check for valid patterns below,\n"
"-- converting the expression into a pattern at the same time.\n"
"\n"
"checkPattern :: HsExp -> P HsPat\n"
"checkPattern e = checkPat e []\n"
"\n"
"checkPat :: HsExp -> [HsPat] -> P HsPat\n"
"checkPat (HsCon c) args = return (HsPApp c args)\n"
"checkPat (HsApp f x) args = do\n"
"	x <- checkPat x []\n"
"	checkPat f (x:args)\n"
"checkPat e [] = case e of\n"
"	HsVar (UnQual x)   -> return (HsPVar x)\n"
"	HsLit l            -> return (HsPLit l)\n"
"	HsInfixApp l op r  -> do\n"
"			      l <- checkPat l []\n"
"			      r <- checkPat r []\n"
"			      case op of\n"
"				 HsQConOp c -> return (HsPInfixApp l c r)\n"
"				 _ -> patFail\n"
"	HsTuple es         -> do\n"
"			      ps <- mapM (\\e -> checkPat e []) es\n"
"			      return (HsPTuple ps)\n"
"	HsList es	   -> do\n"
"			      ps <- mapM (\\e -> checkPat e []) es\n"
"			      return (HsPList ps)\n"
"	HsParen e	   -> do\n"
"			      p <- checkPat e []\n"
"			      return (HsPParen p)\n"
"	HsAsPat n e	   -> do\n"
"			      p <- checkPat e []\n"
"			      return (HsPAsPat n p)\n"
"	HsWildCard	   -> return HsPWildCard\n"
"	HsIrrPat e	   -> do\n"
"			      p <- checkPat e []\n"
"			      return (HsPIrrPat p)\n"
"	HsRecConstr c fs   -> do\n"
"			      fs <- mapM checkPatField fs\n"
"			      return (HsPRec c fs)\n"
"	HsNegApp (HsLit l) -> return (HsPNeg (HsPLit l))\n"
"	_ -> patFail\n"
"\n"
"checkPat _ _ = patFail\n"
"\n"
"checkPatField :: HsFieldUpdate -> P HsPatField\n"
"checkPatField (HsFieldUpdate n e) = do\n"
"	p <- checkPat e []\n"
"	return (HsPFieldPat n p)\n"
"\n"
"patFail :: P a\n"
"patFail = fail \"Parse error in pattern\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Check Expression Syntax\n"
"\n"
"checkExpr :: HsExp -> P HsExp\n"
"checkExpr e = case e of\n"
"	HsVar _			  -> return e\n"
"	HsCon _			  -> return e\n"
"	HsLit _			  -> return e\n"
"	HsInfixApp e1 op e2	  -> check2Exprs e1 e2 (flip HsInfixApp op)\n"
"	HsApp e1 e2		  -> check2Exprs e1 e2 HsApp\n"
"	HsNegApp e		  -> check1Expr e HsNegApp\n"
"	HsLambda loc ps e	  -> check1Expr e (HsLambda loc ps)\n"
"	HsLet bs e		  -> check1Expr e (HsLet bs)\n"
"	HsIf e1 e2 e3		  -> check3Exprs e1 e2 e3 HsIf\n"
"	HsCase e alts		  -> do\n"
"				     alts <- mapM checkAlt alts\n"
"				     e <- checkExpr e\n"
"				     return (HsCase e alts)\n"
"	HsDo stmts		  -> do\n"
"				     stmts <- mapM checkStmt stmts\n"
"				     return (HsDo stmts)\n"
"	HsTuple es		  -> checkManyExprs es HsTuple\n"
"	HsList es		  -> checkManyExprs es HsList\n"
"	HsParen e		  -> check1Expr e HsParen\n"
"	HsLeftSection e op	  -> check1Expr e (flip HsLeftSection op)\n"
"	HsRightSection op e	  -> check1Expr e (HsRightSection op)\n"
"	HsRecConstr c fields	  -> do\n"
"				     fields <- mapM checkField fields\n"
"				     return (HsRecConstr c fields)\n"
"	HsRecUpdate e fields	  -> do\n"
"				     fields <- mapM checkField fields\n"
"				     e <- checkExpr e\n"
"				     return (HsRecUpdate e fields)\n"
"	HsEnumFrom e		  -> check1Expr e HsEnumFrom\n"
"	HsEnumFromTo e1 e2	  -> check2Exprs e1 e2 HsEnumFromTo\n"
"	HsEnumFromThen e1 e2      -> check2Exprs e1 e2 HsEnumFromThen\n"
"	HsEnumFromThenTo e1 e2 e3 -> check3Exprs e1 e2 e3 HsEnumFromThenTo\n"
"	HsListComp e stmts        -> do\n"
"				     stmts <- mapM checkStmt stmts\n"
"				     e <- checkExpr e\n"
"				     return (HsListComp e stmts)\n"
"	HsExpTypeSig loc e ty     -> do\n"
"				     e <- checkExpr e\n"
"				     return (HsExpTypeSig loc e ty)\n"
"	_                         -> fail \"Parse error in expression\"\n"
"\n"
"-- type signature for polymorphic recursion!!\n"
"check1Expr :: HsExp -> (HsExp -> a) -> P a\n"
"check1Expr e1 f = do\n"
"	e1 <- checkExpr e1\n"
"	return (f e1)\n"
"\n"
"check2Exprs :: HsExp -> HsExp -> (HsExp -> HsExp -> a) -> P a\n"
"check2Exprs e1 e2 f = do\n"
"	e1 <- checkExpr e1\n"
"	e2 <- checkExpr e2\n"
"	return (f e1 e2)\n"
"\n"
"check3Exprs :: HsExp -> HsExp -> HsExp -> (HsExp -> HsExp -> HsExp -> a) -> P a\n"
"check3Exprs e1 e2 e3 f = do\n"
"	e1 <- checkExpr e1\n"
"	e2 <- checkExpr e2\n"
"	e3 <- checkExpr e3\n"
"	return (f e1 e2 e3)\n"
"\n"
"checkManyExprs :: [HsExp] -> ([HsExp] -> a) -> P a\n"
"checkManyExprs es f = do\n"
"	es <- mapM checkExpr es\n"
"	return (f es)\n"
"\n"
"checkAlt :: HsAlt -> P HsAlt\n"
"checkAlt (HsAlt loc p galts bs) = do\n"
"	galts <- checkGAlts galts\n"
"	return (HsAlt loc p galts bs)\n"
"\n"
"checkGAlts :: HsGuardedAlts -> P HsGuardedAlts\n"
"checkGAlts (HsUnGuardedAlt e) = check1Expr e HsUnGuardedAlt\n"
"checkGAlts (HsGuardedAlts galts) = do\n"
"	galts <- mapM checkGAlt galts\n"
"	return (HsGuardedAlts galts)\n"
"\n"
"checkGAlt :: HsGuardedAlt -> P HsGuardedAlt\n"
"checkGAlt (HsGuardedAlt loc e1 e2) = check2Exprs e1 e2 (HsGuardedAlt loc)\n"
"\n"
"checkStmt :: HsStmt -> P HsStmt\n"
"checkStmt (HsGenerator loc p e) = check1Expr e (HsGenerator loc p)\n"
"checkStmt (HsQualifier e) = check1Expr e HsQualifier\n"
"checkStmt s@(HsLetStmt _) = return s\n"
"\n"
"checkField :: HsFieldUpdate -> P HsFieldUpdate\n"
"checkField (HsFieldUpdate n e) = check1Expr e (HsFieldUpdate n)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Check Equation Syntax\n"
"\n"
"checkValDef :: SrcLoc -> HsExp -> HsRhs -> [HsDecl] -> P HsDecl\n"
"checkValDef srcloc lhs rhs whereBinds =\n"
"    case isFunLhs lhs [] of\n"
"	 Just (f,es) -> do\n"
"			ps <- mapM checkPattern es\n"
"			return (HsFunBind [HsMatch srcloc f ps rhs whereBinds])\n"
"         Nothing     -> do\n"
"			lhs <- checkPattern lhs\n"
"			return (HsPatBind srcloc lhs rhs whereBinds)\n"
"\n"
"-- A variable binding is parsed as an HsPatBind.\n"
"\n"
"isFunLhs :: HsExp -> [HsExp] -> Maybe (HsName, [HsExp])\n"
"isFunLhs (HsInfixApp l (HsQVarOp (UnQual op)) r) es = Just (op, l:r:es)\n"
"isFunLhs (HsApp (HsVar (UnQual f)) e) es = Just (f, e:es)\n"
"isFunLhs (HsApp (HsParen f) e) es = isFunLhs f (e:es)\n"
"isFunLhs (HsApp f e) es = isFunLhs f (e:es)\n"
"isFunLhs _ _ = Nothing\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- In a class or instance body, a pattern binding must be of a variable.\n"
"\n"
"checkClassBody :: [HsDecl] -> P [HsDecl]\n"
"checkClassBody decls = do\n"
"	mapM_ checkMethodDef decls\n"
"	return decls\n"
"\n"
"checkMethodDef :: HsDecl -> P ()\n"
"checkMethodDef (HsPatBind _ (HsPVar _) _ _) = return ()\n"
"checkMethodDef (HsPatBind loc _ _ _) =\n"
"	fail \"illegal method definition\" `atSrcLoc` loc\n"
"checkMethodDef _ = return ()\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Check that an identifier or symbol is unqualified.\n"
"-- For occasions when doing this in the grammar would cause conflicts.\n"
"\n"
"checkUnQual :: HsQName -> P HsName\n"
"checkUnQual (Qual _ _) = fail \"Illegal qualified name\"\n"
"checkUnQual (UnQual n) = return n\n"
"checkUnQual (Special _) = fail \"Illegal special name\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Miscellaneous utilities\n"
"\n"
"checkPrec :: Integer -> P Int\n"
"checkPrec i | 0 <= i && i <= 9 = return (fromInteger i)\n"
"checkPrec i | otherwise	       = fail (\"Illegal precedence \" ++ show i)\n"
"\n"
"mkRecConstrOrUpdate :: HsExp -> [HsFieldUpdate] -> P HsExp\n"
"mkRecConstrOrUpdate (HsCon c) fs       = return (HsRecConstr c fs)\n"
"mkRecConstrOrUpdate e         fs@(_:_) = return (HsRecUpdate e fs)\n"
"mkRecConstrOrUpdate _         _        = fail \"Empty record update\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Reverse a list of declarations, merging adjacent HsFunBinds of the\n"
"-- same name and checking that their arities match.\n"
"\n"
"checkRevDecls :: [HsDecl] -> P [HsDecl]\n"
"checkRevDecls = mergeFunBinds []\n"
"    where\n"
"	mergeFunBinds revDs [] = return revDs\n"
"	mergeFunBinds revDs (HsFunBind ms1@(HsMatch _ name ps _ _:_):ds1) =\n"
"		mergeMatches ms1 ds1\n"
"	    where\n"
"		arity = length ps\n"
"		mergeMatches ms' (HsFunBind ms@(HsMatch loc name' ps' _ _:_):ds)\n"
"		    | name' == name =\n"
"			if length ps' /= arity\n"
"			then fail (\"arity mismatch for '\" ++ prettyPrint name ++ \"'\")\n"
"			     `atSrcLoc` loc\n"
"			else mergeMatches (ms++ms') ds\n"
"		mergeMatches ms' ds = mergeFunBinds (HsFunBind ms':revDs) ds\n"
"	mergeFunBinds revDs (d:ds) = mergeFunBinds (d:revDs) ds\n";
const char *Language_Haskell_Pretty = "\n"
"{-# OPTIONS -w #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Language.Haskell.Pretty\n"
"-- Copyright   :  (c) The GHC Team, Noel Winstanley 1997-2000\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"--\n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- Pretty printer for Haskell.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Language.Haskell.Pretty (\n"
"		-- * Pretty printing\n"
"		Pretty,\n"
"		prettyPrintStyleMode, prettyPrintWithMode, prettyPrint,\n"
"		-- * Pretty-printing styles (from @Text.PrettyPrint.HughesPJ@)\n"
"		P.Style(..), P.style, P.Mode(..),\n"
"		-- * Haskell formatting modes\n"
"		PPHsMode(..), Indent, PPLayout(..), defaultMode) where\n"
"\n"
"import Language.Haskell.Syntax\n"
"\n"
"import qualified Text.PrettyPrint as P\n"
"\n"
"infixl 5 $$$\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- | Varieties of layout we can use.\n"
"data PPLayout = PPOffsideRule	-- ^ classical layout\n"
"	      | PPSemiColon	-- ^ classical layout made explicit\n"
"	      | PPInLine	-- ^ inline decls, with newlines between them\n"
"	      | PPNoLayout	-- ^ everything on a single line\n"
"	      deriving Eq\n"
"\n"
"type Indent = Int\n"
"\n"
"-- | Pretty-printing parameters.\n"
"data PPHsMode = PPHsMode {\n"
"				-- | indentation of a class or instance\n"
"		classIndent :: Indent,\n"
"				-- | indentation of a @do@-expression\n"
"		doIndent :: Indent,\n"
"				-- | indentation of the body of a\n"
"				-- @case@ expression\n"
"		caseIndent :: Indent,\n"
"				-- | indentation of the declarations in a\n"
"				-- @let@ expression\n"
"		letIndent :: Indent,\n"
"				-- | indentation of the declarations in a\n"
"				-- @where@ clause\n"
"		whereIndent :: Indent,\n"
"				-- | indentation added for continuation\n"
"				-- lines that would otherwise be offside\n"
"		onsideIndent :: Indent,\n"
"				-- | blank lines between statements?\n"
"		spacing :: Bool,\n"
"				-- | Pretty-printing style to use\n"
"		layout :: PPLayout,\n"
"				-- | add GHC-style @LINE@ pragmas to output?\n"
"		linePragmas :: Bool,\n"
"				-- | not implemented yet\n"
"		comments :: Bool\n"
"		}\n"
"\n"
"-- | The default mode: pretty-print using the offside rule and sensible\n"
"-- defaults.\n"
"defaultMode :: PPHsMode\n"
"defaultMode = PPHsMode{\n"
"		      classIndent = 8,\n"
"		      doIndent = 3,\n"
"		      caseIndent = 4,\n"
"		      letIndent = 4,\n"
"		      whereIndent = 6,\n"
"		      onsideIndent = 2,\n"
"		      spacing = True,\n"
"		      layout = PPOffsideRule,\n"
"		      linePragmas = False,\n"
"		      comments = True\n"
"		      }\n"
"\n"
"-- | Pretty printing monad\n"
"newtype DocM s a = DocM (s -> a)\n"
"\n"
"instance Functor (DocM s) where\n"
"	 fmap f xs = do x <- xs; return (f x)\n"
"\n"
"instance Monad (DocM s) where\n"
"	(>>=) = thenDocM\n"
"	(>>) = then_DocM\n"
"	return = retDocM\n"
"\n"
"{-# INLINE thenDocM #-}\n"
"{-# INLINE then_DocM #-}\n"
"{-# INLINE retDocM #-}\n"
"{-# INLINE unDocM #-}\n"
"{-# INLINE getPPEnv #-}\n"
"\n"
"thenDocM :: DocM s a -> (a -> DocM s b) -> DocM s b\n"
"thenDocM m k = DocM $ (\\s -> case unDocM m $ s of a -> unDocM (k a) $ s)\n"
"\n"
"then_DocM :: DocM s a -> DocM s b -> DocM s b\n"
"then_DocM m k = DocM $ (\\s -> case unDocM m $ s of _ -> unDocM k $ s)\n"
"\n"
"retDocM :: a -> DocM s a\n"
"retDocM a = DocM (\\_s -> a)\n"
"\n"
"unDocM :: DocM s a -> (s -> a)\n"
"unDocM (DocM f) = f\n"
"\n"
"-- all this extra stuff, just for this one function.\n"
"getPPEnv :: DocM s s\n"
"getPPEnv = DocM id\n"
"\n"
"-- So that pp code still looks the same\n"
"-- this means we lose some generality though\n"
"\n"
"-- | The document type produced by these pretty printers uses a 'PPHsMode'\n"
"-- environment.\n"
"type Doc = DocM PPHsMode P.Doc\n"
"\n"
"-- | Things that can be pretty-printed, including all the syntactic objects\n"
"-- in \"Language.Haskell.Syntax\".\n"
"class Pretty a where\n"
"	-- | Pretty-print something in isolation.\n"
"	pretty :: a -> Doc\n"
"	-- | Pretty-print something in a precedence context.\n"
"	prettyPrec :: Int -> a -> Doc\n"
"	pretty = prettyPrec 0\n"
"	prettyPrec _ = pretty\n"
"\n"
"-- The pretty printing combinators\n"
"\n"
"empty :: Doc\n"
"empty = return P.empty\n"
"\n"
"nest :: Int -> Doc -> Doc\n"
"nest i m = m >>= return . P.nest i\n"
"\n"
"-- Literals\n"
"\n"
"text, ptext :: String -> Doc\n"
"text = return . P.text\n"
"ptext = return . P.text\n"
"\n"
"char :: Char -> Doc\n"
"char = return . P.char\n"
"\n"
"int :: Int -> Doc\n"
"int = return . P.int\n"
"\n"
"integer :: Integer -> Doc\n"
"integer = return . P.integer\n"
"\n"
"float :: Float -> Doc\n"
"float = return . P.float\n"
"\n"
"double :: Double -> Doc\n"
"double = return . P.double\n"
"\n"
"rational :: Rational -> Doc\n"
"rational = return . P.rational\n"
"\n"
"-- Simple Combining Forms\n"
"\n"
"parens, brackets, braces,quotes,doubleQuotes :: Doc -> Doc\n"
"parens d = d >>= return . P.parens\n"
"brackets d = d >>= return . P.brackets\n"
"braces d = d >>= return . P.braces\n"
"quotes d = d >>= return . P.quotes\n"
"doubleQuotes d = d >>= return . P.doubleQuotes\n"
"\n"
"parensIf :: Bool -> Doc -> Doc\n"
"parensIf True = parens\n"
"parensIf False = id\n"
"\n"
"-- Constants\n"
"\n"
"semi,comma,colon,space,equals :: Doc\n"
"semi = return P.semi\n"
"comma = return P.comma\n"
"colon = return P.colon\n"
"space = return P.space\n"
"equals = return P.equals\n"
"\n"
"lparen,rparen,lbrack,rbrack,lbrace,rbrace :: Doc\n"
"lparen = return  P.lparen\n"
"rparen = return  P.rparen\n"
"lbrack = return  P.lbrack\n"
"rbrack = return  P.rbrack\n"
"lbrace = return  P.lbrace\n"
"rbrace = return  P.rbrace\n"
"\n"
"-- Combinators\n"
"\n"
"(<>),(<+>),($$),($+$) :: Doc -> Doc -> Doc\n"
"aM <> bM = do{a<-aM;b<-bM;return (a P.<> b)}\n"
"aM <+> bM = do{a<-aM;b<-bM;return (a P.<+> b)}\n"
"aM $$ bM = do{a<-aM;b<-bM;return (a P.$$ b)}\n"
"aM $+$ bM = do{a<-aM;b<-bM;return (a P.$+$ b)}\n"
"\n"
"hcat,hsep,vcat,sep,cat,fsep,fcat :: [Doc] -> Doc\n"
"hcat dl = sequence dl >>= return . P.hcat\n"
"hsep dl = sequence dl >>= return . P.hsep\n"
"vcat dl = sequence dl >>= return . P.vcat\n"
"sep dl = sequence dl >>= return . P.sep\n"
"cat dl = sequence dl >>= return . P.cat\n"
"fsep dl = sequence dl >>= return . P.fsep\n"
"fcat dl = sequence dl >>= return . P.fcat\n"
"\n"
"-- Some More\n"
"\n"
"hang :: Doc -> Int -> Doc -> Doc\n"
"hang dM i rM = do{d<-dM;r<-rM;return $ P.hang d i r}\n"
"\n"
"-- Yuk, had to cut-n-paste this one from Pretty.hs\n"
"punctuate :: Doc -> [Doc] -> [Doc]\n"
"punctuate _ []     = []\n"
"punctuate p (d1:ds) = go d1 ds\n"
"                   where\n"
"                     go d [] = [d]\n"
"                     go d (e:es) = (d <> p) : go e es\n"
"\n"
"-- | render the document with a given style and mode.\n"
"renderStyleMode :: P.Style -> PPHsMode -> Doc -> String\n"
"renderStyleMode ppStyle ppMode d = P.renderStyle ppStyle . unDocM d $ ppMode\n"
"\n"
"-- | render the document with a given mode.\n"
"renderWithMode :: PPHsMode -> Doc -> String\n"
"renderWithMode = renderStyleMode P.style\n"
"\n"
"-- | render the document with 'defaultMode'.\n"
"render :: Doc -> String\n"
"render = renderWithMode defaultMode\n"
"\n"
"-- | pretty-print with a given style and mode.\n"
"prettyPrintStyleMode :: Pretty a => P.Style -> PPHsMode -> a -> String\n"
"prettyPrintStyleMode ppStyle ppMode = renderStyleMode ppStyle ppMode . pretty\n"
"\n"
"-- | pretty-print with the default style and a given mode.\n"
"prettyPrintWithMode :: Pretty a => PPHsMode -> a -> String\n"
"prettyPrintWithMode = prettyPrintStyleMode P.style\n"
"\n"
"-- | pretty-print with the default style and 'defaultMode'.\n"
"prettyPrint :: Pretty a => a -> String\n"
"prettyPrint = prettyPrintWithMode defaultMode\n"
"\n"
"fullRenderWithMode :: PPHsMode -> P.Mode -> Int -> Float ->\n"
"		      (P.TextDetails -> a -> a) -> a -> Doc -> a\n"
"fullRenderWithMode ppMode m i f fn e mD =\n"
"		   P.fullRender m i f fn e $ (unDocM mD) ppMode\n"
"\n"
"fullRender :: P.Mode -> Int -> Float -> (P.TextDetails -> a -> a)\n"
"	      -> a -> Doc -> a\n"
"fullRender = fullRenderWithMode defaultMode\n"
"\n"
"-------------------------  Pretty-Print a Module --------------------\n"
"instance Pretty HsModule where\n"
"	pretty (HsModule pos m mbExports imp decls) =\n"
"		markLine pos $\n"
"		topLevel (ppHsModuleHeader m mbExports)\n"
"			 (map pretty imp ++ map pretty decls)\n"
"\n"
"--------------------------  Module Header ------------------------------\n"
"ppHsModuleHeader :: Module -> Maybe [HsExportSpec] ->  Doc\n"
"ppHsModuleHeader m mbExportList = mySep [\n"
"	text \"module\",\n"
"	pretty m,\n"
"	maybePP (parenList . map pretty) mbExportList,\n"
"	text \"where\"]\n"
"\n"
"instance Pretty Module where\n"
"	pretty (Module modName) = text modName\n"
"\n"
"instance Pretty HsExportSpec where\n"
"	pretty (HsEVar name)		    = pretty name\n"
"	pretty (HsEAbs name)		    = pretty name\n"
"	pretty (HsEThingAll name)	    = pretty name <> text \"(..)\"\n"
"	pretty (HsEThingWith name nameList) =\n"
"		pretty name <> (parenList . map pretty $ nameList)\n"
"	pretty (HsEModuleContents m)       = text \"module\" <+> pretty m\n"
"\n"
"instance Pretty HsImportDecl where\n"
"	pretty (HsImportDecl pos m qual mbName mbSpecs) =\n"
"		markLine pos $\n"
"		mySep [text \"import\",\n"
"		       if qual then text \"qualified\" else empty,\n"
"		       pretty m,\n"
"		       maybePP (\\m' -> text \"as\" <+> pretty m') mbName,\n"
"		       maybePP exports mbSpecs]\n"
"	    where\n"
"		exports (b,specList) =\n"
"			if b then text \"hiding\" <+> specs else specs\n"
"		    where specs = parenList . map pretty $ specList\n"
"\n"
"instance Pretty HsImportSpec where\n"
"	pretty (HsIVar name)                = pretty name\n"
"	pretty (HsIAbs name)                = pretty name\n"
"	pretty (HsIThingAll name)           = pretty name <> text \"(..)\"\n"
"	pretty (HsIThingWith name nameList) =\n"
"		pretty name <> (parenList . map pretty $ nameList)\n"
"\n"
"-------------------------  Declarations ------------------------------\n"
"instance Pretty HsDecl where\n"
"	pretty (HsTypeDecl loc name nameList htype) =\n"
"		blankline $\n"
"		markLine loc $\n"
"		mySep ( [text \"type\", pretty name]\n"
"			++ map pretty nameList\n"
"			++ [equals, pretty htype])\n"
"\n"
"	pretty (HsDataDecl loc context name nameList constrList derives) =\n"
"		blankline $\n"
"		markLine loc $\n"
"		mySep ( [text \"data\", ppHsContext context, pretty name]\n"
"			++ map pretty nameList)\n"
"			<+> (myVcat (zipWith (<+>) (equals : repeat (char '|'))\n"
"						   (map pretty constrList))\n"
"			$$$ ppHsDeriving derives)\n"
"\n"
"	pretty (HsNewTypeDecl pos context name nameList constr derives) =\n"
"		blankline $\n"
"		markLine pos $\n"
"		mySep ( [text \"newtype\", ppHsContext context, pretty name]\n"
"			++ map pretty nameList)\n"
"			<+> equals <+> (pretty constr $$$ ppHsDeriving derives)\n"
"\n"
"	--m{spacing=False}\n"
"	-- special case for empty class declaration\n"
"	pretty (HsClassDecl pos context name nameList []) =\n"
"		blankline $\n"
"		markLine pos $\n"
"		mySep ( [text \"class\", ppHsContext context, pretty name]\n"
"			++ map pretty nameList)\n"
"	pretty (HsClassDecl pos context name nameList declList) =\n"
"		blankline $\n"
"		markLine pos $\n"
"		mySep ( [text \"class\", ppHsContext context, pretty name]\n"
"			++ map pretty nameList ++ [text \"where\"])\n"
"		$$$ ppBody classIndent (map pretty declList)\n"
"\n"
"	-- m{spacing=False}\n"
"	-- special case for empty instance declaration\n"
"	pretty (HsInstDecl pos context name args []) =\n"
"		blankline $\n"
"		markLine pos $\n"
"		mySep ( [text \"instance\", ppHsContext context, pretty name]\n"
"			++ map ppHsTypeArg args)\n"
"	pretty (HsInstDecl pos context name args declList) =\n"
"		blankline $\n"
"		markLine pos $\n"
"		mySep ( [text \"instance\", ppHsContext context, pretty name]\n"
"			++ map ppHsTypeArg args ++ [text \"where\"])\n"
"		$$$ ppBody classIndent (map pretty declList)\n"
"\n"
"	pretty (HsDefaultDecl pos htypes) =\n"
"		blankline $\n"
"		markLine pos $\n"
"		text \"default\" <+> parenList (map pretty htypes)\n"
"\n"
"	pretty (HsTypeSig pos nameList qualType) =\n"
"		blankline $\n"
"		markLine pos $\n"
"		mySep ((punctuate comma . map pretty $ nameList)\n"
"		      ++ [text \"::\", pretty qualType])\n"
"\n"
"	pretty (HsFunBind matches) =\n"
"		foldr ($$$) empty (map pretty matches)\n"
"\n"
"	pretty (HsPatBind pos pat rhs whereDecls) =\n"
"		markLine pos $\n"
"		myFsep [pretty pat, pretty rhs] $$$ ppWhere whereDecls\n"
"\n"
"	pretty (HsInfixDecl pos assoc prec opList) =\n"
"		blankline $\n"
"		markLine pos $\n"
"		mySep ([pretty assoc, int prec]\n"
"		       ++ (punctuate comma . map pretty $ opList))\n"
"\n"
"instance Pretty HsAssoc where\n"
"	pretty HsAssocNone  = text \"infix\"\n"
"	pretty HsAssocLeft  = text \"infixl\"\n"
"	pretty HsAssocRight = text \"infixr\"\n"
"\n"
"instance Pretty HsMatch where\n"
"	pretty (HsMatch pos f ps rhs whereDecls) =\n"
"		markLine pos $\n"
"		myFsep (lhs ++ [pretty rhs])\n"
"		$$$ ppWhere whereDecls\n"
"	    where\n"
"		lhs = case ps of\n"
"			l:r:ps' | isSymbolName f ->\n"
"				let hd = [pretty l, ppHsName f, pretty r] in\n"
"				if null ps' then hd\n"
"				else parens (myFsep hd) : map (prettyPrec 2) ps'\n"
"			_ -> pretty f : map (prettyPrec 2) ps\n"
"\n"
"ppWhere :: [HsDecl] -> Doc\n"
"ppWhere [] = empty\n"
"ppWhere l = nest 2 (text \"where\" $$$ ppBody whereIndent (map pretty l))\n"
"\n"
"------------------------- Data & Newtype Bodies -------------------------\n"
"instance Pretty HsConDecl where\n"
"	pretty (HsRecDecl _pos name fieldList) =\n"
"		pretty name <> (braceList . map ppField $ fieldList)\n"
"\n"
"	pretty (HsConDecl _pos name@(HsSymbol _) [l, r]) =\n"
"		myFsep [pretty l, ppHsName name, pretty r]\n"
"	pretty (HsConDecl _pos name typeList) =\n"
"		mySep $ ppHsName name : map pretty typeList\n"
"\n"
"ppField :: ([HsName],HsBangType) -> Doc\n"
"ppField (names, ty) =\n"
"	myFsepSimple $ (punctuate comma . map pretty $ names) ++\n"
"		       [text \"::\", pretty ty]\n"
"\n"
"instance Pretty HsBangType where\n"
"	pretty (HsBangedTy ty) = char '!' <> ppHsTypeArg ty\n"
"	pretty (HsUnBangedTy ty) = ppHsTypeArg ty\n"
"\n"
"ppHsDeriving :: [HsQName] -> Doc\n"
"ppHsDeriving []  = empty\n"
"ppHsDeriving [d] = text \"deriving\" <+> ppHsQName d\n"
"ppHsDeriving ds  = text \"deriving\" <+> parenList (map ppHsQName ds)\n"
"\n"
"------------------------- Types -------------------------\n"
"instance Pretty HsQualType where\n"
"	pretty (HsQualType context htype) =\n"
"		myFsep [ppHsContext context, pretty htype]\n"
"\n"
"ppHsTypeArg :: HsType -> Doc\n"
"ppHsTypeArg = prettyPrec 2\n"
"\n"
"-- precedences:\n"
"-- 0: top level\n"
"-- 1: left argument of ->\n"
"-- 2: argument of constructor\n"
"\n"
"instance Pretty HsType where\n"
"	prettyPrec p (HsTyFun a b) = parensIf (p > 0) $\n"
"		myFsep [prettyPrec 1 a, text \"->\", pretty b]\n"
"	prettyPrec _ (HsTyTuple l) = parenList . map pretty $ l\n"
"	prettyPrec p (HsTyApp a b)\n"
"		| a == list_tycon = brackets $ pretty b		-- special case\n"
"		| otherwise = parensIf (p > 1) $\n"
"			myFsep [pretty a, prettyPrec 2 b]\n"
"	prettyPrec _ (HsTyVar name) = pretty name\n"
"	prettyPrec _ (HsTyCon name) = pretty name\n"
"\n"
"------------------------- Expressions -------------------------\n"
"instance Pretty HsRhs where\n"
"	pretty (HsUnGuardedRhs e) = equals <+> pretty e\n"
"	pretty (HsGuardedRhss guardList) = myVcat . map pretty $ guardList\n"
"\n"
"instance Pretty HsGuardedRhs where\n"
"	pretty (HsGuardedRhs _pos guard body) =\n"
"		myFsep [char '|', pretty guard, equals, pretty body]\n"
"\n"
"instance Pretty HsLiteral where\n"
"	pretty (HsInt i)        = integer i\n"
"	pretty (HsChar c)       = text (show c)\n"
"	pretty (HsString s)     = text (show s)\n"
"	pretty (HsFrac r)       = double (fromRational r)\n"
"	-- GHC unboxed literals:\n"
"	pretty (HsCharPrim c)   = text (show c)           <> char '#'\n"
"	pretty (HsStringPrim s) = text (show s)           <> char '#'\n"
"	pretty (HsIntPrim i)    = integer i               <> char '#'\n"
"	pretty (HsFloatPrim r)  = float  (fromRational r) <> char '#'\n"
"	pretty (HsDoublePrim r) = double (fromRational r) <> text \"##\"\n"
"\n"
"instance Pretty HsExp where\n"
"	pretty (HsLit l) = pretty l\n"
"	-- lambda stuff\n"
"	pretty (HsInfixApp a op b) = myFsep [pretty a, pretty op, pretty b]\n"
"	pretty (HsNegApp e) = myFsep [char '-', pretty e]\n"
"	pretty (HsApp a b) = myFsep [pretty a, pretty b]\n"
"	pretty (HsLambda _loc expList body) = myFsep $\n"
"		char '\\\\' : map pretty expList ++ [text \"->\", pretty body]\n"
"	-- keywords\n"
"	pretty (HsLet expList letBody) =\n"
"		myFsep [text \"let\" <+> ppBody letIndent (map pretty expList),\n"
"			text \"in\", pretty letBody]\n"
"	pretty (HsIf cond thenexp elsexp) =\n"
"		myFsep [text \"if\", pretty cond,\n"
"			text \"then\", pretty thenexp,\n"
"			text \"else\", pretty elsexp]\n"
"	pretty (HsCase cond altList) =\n"
"		myFsep [text \"case\", pretty cond, text \"of\"]\n"
"		$$$ ppBody caseIndent (map pretty altList)\n"
"	pretty (HsDo stmtList) =\n"
"		text \"do\" $$$ ppBody doIndent (map pretty stmtList)\n"
"	-- Constructors & Vars\n"
"	pretty (HsVar name) = pretty name\n"
"	pretty (HsCon name) = pretty name\n"
"	pretty (HsTuple expList) = parenList . map pretty $ expList\n"
"	-- weird stuff\n"
"	pretty (HsParen e) = parens . pretty $ e\n"
"	pretty (HsLeftSection e op) = parens (pretty e <+> pretty op)\n"
"	pretty (HsRightSection op e) = parens (pretty op <+> pretty e)\n"
"	pretty (HsRecConstr c fieldList) =\n"
"		pretty c <> (braceList . map pretty $ fieldList)\n"
"	pretty (HsRecUpdate e fieldList) =\n"
"		pretty e <> (braceList . map pretty $ fieldList)\n"
"	-- patterns\n"
"	-- special case that would otherwise be buggy\n"
"	pretty (HsAsPat name (HsIrrPat e)) =\n"
"		myFsep [pretty name <> char '@', char '~' <> pretty e]\n"
"	pretty (HsAsPat name e) = hcat [pretty name, char '@', pretty e]\n"
"	pretty HsWildCard = char '_'\n"
"	pretty (HsIrrPat e) = char '~' <> pretty e\n"
"	-- Lists\n"
"	pretty (HsList list) =\n"
"		bracketList . punctuate comma . map pretty $ list\n"
"	pretty (HsEnumFrom e) =\n"
"		bracketList [pretty e, text \"..\"]\n"
"	pretty (HsEnumFromTo from to) =\n"
"		bracketList [pretty from, text \"..\", pretty to]\n"
"	pretty (HsEnumFromThen from thenE) =\n"
"		bracketList [pretty from <> comma, pretty thenE, text \"..\"]\n"
"	pretty (HsEnumFromThenTo from thenE to) =\n"
"		bracketList [pretty from <> comma, pretty thenE,\n"
"			     text \"..\", pretty to]\n"
"	pretty (HsListComp e stmtList) =\n"
"		bracketList ([pretty e, char '|']\n"
"			     ++ (punctuate comma . map pretty $ stmtList))\n"
"	pretty (HsExpTypeSig _pos e ty) =\n"
"		myFsep [pretty e, text \"::\", pretty ty]\n"
"\n"
"------------------------- Patterns -----------------------------\n"
"\n"
"instance Pretty HsPat where\n"
"	prettyPrec _ (HsPVar name) = pretty name\n"
"	prettyPrec _ (HsPLit lit) = pretty lit\n"
"	prettyPrec _ (HsPNeg p) = myFsep [char '-', pretty p]\n"
"	prettyPrec p (HsPInfixApp a op b) = parensIf (p > 0) $\n"
"		myFsep [pretty a, pretty (HsQConOp op), pretty b]\n"
"	prettyPrec p (HsPApp n ps) = parensIf (p > 1) $\n"
"		myFsep (pretty n : map pretty ps)\n"
"	prettyPrec _ (HsPTuple ps) = parenList . map pretty $ ps\n"
"	prettyPrec _ (HsPList ps) =\n"
"		bracketList . punctuate comma . map pretty $ ps\n"
"	prettyPrec _ (HsPParen p) = parens . pretty $ p\n"
"	prettyPrec _ (HsPRec c fields) =\n"
"		pretty c <> (braceList . map pretty $ fields)\n"
"	-- special case that would otherwise be buggy\n"
"	prettyPrec _ (HsPAsPat name (HsPIrrPat pat)) =\n"
"		myFsep [pretty name <> char '@', char '~' <> pretty pat]\n"
"	prettyPrec _ (HsPAsPat name pat) =\n"
"		hcat [pretty name, char '@', pretty pat]\n"
"	prettyPrec _ HsPWildCard = char '_'\n"
"	prettyPrec _ (HsPIrrPat pat) = char '~' <> pretty pat\n"
"\n"
"instance Pretty HsPatField where\n"
"	pretty (HsPFieldPat name pat) =\n"
"		myFsep [pretty name, equals, pretty pat]\n"
"\n"
"------------------------- Case bodies  -------------------------\n"
"instance Pretty HsAlt where\n"
"	pretty (HsAlt _pos e gAlts decls) =\n"
"		pretty e <+> pretty gAlts $$$ ppWhere decls\n"
"\n"
"instance Pretty HsGuardedAlts where\n"
"	pretty (HsUnGuardedAlt e) = text \"->\" <+> pretty e\n"
"	pretty (HsGuardedAlts altList) = myVcat . map pretty $ altList\n"
"\n"
"instance Pretty HsGuardedAlt where\n"
"	pretty (HsGuardedAlt _pos e body) =\n"
"		myFsep [char '|', pretty e, text \"->\", pretty body]\n"
"\n"
"------------------------- Statements in monads & list comprehensions -----\n"
"instance Pretty HsStmt where\n"
"	pretty (HsGenerator _loc e from) =\n"
"		pretty e <+> text \"<-\" <+> pretty from\n"
"	pretty (HsQualifier e) = pretty e\n"
"	pretty (HsLetStmt declList) =\n"
"		text \"let\" $$$ ppBody letIndent (map pretty declList)\n"
"\n"
"------------------------- Record updates\n"
"instance Pretty HsFieldUpdate where\n"
"	pretty (HsFieldUpdate name e) =\n"
"		myFsep [pretty name, equals, pretty e]\n"
"\n"
"------------------------- Names -------------------------\n"
"instance Pretty HsQOp where\n"
"	pretty (HsQVarOp n) = ppHsQNameInfix n\n"
"	pretty (HsQConOp n) = ppHsQNameInfix n\n"
"\n"
"ppHsQNameInfix :: HsQName -> Doc\n"
"ppHsQNameInfix name\n"
"	| isSymbolName (getName name) = ppHsQName name\n"
"	| otherwise = char '`' <> ppHsQName name <> char '`'\n"
"\n"
"instance Pretty HsQName where\n"
"	pretty name = parensIf (isSymbolName (getName name)) (ppHsQName name)\n"
"\n"
"ppHsQName :: HsQName -> Doc\n"
"ppHsQName (UnQual name) = ppHsName name\n"
"ppHsQName (Qual m name) = pretty m <> char '.' <> ppHsName name\n"
"ppHsQName (Special sym) = text (specialName sym)\n"
"\n"
"instance Pretty HsOp where\n"
"	pretty (HsVarOp n) = ppHsNameInfix n\n"
"	pretty (HsConOp n) = ppHsNameInfix n\n"
"\n"
"ppHsNameInfix :: HsName -> Doc\n"
"ppHsNameInfix name\n"
"	| isSymbolName name = ppHsName name\n"
"	| otherwise = char '`' <> ppHsName name <> char '`'\n"
"\n"
"instance Pretty HsName where\n"
"	pretty name = parensIf (isSymbolName name) (ppHsName name)\n"
"\n"
"ppHsName :: HsName -> Doc\n"
"ppHsName (HsIdent s)  = text s\n"
"ppHsName (HsSymbol s) = text s\n"
"\n"
"instance Pretty HsCName where\n"
"	pretty (HsVarName n) = pretty n\n"
"	pretty (HsConName n) = pretty n\n"
"\n"
"isSymbolName :: HsName -> Bool\n"
"isSymbolName (HsSymbol _) = True\n"
"isSymbolName _ = False\n"
"\n"
"getName :: HsQName -> HsName\n"
"getName (UnQual s) = s\n"
"getName (Qual _ s) = s\n"
"getName (Special HsCons) = HsSymbol \":\"\n"
"getName (Special HsFunCon) = HsSymbol \"->\"\n"
"getName (Special s) = HsIdent (specialName s)\n"
"\n"
"specialName :: HsSpecialCon -> String\n"
"specialName HsUnitCon = \"()\"\n"
"specialName HsListCon = \"[]\"\n"
"specialName HsFunCon = \"->\"\n"
"specialName (HsTupleCon n) = \"(\" ++ replicate (n-1) ',' ++ \")\"\n"
"specialName HsCons = \":\"\n"
"\n"
"ppHsContext :: HsContext -> Doc\n"
"ppHsContext []      = empty\n"
"ppHsContext context = mySep [parenList (map ppHsAsst context), text \"=>\"]\n"
"\n"
"-- hacked for multi-parameter type classes\n"
"\n"
"ppHsAsst :: HsAsst -> Doc\n"
"ppHsAsst (a,ts) = myFsep (ppHsQName a : map ppHsTypeArg ts)\n"
"\n"
"------------------------- pp utils -------------------------\n"
"maybePP :: (a -> Doc) -> Maybe a -> Doc\n"
"maybePP _ Nothing = empty\n"
"maybePP pp (Just a) = pp a\n"
"\n"
"parenList :: [Doc] -> Doc\n"
"parenList = parens . myFsepSimple . punctuate comma\n"
"\n"
"braceList :: [Doc] -> Doc\n"
"braceList = braces . myFsepSimple . punctuate comma\n"
"\n"
"bracketList :: [Doc] -> Doc\n"
"bracketList = brackets . myFsepSimple\n"
"\n"
"-- Wrap in braces and semicolons, with an extra space at the start in\n"
"-- case the first doc begins with \"-\", which would be scanned as {-\n"
"flatBlock :: [Doc] -> Doc\n"
"flatBlock = braces . (space <>) . hsep . punctuate semi\n"
"\n"
"-- Same, but put each thing on a separate line\n"
"prettyBlock :: [Doc] -> Doc\n"
"prettyBlock = braces . (space <>) . vcat . punctuate semi\n"
"\n"
"-- Monadic PP Combinators -- these examine the env\n"
"\n"
"blankline :: Doc -> Doc\n"
"blankline dl = do{e<-getPPEnv;if spacing e && layout e /= PPNoLayout\n"
"			      then space $$ dl else dl}\n"
"topLevel :: Doc -> [Doc] -> Doc\n"
"topLevel header dl = do\n"
"	 e <- fmap layout getPPEnv\n"
"	 case e of\n"
"	     PPOffsideRule -> header $$ vcat dl\n"
"	     PPSemiColon -> header $$ prettyBlock dl\n"
"	     PPInLine -> header $$ prettyBlock dl\n"
"	     PPNoLayout -> header <+> flatBlock dl\n"
"\n"
"ppBody :: (PPHsMode -> Int) -> [Doc] -> Doc\n"
"ppBody f dl = do\n"
"	 e <- fmap layout getPPEnv\n"
"	 case e of PPOffsideRule -> indent\n"
"		   PPSemiColon   -> indentExplicit\n"
"		   _ -> flatBlock dl\n"
"		   where\n"
"		   indent  = do{i <-fmap f getPPEnv;nest i . vcat $ dl}\n"
"		   indentExplicit = do {i <- fmap f getPPEnv;\n"
"			   nest i . prettyBlock $ dl}\n"
"\n"
"($$$) :: Doc -> Doc -> Doc\n"
"a $$$ b = layoutChoice (a $$) (a <+>) b\n"
"\n"
"mySep :: [Doc] -> Doc\n"
"mySep = layoutChoice mySep' hsep\n"
"	where\n"
"	-- ensure paragraph fills with indentation.\n"
"	mySep' [x]    = x\n"
"	mySep' (x:xs) = x <+> fsep xs\n"
"	mySep' []     = error \"Internal error: mySep\"\n"
"\n"
"myVcat :: [Doc] -> Doc\n"
"myVcat = layoutChoice vcat hsep\n"
"\n"
"myFsepSimple :: [Doc] -> Doc\n"
"myFsepSimple = layoutChoice fsep hsep\n"
"\n"
"-- same, except that continuation lines are indented,\n"
"-- which is necessary to avoid triggering the offside rule.\n"
"myFsep :: [Doc] -> Doc\n"
"myFsep = layoutChoice fsep' hsep\n"
"	where	fsep' [] = empty\n"
"		fsep' (d:ds) = do\n"
"			e <- getPPEnv\n"
"			let n = onsideIndent e\n"
"			nest n (fsep (nest (-n) d:ds))\n"
"\n"
"layoutChoice :: (a -> Doc) -> (a -> Doc) -> a -> Doc\n"
"layoutChoice a b dl = do e <- getPPEnv\n"
"                         if layout e == PPOffsideRule ||\n"
"                            layout e == PPSemiColon\n"
"                          then a dl else b dl\n"
"\n"
"-- Prefix something with a LINE pragma, if requested.\n"
"-- GHC's LINE pragma actually sets the current line number to n-1, so\n"
"-- that the following line is line n.  But if there's no newline before\n"
"-- the line we're talking about, we need to compensate by adding 1.\n"
"\n"
"markLine :: SrcLoc -> Doc -> Doc\n"
"markLine loc doc = do\n"
"	e <- getPPEnv\n"
"	let y = srcLine loc\n"
"	let line l =\n"
"	      text (\"{-# LINE \" ++ show l ++ \" \\\"\" ++ srcFilename loc ++ \"\\\" #-}\")\n"
"	if linePragmas e then layoutChoice (line y $$) (line (y+1) <+>) doc\n"
"	      else doc\n";
const char *Language_Haskell_Lexer = "\n"
"-- #hide\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Language.Haskell.Lexer\n"
"-- Copyright   :  (c) The GHC Team, 1997-2000\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- Lexer for Haskell.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- ToDo: Introduce different tokens for decimal, octal and hexadecimal (?)\n"
"-- ToDo: FloatTok should have three parts (integer part, fraction, exponent) (?)\n"
"-- ToDo: Use a lexical analyser generator (lx?)\n"
"\n"
"module Language.Haskell.Lexer (Token(..), lexer) where\n"
"\n"
"import Language.Haskell.ParseMonad\n"
"\n"
"import Data.Char\n"
"import Data.Ratio\n"
"\n"
"data Token\n"
"        = VarId String\n"
"        | QVarId (String,String)\n"
"	| ConId String\n"
"        | QConId (String,String)\n"
"        | VarSym String\n"
"        | ConSym String\n"
"        | QVarSym (String,String)\n"
"        | QConSym (String,String)\n"
"	| IntTok Integer\n"
"	| FloatTok Rational\n"
"	| Character Char\n"
"        | StringTok String\n"
"\n"
"-- Symbols\n"
"\n"
"	| LeftParen\n"
"	| RightParen\n"
"	| SemiColon\n"
"        | LeftCurly\n"
"        | RightCurly\n"
"        | VRightCurly			-- a virtual close brace\n"
"        | LeftSquare\n"
"        | RightSquare\n"
"	| Comma\n"
"        | Underscore\n"
"        | BackQuote\n"
"\n"
"-- Reserved operators\n"
"\n"
"	| DotDot\n"
"	| Colon\n"
"	| DoubleColon\n"
"	| Equals\n"
"	| Backslash\n"
"	| Bar\n"
"	| LeftArrow\n"
"	| RightArrow\n"
"	| At\n"
"	| Tilde\n"
"	| DoubleArrow\n"
"	| Minus\n"
"	| Exclamation\n"
"\n"
"-- Reserved Ids\n"
"\n"
"	| KW_As\n"
"	| KW_Case\n"
"	| KW_Class\n"
"	| KW_Data\n"
"	| KW_Default\n"
"	| KW_Deriving\n"
"	| KW_Do\n"
"	| KW_Else\n"
"        | KW_Hiding\n"
"	| KW_If\n"
"	| KW_Import\n"
"	| KW_In\n"
"	| KW_Infix\n"
"	| KW_InfixL\n"
"	| KW_InfixR\n"
"	| KW_Instance\n"
"	| KW_Let\n"
"	| KW_Module\n"
"	| KW_NewType\n"
"	| KW_Of\n"
"	| KW_Then\n"
"	| KW_Type\n"
"	| KW_Where\n"
"	| KW_Qualified\n"
"\n"
"        | EOF\n"
"        deriving (Eq,Show)\n"
"\n"
"reserved_ops :: [(String,Token)]\n"
"reserved_ops = [\n"
" ( \"..\", DotDot ),\n"
" ( \":\",  Colon ),\n"
" ( \"::\", DoubleColon ),\n"
" ( \"=\",  Equals ),\n"
" ( \"\\\\\", Backslash ),\n"
" ( \"|\",  Bar ),\n"
" ( \"<-\", LeftArrow ),\n"
" ( \"->\", RightArrow ),\n"
" ( \"@\",  At ),\n"
" ( \"~\",  Tilde ),\n"
" ( \"=>\", DoubleArrow ),\n"
" ( \"-\",  Minus ),			--ToDo: shouldn't be here\n"
" ( \"!\",  Exclamation )		--ditto\n"
" ]\n"
"\n"
"reserved_ids :: [(String,Token)]\n"
"reserved_ids = [\n"
" ( \"_\",         Underscore ),\n"
" ( \"case\",      KW_Case ),\n"
" ( \"class\",     KW_Class ),\n"
" ( \"data\",      KW_Data ),\n"
" ( \"default\",   KW_Default ),\n"
" ( \"deriving\",  KW_Deriving ),\n"
" ( \"do\",        KW_Do ),\n"
" ( \"else\",      KW_Else ),\n"
" ( \"if\",    	KW_If ),\n"
" ( \"import\",    KW_Import ),\n"
" ( \"in\", 	KW_In ),\n"
" ( \"infix\", 	KW_Infix ),\n"
" ( \"infixl\", 	KW_InfixL ),\n"
" ( \"infixr\", 	KW_InfixR ),\n"
" ( \"instance\",  KW_Instance ),\n"
" ( \"let\", 	KW_Let ),\n"
" ( \"module\", 	KW_Module ),\n"
" ( \"newtype\",   KW_NewType ),\n"
" ( \"of\", 	KW_Of ),\n"
" ( \"then\", 	KW_Then ),\n"
" ( \"type\", 	KW_Type ),\n"
" ( \"where\", 	KW_Where ),\n"
" ( \"as\", 	KW_As ),\n"
" ( \"qualified\", KW_Qualified ),\n"
" ( \"hiding\", 	KW_Hiding )\n"
" ]\n"
"\n"
"isIdent, isSymbol :: Char -> Bool\n"
"isIdent  c = isAlpha c || isDigit c || c == '\\'' || c == '_'\n"
"isSymbol c = elem c \":!#$%&*+./<=>?@\\\\^|-~\"\n"
"\n"
"matchChar :: Char -> String -> Lex a ()\n"
"matchChar c msg = do\n"
"	s <- getInput\n"
"	if null s || head s /= c then fail msg else discard 1\n"
"\n"
"-- The top-level lexer.\n"
"-- We need to know whether we are at the beginning of the line to decide\n"
"-- whether to insert layout tokens.\n"
"\n"
"lexer :: (Token -> P a) -> P a\n"
"lexer = runL $ do\n"
"	bol <- checkBOL\n"
"	bol <- lexWhiteSpace bol\n"
"	startToken\n"
"	if bol then lexBOL else lexToken\n"
"\n"
"lexWhiteSpace :: Bool -> Lex a Bool\n"
"lexWhiteSpace bol = do\n"
"	s <- getInput\n"
"	case s of\n"
"	    '{':'-':_ -> do\n"
"		discard 2\n"
"		bol <- lexNestedComment bol\n"
"		lexWhiteSpace bol\n"
"	    '-':'-':rest | all (== '-') (takeWhile isSymbol rest) -> do\n"
"		lexWhile (== '-')\n"
"		lexWhile (/= '\\n')\n"
"		s' <- getInput\n"
"		case s' of\n"
"		    [] -> fail \"Unterminated end-of-line comment\"\n"
"		    _ -> do\n"
"			lexNewline\n"
"			lexWhiteSpace True\n"
"	    '\\n':_ -> do\n"
"		lexNewline\n"
"		lexWhiteSpace True\n"
"	    '\\t':_ -> do\n"
"		lexTab\n"
"		lexWhiteSpace bol\n"
"	    c:_ | isSpace c -> do\n"
"		discard 1\n"
"		lexWhiteSpace bol\n"
"	    _ -> return bol\n"
"\n"
"lexNestedComment :: Bool -> Lex a Bool\n"
"lexNestedComment bol = do\n"
"	s <- getInput\n"
"	case s of\n"
"	    '-':'}':_ -> discard 2 >> return bol\n"
"	    '{':'-':_ -> do\n"
"		discard 2\n"
"		bol <- lexNestedComment bol	-- rest of the subcomment\n"
"		lexNestedComment bol		-- rest of this comment\n"
"	    '\\t':_    -> lexTab >> lexNestedComment bol\n"
"	    '\\n':_    -> lexNewline >> lexNestedComment True\n"
"	    _:_       -> discard 1 >> lexNestedComment bol\n"
"	    []        -> fail \"Unterminated nested comment\"\n"
"\n"
"-- When we are lexing the first token of a line, check whether we need to\n"
"-- insert virtual semicolons or close braces due to layout.\n"
"\n"
"lexBOL :: Lex a Token\n"
"lexBOL = do\n"
"	pos <- getOffside\n"
"	case pos of\n"
"	    LT -> do\n"
"                -- trace \"layout: inserting '}'\\n\" $\n"
"        	-- Set col to 0, indicating that we're still at the\n"
"        	-- beginning of the line, in case we need a semi-colon too.\n"
"        	-- Also pop the context here, so that we don't insert\n"
"        	-- another close brace before the parser can pop it.\n"
"		setBOL\n"
"		popContextL \"lexBOL\"\n"
"		return VRightCurly\n"
"	    EQ ->\n"
"                -- trace \"layout: inserting ';'\\n\" $\n"
"		return SemiColon\n"
"	    GT ->\n"
"		lexToken\n"
"\n"
"lexToken :: Lex a Token\n"
"lexToken = do\n"
"    s <- getInput\n"
"    case s of\n"
"        [] -> return EOF\n"
"\n"
"	'0':c:d:_ | toLower c == 'o' && isOctDigit d -> do\n"
"			discard 2\n"
"			n <- lexOctal\n"
"			return (IntTok n)\n"
"		  | toLower c == 'x' && isHexDigit d -> do\n"
"			discard 2\n"
"			n <- lexHexadecimal\n"
"			return (IntTok n)\n"
"\n"
"	c:_ | isDigit c -> lexDecimalOrFloat\n"
"\n"
"	    | isUpper c -> lexConIdOrQual \"\"\n"
"\n"
"	    | isLower c || c == '_' -> do\n"
"		ident <- lexWhile isIdent\n"
"		return $ case lookup ident reserved_ids of\n"
"			Just keyword -> keyword\n"
"			Nothing -> VarId ident\n"
"\n"
"	    | isSymbol c -> do\n"
"		sym <- lexWhile isSymbol\n"
"		return $ case lookup sym reserved_ops of\n"
"			Just t  -> t\n"
"			Nothing -> case c of\n"
"			    ':' -> ConSym sym\n"
"			    _   -> VarSym sym\n"
"\n"
"	    | otherwise -> do\n"
"		discard 1\n"
"		case c of\n"
"\n"
"		    -- First the special symbols\n"
"		    '(' ->  return LeftParen\n"
"		    ')' ->  return RightParen\n"
"		    ',' ->  return Comma\n"
"		    ';' ->  return SemiColon\n"
"		    '[' ->  return LeftSquare\n"
"		    ']' ->  return RightSquare\n"
"		    '`' ->  return BackQuote\n"
"		    '{' -> do\n"
"			    pushContextL NoLayout\n"
"			    return LeftCurly\n"
"		    '}' -> do\n"
"			    popContextL \"lexToken\"\n"
"			    return RightCurly\n"
"\n"
"		    '\\'' -> do\n"
"			    c2 <- lexChar\n"
"			    matchChar '\\'' \"Improperly terminated character constant\"\n"
"			    return (Character c2)\n"
"\n"
"		    '\"' ->  lexString\n"
"\n"
"		    _ ->    fail (\"Illegal character \\'\" ++ show c ++ \"\\'\\n\")\n"
"\n"
"lexDecimalOrFloat :: Lex a Token\n"
"lexDecimalOrFloat = do\n"
"	ds <- lexWhile isDigit\n"
"	rest <- getInput\n"
"	case rest of\n"
"	    ('.':d:_) | isDigit d -> do\n"
"		discard 1\n"
"		frac <- lexWhile isDigit\n"
"		let num = parseInteger 10 (ds ++ frac)\n"
"		    decimals = toInteger (length frac)\n"
"		exponent <- do\n"
"			rest2 <- getInput\n"
"			case rest2 of\n"
"			    'e':_ -> lexExponent\n"
"			    'E':_ -> lexExponent\n"
"			    _     -> return 0\n"
"		return (FloatTok ((num%1) * 10^^(exponent - decimals)))\n"
"	    e:_ | toLower e == 'e' -> do\n"
"		exponent <- lexExponent\n"
"		return (FloatTok ((parseInteger 10 ds%1) * 10^^exponent))\n"
"	    _ -> return (IntTok (parseInteger 10 ds))\n"
"\n"
"    where\n"
"	lexExponent :: Lex a Integer\n"
"	lexExponent = do\n"
"		discard 1	-- 'e' or 'E'\n"
"		r <- getInput\n"
"		case r of\n"
"		    '+':d:_ | isDigit d -> do\n"
"			discard 1\n"
"			lexDecimal\n"
"		    '-':d:_ | isDigit d -> do\n"
"			discard 1\n"
"			n <- lexDecimal\n"
"			return (negate n)\n"
"		    d:_ | isDigit d -> lexDecimal\n"
"		    _ -> fail \"Float with missing exponent\"\n"
"\n"
"lexConIdOrQual :: String -> Lex a Token\n"
"lexConIdOrQual qual = do\n"
"	con <- lexWhile isIdent\n"
"	let conid | null qual = ConId con\n"
"		  | otherwise = QConId (qual,con)\n"
"	    qual' | null qual = con\n"
"		  | otherwise = qual ++ '.':con\n"
"	just_a_conid <- alternative (return conid)\n"
"	rest <- getInput\n"
"	case rest of\n"
"	  '.':c:_\n"
"	     | isLower c || c == '_' -> do	-- qualified varid?\n"
"		discard 1\n"
"		ident <- lexWhile isIdent\n"
"		case lookup ident reserved_ids of\n"
"		   -- cannot qualify a reserved word\n"
"		   Just _  -> just_a_conid\n"
"		   Nothing -> return (QVarId (qual', ident))\n"
"\n"
"	     | isUpper c -> do		-- qualified conid?\n"
"		discard 1\n"
"		lexConIdOrQual qual'\n"
"\n"
"	     | isSymbol c -> do	-- qualified symbol?\n"
"		discard 1\n"
"		sym <- lexWhile isSymbol\n"
"		case lookup sym reserved_ops of\n"
"		    -- cannot qualify a reserved operator\n"
"		    Just _  -> just_a_conid\n"
"		    Nothing -> return $ case c of\n"
"			':' -> QConSym (qual', sym)\n"
"			_   -> QVarSym (qual', sym)\n"
"\n"
"	  _ ->	return conid -- not a qualified thing\n"
"\n"
"lexChar :: Lex a Char\n"
"lexChar = do\n"
"	r <- getInput\n"
"	case r of\n"
"		'\\\\':_	-> lexEscape\n"
"		c:_	-> discard 1 >> return c\n"
"		[]	-> fail \"Incomplete character constant\"\n"
"\n"
"lexString :: Lex a Token\n"
"lexString = loop \"\"\n"
"    where\n"
"	loop s = do\n"
"		r <- getInput\n"
"		case r of\n"
"		    '\\\\':'&':_ -> do\n"
"				discard 2\n"
"				loop s\n"
"		    '\\\\':c:_ | isSpace c -> do\n"
"				discard 1\n"
"				lexWhiteChars\n"
"				matchChar '\\\\' \"Illegal character in string gap\"\n"
"				loop s\n"
"			     | otherwise -> do\n"
"				ce <- lexEscape\n"
"				loop (ce:s)\n"
"		    '\"':_ -> do\n"
"				discard 1\n"
"				return (StringTok (reverse s))\n"
"		    c:_ -> do\n"
"				discard 1\n"
"				loop (c:s)\n"
"		    [] ->	fail \"Improperly terminated string\"\n"
"\n"
"	lexWhiteChars :: Lex a ()\n"
"	lexWhiteChars = do\n"
"		s <- getInput\n"
"		case s of\n"
"		    '\\n':_ -> do\n"
"			lexNewline\n"
"			lexWhiteChars\n"
"		    '\\t':_ -> do\n"
"			lexTab\n"
"			lexWhiteChars\n"
"		    c:_ | isSpace c -> do\n"
"			discard 1\n"
"			lexWhiteChars\n"
"		    _ -> return ()\n"
"\n"
"lexEscape :: Lex a Char\n"
"lexEscape = do\n"
"	discard 1\n"
"	r <- getInput\n"
"	case r of\n"
"\n"
"-- Production charesc from section B.2 (Note: \\& is handled by caller)\n"
"\n"
"		'a':_		-> discard 1 >> return '\\a'\n"
"		'b':_		-> discard 1 >> return '\\b'\n"
"		'f':_		-> discard 1 >> return '\\f'\n"
"		'n':_		-> discard 1 >> return '\\n'\n"
"		'r':_		-> discard 1 >> return '\\r'\n"
"		't':_		-> discard 1 >> return '\\t'\n"
"		'v':_		-> discard 1 >> return '\\v'\n"
"		'\\\\':_		-> discard 1 >> return '\\\\'\n"
"		'\"':_		-> discard 1 >> return '\\\"'\n"
"		'\\'':_		-> discard 1 >> return '\\''\n"
"\n"
"-- Production ascii from section B.2\n"
"\n"
"		'^':c:_		-> discard 2 >> cntrl c\n"
"		'N':'U':'L':_	-> discard 3 >> return '\\NUL'\n"
"		'S':'O':'H':_	-> discard 3 >> return '\\SOH'\n"
"		'S':'T':'X':_	-> discard 3 >> return '\\STX'\n"
"		'E':'T':'X':_	-> discard 3 >> return '\\ETX'\n"
"		'E':'O':'T':_	-> discard 3 >> return '\\EOT'\n"
"		'E':'N':'Q':_	-> discard 3 >> return '\\ENQ'\n"
"		'A':'C':'K':_	-> discard 3 >> return '\\ACK'\n"
"		'B':'E':'L':_	-> discard 3 >> return '\\BEL'\n"
"		'B':'S':_	-> discard 2 >> return '\\BS'\n"
"		'H':'T':_	-> discard 2 >> return '\\HT'\n"
"		'L':'F':_	-> discard 2 >> return '\\LF'\n"
"		'V':'T':_	-> discard 2 >> return '\\VT'\n"
"		'F':'F':_	-> discard 2 >> return '\\FF'\n"
"		'C':'R':_	-> discard 2 >> return '\\CR'\n"
"		'S':'O':_	-> discard 2 >> return '\\SO'\n"
"		'S':'I':_	-> discard 2 >> return '\\SI'\n"
"		'D':'L':'E':_	-> discard 3 >> return '\\DLE'\n"
"		'D':'C':'1':_	-> discard 3 >> return '\\DC1'\n"
"		'D':'C':'2':_	-> discard 3 >> return '\\DC2'\n"
"		'D':'C':'3':_	-> discard 3 >> return '\\DC3'\n"
"		'D':'C':'4':_	-> discard 3 >> return '\\DC4'\n"
"		'N':'A':'K':_	-> discard 3 >> return '\\NAK'\n"
"		'S':'Y':'N':_	-> discard 3 >> return '\\SYN'\n"
"		'E':'T':'B':_	-> discard 3 >> return '\\ETB'\n"
"		'C':'A':'N':_	-> discard 3 >> return '\\CAN'\n"
"		'E':'M':_	-> discard 2 >> return '\\EM'\n"
"		'S':'U':'B':_	-> discard 3 >> return '\\SUB'\n"
"		'E':'S':'C':_	-> discard 3 >> return '\\ESC'\n"
"		'F':'S':_	-> discard 2 >> return '\\FS'\n"
"		'G':'S':_	-> discard 2 >> return '\\GS'\n"
"		'R':'S':_	-> discard 2 >> return '\\RS'\n"
"		'U':'S':_	-> discard 2 >> return '\\US'\n"
"		'S':'P':_	-> discard 2 >> return '\\SP'\n"
"		'D':'E':'L':_	-> discard 3 >> return '\\DEL'\n"
"\n"
"-- Escaped numbers\n"
"\n"
"		'o':c:_ | isOctDigit c -> do\n"
"					discard 1\n"
"					n <- lexOctal\n"
"					checkChar n\n"
"		'x':c:_ | isHexDigit c -> do\n"
"					discard 1\n"
"					n <- lexHexadecimal\n"
"					checkChar n\n"
"		c:_ | isDigit c -> do\n"
"					n <- lexDecimal\n"
"					checkChar n\n"
"\n"
"		_		-> fail \"Illegal escape sequence\"\n"
"\n"
"    where\n"
"	checkChar n | n <= 0x01FFFF = return (chr (fromInteger n))\n"
"	checkChar _		    = fail \"Character constant out of range\"\n"
"\n"
"-- Production cntrl from section B.2\n"
"\n"
"	cntrl :: Char -> Lex a Char\n"
"	cntrl c | c >= '@' && c <= '_' = return (chr (ord c - ord '@'))\n"
"	cntrl _                        = fail \"Illegal control character\"\n"
"\n"
"-- assumes at least one octal digit\n"
"lexOctal :: Lex a Integer\n"
"lexOctal = do\n"
"	ds <- lexWhile isOctDigit\n"
"	return (parseInteger 8 ds)\n"
"\n"
"-- assumes at least one hexadecimal digit\n"
"lexHexadecimal :: Lex a Integer\n"
"lexHexadecimal = do\n"
"	ds <- lexWhile isHexDigit\n"
"	return (parseInteger 16 ds)\n"
"\n"
"-- assumes at least one decimal digit\n"
"lexDecimal :: Lex a Integer\n"
"lexDecimal = do\n"
"	ds <- lexWhile isDigit\n"
"	return (parseInteger 10 ds)\n"
"\n"
"-- Stolen from Hugs's Prelude\n"
"parseInteger :: Integer -> String -> Integer\n"
"parseInteger radix ds =\n"
"	foldl1 (\\n d -> n * radix + d) (map (toInteger . digitToInt) ds)\n";
const char *Language_Haskell_ParseMonad = "\n"
"-- #hide\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Language.Haskell.ParseMonad\n"
"-- Copyright   :  (c) The GHC Team, 1997-2000\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- Monads for the Haskell parser and lexer.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Language.Haskell.ParseMonad(\n"
"		-- * Parsing\n"
"		P, ParseResult(..), atSrcLoc, LexContext(..),\n"
"		ParseMode(..), defaultParseMode,\n"
"		runParserWithMode, runParser,\n"
"		getSrcLoc, pushCurrentContext, popContext,\n"
"		-- * Lexing\n"
"		Lex, runL, getInput, discard, lexNewline, lexTab, lexWhile,\n"
"		alternative, checkBOL, setBOL, startToken, getOffside,\n"
"		pushContextL, popContextL\n"
"	) where\n"
"\n"
"import Language.Haskell.Syntax(SrcLoc(..))\n"
"\n"
"-- | The result of a parse.\n"
"data ParseResult a\n"
"	= ParseOk a		-- ^ The parse succeeded, yielding a value.\n"
"	| ParseFailed SrcLoc String\n"
"				-- ^ The parse failed at the specified\n"
"				-- source location, with an error message.\n"
"	deriving Show\n"
"\n"
"-- internal version\n"
"data ParseStatus a = Ok ParseState a | Failed SrcLoc String\n"
"	deriving Show\n"
"\n"
"data LexContext = NoLayout | Layout Int\n"
"	deriving (Eq,Ord,Show)\n"
"\n"
"type ParseState = [LexContext]\n"
"\n"
"indentOfParseState :: ParseState -> Int\n"
"indentOfParseState (Layout n:_) = n\n"
"indentOfParseState _            = 0\n"
"\n"
"-- | Static parameters governing a parse.\n"
"-- More to come later, e.g. literate mode, language extensions.\n"
"\n"
"data ParseMode = ParseMode {\n"
"				-- | original name of the file being parsed\n"
"		parseFilename :: String\n"
"		}\n"
"\n"
"-- | Default parameters for a parse,\n"
"-- currently just a marker for an unknown filename.\n"
"\n"
"defaultParseMode :: ParseMode\n"
"defaultParseMode = ParseMode {\n"
"		parseFilename = \"<unknown>\"\n"
"		}\n"
"\n"
"-- | Monad for parsing\n"
"\n"
"newtype P a = P { runP ::\n"
"		        String		-- input string\n"
"		     -> Int		-- current column\n"
"		     -> Int		-- current line\n"
"		     -> SrcLoc		-- location of last token read\n"
"		     -> ParseState	-- layout info.\n"
"		     -> ParseMode	-- parse parameters\n"
"		     -> ParseStatus a\n"
"		}\n"
"\n"
"runParserWithMode :: ParseMode -> P a -> String -> ParseResult a\n"
"runParserWithMode mode (P m) s = case m s 0 1 start [] mode of\n"
"	Ok _ a -> ParseOk a\n"
"	Failed loc msg -> ParseFailed loc msg\n"
"    where start = SrcLoc {\n"
"		srcFilename = parseFilename mode,\n"
"		srcLine = 1,\n"
"		srcColumn = 1\n"
"	}\n"
"\n"
"runParser :: P a -> String -> ParseResult a\n"
"runParser = runParserWithMode defaultParseMode\n"
"\n"
"instance Monad P where\n"
"	return a = P $ \\_i _x _y _l s _m -> Ok s a\n"
"	P m >>= k = P $ \\i x y l s mode ->\n"
"		case m i x y l s mode of\n"
"		    Failed loc msg -> Failed loc msg\n"
"		    Ok s' a -> runP (k a) i x y l s' mode\n"
"	fail s = P $ \\_r _col _line loc _stk _m -> Failed loc s\n"
"\n"
"atSrcLoc :: P a -> SrcLoc -> P a\n"
"P m `atSrcLoc` loc = P $ \\i x y _l -> m i x y loc\n"
"\n"
"getSrcLoc :: P SrcLoc\n"
"getSrcLoc = P $ \\_i _x _y l s _m -> Ok s l\n"
"\n"
"-- Enter a new layout context.  If we are already in a layout context,\n"
"-- ensure that the new indent is greater than the indent of that context.\n"
"-- (So if the source loc is not to the right of the current indent, an\n"
"-- empty list {} will be inserted.)\n"
"\n"
"pushCurrentContext :: P ()\n"
"pushCurrentContext = do\n"
"	loc <- getSrcLoc\n"
"	indent <- currentIndent\n"
"	pushContext (Layout (max (indent+1) (srcColumn loc)))\n"
"\n"
"currentIndent :: P Int\n"
"currentIndent = P $ \\_r _x _y loc stk _mode -> Ok stk (indentOfParseState stk)\n"
"\n"
"pushContext :: LexContext -> P ()\n"
"pushContext ctxt =\n"
"--trace (\"pushing lexical scope: \" ++ show ctxt ++\"\\n\") $\n"
"	P $ \\_i _x _y _l s _m -> Ok (ctxt:s) ()\n"
"\n"
"popContext :: P ()\n"
"popContext = P $ \\_i _x _y _l stk _m ->\n"
"      case stk of\n"
"   	(_:s) -> --trace (\"popping lexical scope, context now \"++show s ++ \"\\n\") $\n"
"            Ok s ()\n"
"        []    -> error \"Internal error: empty context in popContext\"\n"
"\n"
"-- Monad for lexical analysis:\n"
"-- a continuation-passing version of the parsing monad\n"
"\n"
"newtype Lex r a = Lex { runL :: (a -> P r) -> P r }\n"
"\n"
"instance Monad (Lex r) where\n"
"	return a = Lex $ \\k -> k a\n"
"	Lex v >>= f = Lex $ \\k -> v (\\a -> runL (f a) k)\n"
"	Lex v >> Lex w = Lex $ \\k -> v (\\_ -> w k)\n"
"	fail s = Lex $ \\_ -> fail s\n"
"\n"
"-- Operations on this monad\n"
"\n"
"getInput :: Lex r String\n"
"getInput = Lex $ \\cont -> P $ \\r -> runP (cont r) r\n"
"\n"
"-- | Discard some input characters (these must not include tabs or newlines).\n"
"\n"
"discard :: Int -> Lex r ()\n"
"discard n = Lex $ \\cont -> P $ \\r x -> runP (cont ()) (drop n r) (x+n)\n"
"\n"
"-- | Discard the next character, which must be a newline.\n"
"\n"
"lexNewline :: Lex a ()\n"
"lexNewline = Lex $ \\cont -> P $ \\(_:r) _x y -> runP (cont ()) r 1 (y+1)\n"
"\n"
"-- | Discard the next character, which must be a tab.\n"
"\n"
"lexTab :: Lex a ()\n"
"lexTab = Lex $ \\cont -> P $ \\(_:r) x -> runP (cont ()) r (nextTab x)\n"
"\n"
"nextTab :: Int -> Int\n"
"nextTab x = x + (tAB_LENGTH - (x-1) `mod` tAB_LENGTH)\n"
"\n"
"tAB_LENGTH :: Int\n"
"tAB_LENGTH = 8\n"
"\n"
"-- Consume and return the largest string of characters satisfying p\n"
"\n"
"lexWhile :: (Char -> Bool) -> Lex a String\n"
"lexWhile p = Lex $ \\cont -> P $ \\r x ->\n"
"	let (cs,rest) = span p r in\n"
"	runP (cont cs) rest (x + length cs)\n"
"\n"
"-- An alternative scan, to which we can return if subsequent scanning\n"
"-- is unsuccessful.\n"
"\n"
"alternative :: Lex a v -> Lex a (Lex a v)\n"
"alternative (Lex v) = Lex $ \\cont -> P $ \\r x y ->\n"
"	runP (cont (Lex $ \\cont' -> P $ \\_r _x _y ->\n"
"		runP (v cont') r x y)) r x y\n"
"\n"
"-- The source location is the coordinates of the previous token,\n"
"-- or, while scanning a token, the start of the current token.\n"
"\n"
"-- col is the current column in the source file.\n"
"-- We also need to remember between scanning tokens whether we are\n"
"-- somewhere at the beginning of the line before the first token.\n"
"-- This could be done with an extra Bool argument to the P monad,\n"
"-- but as a hack we use a col value of 0 to indicate this situation.\n"
"\n"
"-- Setting col to 0 is used in two places: just after emitting a virtual\n"
"-- close brace due to layout, so that next time through we check whether\n"
"-- we also need to emit a semi-colon, and at the beginning of the file,\n"
"-- by runParser, to kick off the lexer.\n"
"-- Thus when col is zero, the true column can be taken from the loc.\n"
"\n"
"checkBOL :: Lex a Bool\n"
"checkBOL = Lex $ \\cont -> P $ \\r x y loc ->\n"
"		if x == 0 then runP (cont True) r (srcColumn loc) y loc\n"
"			else runP (cont False) r x y loc\n"
"\n"
"setBOL :: Lex a ()\n"
"setBOL = Lex $ \\cont -> P $ \\r _ -> runP (cont ()) r 0\n"
"\n"
"-- Set the loc to the current position\n"
"\n"
"startToken :: Lex a ()\n"
"startToken = Lex $ \\cont -> P $ \\s x y _ stk mode ->\n"
"	let loc = SrcLoc {\n"
"		srcFilename = parseFilename mode,\n"
"		srcLine = y,\n"
"		srcColumn = x\n"
"	} in\n"
"	runP (cont ()) s x y loc stk mode\n"
"\n"
"-- Current status with respect to the offside (layout) rule:\n"
"-- LT: we are to the left of the current indent (if any)\n"
"-- EQ: we are at the current indent (if any)\n"
"-- GT: we are to the right of the current indent, or not subject to layout\n"
"\n"
"getOffside :: Lex a Ordering\n"
"getOffside = Lex $ \\cont -> P $ \\r x y loc stk ->\n"
"		runP (cont (compare x (indentOfParseState stk))) r x y loc stk\n"
"\n"
"pushContextL :: LexContext -> Lex a ()\n"
"pushContextL ctxt = Lex $ \\cont -> P $ \\r x y loc stk ->\n"
"		runP (cont ()) r x y loc (ctxt:stk)\n"
"\n"
"popContextL :: String -> Lex a ()\n"
"popContextL fn = Lex $ \\cont -> P $ \\r x y loc stk -> case stk of\n"
"		(_:ctxt) -> runP (cont ()) r x y loc ctxt\n"
"		[]       -> error (\"Internal error: empty context in \" ++ fn)\n";
const char *Network_Socket = ;
const char *Network_BSD = "{-# LINE 1 \"BSD.hsc\" #-}\n"
"{-# LINE 2 \"BSD.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Network.BSD\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/net/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- The \"Network.BSD\" module defines Haskell bindings to functionality\n"
"-- provided by BSD Unix derivatives. Currently this covers\n"
"-- network programming functionality and symbolic links.\n"
"-- (OK, so the latter is pretty much supported by most Unixes\n"
"-- today, but it was BSD that introduced them.)  \n"
"--\n"
"-- The symlink stuff is really in the wrong place, at some point it will move\n"
"-- to a generic Unix library somewhere else in the module tree.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"\n"
"{-# LINE 24 \"BSD.hsc\" #-}\n"
"\n"
"module Network.BSD (\n"
"       \n"
"    -- * Host names\n"
"    HostName,\n"
"    getHostName,	    -- :: IO HostName\n"
"\n"
"    HostEntry(..),\n"
"    getHostByName,	    -- :: HostName -> IO HostEntry\n"
"    getHostByAddr,	    -- :: HostAddress -> Family -> IO HostEntry\n"
"    hostAddress,	    -- :: HostEntry -> HostAddress\n"
"\n"
"\n"
"{-# LINE 37 \"BSD.hsc\" #-}\n"
"    setHostEntry,	    -- :: Bool -> IO ()\n"
"    getHostEntry,	    -- :: IO HostEntry\n"
"    endHostEntry,	    -- :: IO ()\n"
"    getHostEntries,	    -- :: Bool -> IO [HostEntry]\n"
"\n"
"{-# LINE 42 \"BSD.hsc\" #-}\n"
"\n"
"    -- * Service names\n"
"    ServiceEntry(..),\n"
"    ServiceName,\n"
"    getServiceByName,	    -- :: ServiceName -> ProtocolName -> IO ServiceEntry\n"
"    getServiceByPort,       -- :: PortNumber  -> ProtocolName -> IO ServiceEntry\n"
"    getServicePortNumber,   -- :: ServiceName -> IO PortNumber\n"
"\n"
"\n"
"{-# LINE 51 \"BSD.hsc\" #-}\n"
"    getServiceEntry,	    -- :: IO ServiceEntry\n"
"    setServiceEntry,	    -- :: Bool -> IO ()\n"
"    endServiceEntry,	    -- :: IO ()\n"
"    getServiceEntries,	    -- :: Bool -> IO [ServiceEntry]\n"
"\n"
"{-# LINE 56 \"BSD.hsc\" #-}\n"
"\n"
"    -- * Protocol names\n"
"    ProtocolName,\n"
"    ProtocolNumber,\n"
"    ProtocolEntry(..),\n"
"    getProtocolByName,	    -- :: ProtocolName   -> IO ProtocolEntry\n"
"    getProtocolByNumber,    -- :: ProtocolNumber -> IO ProtcolEntry\n"
"    getProtocolNumber,	    -- :: ProtocolName   -> ProtocolNumber\n"
"\n"
"\n"
"{-# LINE 66 \"BSD.hsc\" #-}\n"
"    setProtocolEntry,	    -- :: Bool -> IO ()\n"
"    getProtocolEntry,	    -- :: IO ProtocolEntry\n"
"    endProtocolEntry,	    -- :: IO ()\n"
"    getProtocolEntries,	    -- :: Bool -> IO [ProtocolEntry]\n"
"\n"
"{-# LINE 71 \"BSD.hsc\" #-}\n"
"\n"
"    -- * Port numbers\n"
"    PortNumber,\n"
"\n"
"    -- * Network names\n"
"    NetworkName,\n"
"    NetworkAddr,\n"
"    NetworkEntry(..)\n"
"\n"
"\n"
"{-# LINE 81 \"BSD.hsc\" #-}\n"
"    , getNetworkByName	    -- :: NetworkName -> IO NetworkEntry\n"
"    , getNetworkByAddr      -- :: NetworkAddr -> Family -> IO NetworkEntry\n"
"    , setNetworkEntry	    -- :: Bool -> IO ()\n"
"    , getNetworkEntry	    -- :: IO NetworkEntry\n"
"    , endNetworkEntry	    -- :: IO ()\n"
"    , getNetworkEntries     -- :: Bool -> IO [NetworkEntry]\n"
"\n"
"{-# LINE 88 \"BSD.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 93 \"BSD.hsc\" #-}\n"
"\n"
"{-# LINE 96 \"BSD.hsc\" #-}\n"
"\n"
"    ) where\n"
"\n"
"\n"
"{-# LINE 100 \"BSD.hsc\" #-}\n"
"import Hugs.Prelude\n"
"\n"
"{-# LINE 102 \"BSD.hsc\" #-}\n"
"import Network.Socket\n"
"\n"
"import Foreign.C.Error ( throwErrnoIfMinus1, throwErrnoIfMinus1_ )\n"
"import Foreign.C.String ( CString, peekCString, peekCStringLen, withCString )\n"
"import Foreign.C.Types ( CInt, CULong, CChar, CSize, CShort )\n"
"import Foreign.Ptr ( Ptr, nullPtr )\n"
"import Foreign.Storable ( Storable(..) )\n"
"import Foreign.Marshal.Array ( allocaArray0, peekArray0 )\n"
"import Foreign.Marshal.Utils ( with, fromBool )\n"
"\n"
"\n"
"{-# LINE 115 \"BSD.hsc\" #-}\n"
"\n"
"import Control.Monad ( liftM )\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Basic Types\n"
"\n"
"type HostName     = String\n"
"type ProtocolName = String\n"
"type ServiceName  = String\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Service Database Access\n"
"\n"
"-- Calling getServiceByName for a given service and protocol returns\n"
"-- the systems service entry.  This should be used to find the port\n"
"-- numbers for standard protocols such as SMTP and FTP.  The remaining\n"
"-- three functions should be used for browsing the service database\n"
"-- sequentially.\n"
"\n"
"-- Calling setServiceEntry with True indicates that the service\n"
"-- database should be left open between calls to getServiceEntry.  To\n"
"-- close the database a call to endServiceEntry is required.  This\n"
"-- database file is usually stored in the file /etc/services.\n"
"\n"
"data ServiceEntry  = \n"
"  ServiceEntry  {\n"
"     serviceName     :: ServiceName,	-- Official Name\n"
"     serviceAliases  :: [ServiceName],	-- aliases\n"
"     servicePort     :: PortNumber,	-- Port Number  ( network byte order )\n"
"     serviceProtocol :: ProtocolName	-- Protocol\n"
"  } deriving (Show)\n"
"\n"
"instance Storable ServiceEntry where\n"
"   sizeOf    _ = 32\n"
"{-# LINE 149 \"BSD.hsc\" #-}\n"
"   alignment _ = alignment (undefined :: CInt) -- ???\n"
"\n"
"   peek p = do\n"
"	s_name    <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0)) p >>= peekCString\n"
"{-# LINE 153 \"BSD.hsc\" #-}\n"
"	s_aliases <- ((\\hsc_ptr -> peekByteOff hsc_ptr 8)) p\n"
"{-# LINE 154 \"BSD.hsc\" #-}\n"
"			   >>= peekArray0 nullPtr\n"
"			   >>= mapM peekCString\n"
"	s_port    <- ((\\hsc_ptr -> peekByteOff hsc_ptr 16)) p\n"
"{-# LINE 157 \"BSD.hsc\" #-}\n"
"	s_proto   <- ((\\hsc_ptr -> peekByteOff hsc_ptr 24)) p >>= peekCString\n"
"{-# LINE 158 \"BSD.hsc\" #-}\n"
"	return (ServiceEntry {\n"
"			serviceName     = s_name,\n"
"			serviceAliases  = s_aliases,\n"
"\n"
"{-# LINE 164 \"BSD.hsc\" #-}\n"
"			   -- s_port is already in network byte order, but it\n"
"			   -- might be the wrong size.\n"
"			servicePort     = PortNum (fromIntegral (s_port :: CInt)),\n"
"\n"
"{-# LINE 168 \"BSD.hsc\" #-}\n"
"			serviceProtocol = s_proto\n"
"		})\n"
"\n"
"   poke p = error \"Storable.poke(BSD.ServiceEntry) not implemented\"\n"
"\n"
"\n"
"getServiceByName :: ServiceName 	-- Service Name\n"
"		 -> ProtocolName 	-- Protocol Name\n"
"		 -> IO ServiceEntry	-- Service Entry\n"
"getServiceByName name proto = do\n"
" withCString name  $ \\ cstr_name  -> do\n"
" withCString proto $ \\ cstr_proto -> do\n"
" throwNoSuchThingIfNull \"getServiceByName\" \"no such service entry\"\n"
"   $ (trySysCall (c_getservbyname cstr_name cstr_proto))\n"
" >>= peek\n"
"\n"
"foreign import ccall unsafe \"HsNet.h getservbyname\" \n"
"  c_getservbyname :: CString -> CString -> IO (Ptr ServiceEntry)\n"
"\n"
"getServiceByPort :: PortNumber -> ProtocolName -> IO ServiceEntry\n"
"getServiceByPort (PortNum port) proto = do\n"
" withCString proto $ \\ cstr_proto -> do\n"
" throwNoSuchThingIfNull \"getServiceByPort\" \"no such service entry\"\n"
"   $ (trySysCall (c_getservbyport (fromIntegral port) cstr_proto))\n"
" >>= peek\n"
"\n"
"foreign import ccall unsafe \"HsNet.h getservbyport\" \n"
"  c_getservbyport :: CInt -> CString -> IO (Ptr ServiceEntry)\n"
"\n"
"getServicePortNumber :: ServiceName -> IO PortNumber\n"
"getServicePortNumber name = do\n"
"    (ServiceEntry _ _ port _) <- getServiceByName name \"tcp\"\n"
"    return port\n"
"\n"
"\n"
"{-# LINE 203 \"BSD.hsc\" #-}\n"
"getServiceEntry	:: IO ServiceEntry\n"
"getServiceEntry = do\n"
" throwNoSuchThingIfNull \"getServiceEntry\" \"no such service entry\"\n"
"   $ trySysCall c_getservent\n"
" >>= peek\n"
"\n"
"foreign import ccall unsafe \"HsNet.h getservent\" c_getservent :: IO (Ptr ServiceEntry)\n"
"\n"
"setServiceEntry	:: Bool -> IO ()\n"
"setServiceEntry flg = trySysCall $ c_setservent (fromBool flg)\n"
"\n"
"foreign import ccall unsafe  \"HsNet.h setservent\" c_setservent :: CInt -> IO ()\n"
"\n"
"endServiceEntry	:: IO ()\n"
"endServiceEntry = trySysCall $ c_endservent\n"
"\n"
"foreign import ccall unsafe  \"HsNet.h endservent\" c_endservent :: IO ()\n"
"\n"
"getServiceEntries :: Bool -> IO [ServiceEntry]\n"
"getServiceEntries stayOpen = do\n"
"  setServiceEntry stayOpen\n"
"  getEntries (getServiceEntry) (endServiceEntry)\n"
"\n"
"{-# LINE 226 \"BSD.hsc\" #-}\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Protocol Entries\n"
"\n"
"-- The following relate directly to the corresponding UNIX C\n"
"-- calls for returning the protocol entries. The protocol entry is\n"
"-- represented by the Haskell type ProtocolEntry.\n"
"\n"
"-- As for setServiceEntry above, calling setProtocolEntry.\n"
"-- determines whether or not the protocol database file, usually\n"
"-- @/etc/protocols@, is to be kept open between calls of\n"
"-- getProtocolEntry. Similarly, \n"
"\n"
"data ProtocolEntry = \n"
"  ProtocolEntry  {\n"
"     protoName    :: ProtocolName,	-- Official Name\n"
"     protoAliases :: [ProtocolName],	-- aliases\n"
"     protoNumber  :: ProtocolNumber	-- Protocol Number\n"
"  } deriving (Read, Show)\n"
"\n"
"instance Storable ProtocolEntry where\n"
"   sizeOf    _ = 24\n"
"{-# LINE 248 \"BSD.hsc\" #-}\n"
"   alignment _ = alignment (undefined :: CInt) -- ???\n"
"\n"
"   peek p = do\n"
"	p_name    <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0)) p >>= peekCString\n"
"{-# LINE 252 \"BSD.hsc\" #-}\n"
"	p_aliases <- ((\\hsc_ptr -> peekByteOff hsc_ptr 8)) p\n"
"{-# LINE 253 \"BSD.hsc\" #-}\n"
"			   >>= peekArray0 nullPtr\n"
"			   >>= mapM peekCString\n"
"\n"
"{-# LINE 262 \"BSD.hsc\" #-}\n"
"	p_proto        <- ((\\hsc_ptr -> peekByteOff hsc_ptr 16)) p \n"
"{-# LINE 263 \"BSD.hsc\" #-}\n"
"\n"
"{-# LINE 264 \"BSD.hsc\" #-}\n"
"	return (ProtocolEntry { \n"
"			protoName    = p_name,\n"
"			protoAliases = p_aliases,\n"
"			protoNumber  = p_proto\n"
"		})\n"
"\n"
"   poke p = error \"Storable.poke(BSD.ProtocolEntry) not implemented\"\n"
"\n"
"getProtocolByName :: ProtocolName -> IO ProtocolEntry\n"
"getProtocolByName name = do\n"
" withCString name $ \\ name_cstr -> do\n"
" throwNoSuchThingIfNull \"getServiceEntry\" \"no such service entry\"\n"
"   $ (trySysCall.c_getprotobyname) name_cstr\n"
" >>= peek\n"
"\n"
"foreign import  ccall unsafe  \"HsNet.h getprotobyname\" \n"
"   c_getprotobyname :: CString -> IO (Ptr ProtocolEntry)\n"
"\n"
"\n"
"getProtocolByNumber :: ProtocolNumber -> IO ProtocolEntry\n"
"getProtocolByNumber num = do\n"
" throwNoSuchThingIfNull \"getServiceEntry\" \"no such service entry\"\n"
"   $ (trySysCall.c_getprotobynumber) (fromIntegral num)\n"
" >>= peek\n"
"\n"
"foreign import ccall unsafe  \"HsNet.h getprotobynumber\"\n"
"   c_getprotobynumber :: CInt -> IO (Ptr ProtocolEntry)\n"
"\n"
"\n"
"getProtocolNumber :: ProtocolName -> IO ProtocolNumber\n"
"getProtocolNumber proto = do\n"
" (ProtocolEntry _ _ num) <- getProtocolByName proto\n"
" return num\n"
"\n"
"\n"
"{-# LINE 299 \"BSD.hsc\" #-}\n"
"getProtocolEntry :: IO ProtocolEntry	-- Next Protocol Entry from DB\n"
"getProtocolEntry = do\n"
" ent <- throwNoSuchThingIfNull \"getProtocolEntry\" \"no such protocol entry\"\n"
"   		$ trySysCall c_getprotoent\n"
" peek ent\n"
"\n"
"foreign import ccall unsafe  \"HsNet.h getprotoent\" c_getprotoent :: IO (Ptr ProtocolEntry)\n"
"\n"
"setProtocolEntry :: Bool -> IO ()	-- Keep DB Open ?\n"
"setProtocolEntry flg = trySysCall $ c_setprotoent (fromBool flg)\n"
"\n"
"foreign import ccall unsafe \"HsNet.h setprotoent\" c_setprotoent :: CInt -> IO ()\n"
"\n"
"endProtocolEntry :: IO ()\n"
"endProtocolEntry = trySysCall $ c_endprotoent\n"
"\n"
"foreign import ccall unsafe \"HsNet.h endprotoent\" c_endprotoent :: IO ()\n"
"\n"
"getProtocolEntries :: Bool -> IO [ProtocolEntry]\n"
"getProtocolEntries stayOpen = do\n"
"  setProtocolEntry stayOpen\n"
"  getEntries (getProtocolEntry) (endProtocolEntry)\n"
"\n"
"{-# LINE 322 \"BSD.hsc\" #-}\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Host lookups\n"
"\n"
"data HostEntry = \n"
"  HostEntry  {\n"
"     hostName      :: HostName,  	-- Official Name\n"
"     hostAliases   :: [HostName],	-- aliases\n"
"     hostFamily    :: Family,	        -- Host Type (currently AF_INET)\n"
"     hostAddresses :: [HostAddress]	-- Set of Network Addresses  (in network byte order)\n"
"  } deriving (Read, Show)\n"
"\n"
"instance Storable HostEntry where\n"
"   sizeOf    _ = 32\n"
"{-# LINE 336 \"BSD.hsc\" #-}\n"
"   alignment _ = alignment (undefined :: CInt) -- ???\n"
"\n"
"   peek p = do\n"
"	h_name       <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0)) p >>= peekCString\n"
"{-# LINE 340 \"BSD.hsc\" #-}\n"
"	h_aliases    <- ((\\hsc_ptr -> peekByteOff hsc_ptr 8)) p\n"
"{-# LINE 341 \"BSD.hsc\" #-}\n"
"				>>= peekArray0 nullPtr\n"
"				>>= mapM peekCString\n"
"	h_addrtype   <- ((\\hsc_ptr -> peekByteOff hsc_ptr 16)) p\n"
"{-# LINE 344 \"BSD.hsc\" #-}\n"
"	-- h_length       <- (#peek struct hostent, h_length) p\n"
"	h_addr_list  <- ((\\hsc_ptr -> peekByteOff hsc_ptr 24)) p\n"
"{-# LINE 346 \"BSD.hsc\" #-}\n"
"				>>= peekArray0 nullPtr\n"
"				>>= mapM peek\n"
"	return (HostEntry {\n"
"			hostName       = h_name,\n"
"			hostAliases    = h_aliases,\n"
"			hostFamily     = unpackFamily h_addrtype,\n"
"			hostAddresses  = h_addr_list\n"
"		})\n"
"\n"
"   poke p = error \"Storable.poke(BSD.ServiceEntry) not implemented\"\n"
"\n"
"\n"
"-- convenience function:\n"
"hostAddress :: HostEntry -> HostAddress\n"
"hostAddress (HostEntry nm _ _ ls) =\n"
" case ls of\n"
"   []    -> error (\"BSD.hostAddress: empty network address list for \" ++ nm)\n"
"   (x:_) -> x\n"
"\n"
"getHostByName :: HostName -> IO HostEntry\n"
"getHostByName name = do\n"
"  withCString name $ \\ name_cstr -> do\n"
"   ent <- throwNoSuchThingIfNull \"getHostByName\" \"no such host entry\"\n"
"    		$ trySysCall $ c_gethostbyname name_cstr\n"
"   peek ent\n"
"\n"
"foreign import ccall unsafe \"HsNet.h gethostbyname\" \n"
"   c_gethostbyname :: CString -> IO (Ptr HostEntry)\n"
"\n"
"getHostByAddr :: Family -> HostAddress -> IO HostEntry\n"
"getHostByAddr family addr = do\n"
" with addr $ \\ ptr_addr -> do\n"
" throwNoSuchThingIfNull 	\"getHostByAddr\" \"no such host entry\"\n"
"   $ trySysCall $ c_gethostbyaddr ptr_addr (fromIntegral (sizeOf addr)) (packFamily family)\n"
" >>= peek\n"
"\n"
"foreign import ccall unsafe \"HsNet.h gethostbyaddr\"\n"
"   c_gethostbyaddr :: Ptr HostAddress -> CInt -> CInt -> IO (Ptr HostEntry)\n"
"\n"
"\n"
"{-# LINE 386 \"BSD.hsc\" #-}\n"
"getHostEntry :: IO HostEntry\n"
"getHostEntry = do\n"
" throwNoSuchThingIfNull 	\"getHostEntry\" \"unable to retrieve host entry\"\n"
"   $ trySysCall $ c_gethostent\n"
" >>= peek\n"
"\n"
"foreign import ccall unsafe \"HsNet.h gethostent\" c_gethostent :: IO (Ptr HostEntry)\n"
"\n"
"setHostEntry :: Bool -> IO ()\n"
"setHostEntry flg = trySysCall $ c_sethostent (fromBool flg)\n"
"\n"
"foreign import ccall unsafe \"HsNet.h sethostent\" c_sethostent :: CInt -> IO ()\n"
"\n"
"endHostEntry :: IO ()\n"
"endHostEntry = c_endhostent\n"
"\n"
"foreign import ccall unsafe \"HsNet.h endhostent\" c_endhostent :: IO ()\n"
"\n"
"getHostEntries :: Bool -> IO [HostEntry]\n"
"getHostEntries stayOpen = do\n"
"  setHostEntry stayOpen\n"
"  getEntries (getHostEntry) (endHostEntry)\n"
"\n"
"{-# LINE 409 \"BSD.hsc\" #-}\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Accessing network information\n"
"\n"
"-- Same set of access functions as for accessing host,protocol and\n"
"-- service system info, this time for the types of networks supported.\n"
"\n"
"-- network addresses are represented in host byte order.\n"
"type NetworkAddr = CULong\n"
"\n"
"type NetworkName = String\n"
"\n"
"data NetworkEntry =\n"
"  NetworkEntry {\n"
"     networkName	:: NetworkName,   -- official name\n"
"     networkAliases	:: [NetworkName], -- aliases\n"
"     networkFamily	:: Family,	   -- type\n"
"     networkAddress	:: NetworkAddr\n"
"   } deriving (Read, Show)\n"
"\n"
"instance Storable NetworkEntry where\n"
"   sizeOf    _ = 32\n"
"{-# LINE 431 \"BSD.hsc\" #-}\n"
"   alignment _ = alignment (undefined :: CInt) -- ???\n"
"\n"
"   peek p = do\n"
"	n_name         <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0)) p >>= peekCString\n"
"{-# LINE 435 \"BSD.hsc\" #-}\n"
"	n_aliases      <- ((\\hsc_ptr -> peekByteOff hsc_ptr 8)) p\n"
"{-# LINE 436 \"BSD.hsc\" #-}\n"
"			 	>>= peekArray0 nullPtr\n"
"			   	>>= mapM peekCString\n"
"	n_addrtype     <- ((\\hsc_ptr -> peekByteOff hsc_ptr 16)) p\n"
"{-# LINE 439 \"BSD.hsc\" #-}\n"
"	n_net          <- ((\\hsc_ptr -> peekByteOff hsc_ptr 20)) p\n"
"{-# LINE 440 \"BSD.hsc\" #-}\n"
"	return (NetworkEntry {\n"
"			networkName      = n_name,\n"
"			networkAliases   = n_aliases,\n"
"			networkFamily    = unpackFamily (fromIntegral \n"
"					    (n_addrtype :: CInt)),\n"
"			networkAddress   = n_net\n"
"		})\n"
"\n"
"   poke p = error \"Storable.poke(BSD.NetEntry) not implemented\"\n"
"\n"
"\n"
"\n"
"{-# LINE 452 \"BSD.hsc\" #-}\n"
"getNetworkByName :: NetworkName -> IO NetworkEntry\n"
"getNetworkByName name = do\n"
" withCString name $ \\ name_cstr -> do\n"
"  throwNoSuchThingIfNull \"getNetworkByName\" \"no such network entry\"\n"
"    $ trySysCall $ c_getnetbyname name_cstr\n"
"  >>= peek\n"
"\n"
"foreign import ccall unsafe \"HsNet.h getnetbyname\" \n"
"   c_getnetbyname  :: CString -> IO (Ptr NetworkEntry)\n"
"\n"
"getNetworkByAddr :: NetworkAddr -> Family -> IO NetworkEntry\n"
"getNetworkByAddr addr family = do\n"
" throwNoSuchThingIfNull \"getNetworkByAddr\" \"no such network entry\"\n"
"   $ trySysCall $ c_getnetbyaddr addr (packFamily family)\n"
" >>= peek\n"
"\n"
"foreign import ccall unsafe \"HsNet.h getnetbyaddr\" \n"
"   c_getnetbyaddr  :: NetworkAddr -> CInt -> IO (Ptr NetworkEntry)\n"
"\n"
"getNetworkEntry :: IO NetworkEntry\n"
"getNetworkEntry = do\n"
" throwNoSuchThingIfNull \"getNetworkEntry\" \"no more network entries\"\n"
"          $ trySysCall $ c_getnetent\n"
" >>= peek\n"
"\n"
"foreign import ccall unsafe \"HsNet.h getnetent\" c_getnetent :: IO (Ptr NetworkEntry)\n"
"\n"
"setNetworkEntry :: Bool -> IO ()\n"
"setNetworkEntry flg = trySysCall $ c_setnetent (fromBool flg)\n"
"\n"
"foreign import ccall unsafe \"HsNet.h setnetent\" c_setnetent :: CInt -> IO ()\n"
"\n"
"endNetworkEntry :: IO ()\n"
"endNetworkEntry = trySysCall $ c_endnetent\n"
"\n"
"foreign import ccall unsafe \"HsNet.h endnetent\" c_endnetent :: IO ()\n"
"\n"
"getNetworkEntries :: Bool -> IO [NetworkEntry]\n"
"getNetworkEntries stayOpen = do\n"
"  setNetworkEntry stayOpen\n"
"  getEntries (getNetworkEntry) (endNetworkEntry)\n"
"\n"
"{-# LINE 494 \"BSD.hsc\" #-}\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Miscellaneous Functions\n"
"\n"
"-- Calling getHostName returns the standard host name for the current\n"
"-- processor, as set at boot time.\n"
"\n"
"getHostName :: IO HostName\n"
"getHostName = do\n"
"  let size = 256\n"
"  allocaArray0 size $ \\ cstr -> do\n"
"    throwSocketErrorIfMinus1_ \"getHostName\" $ c_gethostname cstr (fromIntegral size)\n"
"    peekCString cstr\n"
"\n"
"foreign import ccall unsafe \"HsNet.h gethostname\" \n"
"   c_gethostname :: CString -> CSize -> IO CInt\n"
"\n"
"-- Helper function used by the exported functions that provides a\n"
"-- Haskellised view of the enumerator functions:\n"
"\n"
"getEntries :: IO a  -- read\n"
"           -> IO () -- at end\n"
"	   -> IO [a]\n"
"getEntries getOne atEnd = loop\n"
"  where\n"
"    loop = do\n"
"      vv <- catch (liftM Just getOne) ((const.return) Nothing)\n"
"      case vv of\n"
"        Nothing -> return []\n"
"        Just v  -> loop >>= \\ vs -> atEnd >> return (v:vs)\n"
"\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Symbolic links\n"
"\n"
"\n"
"{-# LINE 540 \"BSD.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 554 \"BSD.hsc\" #-}\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Winsock only:\n"
"--   The BSD API networking calls made locally return NULL upon failure.\n"
"--   That failure may very well be due to WinSock not being initialised,\n"
"--   so if NULL is seen try init'ing and repeat the call.\n"
"\n"
"{-# LINE 561 \"BSD.hsc\" #-}\n"
"trySysCall act = act\n"
"\n"
"{-# LINE 569 \"BSD.hsc\" #-}\n"
"\n"
"throwNoSuchThingIfNull :: String -> String -> IO (Ptr a) -> IO (Ptr a)\n"
"throwNoSuchThingIfNull loc desc act = do\n"
"  ptr <- act\n"
"  if (ptr == nullPtr)\n"
"   then ioError (IOError Nothing NoSuchThing\n"
"	loc desc Nothing)\n"
"   else return ptr\n";
const char *Network_URI = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Network.URI\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/core/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (needs Text.Regex)\n"
"--\n"
"-- This library provides utilities for\n"
"-- parsing and manipulating Uniform Resource Identifiers (a more\n"
"-- general form of Uniform Resource Locators, or URLs). URIs are\n"
"-- described in RFC 2396 <http://www.ietf.org/rfc/rfc2396.txt>.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Network.URI (\n"
"\n"
"  -- * The @URI@ type\n"
"  URI(..),\n"
"\n"
"  -- * Parsing a @URI@\n"
"  parseURI,				-- :: String -> Maybe URI\n"
"	\n"
"  -- * Computing relative @URI@s\n"
"  relativeTo,				-- :: URI -> URI -> Maybe URI\n"
"\n"
"  -- * Operations on @URI@ strings\n"
"\n"
"  -- | support for putting strings into URI-friendly\n"
"  -- escaped format and getting them back again.\n"
"  -- This can't be done transparently, because certain characters\n"
"  -- have different meanings in different kinds of URI.\n"
"\n"
"  reserved, unreserved, isAllowedInURI,	-- :: Char -> Bool\n"
"  escapeString,				-- :: String -> (Char->Bool) -> String\n"
"  unEscapeString			-- :: String -> String\n"
"\n"
"  ) where\n"
"\n"
"import Numeric\n"
"import Data.Char\n"
"import Text.Regex\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- The URI datatype\n"
"\n"
"-- | The decomposition of a general universal resource identifier.\n"
"-- For example, for the URI\n"
"--\n"
"-- >   http://www.haskell.org/ghc?query#frag\n"
"--\n"
"-- the components are ...\n"
"data URI = URI\n"
"	{ scheme	:: String	-- ^ @http@\n"
"	, authority	:: String	-- ^ @www.haskell.org@\n"
"	, path		:: String	-- ^ @\\/ghc@\n"
"	, query		:: String	-- ^ @query@\n"
"	, fragment	:: String	-- ^ @frag@\n"
"	}\n"
"\n"
"instance Show URI where\n"
"  showsPrec _ uri = uriToString uri\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- | Turns a string into a @URI@.  It returns @Nothing@ if the\n"
"-- string isn't a valid URI.\n"
"\n"
"parseURI :: String -> Maybe URI\n"
"parseURI s =\n"
"   let s1 = stripWS s in\n"
"   case matchRegex uriRegex s1 of\n"
"	Nothing -> Nothing\n"
"	Just (_:scheme:_:authority:path:_:query:_:fragment:_)\n"
"	   -> Just URI{\n"
"		  scheme    = scheme,\n"
"		  authority = authority,\n"
"		  path	    = path,\n"
"		  query	    = query,\n"
"		  fragment  = fragment\n"
"	         }\n"
"	_other ->\n"
"	   error \"Network.URI.parseURI: internal error\"		\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- turning a URI back into a string\n"
"\n"
"-- algorithm from part 7, sec 5.2, RFC 2396\n"
"\n"
"uriToString :: URI -> ShowS\n"
"uriToString \n"
"    URI{\n"
"	scheme=scheme,\n"
"	authority=authority,\n"
"	path=path,\n"
"	query=query,\n"
"	fragment=fragment\n"
"       } r\n"
"  = append \":\" scheme (\n"
"    prepend \"//\" authority (\n"
"    append \"\" path (\n"
"    prepend \"?\" query (\n"
"    prepend \"#\" fragment r\n"
"    ))))\n"
"\n"
"  where prepend pre \"\" rest = rest\n"
"	prepend pre s  rest = pre ++ s ++ rest\n"
"	\n"
"	append  post \"\" rest = rest\n"
"	append  post s  rest = s ++ post ++ rest\n"
"\n"
"-- Regex from RFC 2396\n"
"uriRegex = mkRegex \"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\"\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- character classes\n"
"\n"
"-- | Returns 'True' if the character is a \\\"reserved\\\" character in a\n"
"-- URI.  To include a literal instance of one of these characters in a\n"
"-- component of a URI, it must be escaped.\n"
"reserved :: Char -> Bool\n"
"reserved c = c `elem` \";/?:@&=+$,\"\n"
"\n"
"-- | Returns 'True' if the character is an \\\"unreserved\\\" character in\n"
"-- a URI.  These characters do not need to be escaped in a URI.  The\n"
"-- only characters allowed in a URI are either 'reserved',\n"
"-- 'unreserved', or an escape sequence (@%@ followed by two hex digits).\n"
"-- \n"
"unreserved :: Char -> Bool\n"
"unreserved c = (c >= 'A' && c <= 'Z') \n"
"	    || (c >= 'a' && c <= 'z')\n"
"	    || (c >= '0' && c <= '9')\n"
"	    || (c `elem` \"-_.!~*'()\")\n"
"-- can't use isAlphaNum etc. because these deal with ISO 8859 (and\n"
"-- possibly Unicode!) chars.\n"
"\n"
"-- | Returns 'True' if the character is allowed in a URI.\n"
"--\n"
"isAllowedInURI :: Char -> Bool\n"
"isAllowedInURI c = reserved c || unreserved c || c == '%' -- escape char\n"
"\n"
"escapeChar :: Char -> (Char->Bool) -> String\n"
"escapeChar c p | p c = [c]\n"
"	       | otherwise    = '%' : myShowHex (ord c) \"\"\n"
"\n"
"-- | Can be used to make a string valid for use in a URI.\n"
"--\n"
"escapeString\n"
"    :: String		-- ^ the string to process\n"
"    -> (Char->Bool)	-- ^ a predicate which returns 'False' if the character\n"
"			-- should be escaped\n"
"    -> String		-- the processed string\n"
"escapeString s p = foldr (\\c cs -> escapeChar c p ++ cs) \"\" s\n"
"\n"
"myShowHex :: Int -> ShowS\n"
"myShowHex n r\n"
" =  case str of\n"
"	[]  -> \"00\"\n"
"	[c] -> ['0',c]\n"
"	cs  -> cs\n"
" where\n"
"  str = showIntAtBase 16 (toChrHex) n r\n"
"  toChrHex d\n"
"    | d < 10    = chr (ord '0'   + fromIntegral d)\n"
"    | otherwise = chr (ord 'A' + fromIntegral (d - 10))\n"
"\n"
"-- | Turns all instances of escaped characters in the string back into\n"
"-- literal characters.\n"
"unEscapeString :: String -> String\n"
"unEscapeString [] = \"\"\n"
"unEscapeString ('%':x1:x2:s) | isHexDigit x1 && isHexDigit x2 \n"
"  = chr (hexDigit x1 * 16 + hexDigit x2) : unEscapeString s\n"
"unEscapeString (c:s) = c : unEscapeString s\n"
"\n"
"hexDigit c | c >= 'A' && c <= 'F' = ord c - ord 'A' + 10\n"
"	   | c >= 'a' && c <= 'F' = ord c - ord 'a' + 10\n"
"	   | otherwise = ord c - ord '0'\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Resolving a relative URI relative to a base URI\n"
"\n"
"-- algorithm from sec 5.2, RFC 2396\n"
"\n"
"-- | Returns a new @URI@ which represents the value of the first @URI@\n"
"-- relative to the second @URI@.  For example\n"
"--\n"
"-- >  \"foo\" `relativeTo` \"http://bar.org/\" = \"http://bar.org/foo\"\n"
"--\n"
"relativeTo :: URI -> URI -> Maybe URI\n"
"ref `relativeTo` base =\n"
"  -- ref has a scheme name, use it in its entirety.  Otherwise inherit\n"
"  -- the scheme name from base.\n"
"  if ref_scheme    /= \"\"  then Just ref else\n"
"\n"
"  -- ref has an authority - we're done.  Otherwise inherit the authority.\n"
"  if ref_authority /= \"\"  then Just ref{scheme = base_scheme} else\n"
"\n"
"  -- ref has an absolute path, we're done.\n"
"  if not (null ref_path) && head ref_path == '/'\n"
"	then Just ref{scheme = base_scheme, \n"
"	              authority = base_authority} else\n"
"  \n"
"  -- relative path...\n"
"  let new_path = munge (dropLastComponent base_path ++ ref_path) []\n"
"  in if isErrorPath new_path \n"
"	then Nothing \n"
"	else Just ref{scheme = base_scheme, \n"
"	              authority = base_authority,\n"
"	              path = new_path}\n"
"  where\n"
"       	URI{\n"
"	  scheme    = ref_scheme,\n"
"	  authority = ref_authority,\n"
"	  path      = ref_path,\n"
"	  query     = _ref_query,\n"
"	  fragment  = _ref_fragment\n"
"         } = ref\n"
"\n"
"       	URI{\n"
"	  scheme    = base_scheme,\n"
"	  authority = base_authority,\n"
"	  path      = base_path,\n"
"	  query     = _base_query,\n"
"	  fragment  = _base_fragment\n"
"         } = base\n"
"\n"
"	munge [] [] = \"\"\n"
"	munge [] ps = concat (reverse ps)\n"
"	munge ('.':'/':s)     ps     = munge s ps\n"
"	munge ['.']           ps     = munge [] ps\n"
"	munge ('.':'.':'/':s) (p:ps) | p /= \"/\" = munge s ps\n"
"	munge ['.','.']       (p:ps) = munge [] ps\n"
"	munge s		      ps     = munge rest' (p':ps)\n"
"		where (p,rest) = break (=='/') s\n"
"		      (p',rest') = case rest of\n"
"					'/':r -> (p++\"/\",r)\n"
"					r     -> (p,r)\n"
"\n"
"	dropLastComponent = reverse . dropWhile (/= '/') . reverse\n"
"\n"
"	isErrorPath ('/':'.':'.':'/':_) = True\n"
"	isErrorPath _ = False\n"
"\n"
"stripLeadingWS, stripTrailingWS, stripWS :: String -> String\n"
"stripLeadingWS  = dropWhile isSpace\n"
"stripTrailingWS = reverse . stripLeadingWS . reverse\n"
"stripWS         = stripLeadingWS . stripTrailingWS\n"
"\n";
const char *Network_CGI = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Network.CGI\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/core/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (uses Control.Exception)\n"
"--\n"
"-- Haskell binding for CGI\n"
"--\n"
"-- Original Version by Erik Meijer <mailto:erik@cs.ruu.nl>\n"
"-- Further hacked on by Sven Panne <mailto:sven_panne@yahoo.com>\n"
"-- Further hacking by Andy Gill <mailto:andy@galconn.com>\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- note: if using Windows, you might need to wrap 'withSocketsDo' round main.\n"
"\n"
"module Network.CGI (\n"
"    Html, \n"
"    wrapper,            -- ::           ([(String,String)] -> IO Html) -> IO ()\n"
"    pwrapper,           -- :: PortID -> ([(String,String)] -> IO Html) -> IO ()\n"
"    connectToCGIScript  -- :: String -> PortID -> IO ()\n"
"  ) where\n"
"\n"
"import Data.Char ( ord, chr, toUpper, isDigit, isAlphaNum, isHexDigit )\n"
"import System.Environment ( getEnv )\n"
"import Control.Monad(MonadPlus(..), guard)\n"
"import System.IO\n"
"\n"
"import Text.Html\n"
"import Control.Exception as Exception\n"
"import Control.Concurrent\n"
"\n"
"import Network\n"
"import Network.Socket as Socket\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Yet another combinator parser library\n"
"\n"
"-- NOTE: This is all a little bit of a sledgehammer here for the simple task\n"
"-- at hand...\n"
"\n"
"-- The parser monad\n"
"\n"
"newtype Parser a = Parser (String -> [(a,String)])\n"
"\n"
"instance Functor Parser where\n"
"   -- map :: (a -> b) -> (Parser a -> Parser b)\n"
"   fmap f (Parser p) = Parser (\\inp -> [(f v, out) | (v, out) <- p inp])\n"
"\n"
"instance Monad Parser where\n"
"   -- return :: a -> Parser a\n"
"   return v = Parser (\\inp -> [(v,inp)])\n"
"\n"
"   -- >>= :: Parser a -> (a -> Parser b) -> Parser b\n"
"   (Parser p) >>= f = Parser (\\inp -> concat [papply (f v) out\n"
"                                             | (v,out) <- p inp])\n"
"\n"
"instance MonadPlus Parser where\n"
"   -- zero :: Parser a\n"
"   mzero = Parser (\\_ -> [])\n"
"   -- (++) :: Parser a -> Parser a -> Parser a\n"
"   (Parser p) `mplus` (Parser q) = Parser (\\inp -> (p inp ++ q inp))\n"
"\n"
"-- Other primitive parser combinators\n"
"\n"
"item :: Parser Char\n"
"item = Parser (\\inp -> case inp of\n"
"                     []     -> []\n"
"                     (x:xs) -> [(x,xs)])\n"
"\n"
"force :: Parser a -> Parser a\n"
"force (Parser p) = Parser (\\inp -> let x = p inp in\n"
"                             (fst (head x), snd (head x)) : tail x)\n"
"\n"
"first :: Parser a -> Parser a\n"
"first (Parser p) = Parser (\\inp -> case p inp of\n"
"                            []    -> []\n"
"                            (x:_) -> [x])\n"
"\n"
"papply :: Parser a -> String -> [(a,String)]\n"
"papply (Parser p) inp = p inp\n"
"\n"
"-- Derived combinators\n"
"\n"
"plusplusplus :: Parser a -> Parser a -> Parser a\n"
"p `plusplusplus` q = first (p `mplus` q)\n"
"\n"
"sat :: (Char -> Bool) -> Parser Char\n"
"sat p = do {x <- item; guard (p x); return x}\n"
"\n"
"many :: Parser a -> Parser [a]\n"
"many p = force (many1 p `plusplusplus` return [])\n"
"\n"
"many1 :: Parser a -> Parser [a]\n"
"many1 p = do {x <- p; xs <- many p; return (x:xs)}\n"
"\n"
"sepby :: Parser a -> Parser b -> Parser [a]\n"
"p `sepby` sep = (p `sepby1` sep) `plusplusplus` return []\n"
"\n"
"sepby1 :: Parser a -> Parser b -> Parser [a]\n"
"p `sepby1` sep = do x  <- p\n"
"                    xs <- many (do {sep; p})\n"
"                    return(x:xs)\n"
"\n"
"char :: Char -> Parser Char\n"
"char x = sat (x==)\n"
"\n"
"alphanum :: Parser Char\n"
"alphanum = sat isAlphaNum\n"
"\n"
"string :: String -> Parser String\n"
"string []     = return \"\"\n"
"string (x:xs) = do char x\n"
"                   string xs\n"
"                   return (x:xs)\n"
"\n"
"hexdigit :: Parser Char\n"
"hexdigit = sat isHexDigit\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Decoding application/x-www-form-urlencoded data\n"
"\n"
"-- An URL encoded value consist of a sequence of\n"
"-- zero or more name \"=\" value pairs separated by \"&\"\n"
"\n"
"-- Env ::= [Name \"=\" Value {\"&\" Name \"=\" Value}]\n"
"\n"
"-- Names and values are URL-encoded,\n"
"-- according to the following table\n"
"-- \n"
"--    character | encoding\n"
"--    ----------|---------\n"
"--     ' '      | '+'\n"
"--     '<'      | \"%XX\"\n"
"-- 	c       | \"%\"hexval(ord c)\n"
"\n"
"urlDecode :: String -> [(String,String)]\n"
"urlDecode s = case papply env s of\n"
"                 [] -> []\n"
"                 ((e,_):_) -> e\n"
"\n"
"env :: Parser [(String,String)]\n"
"env = (do n <- urlEncoded\n"
"          string \"=\"\n"
"          v <- urlEncoded\n"
"          return (n,v)) `sepby` (string \"&\")\n"
"\n"
"urlEncoded :: Parser String\n"
"urlEncoded\n"
" = many ( alphanum `mplus` extra `mplus` safe\n"
"         `mplus` do{ char '+' ; return ' '}\n"
"         `mplus` do{ char '%'\n"
"		   ; d <- hexadecimal\n"
"		   ; return $ chr (hex2int d)\n"
"		   }\n"
"         )\n"
"\n"
"extra :: Parser Char\n"
"extra = sat (`elem` \"!*'(),\")\n"
"\n"
"safe :: Parser Char\n"
"safe = sat (`elem` \"$-_.\")\n"
"\n"
"hexadecimal :: Parser HexString\n"
"hexadecimal = do d1 <- hexdigit\n"
"                 d2 <- hexdigit\n"
"                 return [d1,d2]\n"
"\n"
"type HexString = String\n"
"\n"
"hex2int :: HexString -> Int\n"
"hex2int ds = foldl (\\n d -> n*16+d) 0 (map (toInt . toUpper) ds)\n"
"   where toInt d | isDigit d    =  ord d - ord '0'\n"
"         toInt d | isHexDigit d = (ord d - ord 'A') + 10\n"
"         toInt d                = error (\"hex2int: illegal hex digit \" ++ [d])\n"
"\n"
"-- A function to do URL encoding and proving its correctness might be a\n"
"-- nice exercise for the book.\n"
"-- \n"
"-- We don't usually need it for CGI scripts though. The browser does the\n"
"-- encoding and the CGI script does the decoding.\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Hide the CGI protocol from the programmer\n"
"\n"
"wrapper :: ([(String,String)] -> IO Html) -> IO ()\n"
"wrapper f = do qs      <- getQueryString\n"
"               cgiVars <- getCgiVars\n"
"               a       <- f (cgiVars ++ urlDecode qs)\n"
"	       putStr \"Content-type: text/html\\n\\n\"\n"
"               putStr (renderHtml a)\n"
"\n"
"getCgiVars :: IO [(String,String)]\n"
"getCgiVars = do vals <- mapM myGetEnv cgiVarNames\n"
"                return (zip cgiVarNames vals)\n"
"\n"
"cgiVarNames :: [String]\n"
"cgiVarNames =\n"
"   [ \"DOCUMENT_ROOT\"\n"
"   , \"AUTH_TYPE\"\n"
"   , \"GATEWAY_INTERFACE\"\n"
"   , \"SERVER_SOFTWARE\"\n"
"   , \"SERVER_NAME\"\n"
"   , \"REQUEST_METHOD\"\n"
"   , \"SERVER_ADMIN\"\n"
"   , \"SERVER_PORT\"\n"
"   , \"QUERY_STRING\"\n"
"   , \"CONTENT_LENGTH\"\n"
"   , \"CONTENT_TYPE\"\n"
"   , \"REMOTE_USER\"\n"
"   , \"REMOTE_IDENT\"\n"
"   , \"REMOTE_ADDR\"\n"
"   , \"REMOTE_HOST\"\n"
"   , \"TZ\"\n"
"   , \"PATH\"\n"
"   , \"PATH_INFO\"\n"
"   , \"PATH_TRANSLATED\"\n"
"   , \"SCRIPT_NAME\"\n"
"   , \"SCRIPT_FILENAME\"\n"
"   , \"HTTP_CONNECTION\"\n"
"   , \"HTTP_ACCEPT_LANGUAGE\"\n"
"   , \"HTTP_ACCEPT\"\n"
"   , \"HTTP_HOST\"\n"
"   , \"HTTP_UA_COLOR\"\n"
"   , \"HTTP_UA_CPU\"\n"
"   , \"HTTP_UA_OS\"\n"
"   , \"HTTP_UA_PIXELS\"\n"
"   , \"HTTP_USER_AGENT\"\n"
"   ]                      \n"
"\n"
"pwrapper :: PortID -> ([(String,String)] -> IO Html) -> IO ()\n"
"pwrapper pid f = \n"
"       do { sock <- listenOn pid\n"
"          ; acceptConnections fn sock\n"
"          }\n"
"  where\n"
"       fn h = do { qs <- hGetLine h\n"
"                 ; a <- f (urlDecode qs)\n"
"	         ; hPutStr h \"Content-type: text/html\\n\\n\"\n"
"                 ; hPutStr h (renderHtml a)\n"
"                 }\n"
"\n"
"acceptConnections fn sock = do\n"
"  (h, SockAddrInet port haddr) <- accept' sock\n"
"  forkIO (fn h `finally` (hClose h))\n"
"  acceptConnections fn sock\n"
"\n"
"accept' :: Socket 		-- Listening Socket\n"
"       -> IO (Handle,SockAddr)	-- StdIO Handle for read/write\n"
"accept' sock = do\n"
" (sock', addr) <- Socket.accept sock\n"
" handle	<- socketToHandle sock' ReadWriteMode\n"
" return (handle,addr)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Small boot function for creating dummy cgi scripts\n"
"\n"
"-- Sample program:\n"
"-- \n"
"-- 	   main = connectToCGIScript \"localhost\" (PortNumber 3432)\n"
"-- \n"
"\n"
"connectToCGIScript :: String -> PortID -> IO ()\n"
"connectToCGIScript host portId\n"
"     = do { str <- getQueryString\n"
"          ; h <- connectTo host portId\n"
"                 `Exception.catch`\n"
"                   (\\ e -> abort \"Can not connect to CGI damon.\" e)\n"
"	  ; hPutStrLn h str\n"
"	  ; (sendBack h `finally` (hClose h))\n"
"               `Prelude.catch` (\\e -> if isEOFError e\n"
"			              then return ()\n"
"                                      else ioError e)\n"
"          }\n"
"\n"
"abort :: String -> Exception -> IO a\n"
"abort msg e = \n"
"    do { putStrLn (\"Content-type: text/html\\n\\n\" ++\n"
"		   \"<html><body>\" ++ msg ++ \"</body></html>\")\n"
"       ; throw e\n"
"       }\n"
"\n"
"sendBack h = do { s <- hGetLine h\n"
"                ; putStrLn s\n"
"		; sendBack h\n"
"                }\n"
"\n"
"getQueryString :: IO String\n"
"getQueryString = do\n"
"   method <- myGetEnv \"REQUEST_METHOD\"\n"
"   case method of\n"
"      \"POST\" -> do len <- myGetEnv \"CONTENT_LENGTH\"\n"
"                   inp <- getContents\n"
"                   return (take (read len) inp)\n"
"      _      -> myGetEnv \"QUERY_STRING\"\n"
"\n"
"myGetEnv :: String -> IO String\n"
"myGetEnv v = Prelude.catch (getEnv v) (const (return \"\"))\n";
const char *Control_Exception = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Exception\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- This module provides support for raising and catching both built-in\n"
"-- and user-defined exceptions.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Exception (\n"
"\n"
"	-- * The Exception type\n"
"	Exception(..),		-- instance Eq, Ord, Show, Typeable\n"
"	IOException,		-- instance Eq, Ord, Show, Typeable\n"
"	ArithException(..),	-- instance Eq, Ord, Show, Typeable\n"
"	ArrayException(..),	-- instance Eq, Ord, Show, Typeable\n"
"	AsyncException(..),	-- instance Eq, Ord, Show, Typeable\n"
"\n"
"	-- * Throwing exceptions\n"
"	throwIO,	-- :: Exception -> IO a\n"
"	throw,		-- :: Exception -> a\n"
"	ioError,	-- :: IOError -> IO a\n"
"\n"
"	-- * Catching Exceptions\n"
"\n"
"	-- |There are several functions for catching and examining\n"
"    	-- exceptions; all of them may only be used from within the\n"
"    	-- 'IO' monad.\n"
"\n"
"	-- ** The @catch@ functions\n"
"	catch,     -- :: IO a -> (Exception -> IO a) -> IO a\n"
"	catchJust, -- :: (Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a\n"
"\n"
"	-- ** The @handle@ functions\n"
"	handle,	   -- :: (Exception -> IO a) -> IO a -> IO a\n"
"	handleJust,-- :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a\n"
"\n"
"	-- ** The @try@ functions\n"
"	try,       -- :: IO a -> IO (Either Exception a)\n"
"	tryJust,   -- :: (Exception -> Maybe b) -> a    -> IO (Either b a)\n"
"\n"
"	-- ** The @evaluate@ function\n"
"	evaluate,  -- :: a -> IO a\n"
"\n"
"	-- ** The @mapException@ function\n"
"	mapException,		-- :: (Exception -> Exception) -> a -> a\n"
"\n"
"	-- ** Exception predicates\n"
"	\n"
"	-- $preds\n"
"\n"
"	ioErrors,		-- :: Exception -> Maybe IOError\n"
"	arithExceptions, 	-- :: Exception -> Maybe ArithException\n"
"	errorCalls,		-- :: Exception -> Maybe String\n"
"	dynExceptions,		-- :: Exception -> Maybe Dynamic\n"
"	assertions,		-- :: Exception -> Maybe String\n"
"	asyncExceptions, 	-- :: Exception -> Maybe AsyncException\n"
"	userErrors,		-- :: Exception -> Maybe String\n"
"\n"
"	-- * Dynamic exceptions\n"
"\n"
"	-- $dynamic\n"
"	throwDyn, 	-- :: Typeable ex => ex -> b\n"
"	catchDyn, 	-- :: Typeable ex => IO a -> (ex -> IO a) -> IO a\n"
"	\n"
"	-- * Asynchronous Exceptions\n"
"\n"
"	-- $async\n"
"\n"
"	-- ** Asynchronous exception control\n"
"\n"
"	-- |The following two functions allow a thread to control delivery of\n"
"	-- asynchronous exceptions during a critical region.\n"
"\n"
"        block,          -- :: IO a -> IO a\n"
"        unblock,        -- :: IO a -> IO a\n"
"\n"
"	-- *** Applying @block@ to an exception handler\n"
"\n"
"	-- $block_handler\n"
"\n"
"	-- *** Interruptible operations\n"
"\n"
"	-- $interruptible\n"
"\n"
"	-- * Assertions\n"
"\n"
"	assert,		-- :: Bool -> a -> a\n"
"\n"
"	-- * Utilities\n"
"\n"
"	bracket,  	-- :: IO a -> (a -> IO b) -> (a -> IO c) -> IO ()\n"
"	bracket_, 	-- :: IO a -> IO b -> IO c -> IO ()\n"
"\n"
"	finally, 	-- :: IO a -> IO b -> IO a\n"
"\n"
"  ) where\n"
"\n"
"import Hugs.Exception	as ExceptionBase\n"
"\n"
"import Prelude 		hiding ( catch )\n"
"import System.IO.Error	hiding ( catch, try )\n"
"import System.IO.Unsafe (unsafePerformIO)\n"
"import Data.Dynamic\n"
"\n"
"exceptionTc = mkTyCon \"Exception\"; instance Typeable Exception where { typeOf _ = mkAppTy exceptionTc [] }\n"
"ioExceptionTc = mkTyCon \"IOException\"; instance Typeable IOException where { typeOf _ = mkAppTy ioExceptionTc [] }\n"
"arithExceptionTc = mkTyCon \"ArithException\"; instance Typeable ArithException where { typeOf _ = mkAppTy arithExceptionTc [] }\n"
"arrayExceptionTc = mkTyCon \"ArrayException\"; instance Typeable ArrayException where { typeOf _ = mkAppTy arrayExceptionTc [] }\n"
"asyncExceptionTc = mkTyCon \"AsyncException\"; instance Typeable AsyncException where { typeOf _ = mkAppTy asyncExceptionTc [] }\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Catching exceptions\n"
"\n"
"-- |This is the simplest of the exception-catching functions.  It\n"
"-- takes a single argument, runs it, and if an exception is raised\n"
"-- the \\\"handler\\\" is executed, with the value of the exception passed as an\n"
"-- argument.  Otherwise, the result is returned as normal.  For example:\n"
"--\n"
"-- >   catch (openFile f ReadMode) \n"
"-- >       (\\e -> hPutStr stderr (\\\"Couldn\\'t open \\\"++f++\\\": \\\" ++ show e))\n"
"--\n"
"-- For catching exceptions in pure (non-'IO') expressions, see the\n"
"-- function 'evaluate'.\n"
"--\n"
"-- Note that due to Haskell\\'s unspecified evaluation order, an\n"
"-- expression may return one of several possible exceptions: consider\n"
"-- the expression @error \\\"urk\\\" + 1 \\`div\\` 0@.  Does\n"
"-- 'catch' execute the handler passing\n"
"-- @ErrorCall \\\"urk\\\"@, or @ArithError DivideByZero@?\n"
"--\n"
"-- The answer is \\\"either\\\": 'catch' makes a\n"
"-- non-deterministic choice about which exception to catch.  If you\n"
"-- call it again, you might get a different exception back.  This is\n"
"-- ok, because 'catch' is an 'IO' computation.\n"
"--\n"
"-- Note that 'catch' catches all types of exceptions, and is generally\n"
"-- used for \\\"cleaning up\\\" before passing on the exception using\n"
"-- 'throwIO'.  It is not good practice to discard the exception and\n"
"-- continue, without first checking the type of the exception (it\n"
"-- might be a 'ThreadKilled', for example).  In this case it is usually better\n"
"-- to use 'catchJust' and select the kinds of exceptions to catch.\n"
"--\n"
"-- Also note that The \"Prelude\" also exports a\n"
"-- function called 'catch' which has the same type as\n"
"-- 'Control.Exception.catch', the difference being that the\n"
"-- \"Prelude\" version only catches the IO and user\n"
"-- families of exceptions (as required by Haskell 98).  We recommend\n"
"-- either hiding the \"Prelude\" version of\n"
"-- 'catch' when importing\n"
"-- \"Control.Exception\", or importing\n"
"-- \"Control.Exception\" qualified, to avoid name-clashes.\n"
"\n"
"catch  	:: IO a 		-- ^ The computation to run\n"
"  	-> (Exception -> IO a)	-- ^ Handler to invoke if an exception is raised\n"
"  	-> IO a			\n"
"catch =  ExceptionBase.catchException\n"
"\n"
"-- | The function 'catchJust' is like 'catch', but it takes an extra\n"
"-- argument which is an /exception predicate/, a function which\n"
"-- selects which type of exceptions we\\'re interested in.  There are\n"
"-- some predefined exception predicates for useful subsets of\n"
"-- exceptions: 'ioErrors', 'arithExceptions', and so on.  For example,\n"
"-- to catch just calls to the 'error' function, we could use\n"
"--\n"
"-- >   result <- catchJust errorCalls thing_to_try handler\n"
"--\n"
"-- Any other exceptions which are not matched by the predicate\n"
"-- are re-raised, and may be caught by an enclosing\n"
"-- 'catch' or 'catchJust'.\n"
"catchJust\n"
"	:: (Exception -> Maybe b) -- ^ Predicate to select exceptions\n"
"	-> IO a		 	  -- ^ Computation to run\n"
"	-> (b -> IO a)		  -- ^ Handler\n"
"	-> IO a\n"
"catchJust p a handler = catch a handler'\n"
"  where handler' e = case p e of \n"
"			Nothing -> throw e\n"
"			Just b  -> handler b\n"
"\n"
"-- | A version of 'catch' with the arguments swapped around; useful in\n"
"-- situations where the code for the handler is shorter.  For example:\n"
"--\n"
"-- >   do handle (\\e -> exitWith (ExitFailure 1)) $\n"
"-- >	  ...\n"
"handle	   :: (Exception -> IO a) -> IO a -> IO a\n"
"handle     =  flip catch\n"
"\n"
"-- | A version of 'catchJust' with the arguments swapped around (see\n"
"-- 'handle').\n"
"handleJust :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a\n"
"handleJust p =  flip (catchJust p)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- evaluate\n"
"\n"
"-- | Forces its argument to be evaluated, and returns the result in\n"
"-- the 'IO' monad.  It can be used to order evaluation with respect to\n"
"-- other 'IO' operations; its semantics are given by\n"
"--\n"
"-- >   evaluate undefined `seq` return ()  ==> return ()\n"
"-- >   catch (evaluate undefined) (\\e -> return ())  ==> return ()\n"
"--\n"
"-- NOTE: @(evaluate a)@ is /not/ the same as @(a \\`seq\\` return a)@.\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- 'mapException'\n"
"\n"
"-- | This function maps one exception into another as proposed in the\n"
"-- paper \\\"A semantics for imprecise exceptions\\\".\n"
"\n"
"-- Notice that the usage of 'unsafePerformIO' is safe here.\n"
"\n"
"mapException :: (Exception -> Exception) -> a -> a\n"
"mapException f v = unsafePerformIO (catch (evaluate v)\n"
"                                          (\\x -> throw (f x)))\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- 'try' and variations.\n"
"\n"
"-- | Similar to 'catch', but returns an 'Either' result which is\n"
"-- @(Right a)@ if no exception was raised, or @(Left e)@ if an\n"
"-- exception was raised and its value is @e@.\n"
"--\n"
"-- >  try a = catch (Right \\`liftM\\` a) (return . Left)\n"
"--\n"
"-- Note: as with 'catch', it is only polite to use this variant if you intend\n"
"-- to re-throw the exception after performing whatever cleanup is needed.\n"
"-- Otherwise, 'tryJust' is generally considered to be better.\n"
"--\n"
"try :: IO a -> IO (Either Exception a)\n"
"try a = catch (a >>= \\ v -> return (Right v)) (\\e -> return (Left e))\n"
"\n"
"-- | A variant of 'try' that takes an exception predicate to select\n"
"-- which exceptions are caught (c.f. 'catchJust').  If the exception\n"
"-- does not match the predicate, it is re-thrown.\n"
"tryJust :: (Exception -> Maybe b) -> IO a -> IO (Either b a)\n"
"tryJust p a = do\n"
"  r <- try a\n"
"  case r of\n"
"	Right v -> return (Right v)\n"
"	Left  e -> case p e of\n"
"			Nothing -> throw e\n"
"			Just b  -> return (Left b)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Dynamic exceptions\n"
"\n"
"-- $dynamic\n"
"--  #DynamicExceptions# Because the 'Exception' datatype is not extensible, there is an\n"
"-- interface for throwing and catching exceptions of type 'Dynamic'\n"
"-- (see \"Data.Dynamic\") which allows exception values of any type in\n"
"-- the 'Typeable' class to be thrown and caught.\n"
"\n"
"-- | Raise any value as an exception, provided it is in the\n"
"-- 'Typeable' class.\n"
"throwDyn :: Typeable exception => exception -> b\n"
"throwDyn exception = throw (DynException (toDyn exception))\n"
"\n"
"-- | Catch dynamic exceptions of the required type.  All other\n"
"-- exceptions are re-thrown, including dynamic exceptions of the wrong\n"
"-- type.\n"
"--\n"
"-- When using dynamic exceptions it is advisable to define a new\n"
"-- datatype to use for your exception type, to avoid possible clashes\n"
"-- with dynamic exceptions used in other libraries.\n"
"--\n"
"catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a\n"
"catchDyn m k = catchException m handle\n"
"  where handle ex = case ex of\n"
"  			   (DynException dyn) ->\n"
"		  	  	case fromDynamic dyn of\n"
"				    Just exception  -> k exception\n"
"				    Nothing -> throw ex\n"
"			   _ -> throw ex\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Exception Predicates\n"
"\n"
"-- $preds\n"
"-- These pre-defined predicates may be used as the first argument to\n"
"-- 'catchJust', 'tryJust', or 'handleJust' to select certain common\n"
"-- classes of exceptions.\n"
"\n"
"ioErrors		:: Exception -> Maybe IOError\n"
"arithExceptions 	:: Exception -> Maybe ArithException\n"
"errorCalls		:: Exception -> Maybe String\n"
"assertions		:: Exception -> Maybe String\n"
"dynExceptions		:: Exception -> Maybe Dynamic\n"
"asyncExceptions 	:: Exception -> Maybe AsyncException\n"
"userErrors		:: Exception -> Maybe String\n"
"\n"
"ioErrors (IOException e) = Just e\n"
"ioErrors _ = Nothing\n"
"\n"
"arithExceptions (ArithException e) = Just e\n"
"arithExceptions _ = Nothing\n"
"\n"
"errorCalls (ErrorCall e) = Just e\n"
"errorCalls _ = Nothing\n"
"\n"
"assertions (AssertionFailed e) = Just e\n"
"assertions _ = Nothing\n"
"\n"
"dynExceptions (DynException e) = Just e\n"
"dynExceptions _ = Nothing\n"
"\n"
"asyncExceptions (AsyncException e) = Just e\n"
"asyncExceptions _ = Nothing\n"
"\n"
"userErrors (IOException e) | isUserError e = Just (ioeGetErrorString e)\n"
"userErrors _ = Nothing\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Some Useful Functions\n"
"\n"
"-- | When you want to acquire a resource, do some work with it, and\n"
"-- then release the resource, it is a good idea to use 'bracket',\n"
"-- because 'bracket' will install the necessary exception handler to\n"
"-- release the resource in the event that an exception is raised\n"
"-- during the computation.  If an exception is raised, then 'bracket' will \n"
"-- re-raise the exception (after performing the release).\n"
"--\n"
"-- A common example is opening a file:\n"
"--\n"
"-- > bracket\n"
"-- >   (openFile \"filename\" ReadMode)\n"
"-- >   (hClose)\n"
"-- >   (\\handle -> do { ... })\n"
"--\n"
"-- The arguments to 'bracket' are in this order so that we can partially apply \n"
"-- it, e.g.:\n"
"--\n"
"-- > withFile name = bracket (openFile name) hClose\n"
"--\n"
"bracket \n"
"	:: IO a		-- ^ computation to run first (\\\"acquire resource\\\")\n"
"	-> (a -> IO b)  -- ^ computation to run last (\\\"release resource\\\")\n"
"	-> (a -> IO c)	-- ^ computation to run in-between\n"
"	-> IO c		-- returns the value from the in-between computation\n"
"bracket before after thing =\n"
"  block (do\n"
"    a <- before \n"
"    r <- catch \n"
"	   (unblock (thing a))\n"
"	   (\\e -> do { after a; throw e })\n"
"    after a\n"
"    return r\n"
" )\n"
"   \n"
"\n"
"-- | A specialised variant of 'bracket' with just a computation to run\n"
"-- afterward.\n"
"-- \n"
"finally :: IO a		-- ^ computation to run first\n"
"	-> IO b		-- ^ computation to run afterward (even if an exception \n"
"			-- was raised)\n"
"	-> IO a		-- returns the value from the first computation\n"
"a `finally` sequel =\n"
"  block (do\n"
"    r <- catch \n"
"	     (unblock a)\n"
"	     (\\e -> do { sequel; throw e })\n"
"    sequel\n"
"    return r\n"
"  )\n"
"\n"
"-- | A variant of 'bracket' where the return value from the first computation\n"
"-- is not required.\n"
"bracket_ :: IO a -> IO b -> IO c -> IO c\n"
"bracket_ before after thing = bracket before (const after) (const thing)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Asynchronous exceptions\n"
"\n"
"{- $async\n"
"\n"
" #AsynchronousExceptions# Asynchronous exceptions are so-called because they arise due to\n"
"external influences, and can be raised at any point during execution.\n"
"'StackOverflow' and 'HeapOverflow' are two examples of\n"
"system-generated asynchronous exceptions.\n"
"\n"
"The primary source of asynchronous exceptions, however, is\n"
"'throwTo':\n"
"\n"
">  throwTo :: ThreadId -> Exception -> IO ()\n"
"\n"
"'throwTo' (also 'throwDynTo' and 'Control.Concurrent.killThread') allows one\n"
"running thread to raise an arbitrary exception in another thread.  The\n"
"exception is therefore asynchronous with respect to the target thread,\n"
"which could be doing anything at the time it receives the exception.\n"
"Great care should be taken with asynchronous exceptions; it is all too\n"
"easy to introduce race conditions by the over zealous use of\n"
"'throwTo'.\n"
"-}\n"
"\n"
"{- $block_handler\n"
"There\\'s an implied 'block' around every exception handler in a call\n"
"to one of the 'catch' family of functions.  This is because that is\n"
"what you want most of the time - it eliminates a common race condition\n"
"in starting an exception handler, because there may be no exception\n"
"handler on the stack to handle another exception if one arrives\n"
"immediately.  If asynchronous exceptions are blocked on entering the\n"
"handler, though, we have time to install a new exception handler\n"
"before being interrupted.  If this weren\\'t the default, one would have\n"
"to write something like\n"
"\n"
">      block (\n"
">           catch (unblock (...))\n"
">                      (\\e -> handler)\n"
">      )\n"
"\n"
"If you need to unblock asynchronous exceptions again in the exception\n"
"handler, just use 'unblock' as normal.\n"
"\n"
"Note that 'try' and friends /do not/ have a similar default, because\n"
"there is no exception handler in this case.  If you want to use 'try'\n"
"in an asynchronous-exception-safe way, you will need to use\n"
"'block'.\n"
"-}\n"
"\n"
"{- $interruptible\n"
"\n"
"Some operations are /interruptible/, which means that they can receive\n"
"asynchronous exceptions even in the scope of a 'block'.  Any function\n"
"which may itself block is defined as interruptible; this includes\n"
"'Control.Concurrent.MVar.takeMVar'\n"
"(but not 'Control.Concurrent.MVar.tryTakeMVar'),\n"
"and most operations which perform\n"
"some I\\/O with the outside world.  The reason for having\n"
"interruptible operations is so that we can write things like\n"
"\n"
">      block (\n"
">         a <- takeMVar m\n"
">         catch (unblock (...))\n"
">               (\\e -> ...)\n"
">      )\n"
"\n"
"if the 'Control.Concurrent.MVar.takeMVar' was not interruptible,\n"
"then this particular\n"
"combination could lead to deadlock, because the thread itself would be\n"
"blocked in a state where it can\\'t receive any asynchronous exceptions.\n"
"With 'Control.Concurrent.MVar.takeMVar' interruptible, however, we can be\n"
"safe in the knowledge that the thread can receive exceptions right up\n"
"until the point when the 'Control.Concurrent.MVar.takeMVar' succeeds.\n"
"Similar arguments apply for other interruptible operations like\n"
"'System.IO.openFile'.\n"
"-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Assert\n"
"\n"
"assert :: Bool -> a -> a\n"
"assert True x = x\n"
"assert False _ = throw (AssertionFailed \"\")\n";
const char *Control_Concurrent = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Concurrent\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (concurrency)\n"
"--\n"
"-- A common interface to a collection of useful concurrency\n"
"-- abstractions.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Concurrent (\n"
"	-- * Concurrent Haskell\n"
"\n"
"	-- $conc_intro\n"
"\n"
"	-- * Basic concurrency operations\n"
"\n"
"        ThreadId,\n"
"\n"
"	forkIO,\n"
"\n"
"	-- * Scheduling\n"
"\n"
"	-- $conc_scheduling	\n"
"	yield,         		-- :: IO ()\n"
"\n"
"	-- ** Blocking\n"
"	\n"
"	-- $blocking\n"
"\n"
"	-- * Communication abstractions\n"
"\n"
"	module Control.Concurrent.MVar,\n"
"	module Control.Concurrent.Chan,\n"
"	module Control.Concurrent.QSem,\n"
"	module Control.Concurrent.QSemN,\n"
"	module Control.Concurrent.SampleVar,\n"
"\n"
"	-- * Merging of streams\n"
"	-- $merge\n"
"\n"
"	-- * GHC's implementation of concurrency\n"
"\n"
"	-- |This section describes features specific to GHC's\n"
"	-- implementation of Concurrent Haskell.\n"
"	\n"
"	-- ** Terminating the program\n"
"\n"
"	-- $termination\n"
"\n"
"	-- ** Pre-emption\n"
"\n"
"	-- $preemption\n"
"    ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Exception as Exception\n"
"\n"
"import Hugs.ConcBase\n"
"\n"
"import Control.Concurrent.MVar\n"
"import Control.Concurrent.Chan\n"
"import Control.Concurrent.QSem\n"
"import Control.Concurrent.QSemN\n"
"import Control.Concurrent.SampleVar\n"
"\n"
"type ThreadId = ()\n"
"\n"
"{- $conc_intro\n"
"\n"
"The concurrency extension for Haskell is described in the paper\n"
"/Concurrent Haskell/\n"
"<http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz>.\n"
"\n"
"Concurrency is \\\"lightweight\\\", which means that both thread creation\n"
"and context switching overheads are extremely low.  Scheduling of\n"
"Haskell threads is done internally in the Haskell runtime system, and\n"
"doesn't make use of any operating system-supplied thread packages.\n"
"\n"
"However, if you want to interact with a foreign library that expects your\n"
"program to use the operating system-supplied thread package, you can do so\n"
"by using 'forkOS' instead of 'forkIO'.\n"
"\n"
"Haskell threads can communicate via 'MVar's, a kind of synchronised\n"
"mutable variable (see \"Control.Concurrent.MVar\").  Several common\n"
"concurrency abstractions can be built from 'MVar's, and these are\n"
"provided by the \"Control.Concurrent\" library.\n"
"In GHC, threads may also communicate via exceptions.\n"
"-}\n"
"\n"
"{- $conc_scheduling\n"
"\n"
"    Scheduling may be either pre-emptive or co-operative,\n"
"    depending on the implementation of Concurrent Haskell (see below\n"
"    for imformation related to specific compilers).  In a co-operative\n"
"    system, context switches only occur when you use one of the\n"
"    primitives defined in this module.  This means that programs such\n"
"    as:\n"
"\n"
">   main = forkIO (write 'a') >> write 'b'\n"
">     where write c = putChar c >> write c\n"
"\n"
"    will print either @aaaaaaaaaaaaaa...@ or @bbbbbbbbbbbb...@,\n"
"    instead of some random interleaving of @a@s and @b@s.  In\n"
"    practice, cooperative multitasking is sufficient for writing\n"
"    simple graphical user interfaces.  \n"
"-}\n"
"\n"
"{- $blocking\n"
"Calling a foreign C procedure (such as @getchar@) that blocks waiting\n"
"for input will block /all/ threads, unless the @threadsafe@ attribute\n"
"is used on the foreign call (and your compiler \\/ operating system\n"
"supports it).  GHC's I\\/O system uses non-blocking I\\/O internally to\n"
"implement thread-friendly I\\/O, so calling standard Haskell I\\/O\n"
"functions blocks only the thread making the call.\n"
"-}\n"
"\n"
"-- Thread Ids, specifically the instances of Eq and Ord for these things.\n"
"-- The ThreadId type itself is defined in std/PrelConc.lhs.\n"
"\n"
"-- Rather than define a new primitve, we use a little helper function\n"
"-- cmp_thread in the RTS.\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- More docs\n"
"\n"
"{- $termination\n"
"\n"
"      In a standalone GHC program, only the main thread is\n"
"      required to terminate in order for the process to terminate.\n"
"      Thus all other forked threads will simply terminate at the same\n"
"      time as the main thread (the terminology for this kind of\n"
"      behaviour is \\\"daemonic threads\\\").\n"
"\n"
"      If you want the program to wait for child threads to\n"
"      finish before exiting, you need to program this yourself.  A\n"
"      simple mechanism is to have each child thread write to an\n"
"      'MVar' when it completes, and have the main\n"
"      thread wait on all the 'MVar's before\n"
"      exiting:\n"
"\n"
">   myForkIO :: IO () -> IO (MVar ())\n"
">   myForkIO io = do\n"
">     mvar \\<- newEmptyMVar\n"
">     forkIO (io \\`finally\\` putMVar mvar ())\n"
">     return mvar\n"
"\n"
"      Note that we use 'finally' from the\n"
"      \"Control.Exception\" module to make sure that the\n"
"      'MVar' is written to even if the thread dies or\n"
"      is killed for some reason.\n"
"\n"
"      A better method is to keep a global list of all child\n"
"      threads which we should wait for at the end of the program:\n"
"\n"
">     children :: MVar [MVar ()]\n"
">     children = unsafePerformIO (newMVar [])\n"
">     \n"
">     waitForChildren :: IO ()\n"
">     waitForChildren = do\n"
">     	(mvar:mvars) \\<- takeMVar children\n"
">     	putMVar children mvars\n"
">     	takeMVar mvar\n"
">     	waitForChildren\n"
">     \n"
">     forkChild :: IO () -> IO ()\n"
">     forkChild io = do\n"
">     	 mvar \\<- newEmptyMVar\n"
">     	 forkIO (p \\`finally\\` putMVar mvar ())\n"
">     	 childs \\<- takeMVar children\n"
">     	 putMVar children (mvar:childs)\n"
">     \n"
">     later = flip finally\n"
">     \n"
">     main =\n"
">     	later waitForChildren $\n"
">     	...\n"
"\n"
"      The main thread principle also applies to calls to Haskell from\n"
"      outside, using @foreign export@.  When the @foreign export@ed\n"
"      function is invoked, it starts a new main thread, and it returns\n"
"      when this main thread terminates.  If the call causes new\n"
"      threads to be forked, they may remain in the system after the\n"
"      @foreign export@ed function has returned.\n"
"-}\n"
"\n"
"{- $preemption\n"
"\n"
"      GHC implements pre-emptive multitasking: the execution of\n"
"      threads are interleaved in a random fashion.  More specifically,\n"
"      a thread may be pre-empted whenever it allocates some memory,\n"
"      which unfortunately means that tight loops which do no\n"
"      allocation tend to lock out other threads (this only seems to\n"
"      happen with pathalogical benchmark-style code, however).\n"
"\n"
"      The rescheduling timer runs on a 20ms granularity by\n"
"      default, but this may be altered using the\n"
"      @-i\\<n\\>@ RTS option.  After a rescheduling\n"
"      \\\"tick\\\" the running thread is pre-empted as soon as\n"
"      possible.\n"
"\n"
"      One final note: the\n"
"      @aaaa@ @bbbb@ example may not\n"
"      work too well on GHC (see Scheduling, above), due\n"
"      to the locking on a 'System.IO.Handle'.  Only one thread\n"
"      may hold the lock on a 'System.IO.Handle' at any one\n"
"      time, so if a reschedule happens while a thread is holding the\n"
"      lock, the other thread won't be able to run.  The upshot is that\n"
"      the switch from @aaaa@ to\n"
"      @bbbbb@ happens infrequently.  It can be\n"
"      improved by lowering the reschedule tick period.  We also have a\n"
"      patch that causes a reschedule whenever a thread waiting on a\n"
"      lock is woken up, but haven't found it to be useful for anything\n"
"      other than this example :-)\n"
"-}\n";
const char *Control_Monad = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- The 'Functor', 'Monad' and 'MonadPlus' classes,\n"
"-- with some useful operations on monads.\n"
"\n"
"module Control.Monad\n"
"    (\n"
"    -- * Functor and monad classes\n"
"\n"
"      Functor(fmap)\n"
"    , Monad((>>=), (>>), return, fail)\n"
"\n"
"    , MonadPlus (   -- class context: Monad\n"
"	  mzero     -- :: (MonadPlus m) => m a\n"
"	, mplus     -- :: (MonadPlus m) => m a -> m a -> m a\n"
"	)\n"
"    -- * Functions\n"
"\n"
"    -- ** Naming conventions\n"
"    -- $naming\n"
"\n"
"    -- ** Basic functions from the \"Prelude\"\n"
"\n"
"    , mapM          -- :: (Monad m) => (a -> m b) -> [a] -> m [b]\n"
"    , mapM_         -- :: (Monad m) => (a -> m b) -> [a] -> m ()\n"
"    , sequence      -- :: (Monad m) => [m a] -> m [a]\n"
"    , sequence_     -- :: (Monad m) => [m a] -> m ()\n"
"    , (=<<)         -- :: (Monad m) => (a -> m b) -> m a -> m b\n"
"\n"
"    -- ** Generalisations of list functions\n"
"\n"
"    , join          -- :: (Monad m) => m (m a) -> m a\n"
"    , msum          -- :: (MonadPlus m) => [m a] -> m a\n"
"    , filterM       -- :: (Monad m) => (a -> m Bool) -> [a] -> m [a]\n"
"    , mapAndUnzipM  -- :: (Monad m) => (a -> m (b,c)) -> [a] -> m ([b], [c])\n"
"    , zipWithM      -- :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]\n"
"    , zipWithM_     -- :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()\n"
"    , foldM         -- :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a \n"
"    , foldM_        -- :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m ()\n"
"    , replicateM    -- :: (Monad m) => Int -> m a -> m [a]\n"
"    , replicateM_   -- :: (Monad m) => Int -> m a -> m ()\n"
"\n"
"    -- ** Conditional execution of monadic expressions\n"
"\n"
"    , guard         -- :: (MonadPlus m) => Bool -> m ()\n"
"    , when          -- :: (Monad m) => Bool -> m () -> m ()\n"
"    , unless        -- :: (Monad m) => Bool -> m () -> m ()\n"
"\n"
"    -- ** Monadic lifting operators\n"
"    -- $lifting\n"
"\n"
"    , liftM         -- :: (Monad m) => (a -> b) -> (m a -> m b)\n"
"    , liftM2        -- :: (Monad m) => (a -> b -> c) -> (m a -> m b -> m c)\n"
"    , liftM3        -- :: ...\n"
"    , liftM4        -- :: ...\n"
"    , liftM5        -- :: ...\n"
"\n"
"    , ap            -- :: (Monad m) => m (a -> b) -> m a -> m b\n"
"\n"
"    ) where\n"
"\n"
"import Data.Maybe\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- |The MonadPlus class definition\n"
"\n"
"class Monad m => MonadPlus m where\n"
"   mzero :: m a\n"
"   mplus :: m a -> m a -> m a\n"
"\n"
"instance MonadPlus [] where\n"
"   mzero = []\n"
"   mplus = (++)\n"
"\n"
"instance MonadPlus Maybe where\n"
"   mzero = Nothing\n"
"\n"
"   Nothing `mplus` ys  = ys\n"
"   xs      `mplus` _ys = xs\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Functions mandated by the Prelude\n"
"\n"
"guard           :: (MonadPlus m) => Bool -> m ()\n"
"guard True      =  return ()\n"
"guard False     =  mzero\n"
"\n"
"-- This subsumes the list-based filter function.\n"
"\n"
"filterM          :: (Monad m) => (a -> m Bool) -> [a] -> m [a]\n"
"filterM _ []     =  return []\n"
"filterM p (x:xs) =  do\n"
"   flg <- p x\n"
"   ys  <- filterM p xs\n"
"   return (if flg then x:ys else ys)\n"
"\n"
"-- This subsumes the list-based concat function.\n"
"\n"
"msum        :: MonadPlus m => [m a] -> m a\n"
"{-# INLINE msum #-}\n"
"msum        =  foldr mplus mzero\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Other monad functions\n"
"\n"
"-- | The 'join' function is the conventional monad join operator. It is used to\n"
"-- remove one level of monadic structure, projecting its bound argument into the\n"
"-- outer level.\n"
"join              :: (Monad m) => m (m a) -> m a\n"
"join x            =  x >>= id\n"
"\n"
"-- | The 'mapAndUnzipM' function maps its first argument over a list, returning\n"
"-- the result as a pair of lists. This function is mainly used with complicated\n"
"-- data structures or a state-transforming monad.\n"
"mapAndUnzipM      :: (Monad m) => (a -> m (b,c)) -> [a] -> m ([b], [c])\n"
"mapAndUnzipM f xs =  sequence (map f xs) >>= return . unzip\n"
"\n"
"-- | The 'zipWithM' function generalises 'zipWith' to arbitrary monads.\n"
"zipWithM          :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]\n"
"zipWithM f xs ys  =  sequence (zipWith f xs ys)\n"
"\n"
"-- | 'zipWithM_' is the extension of 'zipWithM' which ignores the final result.\n"
"zipWithM_         :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()\n"
"zipWithM_ f xs ys =  sequence_ (zipWith f xs ys)\n"
"\n"
"{- | The 'foldM' function is analogous to 'foldl', except that its result is\n"
"encapsulated in a monad. Note that 'foldM' works from left-to-right over\n"
"the list arguments. This could be an issue where '(>>)' and the `folded\n"
"function' are not commutative.\n"
"\n"
">	foldM f a1 [x1, x2, ..., xm ]\n"
"\n"
"==  \n"
"\n"
">	do\n"
">	  a2 <- f a1 x1\n"
">	  a3 <- f a2 x2\n"
">	  ...\n"
">	  f am xm\n"
"\n"
"If right-to-left evaluation is required, the input list should be reversed.\n"
"-}\n"
"\n"
"foldM             :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a\n"
"foldM _ a []      =  return a\n"
"foldM f a (x:xs)  =  f a x >>= \\fax -> foldM f fax xs\n"
"\n"
"foldM_            :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m ()\n"
"foldM_ f a xs     = foldM f a xs >> return ()\n"
"\n"
"replicateM        :: (Monad m) => Int -> m a -> m [a]\n"
"replicateM n x    = sequence (replicate n x)\n"
"\n"
"replicateM_       :: (Monad m) => Int -> m a -> m ()\n"
"replicateM_ n x   = sequence_ (replicate n x)\n"
"\n"
"{- | Conditional execution of monadic expressions. For example, \n"
"\n"
">	when debug (putStr \"Debugging\\n\")\n"
"\n"
"will output the string @Debugging\\\\n@ if the Boolean value @debug@ is 'True',\n"
"and otherwise do nothing.\n"
"-}\n"
"\n"
"when              :: (Monad m) => Bool -> m () -> m ()\n"
"when p s          =  if p then s else return ()\n"
"\n"
"-- | The reverse of 'when'.\n"
"\n"
"unless            :: (Monad m) => Bool -> m () -> m ()\n"
"unless p s        =  if p then return () else s\n"
"\n"
"{- $lifting\n"
"\n"
"The monadic lifting operators promote a function to a monad.\n"
"The function arguments are scanned left to right. For example, \n"
"\n"
">	liftM2 (+) [0,1] [0,2] = [0,2,1,3]\n"
">	liftM2 (+) (Just 1) Nothing = Nothing\n"
"\n"
"-}\n"
"\n"
"liftM   :: (Monad m) => (a1 -> r) -> m a1 -> m r\n"
"liftM2  :: (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r\n"
"liftM3  :: (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r\n"
"liftM4  :: (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r\n"
"liftM5  :: (Monad m) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r\n"
"\n"
"liftM f m1              = do { x1 <- m1; return (f x1) }\n"
"liftM2 f m1 m2          = do { x1 <- m1; x2 <- m2; return (f x1 x2) }\n"
"liftM3 f m1 m2 m3       = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }\n"
"liftM4 f m1 m2 m3 m4    = do { x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; return (f x1 x2 x3 x4) }\n"
"liftM5 f m1 m2 m3 m4 m5 = do { x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; x5 <- m5; return (f x1 x2 x3 x4 x5) }\n"
"\n"
"{- | In many situations, the 'liftM' operations can be replaced by uses of\n"
"'ap', which promotes function application. \n"
"\n"
">	return f `ap` x1 `ap` ... `ap` xn\n"
"\n"
"is equivalent to \n"
"\n"
">	liftMn f x1 x2 ... xn\n"
"\n"
"-}\n"
"\n"
"ap                :: (Monad m) => m (a -> b) -> m a -> m b\n"
"ap                =  liftM2 id\n"
"\n"
"{- $naming\n"
"\n"
"The functions in this library use the following naming conventions: \n"
"\n"
"* A postfix \\`M\\' always stands for a function in the Kleisli category:\n"
"  @m@ is added to function results (modulo currying) and nowhere else.\n"
"  So, for example, \n"
"\n"
">  filter  ::              (a ->   Bool) -> [a] ->   [a]\n"
">  filterM :: (Monad m) => (a -> m Bool) -> [a] -> m [a]\n"
"\n"
"* A postfix \\`_\\' changes the result type from @(m a)@ to @(m ())@.\n"
"  Thus (in the \"Prelude\"): \n"
"\n"
">  sequence  :: Monad m => [m a] -> m [a] \n"
">  sequence_ :: Monad m => [m a] -> m () \n"
"\n"
"* A prefix \\`m\\' generalises an existing function to a monadic form.\n"
"  Thus, for example: \n"
"\n"
">  sum  :: Num a       => [a]   -> a\n"
">  msum :: MonadPlus m => [m a] -> m a\n"
"\n"
"-}\n";
const char *Control_Arrow = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Arrow\n"
"-- Copyright   :  (c) Ross Paterson 2002\n"
"-- License     :  BSD-style (see the LICENSE file in the distribution)\n"
"--\n"
"-- Maintainer  :  ross@soi.city.ac.uk\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- Basic arrow definitions, based on\n"
"--	/Generalising Monads to Arrows/, by John Hughes,\n"
"--	/Science of Computer Programming/ 37, pp67-111, May 2000.\n"
"-- plus a couple of definitions ('returnA' and 'loop') from\n"
"--	/A New Notation for Arrows/, by Ross Paterson, in /ICFP 2001/,\n"
"--	Firenze, Italy, pp229-240.\n"
"-- See these papers for the equations these combinators are expected to\n"
"-- satisfy.  These papers and more information on arrows can be found at\n"
"-- <http://www.haskell.org/arrows/>.\n"
"\n"
"module Control.Arrow (\n"
"		-- * Arrows\n"
"		Arrow(..), Kleisli(..),\n"
"		-- ** Derived combinators\n"
"		returnA, (<<<),\n"
"		-- * Monoid operations\n"
"		ArrowZero(..), ArrowPlus(..),\n"
"		-- * Conditionals\n"
"		ArrowChoice(..),\n"
"		-- * Arrow application\n"
"		ArrowApply(..), ArrowMonad(..), leftApp,\n"
"		-- * Feedback\n"
"		ArrowLoop(..)\n"
"	) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Monad\n"
"import Control.Monad.Fix\n"
"\n"
"infixr 5 <+>\n"
"infixr 3 ***\n"
"infixr 3 &&&\n"
"infixr 2 +++\n"
"infixr 2 |||\n"
"infixr 1 >>>\n"
"infixr 1 <<<\n"
"\n"
"-- | The basic arrow class.\n"
"--   Any instance must define either 'arr' or 'pure' (which are synonyms),\n"
"--   as well as '>>>' and 'first'.  The other combinators have sensible\n"
"--   default definitions, which may be overridden for efficiency.\n"
"\n"
"class Arrow a where\n"
"\n"
"	-- | Lift a function to an arrow: you must define either this\n"
"	--   or 'pure'.\n"
"	arr :: (b -> c) -> a b c\n"
"	arr = pure\n"
"\n"
"	-- | A synonym for 'arr': you must define one or other of them.\n"
"	pure :: (b -> c) -> a b c\n"
"	pure = arr\n"
"\n"
"	-- | Left-to-right composition of arrows.\n"
"	(>>>) :: a b c -> a c d -> a b d\n"
"\n"
"	-- | Send the first component of the input through the argument\n"
"	--   arrow, and copy the rest unchanged to the output.\n"
"	first :: a b c -> a (b,d) (c,d)\n"
"\n"
"	-- | A mirror image of 'first'.\n"
"	--\n"
"	--   The default definition may be overridden with a more efficient\n"
"	--   version if desired.\n"
"	second :: a b c -> a (d,b) (d,c)\n"
"	second f = arr swap >>> first f >>> arr swap\n"
"			where	swap ~(x,y) = (y,x)\n"
"\n"
"	-- | Split the input between the two argument arrows and combine\n"
"	--   their output.  Note that this is in general not a functor.\n"
"	--\n"
"	--   The default definition may be overridden with a more efficient\n"
"	--   version if desired.\n"
"	(***) :: a b c -> a b' c' -> a (b,b') (c,c')\n"
"	f *** g = first f >>> second g\n"
"\n"
"	-- | Fanout: send the input to both argument arrows and combine\n"
"	--   their output.\n"
"	--\n"
"	--   The default definition may be overridden with a more efficient\n"
"	--   version if desired.\n"
"	(&&&) :: a b c -> a b c' -> a b (c,c')\n"
"	f &&& g = arr (\\b -> (b,b)) >>> f *** g\n"
"\n"
"-- Ordinary functions are arrows.\n"
"\n"
"instance Arrow (->) where\n"
"	arr f = f\n"
"	f >>> g = g . f\n"
"	first f = f *** id\n"
"	second f = id *** f\n"
"--	(f *** g) ~(x,y) = (f x, g y)\n"
"--	sorry, although the above defn is fully H'98, nhc98 can't parse it.\n"
"	(***) f g ~(x,y) = (f x, g y)\n"
"\n"
"-- | Kleisli arrows of a monad.\n"
"\n"
"newtype Kleisli m a b = Kleisli (a -> m b)\n"
"\n"
"instance Monad m => Arrow (Kleisli m) where\n"
"	arr f = Kleisli (return . f)\n"
"	Kleisli f >>> Kleisli g = Kleisli (\\b -> f b >>= g)\n"
"	first (Kleisli f) = Kleisli (\\ ~(b,d) -> f b >>= \\c -> return (c,d))\n"
"	second (Kleisli f) = Kleisli (\\ ~(d,b) -> f b >>= \\c -> return (d,c))\n"
"\n"
"-- | The identity arrow, which plays the role of 'return' in arrow notation.\n"
"\n"
"returnA :: Arrow a => a b b\n"
"returnA = arr id\n"
"\n"
"-- | Right-to-left composition, for a better fit with arrow notation.\n"
"\n"
"(<<<) :: Arrow a => a c d -> a b c -> a b d\n"
"f <<< g = g >>> f\n"
"\n"
"class Arrow a => ArrowZero a where\n"
"	zeroArrow :: a b c\n"
"\n"
"instance MonadPlus m => ArrowZero (Kleisli m) where\n"
"	zeroArrow = Kleisli (\\x -> mzero)\n"
"\n"
"class ArrowZero a => ArrowPlus a where\n"
"	(<+>) :: a b c -> a b c -> a b c\n"
"\n"
"instance MonadPlus m => ArrowPlus (Kleisli m) where\n"
"	Kleisli f <+> Kleisli g = Kleisli (\\x -> f x `mplus` g x)\n"
"\n"
"-- | Choice, for arrows that support it.  This class underlies the\n"
"--   @if@ and @case@ constructs in arrow notation.\n"
"--   Any instance must define 'left'.  The other combinators have sensible\n"
"--   default definitions, which may be overridden for efficiency.\n"
"\n"
"class Arrow a => ArrowChoice a where\n"
"\n"
"	-- | Feed marked inputs through the argument arrow, passing the\n"
"	--   rest through unchanged to the output.\n"
"	left :: a b c -> a (Either b d) (Either c d)\n"
"\n"
"	-- | A mirror image of 'left'.\n"
"	--\n"
"	--   The default definition may be overridden with a more efficient\n"
"	--   version if desired.\n"
"	right :: a b c -> a (Either d b) (Either d c)\n"
"	right f = arr mirror >>> left f >>> arr mirror\n"
"			where	mirror (Left x) = Right x\n"
"				mirror (Right y) = Left y\n"
"\n"
"	-- | Split the input between the two argument arrows, retagging\n"
"	--   and merging their outputs.\n"
"	--   Note that this is in general not a functor.\n"
"	--\n"
"	--   The default definition may be overridden with a more efficient\n"
"	--   version if desired.\n"
"	(+++) :: a b c -> a b' c' -> a (Either b b') (Either c c')\n"
"	f +++ g = left f >>> right g\n"
"\n"
"	-- | Fanin: Split the input between the two argument arrows and\n"
"	--   merge their outputs.\n"
"	--\n"
"	--   The default definition may be overridden with a more efficient\n"
"	--   version if desired.\n"
"	(|||) :: a b d -> a c d -> a (Either b c) d\n"
"	f ||| g = f +++ g >>> arr untag\n"
"			where	untag (Left x) = x\n"
"				untag (Right y) = y\n"
"\n"
"instance ArrowChoice (->) where\n"
"	left f = f +++ id\n"
"	right f = id +++ f\n"
"	f +++ g = (Left . f) ||| (Right . g)\n"
"	(|||) = either\n"
"\n"
"instance Monad m => ArrowChoice (Kleisli m) where\n"
"	left f = f +++ arr id\n"
"	right f = arr id +++ f\n"
"	f +++ g = (f >>> arr Left) ||| (g >>> arr Right)\n"
"	Kleisli f ||| Kleisli g = Kleisli (either f g)\n"
"\n"
"-- | Some arrows allow application of arrow inputs to other inputs.\n"
"\n"
"class Arrow a => ArrowApply a where\n"
"	app :: a (a b c, b) c\n"
"\n"
"instance ArrowApply (->) where\n"
"	app (f,x) = f x\n"
"\n"
"instance Monad m => ArrowApply (Kleisli m) where\n"
"	app = Kleisli (\\(Kleisli f, x) -> f x)\n"
"\n"
"-- | The 'ArrowApply' class is equivalent to 'Monad': any monad gives rise\n"
"--   to a 'Kleisli' arrow, and any instance of 'ArrowApply' defines a monad.\n"
"\n"
"newtype ArrowApply a => ArrowMonad a b = ArrowMonad (a () b)\n"
"\n"
"instance ArrowApply a => Monad (ArrowMonad a) where\n"
"	return x = ArrowMonad (arr (\\z -> x))\n"
"	ArrowMonad m >>= f = ArrowMonad (m >>>\n"
"			arr (\\x -> let ArrowMonad h = f x in (h, ())) >>>\n"
"			app)\n"
"\n"
"-- | Any instance of 'ArrowApply' can be made into an instance of\n"
"--   'ArrowChoice' by defining 'left' = 'leftApp'.\n"
"\n"
"leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)\n"
"leftApp f = arr ((\\b -> (arr (\\() -> b) >>> f >>> arr Left, ())) |||\n"
"		 (\\d -> (arr (\\() -> d) >>> arr Right, ()))) >>> app\n"
"\n"
"-- | The 'loop' operator expresses computations in which an output value is\n"
"--   fed back as input, even though the computation occurs only once.\n"
"--   It underlies the @rec@ value recursion construct in arrow notation.\n"
"\n"
"class Arrow a => ArrowLoop a where\n"
"	loop :: a (b,d) (c,d) -> a b c\n"
"\n"
"instance ArrowLoop (->) where\n"
"	loop f b = let (c,d) = f (b,d) in c\n"
"\n"
"instance MonadFix m => ArrowLoop (Kleisli m) where\n"
"	loop (Kleisli f) = Kleisli (liftM fst . mfix . f')\n"
"		where	f' x y = f (x, snd y)\n";
const char *Control_Parallel = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Parallel\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- Parallel Constructs\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Parallel (\n"
"          par, seq -- re-exported\n"
"    ) where\n"
"\n"
"import Prelude\n"
"\n"
"-- Maybe parIO and the like could be added here later.\n"
"-- For now, Hugs does not support par properly.\n"
"par a b = b\n";
const char *Control_Monad_ST = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.ST\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (requires universal quantification for runST)\n"
"--\n"
"-- This library provides support for /strict/ state threads, as\n"
"-- described in the PLDI \\'94 paper by John Launchbury and Simon Peyton\n"
"-- Jones /Lazy State Threads/.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.ST\n"
"  (\n"
"	-- * The 'ST' Monad\n"
"	ST,		-- abstract, instance of Functor, Monad, Typeable.\n"
"	runST,		-- :: (forall s. ST s a) -> a\n"
"	fixST,		-- :: (a -> ST s a) -> ST s a\n"
"\n"
"	-- * Converting 'ST' to 'IO'\n"
"	RealWorld,		-- abstract\n"
"	stToIO,			-- :: ST RealWorld a -> IO a\n"
"\n"
"	-- * Unsafe operations\n"
"	unsafeInterleaveST,  	-- :: ST s a -> ST s a\n"
"	unsafeIOToST		-- :: IO a -> ST s a\n"
"      ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Monad.Fix\n"
"import Data.Typeable\n"
"\n"
"import Hugs.ST\n"
"import qualified Hugs.LazyST as LazyST\n"
"\n"
"fixST :: (a -> ST s a) -> ST s a\n"
"fixST f = LazyST.lazyToStrictST (LazyST.fixST (LazyST.strictToLazyST . f))\n"
"\n"
"unsafeInterleaveST :: ST s a -> ST s a\n"
"unsafeInterleaveST =\n"
"    LazyST.lazyToStrictST . LazyST.unsafeInterleaveST . LazyST.strictToLazyST\n"
"\n"
"instance MonadFix (ST s) where\n"
"	mfix = fixST\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Typeable instance\n"
"\n"
"sTTc :: TyCon\n"
"sTTc = mkTyCon \"ST\"\n"
"\n"
"instance (Typeable a, Typeable b) => Typeable (ST a b) where\n"
"  typeOf st = mkAppTy sTTc [typeOf ((undefined :: ST a b -> a) st),\n"
"			    typeOf ((undefined :: ST a b -> b) st)]\n";
const char *Control_Monad_RWS = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.RWS\n"
"-- Copyright   :  (c) Andy Gill 2001,\n"
"--		  (c) Oregon Graduate Institute of Science and Technology, 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (multi-param classes, functional dependencies)\n"
"--\n"
"-- Declaration of the MonadRWS class.\n"
"--\n"
"--	  Inspired by the paper\n"
"--	  /Functional Programming with Overloading and\n"
"--	      Higher-Order Polymorphism/, \n"
"--	    Mark P Jones (<http://www.cse.ogi.edu/~mpj/>)\n"
"--		  Advanced School of Functional Programming, 1995.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.RWS (\n"
"	RWS(..),\n"
"	evalRWS,\n"
"	execRWS,\n"
"	mapRWS,\n"
"	withRWS,\n"
"	RWST(..),\n"
"	evalRWST,\n"
"	execRWST,\n"
"	mapRWST,\n"
"	withRWST,\n"
"	module Control.Monad.Reader,\n"
"	module Control.Monad.Writer,\n"
"	module Control.Monad.State,\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Monad\n"
"import Control.Monad.Fix\n"
"import Control.Monad.Trans\n"
"import Control.Monad.Reader\n"
"import Control.Monad.Writer\n"
"import Control.Monad.State\n"
"import Data.Monoid\n"
"\n"
"newtype RWS r w s a = RWS { runRWS :: r -> s -> (a, s, w) }\n"
"\n"
"instance Functor (RWS r w s) where\n"
"	fmap f m = RWS $ \\r s -> let\n"
"		(a, s', w) = runRWS m r s\n"
"		in (f a, s', w)\n"
"\n"
"instance (Monoid w) => Monad (RWS r w s) where\n"
"	return a = RWS $ \\_ s -> (a, s, mempty)\n"
"	m >>= k  = RWS $ \\r s -> let\n"
"		(a, s',  w)  = runRWS m r s\n"
"		(b, s'', w') = runRWS (k a) r s'\n"
"		in (b, s'', w `mappend` w')\n"
"\n"
"instance (Monoid w) => MonadFix (RWS r w s) where\n"
"	mfix f = RWS $ \\r s -> let (a, s', w) = runRWS (f a) r s in (a, s', w)\n"
"\n"
"instance (Monoid w) => MonadReader r (RWS r w s) where\n"
"	ask       = RWS $ \\r s -> (r, s, mempty)\n"
"	local f m = RWS $ \\r s -> runRWS m (f r) s\n"
"\n"
"instance (Monoid w) => MonadWriter w (RWS r w s) where\n"
"	tell   w = RWS $ \\_ s -> ((), s, w)\n"
"	listen m = RWS $ \\r s -> let\n"
"		(a, s', w) = runRWS m r s\n"
"		in ((a, w), s', w)\n"
"	pass   m = RWS $ \\r s -> let\n"
"		((a, f), s', w) = runRWS m r s\n"
"		in (a, s', f w)\n"
"\n"
"instance (Monoid w) => MonadState s (RWS r w s) where\n"
"	get   = RWS $ \\_ s -> (s, s, mempty)\n"
"	put s = RWS $ \\_ _ -> ((), s, mempty)\n"
"\n"
"evalRWS :: RWS r w s a -> r -> s -> (a, w)\n"
"evalRWS m r s = let\n"
"    (a, _, w) = runRWS m r s\n"
"    in (a, w)\n"
"\n"
"execRWS :: RWS r w s a -> r -> s -> (s, w)\n"
"execRWS m r s = let\n"
"    (_, s', w) = runRWS m r s\n"
"    in (s', w)\n"
"\n"
"mapRWS :: ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b\n"
"mapRWS f m = RWS $ \\r s -> f (runRWS m r s)\n"
"\n"
"withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a\n"
"withRWS f m = RWS $ \\r s -> uncurry (runRWS m) (f r s)\n"
"\n"
"newtype RWST r w s m a = RWST { runRWST :: r -> s -> m (a, s, w) }\n"
"\n"
"instance (Monad m) => Functor (RWST r w s m) where\n"
"	fmap f m = RWST $ \\r s -> do\n"
"		(a, s', w) <- runRWST m r s\n"
"		return (f a, s', w)\n"
"\n"
"instance (Monoid w, Monad m) => Monad (RWST r w s m) where\n"
"	return a = RWST $ \\_ s -> return (a, s, mempty)\n"
"	m >>= k  = RWST $ \\r s -> do\n"
"		(a, s', w)  <- runRWST m r s\n"
"		(b, s'',w') <- runRWST (k a) r s'\n"
"		return (b, s'', w `mappend` w')\n"
"	fail msg = RWST $ \\_ _ -> fail msg\n"
"\n"
"instance (Monoid w, MonadPlus m) => MonadPlus (RWST r w s m) where\n"
"	mzero       = RWST $ \\_ _ -> mzero\n"
"	m `mplus` n = RWST $ \\r s -> runRWST m r s `mplus` runRWST n r s\n"
"\n"
"instance (Monoid w, MonadFix m) => MonadFix (RWST r w s m) where\n"
"	mfix f = RWST $ \\r s -> mfix $ \\ ~(a, _, _) -> runRWST (f a) r s\n"
"\n"
"instance (Monoid w, Monad m) => MonadReader r (RWST r w s m) where\n"
"	ask       = RWST $ \\r s -> return (r, s, mempty)\n"
"	local f m = RWST $ \\r s -> runRWST m (f r) s\n"
"\n"
"instance (Monoid w, Monad m) => MonadWriter w (RWST r w s m) where\n"
"	tell   w = RWST $ \\_ s -> return ((),s,w)\n"
"	listen m = RWST $ \\r s -> do\n"
"		(a, s', w) <- runRWST m r s\n"
"		return ((a, w), s', w)\n"
"	pass   m = RWST $ \\r s -> do\n"
"		((a, f), s', w) <- runRWST m r s\n"
"		return (a, s', f w)\n"
"\n"
"instance (Monoid w, Monad m) => MonadState s (RWST r w s m) where\n"
"	get   = RWST $ \\_ s -> return (s, s, mempty)\n"
"	put s = RWST $ \\_ _ -> return ((), s, mempty)\n"
"\n"
"instance (Monoid w) => MonadTrans (RWST r w s) where\n"
"	lift m = RWST $ \\_ s -> do\n"
"		a <- m\n"
"		return (a, s, mempty)\n"
"\n"
"instance (Monoid w, MonadIO m) => MonadIO (RWST r w s m) where\n"
"	liftIO = lift . liftIO\n"
"\n"
"evalRWST :: (Monad m) => RWST r w s m a -> r -> s -> m (a, w)\n"
"evalRWST m r s = do\n"
"    (a, _, w) <- runRWST m r s\n"
"    return (a, w)\n"
"\n"
"execRWST :: (Monad m) => RWST r w s m a -> r -> s -> m (s, w)\n"
"execRWST m r s = do\n"
"    (_, s', w) <- runRWST m r s\n"
"    return (s', w)\n"
"\n"
"mapRWST :: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b\n"
"mapRWST f m = RWST $ \\r s -> f (runRWST m r s)\n"
"\n"
"withRWST :: (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a\n"
"withRWST f m = RWST $ \\r s -> uncurry (runRWST m) (f r s)\n";
const char *Control_Monad_Fix = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.Fix\n"
"-- Copyright   :  (c) Andy Gill 2001,\n"
"--		  (c) Oregon Graduate Institute of Science and Technology, 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- The Fix monad.\n"
"--\n"
"--	  Inspired by the paper\n"
"--	  /Functional Programming with Overloading and\n"
"--	      Higher-Order Polymorphism/, \n"
"--	    Mark P Jones (<http://www.cse.ogi.edu/~mpj/>)\n"
"--		  Advanced School of Functional Programming, 1995.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.Fix (\n"
"	MonadFix(\n"
"	   mfix	-- :: (a -> m a) -> m a\n"
"         ),\n"
"	fix	-- :: (a -> a) -> a\n"
"  ) where\n"
"\n"
"import Prelude\n"
"import System.IO\n"
"\n"
"fix :: (a -> a) -> a\n"
"fix f = let x = f x in x\n"
"\n"
"class (Monad m) => MonadFix m where\n"
"	mfix :: (a -> m a) -> m a\n"
"\n"
"-- Instances of MonadFix for Prelude monads\n"
"\n"
"-- Maybe:\n"
"instance MonadFix Maybe where\n"
"    mfix f = let a = f (unJust a) in a\n"
"             where unJust (Just x) = x\n"
"\n"
"-- List:\n"
"instance MonadFix [] where\n"
"    mfix f = case fix (f . head) of\n"
"               []    -> []\n"
"               (x:_) -> x : mfix (tail . f)\n"
"\n"
"-- IO:\n"
"instance MonadFix IO where\n"
"    mfix = fixIO \n";
const char *Control_Monad_Writer = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.Writer\n"
"-- Copyright   :  (c) Andy Gill 2001,\n"
"--		  (c) Oregon Graduate Institute of Science and Technology, 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (multi-param classes, functional dependencies)\n"
"--\n"
"-- The MonadWriter class.\n"
"--\n"
"--	  Inspired by the paper\n"
"--	  /Functional Programming with Overloading and\n"
"--	      Higher-Order Polymorphism/, \n"
"--	    Mark P Jones (<http://www.cse.ogi.edu/~mpj/>)\n"
"--		  Advanced School of Functional Programming, 1995.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.Writer (\n"
"	MonadWriter(..),\n"
"	listens,\n"
"	censor,\n"
"	Writer(..),\n"
"	execWriter,\n"
"	mapWriter,\n"
"	WriterT(..),\n"
"	execWriterT,\n"
"	mapWriterT,\n"
"	module Control.Monad,\n"
"	module Control.Monad.Fix,\n"
"	module Control.Monad.Trans,\n"
"	module Data.Monoid,\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Monad\n"
"import Control.Monad.Fix\n"
"import Control.Monad.Trans\n"
"import Control.Monad.Reader\n"
"import Data.Monoid\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- MonadWriter class\n"
"--\n"
"-- tell is like tell on the MUD's it shouts to monad\n"
"-- what you want to be heard. The monad carries this 'packet'\n"
"-- upwards, merging it if needed (hence the Monoid requirement)}\n"
"--\n"
"-- listen listens to a monad acting, and returns what the monad \"said\".\n"
"--\n"
"-- pass lets you provide a writer transformer which changes internals of\n"
"-- the written object.\n"
"\n"
"class (Monoid w, Monad m) => MonadWriter w m | m -> w where\n"
"	tell   :: w -> m ()\n"
"	listen :: m a -> m (a, w)\n"
"	pass   :: m (a, w -> w) -> m a\n"
"\n"
"listens :: (MonadWriter w m) => (w -> b) -> m a -> m (a, b)\n"
"listens f m = do\n"
"	(a, w) <- listen m\n"
"	return (a, f w)\n"
"\n"
"censor :: (MonadWriter w m) => (w -> w) -> m a -> m a\n"
"censor f m = pass $ do\n"
"	a <- m\n"
"	return (a, f)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Our parameterizable writer monad\n"
"\n"
"newtype Writer w a = Writer { runWriter :: (a, w) }\n"
"\n"
"instance Functor (Writer w) where\n"
"	fmap f m = Writer $ let (a, w) = runWriter m in (f a, w)\n"
"\n"
"instance (Monoid w) => Monad (Writer w) where\n"
"	return a = Writer (a, mempty)\n"
"	m >>= k  = Writer $ let\n"
"		(a, w)  = runWriter m\n"
"		(b, w') = runWriter (k a)\n"
"		in (b, w `mappend` w')\n"
"\n"
"instance (Monoid w) => MonadFix (Writer w) where\n"
"	mfix m = Writer $ let (a, w) = runWriter (m a) in (a, w)\n"
"\n"
"instance (Monoid w) => MonadWriter w (Writer w) where\n"
"	tell   w = Writer ((), w)\n"
"	listen m = Writer $ let (a, w) = runWriter m in ((a, w), w)\n"
"	pass   m = Writer $ let ((a, f), w) = runWriter m in (a, f w)\n"
"\n"
"execWriter :: Writer w a -> w\n"
"execWriter m = snd (runWriter m)\n"
"\n"
"mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b\n"
"mapWriter f m = Writer $ f (runWriter m)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Our parameterizable writer monad, with an inner monad\n"
"\n"
"newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }\n"
"\n"
"instance (Monad m) => Functor (WriterT w m) where\n"
"	fmap f m = WriterT $ do\n"
"		(a, w) <- runWriterT m\n"
"		return (f a, w)\n"
"\n"
"instance (Monoid w, Monad m) => Monad (WriterT w m) where\n"
"	return a = WriterT $ return (a, mempty)\n"
"	m >>= k  = WriterT $ do\n"
"		(a, w)  <- runWriterT m\n"
"		(b, w') <- runWriterT (k a)\n"
"		return (b, w `mappend` w')\n"
"	fail msg = WriterT $ fail msg\n"
"\n"
"instance (Monoid w, MonadPlus m) => MonadPlus (WriterT w m) where\n"
"	mzero       = WriterT mzero\n"
"	m `mplus` n = WriterT $ runWriterT m `mplus` runWriterT n\n"
"\n"
"instance (Monoid w, MonadFix m) => MonadFix (WriterT w m) where\n"
"	mfix m = WriterT $ mfix $ \\ ~(a, _) -> runWriterT (m a)\n"
"\n"
"instance (Monoid w, Monad m) => MonadWriter w (WriterT w m) where\n"
"	tell   w = WriterT $ return ((), w)\n"
"	listen m = WriterT $ do\n"
"		(a, w) <- runWriterT m\n"
"		return ((a, w), w)\n"
"	pass   m = WriterT $ do\n"
"		((a, f), w) <- runWriterT m\n"
"		return (a, f w)\n"
"\n"
"instance (Monoid w) => MonadTrans (WriterT w) where\n"
"	lift m = WriterT $ do\n"
"		a <- m\n"
"		return (a, mempty)\n"
"\n"
"instance (Monoid w, MonadIO m) => MonadIO (WriterT w m) where\n"
"	liftIO = lift . liftIO\n"
"\n"
"instance (Monoid w, MonadReader r m) => MonadReader r (WriterT w m) where\n"
"	ask       = lift ask\n"
"	local f m = WriterT $ local f (runWriterT m)\n"
"\n"
"execWriterT :: Monad m => WriterT w m a -> m w\n"
"execWriterT m = do\n"
"	(_, w) <- runWriterT m\n"
"	return w\n"
"\n"
"mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b\n"
"mapWriterT f m = WriterT $ f (runWriterT m)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- MonadWriter instances for other monad transformers\n"
"\n"
"instance (MonadWriter w m) => MonadWriter w (ReaderT r m) where\n"
"	tell     = lift . tell\n"
"	listen m = ReaderT $ \\w -> listen (runReaderT m w)\n"
"	pass   m = ReaderT $ \\w -> pass   (runReaderT m w)\n";
const char *Control_Monad_List = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.List\n"
"-- Copyright   :  (c) Andy Gill 2001,\n"
"--		  (c) Oregon Graduate Institute of Science and Technology, 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (multi-parameter type classes)\n"
"--\n"
"-- The List monad.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.List (\n"
"	ListT(..),\n"
"	mapListT,\n"
"	module Control.Monad,\n"
"	module Control.Monad.Trans,\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Monad\n"
"import Control.Monad.Trans\n"
"import Control.Monad.Reader\n"
"import Control.Monad.State\n"
"import Control.Monad.Cont\n"
"import Control.Monad.Error\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Our parameterizable list monad, with an inner monad\n"
"\n"
"newtype ListT m a = ListT { runListT :: m [a] }\n"
"\n"
"instance (Monad m) => Functor (ListT m) where\n"
"	fmap f m = ListT $ do\n"
"		a <- runListT m\n"
"		return (map f a)\n"
"\n"
"instance (Monad m) => Monad (ListT m) where\n"
"	return a = ListT $ return [a]\n"
"	m >>= k  = ListT $ do\n"
"		a <- runListT m\n"
"		b <- mapM (runListT . k) a\n"
"		return (concat b)\n"
"	fail _ = ListT $ return []\n"
"\n"
"instance (Monad m) => MonadPlus (ListT m) where\n"
"	mzero       = ListT $ return []\n"
"	m `mplus` n = ListT $ do\n"
"		a <- runListT m\n"
"		b <- runListT n\n"
"		return (a ++ b)\n"
"\n"
"instance MonadTrans ListT where\n"
"	lift m = ListT $ do\n"
"		a <- m\n"
"		return [a]\n"
"\n"
"instance (MonadIO m) => MonadIO (ListT m) where\n"
"	liftIO = lift . liftIO\n"
"\n"
"instance (MonadReader s m) => MonadReader s (ListT m) where\n"
"	ask       = lift ask\n"
"	local f m = ListT $ local f (runListT m)\n"
"\n"
"instance (MonadState s m) => MonadState s (ListT m) where\n"
"	get = lift get\n"
"	put = lift . put\n"
"\n"
"instance (MonadCont m) => MonadCont (ListT m) where\n"
"	callCC f = ListT $\n"
"		callCC $ \\c ->\n"
"		runListT (f (\\a -> ListT $ c [a]))\n"
"\n"
"instance (MonadError e m) => MonadError e (ListT m) where\n"
"	throwError       = lift . throwError\n"
"	m `catchError` h = ListT $ runListT m\n"
"		`catchError` \\e -> runListT (h e)\n"
"\n"
"mapListT :: (m [a] -> n [b]) -> ListT m a -> ListT n b\n"
"mapListT f m = ListT $ f (runListT m)\n";
const char *Control_Monad_Identity = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.Identity\n"
"-- Copyright   :  (c) Andy Gill 2001,\n"
"--		  (c) Oregon Graduate Institute of Science and Technology, 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- The Identity monad.\n"
"--\n"
"--	  Inspired by the paper\n"
"--	  /Functional Programming with Overloading and\n"
"--	      Higher-Order Polymorphism/, \n"
"--	    Mark P Jones (<http://www.cse.ogi.edu/~mpj/>)\n"
"--		  Advanced School of Functional Programming, 1995.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.Identity (\n"
"	Identity(..),\n"
"	module Control.Monad,\n"
"	module Control.Monad.Fix,\n"
"   ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Monad\n"
"import Control.Monad.Fix\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Identity wrapper\n"
"--\n"
"--	Abstraction for wrapping up a object.\n"
"--	If you have an monadic function, say:\n"
"--\n"
"--	    example :: Int -> IdentityMonad Int\n"
"--	    example x = return (x*x)\n"
"--\n"
"--      you can \"run\" it, using\n"
"--\n"
"--	  Main> runIdentity (example 42)\n"
"--	  1764 :: Int\n"
"\n"
"newtype Identity a = Identity { runIdentity :: a }\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Identity instances for Functor and Monad\n"
"\n"
"instance Functor Identity where\n"
"	fmap f m = Identity (f (runIdentity m))\n"
"\n"
"instance Monad Identity where\n"
"	return a = Identity a\n"
"	m >>= k  = k (runIdentity m)\n"
"\n"
"instance MonadFix Identity where\n"
"	mfix f = Identity (fix (runIdentity . f))\n";
const char *Control_Monad_Cont = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.Cont\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (multi-parameter type classes)\n"
"--\n"
"-- Continuation monads.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.Cont (\n"
"	MonadCont(..),\n"
"	Cont(..),\n"
"	mapCont,\n"
"	withCont,\n"
"	ContT(..),\n"
"	mapContT,\n"
"	withContT,\n"
"	module Control.Monad,\n"
"	module Control.Monad.Trans,\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Monad\n"
"import Control.Monad.Trans\n"
"import Control.Monad.Reader\n"
"import Control.Monad.Writer\n"
"import Control.Monad.State\n"
"import Control.Monad.RWS\n"
"\n"
"class (Monad m) => MonadCont m where\n"
"	callCC :: ((a -> m b) -> m a) -> m a\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Our parameterizable continuation monad\n"
"\n"
"newtype Cont r a = Cont { runCont :: (a -> r) -> r }\n"
"\n"
"instance Functor (Cont r) where\n"
"	fmap f m = Cont $ \\c -> runCont m (c . f)\n"
"\n"
"instance Monad (Cont r) where\n"
"	return a = Cont ($ a)\n"
"	m >>= k  = Cont $ \\c -> runCont m $ \\a -> runCont (k a) c\n"
"\n"
"instance MonadCont (Cont r) where\n"
"	callCC f = Cont $ \\c -> runCont (f (\\a -> Cont $ \\_ -> c a)) c\n"
"\n"
"mapCont :: (r -> r) -> Cont r a -> Cont r a\n"
"mapCont f m = Cont $ f . runCont m\n"
"\n"
"withCont :: ((b -> r) -> (a -> r)) -> Cont r a -> Cont r b\n"
"withCont f m = Cont $ runCont m . f\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Our parameterizable continuation monad, with an inner monad\n"
"\n"
"newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }\n"
"\n"
"instance (Monad m) => Functor (ContT r m) where\n"
"	fmap f m = ContT $ \\c -> runContT m (c . f)\n"
"\n"
"instance (Monad m) => Monad (ContT r m) where\n"
"	return a = ContT ($ a)\n"
"	m >>= k  = ContT $ \\c -> runContT m (\\a -> runContT (k a) c)\n"
"\n"
"instance (Monad m) => MonadCont (ContT r m) where\n"
"	callCC f = ContT $ \\c -> runContT (f (\\a -> ContT $ \\_ -> c a)) c\n"
"\n"
"instance MonadTrans (ContT r) where\n"
"	lift m = ContT (m >>=)\n"
"\n"
"instance (MonadIO m) => MonadIO (ContT r m) where\n"
"	liftIO = lift . liftIO\n"
"\n"
"instance (MonadReader r' m) => MonadReader r' (ContT r m) where\n"
"	ask       = lift ask\n"
"	local f m = ContT $ \\c -> do\n"
"		r <- ask\n"
"		local f (runContT m (local (const r) . c))\n"
"\n"
"instance (MonadState s m) => MonadState s (ContT r m) where\n"
"	get = lift get\n"
"	put = lift . put\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- MonadCont instances for other monad transformers\n"
"\n"
"instance (MonadCont m) => MonadCont (ReaderT r m) where\n"
"	callCC f = ReaderT $ \\r ->\n"
"		callCC $ \\c ->\n"
"		runReaderT (f (\\a -> ReaderT $ \\_ -> c a)) r\n"
"\n"
"instance (MonadCont m) => MonadCont (StateT s m) where\n"
"	callCC f = StateT $ \\s ->\n"
"		callCC $ \\c ->\n"
"		runStateT (f (\\a -> StateT $ \\s' -> c (a, s'))) s\n"
"\n"
"instance (Monoid w, MonadCont m) => MonadCont (WriterT w m) where\n"
"	callCC f = WriterT $\n"
"		callCC $ \\c ->\n"
"		runWriterT (f (\\a -> WriterT $ c (a, mempty)))\n"
"\n"
"instance (Monoid w, MonadCont m) => MonadCont (RWST r w s m) where\n"
"	callCC f = RWST $ \\r s ->\n"
"		callCC $ \\c ->\n"
"		runRWST (f (\\a -> RWST $ \\_ s' -> c (a, s', mempty))) r s\n"
"\n"
"mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a\n"
"mapContT f m = ContT $ f . runContT m\n"
"\n"
"withContT :: ((b -> m r) -> (a -> m r)) -> ContT r m a -> ContT r m b\n"
"withContT f m = ContT $ runContT m . f\n";
const char *Control_Monad_Error = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.Error\n"
"-- Copyright   :  (c) Michael Weber <michael.weber@post.rwth-aachen.de>, 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (multi-parameter type classes)\n"
"--\n"
"-- The Error monad.\n"
"--\n"
"-- Rendered by Michael Weber <mailto:michael.weber@post.rwth-aachen.de>,\n"
"--	inspired by the Haskell Monad Template Library from\n"
"--	Andy Gill (<http://www.cse.ogi.edu/~andy/>)\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.Error (\n"
"	Error(..),\n"
"	MonadError(..),\n"
"	ErrorT(..),\n"
"	mapErrorT,\n"
"	module Control.Monad,\n"
"	module Control.Monad.Fix,\n"
"	module Control.Monad.Trans,\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Monad\n"
"import Control.Monad.Fix\n"
"import Control.Monad.Trans\n"
"import Control.Monad.Reader\n"
"import Control.Monad.Writer\n"
"import Control.Monad.State\n"
"import Control.Monad.RWS\n"
"import Control.Monad.Cont\n"
"\n"
"import System.IO\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- class MonadError\n"
"--\n"
"--    throws an exception inside the monad and thus interrupts\n"
"--    normal execution order, until an error handler is reached}\n"
"--\n"
"--    catches an exception inside the monad (that was previously\n"
"--    thrown by throwError\n"
"\n"
"class Error a where\n"
"	noMsg  :: a\n"
"	strMsg :: String -> a\n"
"\n"
"	noMsg    = strMsg \"\"\n"
"	strMsg _ = noMsg\n"
"\n"
"instance Error [Char] where\n"
"	noMsg  = \"\"\n"
"	strMsg = id\n"
"\n"
"instance Error IOError where\n"
"	strMsg = userError\n"
"\n"
"class (Monad m) => MonadError e m | m -> e where\n"
"	throwError :: e -> m a\n"
"	catchError :: m a -> (e -> m a) -> m a\n"
"\n"
"instance MonadPlus IO where\n"
"	mzero       = ioError (userError \"mzero\")\n"
"	m `mplus` n = m `catch` \\_ -> n\n"
"\n"
"instance MonadError IOError IO where\n"
"	throwError = ioError\n"
"	catchError = catch\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Our parameterizable error monad\n"
"\n"
"instance Functor (Either e) where\n"
"	fmap _ (Left  l) = Left  l\n"
"	fmap f (Right r) = Right (f r)\n"
"\n"
"instance (Error e) => Monad (Either e) where\n"
"	return        = Right\n"
"	Left  l >>= _ = Left l\n"
"	Right r >>= k = k r\n"
"	fail msg      = Left (strMsg msg)\n"
"\n"
"instance (Error e) => MonadPlus (Either e) where\n"
"	mzero            = Left noMsg\n"
"	Left _ `mplus` n = n\n"
"	m      `mplus` _ = m\n"
"\n"
"instance (Error e) => MonadFix (Either e) where\n"
"	mfix f = let\n"
"		a = f $ case a of\n"
"			Right r -> r\n"
"			_       -> error \"empty mfix argument\"\n"
"		in a\n"
"\n"
"instance (Error e) => MonadError e (Either e) where\n"
"	throwError             = Left\n"
"	Left  l `catchError` h = h l\n"
"	Right r `catchError` _ = Right r\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Our parameterizable error monad, with an inner monad\n"
"\n"
"newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }\n"
"\n"
"-- The ErrorT Monad structure is parameterized over two things:\n"
"-- 	* e - The error type.\n"
"--	* m - The inner monad.\n"
"\n"
"-- Here are some examples of use:\n"
"--\n"
"--   type ErrorWithIO e a = ErrorT e IO a\n"
"--	==> ErrorT (IO (Either e a))\n"
"--\n"
"--   type ErrorAndStateWithIO e s a = ErrorT e (StateT s IO) a\n"
"--	==> ErrorT (StateT s IO (Either e a))\n"
"--	==> ErrorT (StateT (s -> IO (Either e a,s)))\n"
"--\n"
"\n"
"instance (Monad m) => Functor (ErrorT e m) where\n"
"	fmap f m = ErrorT $ do\n"
"		a <- runErrorT m\n"
"		case a of\n"
"			Left  l -> return (Left  l)\n"
"			Right r -> return (Right (f r))\n"
"\n"
"instance (Monad m, Error e) => Monad (ErrorT e m) where\n"
"	return a = ErrorT $ return (Right a)\n"
"	m >>= k  = ErrorT $ do\n"
"		a <- runErrorT m\n"
"		case a of\n"
"			Left  l -> return (Left l)\n"
"			Right r -> runErrorT (k r)\n"
"	fail msg = ErrorT $ return (Left (strMsg msg))\n"
"\n"
"instance (Monad m, Error e) => MonadPlus (ErrorT e m) where\n"
"	mzero       = ErrorT $ return (Left noMsg)\n"
"	m `mplus` n = ErrorT $ do\n"
"		a <- runErrorT m\n"
"		case a of\n"
"			Left  _ -> runErrorT n\n"
"			Right r -> return (Right r)\n"
"\n"
"instance (MonadFix m, Error e) => MonadFix (ErrorT e m) where\n"
"	mfix f = ErrorT $ mfix $ \\a -> runErrorT $ f $ case a of\n"
"		Right r -> r\n"
"		_       -> error \"empty mfix argument\"\n"
"\n"
"instance (Monad m, Error e) => MonadError e (ErrorT e m) where\n"
"	throwError l     = ErrorT $ return (Left l)\n"
"	m `catchError` h = ErrorT $ do\n"
"		a <- runErrorT m\n"
"		case a of\n"
"			Left  l -> runErrorT (h l)\n"
"			Right r -> return (Right r)\n"
"\n"
"instance (Error e) => MonadTrans (ErrorT e) where\n"
"	lift m = ErrorT $ do\n"
"		a <- m\n"
"		return (Right a)\n"
"\n"
"instance (Error e, MonadIO m) => MonadIO (ErrorT e m) where\n"
"	liftIO = lift . liftIO\n"
"\n"
"instance (Error e, MonadReader r m) => MonadReader r (ErrorT e m) where\n"
"	ask       = lift ask\n"
"	local f m = ErrorT $ local f (runErrorT m)\n"
"\n"
"instance (Error e, MonadWriter w m) => MonadWriter w (ErrorT e m) where\n"
"	tell     = lift . tell\n"
"	listen m = ErrorT $ do\n"
"		(a, w) <- listen (runErrorT m)\n"
"		return $ case a of\n"
"			Left  l -> Left  l\n"
"			Right r -> Right (r, w)\n"
"	pass   m = ErrorT $ pass $ do\n"
"		a <- runErrorT m\n"
"		return $ case a of\n"
"			Left  l      -> (Left  l, id)\n"
"			Right (r, f) -> (Right r, f)\n"
"\n"
"instance (Error e, MonadState s m) => MonadState s (ErrorT e m) where\n"
"	get = lift get\n"
"	put = lift . put\n"
"\n"
"instance (Error e, MonadCont m) => MonadCont (ErrorT e m) where\n"
"	callCC f = ErrorT $\n"
"		callCC $ \\c ->\n"
"		runErrorT (f (\\a -> ErrorT $ c (Right a)))\n"
"\n"
"mapErrorT :: (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b\n"
"mapErrorT f m = ErrorT $ f (runErrorT m)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- MonadError instances for other monad transformers\n"
"\n"
"instance (MonadError e m) => MonadError e (ReaderT r m) where\n"
"	throwError       = lift . throwError\n"
"	m `catchError` h = ReaderT $ \\r -> runReaderT m r\n"
"		`catchError` \\e -> runReaderT (h e) r\n"
"\n"
"instance (Monoid w, MonadError e m) => MonadError e (WriterT w m) where\n"
"	throwError       = lift . throwError\n"
"	m `catchError` h = WriterT $ runWriterT m\n"
"		`catchError` \\e -> runWriterT (h e)\n"
"\n"
"instance (MonadError e m) => MonadError e (StateT s m) where\n"
"	throwError       = lift . throwError\n"
"	m `catchError` h = StateT $ \\s -> runStateT m s\n"
"		`catchError` \\e -> runStateT (h e) s\n"
"\n"
"instance (Monoid w, MonadError e m) => MonadError e (RWST r w s m) where\n"
"	throwError       = lift . throwError\n"
"	m `catchError` h = RWST $ \\r s -> runRWST m r s\n"
"		`catchError` \\e -> runRWST (h e) r s\n";
const char *Control_Monad_State = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.State\n"
"-- Copyright   :  (c) Andy Gill 2001,\n"
"--		  (c) Oregon Graduate Institute of Science and Technology, 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (multi-param classes, functional dependencies)\n"
"--\n"
"-- State monads.\n"
"--\n"
"--	  This module is inspired by the paper\n"
"--	  /Functional Programming with Overloading and\n"
"--	      Higher-Order Polymorphism/, \n"
"--	    Mark P Jones (<http://www.cse.ogi.edu/~mpj/>)\n"
"--		  Advanced School of Functional Programming, 1995.\n"
"--\n"
"-- See below for examples.\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.State (\n"
"	-- * MonadState class\n"
"	MonadState(..),\n"
"	modify,\n"
"	gets,\n"
"	-- * The State Monad\n"
"	State(..),\n"
"	evalState,\n"
"	execState,\n"
"	mapState,\n"
"	withState,\n"
"	-- * The StateT Monad\n"
"	StateT(..),\n"
"	evalStateT,\n"
"	execStateT,\n"
"	mapStateT,\n"
"	withStateT,\n"
"	module Control.Monad,\n"
"	module Control.Monad.Fix,\n"
"	module Control.Monad.Trans,\n"
"	-- * Examples\n"
"	-- $examples\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Monad\n"
"import Control.Monad.Fix\n"
"import Control.Monad.Trans\n"
"import Control.Monad.Reader\n"
"import Control.Monad.Writer\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- | /get/ returns the state from the internals of the monad.\n"
"--\n"
"-- /put/ replaces the state inside the monad.\n"
"\n"
"class (Monad m) => MonadState s m | m -> s where\n"
"	get :: m s\n"
"	put :: s -> m ()\n"
"\n"
"-- | Monadic state transformer.\n"
"--\n"
"--      Maps an old state to a new state inside a state monad.\n"
"--      The old state is thrown away.\n"
"--\n"
"-- >	  Main> :t modify ((+1) :: Int -> Int)\n"
"-- >	  modify (...) :: (MonadState Int a) => a ()\n"
"--\n"
"--	This says that @modify (+1)@ acts over any\n"
"--	Monad that is a member of the @MonadState@ class,\n"
"--	with an @Int@ state.\n"
"\n"
"modify :: (MonadState s m) => (s -> s) -> m ()\n"
"modify f = do\n"
"	s <- get\n"
"	put (f s)\n"
"\n"
"-- | Gets specific component of the state, using a projection function\n"
"-- supplied.\n"
"\n"
"gets :: (MonadState s m) => (s -> a) -> m a\n"
"gets f = do\n"
"	s <- get\n"
"	return (f s)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- | A parameterizable state monad where /s/ is the type of the state\n"
"-- to carry and /a/ is the type of the /return value/.\n"
"\n"
"newtype State s a = State { runState :: s -> (a, s) }\n"
"\n"
"-- The State Monad structure is parameterized over just the state.\n"
"\n"
"instance Functor (State s) where\n"
"	fmap f m = State $ \\s -> let\n"
"		(a, s') = runState m s\n"
"		in (f a, s')\n"
"\n"
"instance Monad (State s) where\n"
"	return a = State $ \\s -> (a, s)\n"
"	m >>= k  = State $ \\s -> let\n"
"		(a, s') = runState m s\n"
"		in runState (k a) s'\n"
"\n"
"instance MonadFix (State s) where\n"
"	mfix f = State $ \\s -> let (a, s') = runState (f a) s in (a, s')\n"
"\n"
"instance MonadState s (State s) where\n"
"	get   = State $ \\s -> (s, s)\n"
"	put s = State $ \\_ -> ((), s)\n"
"\n"
"-- |Evaluate this state monad with the given initial state,throwing\n"
"-- away the final state.  Very much like @fst@ composed with\n"
"-- @runstate@.\n"
"\n"
"evalState :: State s a -- ^The state to evaluate\n"
"	  -> s         -- ^An initial value\n"
"	  -> a         -- ^The return value of the state application\n"
"evalState m s = fst (runState m s)\n"
"\n"
"-- |Execute this state and return the new state, throwing away the\n"
"-- return value.  Very much like @snd@ composed with\n"
"-- @runstate@.\n"
"\n"
"execState :: State s a -- ^The state to evaluate\n"
"	  -> s         -- ^An initial value\n"
"	  -> s         -- ^The new state\n"
"execState m s = snd (runState m s)\n"
"\n"
"-- |Map a stateful computation from one (return value, state) pair to\n"
"-- another.  For instance, to convert numberTree from a function that\n"
"-- returns a tree to a function that returns the sum of the numbered\n"
"-- tree (see the Examples section for numberTree and sumTree) you may\n"
"-- write:\n"
"--\n"
"-- > sumNumberedTree :: (Eq a) => Tree a -> State (Table a) Int\n"
"-- > sumNumberedTree = mapState (\\ (t, tab) -> (sumTree t, tab))  . numberTree\n"
"\n"
"mapState :: ((a, s) -> (b, s)) -> State s a -> State s b\n"
"mapState f m = State $ f . runState m\n"
"\n"
"-- |Apply this function to this state and return the resulting state.\n"
"withState :: (s -> s) -> State s a -> State s a\n"
"withState f m = State $ runState m . f\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- | A parameterizable state monad for encapsulating an inner\n"
"-- monad.\n"
"--\n"
"-- The StateT Monad structure is parameterized over two things:\n"
"--\n"
"--   * s - The state.\n"
"--\n"
"--   * m - The inner monad.\n"
"--\n"
"-- Here are some examples of use:\n"
"--\n"
"-- (Parser from ParseLib with Hugs)\n"
"--\n"
"-- >  type Parser a = StateT String [] a\n"
"-- >     ==> StateT (String -> [(a,String)])\n"
"--\n"
"-- For example, item can be written as:\n"
"--\n"
"-- >   item = do (x:xs) <- get\n"
"-- >          put xs\n"
"-- >          return x\n"
"-- >\n"
"-- >   type BoringState s a = StateT s Indentity a\n"
"-- >        ==> StateT (s -> Identity (a,s))\n"
"-- >\n"
"-- >   type StateWithIO s a = StateT s IO a\n"
"-- >        ==> StateT (s -> IO (a,s))\n"
"-- >\n"
"-- >   type StateWithErr s a = StateT s Maybe a\n"
"-- >        ==> StateT (s -> Maybe (a,s))\n"
"\n"
"newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }\n"
"\n"
"instance (Monad m) => Functor (StateT s m) where\n"
"	fmap f m = StateT $ \\s -> do\n"
"		(x, s') <- runStateT m s\n"
"		return (f x, s')\n"
"\n"
"instance (Monad m) => Monad (StateT s m) where\n"
"	return a = StateT $ \\s -> return (a, s)\n"
"	m >>= k  = StateT $ \\s -> do\n"
"		(a, s') <- runStateT m s\n"
"		runStateT (k a) s'\n"
"	fail str = StateT $ \\_ -> fail str\n"
"\n"
"instance (MonadPlus m) => MonadPlus (StateT s m) where\n"
"	mzero       = StateT $ \\_ -> mzero\n"
"	m `mplus` n = StateT $ \\s -> runStateT m s `mplus` runStateT n s\n"
"\n"
"instance (MonadFix m) => MonadFix (StateT s m) where\n"
"	mfix f = StateT $ \\s -> mfix $ \\ ~(a, _) -> runStateT (f a) s\n"
"\n"
"instance (Monad m) => MonadState s (StateT s m) where\n"
"	get   = StateT $ \\s -> return (s, s)\n"
"	put s = StateT $ \\_ -> return ((), s)\n"
"\n"
"instance MonadTrans (StateT s) where\n"
"	lift m = StateT $ \\s -> do\n"
"		a <- m\n"
"		return (a, s)\n"
"\n"
"instance (MonadIO m) => MonadIO (StateT s m) where\n"
"	liftIO = lift . liftIO\n"
"\n"
"instance (MonadReader r m) => MonadReader r (StateT s m) where\n"
"	ask       = lift ask\n"
"	local f m = StateT $ \\s -> local f (runStateT m s)\n"
"\n"
"instance (MonadWriter w m) => MonadWriter w (StateT s m) where\n"
"	tell     = lift . tell\n"
"	listen m = StateT $ \\s -> do\n"
"		((a, s'), w) <- listen (runStateT m s)\n"
"		return ((a, w), s')\n"
"	pass   m = StateT $ \\s -> pass $ do\n"
"		((a, f), s') <- runStateT m s\n"
"		return ((a, s'), f)\n"
"\n"
"-- |Similar to 'evalState'\n"
"evalStateT :: (Monad m) => StateT s m a -> s -> m a\n"
"evalStateT m s = do\n"
"	(a, _) <- runStateT m s\n"
"	return a\n"
"\n"
"-- |Similar to 'execState'\n"
"execStateT :: (Monad m) => StateT s m a -> s -> m s\n"
"execStateT m s = do\n"
"	(_, s') <- runStateT m s\n"
"	return s'\n"
"\n"
"-- |Similar to 'mapState'\n"
"mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b\n"
"mapStateT f m = StateT $ f . runStateT m\n"
"\n"
"-- |Similar to 'withState'\n"
"withStateT :: (s -> s) -> StateT s m a -> StateT s m a\n"
"withStateT f m = StateT $ runStateT m . f\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- MonadState instances for other monad transformers\n"
"\n"
"instance (MonadState s m) => MonadState s (ReaderT r m) where\n"
"	get = lift get\n"
"	put = lift . put\n"
"\n"
"instance (Monoid w, MonadState s m) => MonadState s (WriterT w m) where\n"
"	get = lift get\n"
"	put = lift . put\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- $examples\n"
"-- A function to increment a counter.  Taken from the paper\n"
"-- /Generalising Monads to Arrows/, John\n"
"-- Hughes (<http://www.math.chalmers.se/~rjmh/>), November 1998:\n"
"--\n"
"-- > tick :: State Int Int\n"
"-- > tick = do n <- get\n"
"-- >           put (n+1)\n"
"-- >           return n\n"
"--\n"
"-- Add one to the given number using the state monad:\n"
"--\n"
"-- > plusOne :: Int -> Int\n"
"-- > plusOne n = execState tick n\n"
"--\n"
"-- A contrived addition example. Works only with positive numbers:\n"
"--\n"
"-- > plus :: Int -> Int -> Int\n"
"-- > plus n x = execState (sequence $ replicate n tick) x\n"
"--\n"
"-- An example from /The Craft of Functional Programming/, Simon\n"
"-- Thompson (<http://www.cs.kent.ac.uk/people/staff/sjt/>),\n"
"-- Addison-Wesley 1999: \\\"Given an arbitrary tree, transform it to a\n"
"-- tree of integers in which the original elements are replaced by\n"
"-- natural numbers, starting from 0.  The same element has to be\n"
"-- replaced by the same number at every occurrence, and when we meet\n"
"-- an as-yet-unvisited element we have to find a 'new' number to match\n"
"-- it with:\\\"\n"
"--\n"
"-- > data Tree a = Nil | Node a (Tree a) (Tree a) deriving (Show, Eq)\n"
"-- > type Table a = [a]\n"
"--\n"
"-- > numberTree :: Eq a => Tree a -> State (Table a) (Tree Int)\n"
"-- > numberTree Nil = return Nil\n"
"-- > numberTree (Node x t1 t2) \n"
"-- >        =  do num <- numberNode x\n"
"-- >              nt1 <- numberTree t1\n"
"-- >              nt2 <- numberTree t2\n"
"-- >              return (Node num nt1 nt2)\n"
"-- >     where \n"
"-- >     numberNode :: Eq a => a -> State (Table a) Int\n"
"-- >     numberNode x\n"
"-- >        = do table <- get\n"
"-- >             (newTable, newPos) <- return (nNode x table)\n"
"-- >             put newTable\n"
"-- >             return newPos\n"
"-- >     nNode::  (Eq a) => a -> Table a -> (Table a, Int)\n"
"-- >     nNode x table\n"
"-- >        = case (findIndexInList (== x) table) of\n"
"-- >          Nothing -> (table ++ [x], length table)\n"
"-- >          Just i  -> (table, i)\n"
"-- >     findIndexInList :: (a -> Bool) -> [a] -> Maybe Int\n"
"-- >     findIndexInList = findIndexInListHelp 0\n"
"-- >     findIndexInListHelp _ _ [] = Nothing\n"
"-- >     findIndexInListHelp count f (h:t)\n"
"-- >        = if (f h)\n"
"-- >          then Just count\n"
"-- >          else findIndexInListHelp (count+1) f t\n"
"--\n"
"-- numTree applies numberTree with an initial state:\n"
"--\n"
"-- > numTree :: (Eq a) => Tree a -> Tree Int\n"
"-- > numTree t = evalState (numberTree t) []\n"
"--\n"
"-- > testTree = Node \"Zero\" (Node \"One\" (Node \"Two\" Nil Nil) (Node \"One\" (Node \"Zero\" Nil Nil) Nil)) Nil\n"
"-- > numTree testTree => Node 0 (Node 1 (Node 2 Nil Nil) (Node 1 (Node 0 Nil Nil) Nil)) Nil\n"
"--\n"
"-- sumTree is a little helper function that does not use the State monad:\n"
"--\n"
"-- > sumTree :: (Num a) => Tree a -> a\n"
"-- > sumTree Nil = 0\n"
"-- > sumTree (Node e t1 t2) = e + (sumTree t1) + (sumTree t2)\n";
const char *Control_Monad_Trans = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.Trans\n"
"-- Copyright   :  (c) Andy Gill 2001,\n"
"--		  (c) Oregon Graduate Institute of Science and Technology, 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- The MonadTrans class.\n"
"--\n"
"--	  Inspired by the paper\n"
"--	  /Functional Programming with Overloading and\n"
"--	      Higher-Order Polymorphism/, \n"
"--	    Mark P Jones (<http://www.cse.ogi.edu/~mpj/>)\n"
"--		  Advanced School of Functional Programming, 1995.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.Trans (\n"
"	MonadTrans(..),\n"
"	MonadIO(..),  \n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import System.IO\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- MonadTrans class\n"
"--\n"
"-- Monad to facilitate stackable Monads.\n"
"-- Provides a way of digging into an outer\n"
"-- monad, giving access to (lifting) the inner monad.\n"
"\n"
"class MonadTrans t where\n"
"	lift :: Monad m => m a -> t m a\n"
"\n"
"class (Monad m) => MonadIO m where\n"
"	liftIO :: IO a -> m a\n"
"\n"
"instance MonadIO IO where\n"
"	liftIO = id\n";
const char *Control_Monad_Reader = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.Reader\n"
"-- Copyright   :  (c) Andy Gill 2001,\n"
"--		  (c) Oregon Graduate Institute of Science and Technology, 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (multi-param classes, functional dependencies)\n"
"--\n"
"-- Declaration of the Monoid class,and instances for list and functions\n"
"--\n"
"--	  Inspired by the paper\n"
"--	  /Functional Programming with Overloading and\n"
"--	      Higher-Order Polymorphism/, \n"
"--	    Mark P Jones (<http://www.cse.ogi.edu/~mpj/>)\n"
"--		  Advanced School of Functional Programming, 1995.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.Reader (\n"
"	MonadReader(..),\n"
"	asks,\n"
"	Reader(..),\n"
"	mapReader,\n"
"	withReader,\n"
"	ReaderT(..),\n"
"	mapReaderT,\n"
"	withReaderT,\n"
"	module Control.Monad,\n"
"	module Control.Monad.Fix,\n"
"	module Control.Monad.Trans,\n"
"	) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Monad\n"
"import Control.Monad.Fix\n"
"import Control.Monad.Trans\n"
"\n"
"-- ----------------------------------------------------------------------------\n"
"-- class MonadReader\n"
"--  asks for the internal (non-mutable) state.\n"
"\n"
"class (Monad m) => MonadReader r m | m -> r where\n"
"	ask   :: m r\n"
"	local :: (r -> r) -> m a -> m a\n"
"\n"
"-- This allows you to provide a projection function.\n"
"\n"
"asks :: (MonadReader r m) => (r -> a) -> m a\n"
"asks f = do\n"
"	r <- ask\n"
"	return (f r)\n"
"\n"
"-- ----------------------------------------------------------------------------\n"
"-- The partially applied function type is a simple reader monad\n"
"\n"
"instance Functor ((->) r) where\n"
"	fmap = (.)\n"
"\n"
"instance Monad ((->) r) where\n"
"	return  = const\n"
"	m >>= k = \\r -> k (m r) r\n"
"\n"
"instance MonadFix ((->) r) where\n"
"	mfix f = \\r -> let a = f a r in a\n"
"\n"
"instance MonadReader r ((->) r) where\n"
"	ask       = id\n"
"	local f m = m . f\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Our parameterizable reader monad\n"
"\n"
"newtype Reader r a = Reader { runReader :: r -> a }\n"
"\n"
"instance Functor (Reader r) where\n"
"	fmap f m = Reader $ \\r -> f (runReader m r)\n"
"\n"
"instance Monad (Reader r) where\n"
"	return a = Reader $ \\_ -> a\n"
"	m >>= k  = Reader $ \\r -> runReader (k (runReader m r)) r\n"
"\n"
"instance MonadFix (Reader r) where\n"
"	mfix f = Reader $ \\r -> let a = runReader (f a) r in a\n"
"\n"
"instance MonadReader r (Reader r) where\n"
"	ask       = Reader id\n"
"	local f m = Reader $ runReader m . f\n"
"\n"
"mapReader :: (a -> b) -> Reader r a -> Reader r b\n"
"mapReader f m = Reader $ f . runReader m\n"
"\n"
"-- This is a more general version of local.\n"
"\n"
"withReader :: (r' -> r) -> Reader r a -> Reader r' a\n"
"withReader f m = Reader $ runReader m . f\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Our parameterizable reader monad, with an inner monad\n"
"\n"
"newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }\n"
"\n"
"instance (Monad m) => Functor (ReaderT r m) where\n"
"	fmap f m = ReaderT $ \\r -> do\n"
"		a <- runReaderT m r\n"
"		return (f a)\n"
"\n"
"instance (Monad m) => Monad (ReaderT r m) where\n"
"	return a = ReaderT $ \\_ -> return a\n"
"	m >>= k  = ReaderT $ \\r -> do\n"
"		a <- runReaderT m r\n"
"		runReaderT (k a) r\n"
"	fail msg = ReaderT $ \\_ -> fail msg\n"
"\n"
"instance (MonadPlus m) => MonadPlus (ReaderT r m) where\n"
"	mzero       = ReaderT $ \\_ -> mzero\n"
"	m `mplus` n = ReaderT $ \\r -> runReaderT m r `mplus` runReaderT n r\n"
"\n"
"instance (MonadFix m) => MonadFix (ReaderT r m) where\n"
"	mfix f = ReaderT $ \\r -> mfix $ \\a -> runReaderT (f a) r\n"
"\n"
"instance (Monad m) => MonadReader r (ReaderT r m) where\n"
"	ask       = ReaderT return\n"
"	local f m = ReaderT $ \\r -> runReaderT m (f r)\n"
"\n"
"instance MonadTrans (ReaderT r) where\n"
"	lift m = ReaderT $ \\_ -> m\n"
"\n"
"instance (MonadIO m) => MonadIO (ReaderT r m) where\n"
"	liftIO = lift . liftIO\n"
"\n"
"mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b\n"
"mapReaderT f m = ReaderT $ f . runReaderT m\n"
"\n"
"withReaderT :: (r' -> r) -> ReaderT r m a -> ReaderT r' m a\n"
"withReaderT f m = ReaderT $ runReaderT m . f\n";
const char *Control_Monad_ST_Strict = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.ST.Strict\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires universal quantification for runST)\n"
"--\n"
"-- The strict ST monad (re-export of \"Control.Monad.ST\")\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.ST.Strict (\n"
" 	module Control.Monad.ST\n"
"  ) where\n"
"\n"
"import Prelude\n"
"import Control.Monad.ST\n";
const char *Control_Monad_ST_Lazy = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Monad.ST.Lazy\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires universal quantification for runST)\n"
"--\n"
"-- This module presents an identical interface to \"Control.Monad.ST\",\n"
"-- but the underlying implementation of the state thread is /lazy/ (in\n"
"-- the sense that (@_|_ >> a@ is not necessarily equal to @_|_@).\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Monad.ST.Lazy (\n"
"	-- * The 'ST' monad\n"
"	ST,\n"
"	runST,\n"
"	fixST,\n"
"\n"
"	-- * Converting between strict and lazy 'ST'\n"
"	strictToLazyST, lazyToStrictST,\n"
"\n"
"	-- * Converting 'ST' To 'IO'\n"
"	RealWorld,\n"
"	stToIO,\n"
"\n"
"	-- * Unsafe operations\n"
"	unsafeInterleaveST,\n"
"	unsafeIOToST\n"
"    ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Monad.Fix\n"
"\n"
"import Control.Monad.ST (RealWorld)\n"
"import qualified Control.Monad.ST as ST\n"
"\n"
"import Hugs.LazyST\n"
"\n"
"instance MonadFix (ST s) where\n"
"	mfix = fixST\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Strict <--> Lazy\n"
"\n"
"unsafeIOToST :: IO a -> ST s a\n"
"unsafeIOToST = strictToLazyST . ST.unsafeIOToST\n"
"\n"
"-- | A monad transformer embedding lazy state transformers in the 'IO'\n"
"-- monad.  The 'RealWorld' parameter indicates that the internal state\n"
"-- used by the 'ST' computation is a special one supplied by the 'IO'\n"
"-- monad, and thus distinct from those used by invocations of 'runST'.\n"
"stToIO :: ST RealWorld a -> IO a\n"
"stToIO = ST.stToIO . lazyToStrictST\n";
const char *Control_Concurrent_QSemN = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Concurrent.QSemN\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (concurrency)\n"
"--\n"
"-- Quantity semaphores in which each thread may wait for an arbitrary\n"
"-- \\\"amount\\\".\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Concurrent.QSemN\n"
"	(  -- * General Quantity Semaphores\n"
"	  QSemN,	-- abstract\n"
"	  newQSemN,	-- :: Int   -> IO QSemN\n"
"	  waitQSemN,	-- :: QSemN -> Int -> IO ()\n"
"	  signalQSemN	-- :: QSemN -> Int -> IO ()\n"
"      ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Concurrent.MVar\n"
"\n"
"-- |A 'QSemN' is a quantity semaphore, in which the available\n"
"-- \\\"quantity\\\" may be signalled or waited for in arbitrary amounts.\n"
"newtype QSemN = QSemN (MVar (Int,[(Int,MVar ())]))\n"
"\n"
"-- |Build a new 'QSemN' with a supplied initial quantity.\n"
"newQSemN :: Int -> IO QSemN \n"
"newQSemN init = do\n"
"   sem <- newMVar (init,[])\n"
"   return (QSemN sem)\n"
"\n"
"-- |Wait for the specified quantity to become available\n"
"waitQSemN :: QSemN -> Int -> IO ()\n"
"waitQSemN (QSemN sem) sz = do\n"
"  (avail,blocked) <- takeMVar sem   -- gain ex. access\n"
"  if (avail - sz) >= 0 then\n"
"       -- discharging 'sz' still leaves the semaphore\n"
"       -- in an 'unblocked' state.\n"
"     putMVar sem (avail-sz,blocked)\n"
"   else do\n"
"     block <- newEmptyMVar\n"
"     putMVar sem (avail, blocked++[(sz,block)])\n"
"     takeMVar block\n"
"\n"
"-- |Signal that a given quantity is now available from the 'QSemN'.\n"
"signalQSemN :: QSemN -> Int  -> IO ()\n"
"signalQSemN (QSemN sem) n = do\n"
"   (avail,blocked)   <- takeMVar sem\n"
"   (avail',blocked') <- free (avail+n) blocked\n"
"   putMVar sem (avail',blocked')\n"
" where\n"
"   free avail []    = return (avail,[])\n"
"   free avail ((req,block):blocked)\n"
"     | avail >= req = do\n"
"	putMVar block ()\n"
"	free (avail-req) blocked\n"
"     | otherwise    = do\n"
"	(avail',blocked') <- free avail blocked\n"
"        return (avail',(req,block):blocked')\n";
const char *Control_Concurrent_SampleVar = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Concurrent.SampleVar\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (concurrency)\n"
"--\n"
"-- Sample variables\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Concurrent.SampleVar\n"
"       (\n"
"	 -- * Sample Variables\n"
"         SampleVar,         -- :: type _ =\n"
" \n"
"	 newEmptySampleVar, -- :: IO (SampleVar a)\n"
"         newSampleVar,      -- :: a -> IO (SampleVar a)\n"
"	 emptySampleVar,    -- :: SampleVar a -> IO ()\n"
"	 readSampleVar,	    -- :: SampleVar a -> IO a\n"
"	 writeSampleVar	    -- :: SampleVar a -> a -> IO ()\n"
"\n"
"       ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Concurrent.MVar\n"
"\n"
"-- |\n"
"-- Sample variables are slightly different from a normal 'MVar':\n"
"-- \n"
"--  * Reading an empty 'SampleVar' causes the reader to block.\n"
"--    (same as 'takeMVar' on empty 'MVar')\n"
"-- \n"
"--  * Reading a filled 'SampleVar' empties it and returns value.\n"
"--    (same as 'takeMVar')\n"
"-- \n"
"--  * Writing to an empty 'SampleVar' fills it with a value, and\n"
"--    potentially, wakes up a blocked reader (same as for 'putMVar' on\n"
"--    empty 'MVar').\n"
"--\n"
"--  * Writing to a filled 'SampleVar' overwrites the current value.\n"
"--    (different from 'putMVar' on full 'MVar'.)\n"
"\n"
"type SampleVar a\n"
" = MVar (Int,		-- 1  == full\n"
"			-- 0  == empty\n"
"			-- <0 no of readers blocked\n"
"          MVar a)\n"
"\n"
"-- |Build a new, empty, 'SampleVar'\n"
"newEmptySampleVar :: IO (SampleVar a)\n"
"newEmptySampleVar = do\n"
"   v <- newEmptyMVar\n"
"   newMVar (0,v)\n"
"\n"
"-- |Build a 'SampleVar' with an initial value.\n"
"newSampleVar :: a -> IO (SampleVar a)\n"
"newSampleVar a = do\n"
"   v <- newEmptyMVar\n"
"   putMVar v a\n"
"   newMVar (1,v)\n"
"\n"
"-- |If the SampleVar is full, leave it empty.  Otherwise, do nothing.\n"
"emptySampleVar :: SampleVar a -> IO ()\n"
"emptySampleVar v = do\n"
"   (readers, var) <- takeMVar v\n"
"   if readers >= 0 then\n"
"     putMVar v (0,var)\n"
"    else\n"
"     putMVar v (readers,var)\n"
"\n"
"-- |Wait for a value to become available, then take it and return.\n"
"readSampleVar :: SampleVar a -> IO a\n"
"readSampleVar svar = do\n"
"--\n"
"-- filled => make empty and grab sample\n"
"-- not filled => try to grab value, empty when read val.\n"
"--\n"
"   (readers,val) <- takeMVar svar\n"
"   putMVar svar (readers-1,val)\n"
"   takeMVar val\n"
"\n"
"-- |Write a value into the 'SampleVar', overwriting any previous value that\n"
"-- was there.\n"
"writeSampleVar :: SampleVar a -> a -> IO ()\n"
"writeSampleVar svar v = do\n"
"--\n"
"-- filled => overwrite\n"
"-- not filled => fill, write val\n"
"--\n"
"   (readers,val) <- takeMVar svar\n"
"   case readers of\n"
"     1 -> \n"
"       swapMVar val v >> \n"
"       putMVar svar (1,val)\n"
"     _ -> \n"
"       putMVar val v >> \n"
"       putMVar svar (min 1 (readers+1), val)\n";
const char *Control_Concurrent_Chan = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Concurrent.Chan\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (concurrency).\n"
"--\n"
"-- Unbounded channels.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Concurrent.Chan\n"
"  ( \n"
"	  -- * The 'Chan' type\n"
"	Chan,			-- abstract\n"
"\n"
"	  -- * Operations\n"
"	newChan,	 	-- :: IO (Chan a)\n"
"	writeChan,	 	-- :: Chan a -> a -> IO ()\n"
"	readChan,	 	-- :: Chan a -> IO a\n"
"	dupChan,	 	-- :: Chan a -> IO (Chan a)\n"
"	unGetChan,		-- :: Chan a -> a -> IO ()\n"
"	isEmptyChan,		-- :: Chan a -> IO Bool\n"
"\n"
"	  -- * Stream interface\n"
"	getChanContents,	-- :: Chan a -> IO [a]\n"
"	writeList2Chan,		-- :: Chan a -> [a] -> IO ()\n"
"   ) where\n"
"\n"
"import Prelude\n"
"\n"
"import System.IO.Unsafe		( unsafeInterleaveIO )\n"
"import Control.Concurrent.MVar\n"
"\n"
"-- A channel is represented by two @MVar@s keeping track of the two ends\n"
"-- of the channel contents,i.e.,  the read- and write ends. Empty @MVar@s\n"
"-- are used to handle consumers trying to read from an empty channel.\n"
"\n"
"-- |'Chan' is an abstract type representing an unbounded FIFO channel.\n"
"data Chan a\n"
" = Chan (MVar (Stream a))\n"
"        (MVar (Stream a))\n"
"\n"
"type Stream a = MVar (ChItem a)\n"
"\n"
"data ChItem a = ChItem a (Stream a)\n"
"\n"
"-- See the Concurrent Haskell paper for a diagram explaining the\n"
"-- how the different channel operations proceed.\n"
"\n"
"-- @newChan@ sets up the read and write end of a channel by initialising\n"
"-- these two @MVar@s with an empty @MVar@.\n"
"\n"
"-- |Build and returns a new instance of 'Chan'.\n"
"newChan :: IO (Chan a)\n"
"newChan = do\n"
"   hole  <- newEmptyMVar\n"
"   read  <- newMVar hole\n"
"   write <- newMVar hole\n"
"   return (Chan read write)\n"
"\n"
"-- To put an element on a channel, a new hole at the write end is created.\n"
"-- What was previously the empty @MVar@ at the back of the channel is then\n"
"-- filled in with a new stream element holding the entered value and the\n"
"-- new hole.\n"
"\n"
"-- |Write a value to a 'Chan'.\n"
"writeChan :: Chan a -> a -> IO ()\n"
"writeChan (Chan _read write) val = do\n"
"  new_hole <- newEmptyMVar\n"
"  modifyMVar_ write $ \\old_hole -> do\n"
"    putMVar old_hole (ChItem val new_hole)\n"
"    return new_hole\n"
"\n"
"-- |Read the next value from the 'Chan'.\n"
"readChan :: Chan a -> IO a\n"
"readChan (Chan read _write) = do\n"
"  modifyMVar read $ \\read_end -> do\n"
"    (ChItem val new_read_end) <- readMVar read_end\n"
"	-- Use readMVar here, not takeMVar,\n"
"	-- else dupChan doesn't work\n"
"    return (new_read_end, val)\n"
"\n"
"-- |Duplicate a 'Chan': the duplicate channel begins empty, but data written to\n"
"-- either channel from then on will be available from both.  Hence this creates\n"
"-- a kind of broadcast channel, where data written by anyone is seen by\n"
"-- everyone else.\n"
"dupChan :: Chan a -> IO (Chan a)\n"
"dupChan (Chan _read write) = do\n"
"   hole     <- readMVar write\n"
"   new_read <- newMVar hole\n"
"   return (Chan new_read write)\n"
"\n"
"-- |Put a data item back onto a channel, where it will be the next item read.\n"
"unGetChan :: Chan a -> a -> IO ()\n"
"unGetChan (Chan read _write) val = do\n"
"   new_read_end <- newEmptyMVar\n"
"   modifyMVar_ read $ \\read_end -> do\n"
"     putMVar new_read_end (ChItem val read_end)\n"
"     return new_read_end\n"
"\n"
"-- |Returns 'True' if the supplied 'Chan' is empty.\n"
"isEmptyChan :: Chan a -> IO Bool\n"
"isEmptyChan (Chan read write) = do\n"
"   withMVar read $ \\r -> do\n"
"     w <- readMVar write\n"
"     let eq = r == w\n"
"     eq `seq` return eq\n"
"\n"
"-- Operators for interfacing with functional streams.\n"
"\n"
"-- |Return a lazy list representing the contents of the supplied\n"
"-- 'Chan', much like 'System.IO.hGetContents'.\n"
"getChanContents :: Chan a -> IO [a]\n"
"getChanContents ch\n"
"  = unsafeInterleaveIO (do\n"
"	x  <- readChan ch\n"
"    	xs <- getChanContents ch\n"
"    	return (x:xs)\n"
"    )\n"
"\n"
"-- |Write an entire list of items to a 'Chan'.\n"
"writeList2Chan :: Chan a -> [a] -> IO ()\n"
"writeList2Chan ch ls = sequence_ (map (writeChan ch) ls)\n";
const char *Control_Concurrent_QSem = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Concurrent.QSem\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (concurrency)\n"
"--\n"
"-- Simple quantity semaphores.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Concurrent.QSem\n"
"	( -- * Simple Quantity Semaphores\n"
"	  QSem,		-- abstract\n"
"	  newQSem,	-- :: Int  -> IO QSem\n"
"	  waitQSem,	-- :: QSem -> IO ()\n"
"	  signalQSem	-- :: QSem -> IO ()\n"
"	) where\n"
"\n"
"import Prelude\n"
"import Control.Concurrent.MVar\n"
"\n"
"-- General semaphores are also implemented readily in terms of shared\n"
"-- @MVar@s, only have to catch the case when the semaphore is tried\n"
"-- waited on when it is empty (==0). Implement this in the same way as\n"
"-- shared variables are implemented - maintaining a list of @MVar@s\n"
"-- representing threads currently waiting. The counter is a shared\n"
"-- variable, ensuring the mutual exclusion on its access.\n"
"\n"
"-- |A 'QSem' is a simple quantity semaphore, in which the available\n"
"-- \\\"quantity\\\" is always dealt with in units of one.\n"
"newtype QSem = QSem (MVar (Int, [MVar ()]))\n"
"\n"
"-- |Build a new 'QSem'\n"
"newQSem :: Int -> IO QSem\n"
"newQSem init = do\n"
"   sem <- newMVar (init,[])\n"
"   return (QSem sem)\n"
"\n"
"-- |Wait for a unit to become available\n"
"waitQSem :: QSem -> IO ()\n"
"waitQSem (QSem sem) = do\n"
"   (avail,blocked) <- takeMVar sem  -- gain ex. access\n"
"   if avail > 0 then\n"
"     putMVar sem (avail-1,[])\n"
"    else do\n"
"     block <- newEmptyMVar\n"
"      {-\n"
"	Stuff the reader at the back of the queue,\n"
"	so as to preserve waiting order. A signalling\n"
"	process then only have to pick the MVar at the\n"
"	front of the blocked list.\n"
"\n"
"	The version of waitQSem given in the paper could\n"
"	lead to starvation.\n"
"      -}\n"
"     putMVar sem (0, blocked++[block])\n"
"     takeMVar block\n"
"\n"
"-- |Signal that a unit of the 'QSem' is available\n"
"signalQSem :: QSem -> IO ()\n"
"signalQSem (QSem sem) = do\n"
"   (avail,blocked) <- takeMVar sem\n"
"   case blocked of\n"
"     [] -> putMVar sem (avail+1,[])\n"
"\n"
"     (block:blocked') -> do\n"
"	   putMVar sem (0,blocked')\n"
"	   putMVar block ()\n";
const char *Control_Concurrent_MVar = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Control.Concurrent.MVar\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (concurrency)\n"
"--\n"
"-- Synchronising variables\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Control.Concurrent.MVar\n"
"	( \n"
"	  -- * @MVar@s\n"
"	  MVar		-- abstract\n"
"	, newEmptyMVar  -- :: IO (MVar a)\n"
"	, newMVar 	-- :: a -> IO (MVar a)\n"
"	, takeMVar 	-- :: MVar a -> IO a\n"
"	, putMVar  	-- :: MVar a -> a -> IO ()\n"
"	, readMVar 	-- :: MVar a -> IO a\n"
"	, swapMVar 	-- :: MVar a -> a -> IO a\n"
"	, tryTakeMVar   -- :: MVar a -> IO (Maybe a)\n"
"	, tryPutMVar    -- :: MVar a -> a -> IO Bool\n"
"	, isEmptyMVar	-- :: MVar a -> IO Bool\n"
"	, withMVar	-- :: MVar a -> (a -> IO b) -> IO b\n"
"	, modifyMVar_ 	-- :: MVar a -> (a -> IO a) -> IO ()\n"
"	, modifyMVar 	-- :: MVar a -> (a -> IO (a,b)) -> IO b\n"
"    ) where\n"
"\n"
"import Hugs.ConcBase ( MVar, newEmptyMVar, newMVar, takeMVar, putMVar,\n"
"		  tryTakeMVar, tryPutMVar, isEmptyMVar,\n"
"		)\n"
"\n"
"import Prelude\n"
"import Control.Exception as Exception\n"
"\n"
"{-|\n"
"  This is a combination of 'takeMVar' and 'putMVar'; ie. it takes the value\n"
"  from the 'MVar', puts it back, and also returns it.\n"
"-}\n"
"readMVar :: MVar a -> IO a\n"
"readMVar m =\n"
"  block $ do\n"
"    a <- takeMVar m\n"
"    putMVar m a\n"
"    return a\n"
"\n"
"-- |Swap the contents of an 'MVar' for a new value.\n"
"swapMVar :: MVar a -> a -> IO a\n"
"swapMVar mvar new =\n"
"  block $ do\n"
"    old <- takeMVar mvar\n"
"    putMVar mvar new\n"
"    return old\n"
"\n"
"{-|\n"
"  'withMVar' is a safe wrapper for operating on the contents of an\n"
"  'MVar'.  This operation is exception-safe: it will replace the\n"
"  original contents of the 'MVar' if an exception is raised (see\n"
"  \"Control.Exception\").\n"
"-}\n"
"withMVar :: MVar a -> (a -> IO b) -> IO b\n"
"withMVar m io = \n"
"  block $ do\n"
"    a <- takeMVar m\n"
"    b <- Exception.catch (unblock (io a))\n"
"      	    (\\e -> do putMVar m a; throw e)\n"
"    putMVar m a\n"
"    return b\n"
"\n"
"{-|\n"
"  A safe wrapper for modifying the contents of an 'MVar'.  Like 'withMVar', \n"
"  'modifyMVar' will replace the original contents of the 'MVar' if an\n"
"  exception is raised during the operation.\n"
"-}\n"
"modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()\n"
"modifyMVar_ m io = \n"
"  block $ do\n"
"    a  <- takeMVar m\n"
"    a' <- Exception.catch (unblock (io a))\n"
"      	    (\\e -> do putMVar m a; throw e)\n"
"    putMVar m a'\n"
"\n"
"{-|\n"
"  A slight variation on 'modifyMVar_' that allows a value to be\n"
"  returned (@b@) in addition to the modified value of the 'MVar'.\n"
"-}\n"
"modifyMVar :: MVar a -> (a -> IO (a,b)) -> IO b\n"
"modifyMVar m io = \n"
"  block $ do\n"
"    a      <- takeMVar m\n"
"    (a',b) <- Exception.catch (unblock (io a))\n"
"      	        (\\e -> do putMVar m a; throw e)\n"
"    putMVar m a'\n"
"    return b\n";
const char *Text_Read = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.Read\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (uses Text.ParserCombinators.ReadP)\n"
"--\n"
"-- The \"Text.Read\" library is the canonical library to import for\n"
"-- 'Read'-class facilities.  For GHC only, it offers an extended and much\n"
"-- improved 'Read' class, which constitutes a proposed alternative to the \n"
"-- Haskell 98 'Read'.  In particular, writing parsers is easier, and\n"
"-- the parsers are much more efficient.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.Read (\n"
"   -- * The 'Read' class\n"
"   Read(..),		-- The Read class\n"
"   ReadS, 		-- String -> Maybe (a,String)\n"
"\n"
"   -- * Haskell 98 functions\n"
"   reads,		-- :: (Read a) => ReadS a\n"
"   read,		-- :: (Read a) => String -> a\n"
"   readParen, 		-- :: Bool -> ReadS a -> ReadS a\n"
"   lex,			-- :: ReadS String\n"
"\n"
"   -- * New parsing functions\n"
"   module Text.ParserCombinators.ReadPrec,\n"
"   L.Lexeme(..),	\n"
"   lexP,		-- :: ReadPrec Lexeme\n"
"\n"
" ) where\n"
"\n"
"import Text.ParserCombinators.ReadPrec\n"
"import qualified Text.Read.Lex as L\n"
"\n"
"-- copied from GHC.Read\n"
"\n"
"lexP :: ReadPrec L.Lexeme\n"
"lexP = lift L.lex\n";
const char *Text_PrettyPrint = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.PrettyPrint\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- Re-export of \"Text.PrettyPrint.HughesPJ\" to provide a default\n"
"-- pretty-printing library.  Marked experimental at the moment; the \n"
"-- default library might change at a later date.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.PrettyPrint ( \n"
" 	module Text.PrettyPrint.HughesPJ\n"
" ) where\n"
"\n"
"import Prelude\n"
"import Text.PrettyPrint.HughesPJ\n";
const char *Text_Html = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.Html\n"
"-- Copyright   :  (c) Andy Gill, and the Oregon Graduate Institute of \n"
"--		  Science and Technology, 1999-2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  Andy Gill <andy@galconn.com>\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- An Html combinator library\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.Html (\n"
"      module Text.Html,\n"
"      ) where\n"
"\n"
"import Prelude\n"
"\n"
"import qualified Text.Html.BlockTable as BT\n"
"\n"
"infixr 3 </>  -- combining table cells \n"
"infixr 4 <->  -- combining table cells\n"
"infixr 2 +++  -- combining Html\n"
"infixr 7 <<   -- nesting Html\n"
"infixl 8 !    -- adding optional arguments\n"
"\n"
"-- A important property of Html is that all strings inside the\n"
"-- structure are already in Html friendly format.\n"
"-- For example, use of &gt;,etc.\n"
"\n"
"data HtmlElement\n"
"{-\n"
" -    ..just..plain..normal..text... but using &copy; and &amb;, etc.\n"
" -}\n"
"      = HtmlString String\n"
"{-\n"
" -    <thetag {..attrs..}> ..content.. </thetag>\n"
" -}\n"
"      | HtmlTag {                   -- tag with internal markup\n"
"              markupTag      :: String,\n"
"              markupAttrs    :: [HtmlAttr],\n"
"              markupContent  :: Html\n"
"              }\n"
"\n"
"{- These are the index-value pairs.\n"
" - The empty string is a synonym for tags with no arguments.\n"
" - (not strictly HTML, but anyway).\n"
" -}\n"
"\n"
"data HtmlAttr = HtmlAttr String String\n"
"\n"
"newtype Html = Html { getHtmlElements :: [HtmlElement] }\n"
"\n"
"-- Read MARKUP as the class of things that can be validly rendered\n"
"-- inside MARKUP tag brackets. So this can be one or more Html's,\n"
"-- or a String, for example.\n"
"\n"
"class HTML a where\n"
"      toHtml     :: a -> Html\n"
"      toHtmlFromList :: [a] -> Html\n"
"\n"
"      toHtmlFromList xs = Html (concat [ x | (Html x) <- map toHtml xs])\n"
"\n"
"instance HTML Html where\n"
"      toHtml a    = a\n"
"\n"
"instance HTML Char where\n"
"      toHtml       a = toHtml [a]\n"
"      toHtmlFromList []  = Html []\n"
"      toHtmlFromList str = Html [HtmlString (stringToHtmlString str)]\n"
"\n"
"instance (HTML a) => HTML [a] where\n"
"      toHtml xs = toHtmlFromList xs\n"
"\n"
"class ADDATTRS a where\n"
"      (!) :: a -> [HtmlAttr] -> a\n"
"\n"
"instance (ADDATTRS b) => ADDATTRS (a -> b) where\n"
"      fn ! attr = \\ arg -> fn arg ! attr\n"
"\n"
"instance ADDATTRS Html where\n"
"      (Html htmls) ! attr = Html (map addAttrs htmls)\n"
"        where\n"
"              addAttrs (html@(HtmlTag { markupAttrs = markupAttrs }) )\n"
"                              = html { markupAttrs = markupAttrs ++ attr }\n"
"              addAttrs html = html\n"
"\n"
"(<<)            :: (HTML a) => (Html -> b) -> a        -> b\n"
"fn << arg = fn (toHtml arg)\n"
"\n"
"concatHtml :: (HTML a) => [a] -> Html\n"
"concatHtml as = Html (concat (map (getHtmlElements.toHtml) as))\n"
"\n"
"(+++) :: (HTML a,HTML b) => a -> b -> Html\n"
"a +++ b = Html (getHtmlElements (toHtml a) ++ getHtmlElements (toHtml b))\n"
"\n"
"noHtml :: Html\n"
"noHtml = Html []\n"
"\n"
"isNoHtml (Html xs) = null xs\n"
"\n"
"tag  :: String -> Html -> Html\n"
"tag str       htmls = Html [\n"
"      HtmlTag {\n"
"              markupTag = str,\n"
"              markupAttrs = [],\n"
"              markupContent = htmls }]\n"
"\n"
"itag :: String -> Html\n"
"itag str = tag str noHtml\n"
"\n"
"emptyAttr :: String -> HtmlAttr\n"
"emptyAttr s = HtmlAttr s \"\"\n"
"\n"
"intAttr :: String -> Int -> HtmlAttr\n"
"intAttr s i = HtmlAttr s (show i)\n"
"\n"
"strAttr :: String -> String -> HtmlAttr\n"
"strAttr s t = HtmlAttr s t\n"
"\n"
"{-\n"
"foldHtml :: (String -> [HtmlAttr] -> [a] -> a) \n"
"      -> (String -> a)\n"
"      -> Html\n"
"      -> a\n"
"foldHtml f g (HtmlTag str attr fmls) \n"
"      = f str attr (map (foldHtml f g) fmls) \n"
"foldHtml f g (HtmlString  str)           \n"
"      = g str\n"
"\n"
"-}\n"
"-- Processing Strings into Html friendly things.\n"
"-- This converts a String to a Html String.\n"
"stringToHtmlString :: String -> String\n"
"stringToHtmlString = concatMap fixChar\n"
"    where\n"
"      fixChar '<' = \"&lt;\"\n"
"      fixChar '>' = \"&gt;\"\n"
"      fixChar '&' = \"&amp;\"\n"
"      fixChar '\"' = \"&quot;\"\n"
"      fixChar c   = [c]               \n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Classes\n"
"\n"
"instance Show Html where\n"
"      showsPrec _ html = showString (prettyHtml html)\n"
"      showList htmls   = showString (concat (map show htmls))\n"
"\n"
"instance Show HtmlAttr where\n"
"      showsPrec _ (HtmlAttr str val) = \n"
"              showString str .\n"
"              showString \"=\" .\n"
"              shows val\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Data types\n"
"\n"
"type URL = String\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Basic primitives\n"
"\n"
"-- This is not processed for special chars. \n"
"-- use stringToHtml or lineToHtml instead, for user strings, \n"
"-- because they  understand special chars, like '<'.\n"
"\n"
"primHtml      :: String                                -> Html\n"
"primHtml x    = Html [HtmlString x]\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Basic Combinators\n"
"\n"
"stringToHtml          :: String                       -> Html\n"
"stringToHtml = primHtml . stringToHtmlString \n"
"\n"
"-- This converts a string, but keeps spaces as non-line-breakable\n"
"\n"
"lineToHtml            :: String                       -> Html\n"
"lineToHtml = primHtml . concatMap htmlizeChar2 . stringToHtmlString \n"
"   where \n"
"      htmlizeChar2 ' ' = \"&nbsp;\"\n"
"      htmlizeChar2 c   = [c]\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Html Constructors\n"
"\n"
"-- (automatically generated)\n"
"\n"
"address             :: Html -> Html\n"
"anchor              :: Html -> Html\n"
"applet              :: Html -> Html\n"
"area                ::         Html\n"
"basefont            ::         Html\n"
"big                 :: Html -> Html\n"
"blockquote          :: Html -> Html\n"
"body                :: Html -> Html\n"
"bold                :: Html -> Html\n"
"br                  ::         Html\n"
"caption             :: Html -> Html\n"
"center              :: Html -> Html\n"
"cite                :: Html -> Html\n"
"ddef                :: Html -> Html\n"
"define              :: Html -> Html\n"
"dlist               :: Html -> Html\n"
"dterm               :: Html -> Html\n"
"emphasize           :: Html -> Html\n"
"fieldset            :: Html -> Html\n"
"font                :: Html -> Html\n"
"form                :: Html -> Html\n"
"frame               :: Html -> Html\n"
"frameset            :: Html -> Html\n"
"h1                  :: Html -> Html\n"
"h2                  :: Html -> Html\n"
"h3                  :: Html -> Html\n"
"h4                  :: Html -> Html\n"
"h5                  :: Html -> Html\n"
"h6                  :: Html -> Html\n"
"header              :: Html -> Html\n"
"hr                  ::         Html\n"
"image               ::         Html\n"
"input               ::         Html\n"
"italics             :: Html -> Html\n"
"keyboard            :: Html -> Html\n"
"legend              :: Html -> Html\n"
"li                  :: Html -> Html\n"
"meta                ::         Html\n"
"noframes            :: Html -> Html\n"
"olist               :: Html -> Html\n"
"option              :: Html -> Html\n"
"paragraph           :: Html -> Html\n"
"param               ::         Html\n"
"pre                 :: Html -> Html\n"
"sample              :: Html -> Html\n"
"select              :: Html -> Html\n"
"small               :: Html -> Html\n"
"strong              :: Html -> Html\n"
"style               :: Html -> Html\n"
"sub                 :: Html -> Html\n"
"sup                 :: Html -> Html\n"
"table               :: Html -> Html\n"
"td                  :: Html -> Html\n"
"textarea            :: Html -> Html\n"
"th                  :: Html -> Html\n"
"thebase             ::         Html\n"
"thecode             :: Html -> Html\n"
"thediv              :: Html -> Html\n"
"thehtml             :: Html -> Html\n"
"thelink             :: Html -> Html\n"
"themap              :: Html -> Html\n"
"thespan             :: Html -> Html\n"
"thetitle            :: Html -> Html\n"
"tr                  :: Html -> Html\n"
"tt                  :: Html -> Html\n"
"ulist               :: Html -> Html\n"
"underline           :: Html -> Html\n"
"variable            :: Html -> Html\n"
"\n"
"address             =  tag \"ADDRESS\"\n"
"anchor              =  tag \"A\"\n"
"applet              =  tag \"APPLET\"\n"
"area                = itag \"AREA\"\n"
"basefont            = itag \"BASEFONT\"\n"
"big                 =  tag \"BIG\"\n"
"blockquote          =  tag \"BLOCKQUOTE\"\n"
"body                =  tag \"BODY\"\n"
"bold                =  tag \"B\"\n"
"br                  = itag \"BR\"\n"
"caption             =  tag \"CAPTION\"\n"
"center              =  tag \"CENTER\"\n"
"cite                =  tag \"CITE\"\n"
"ddef                =  tag \"DD\"\n"
"define              =  tag \"DFN\"\n"
"dlist               =  tag \"DL\"\n"
"dterm               =  tag \"DT\"\n"
"emphasize           =  tag \"EM\"\n"
"fieldset            =  tag \"FIELDSET\"\n"
"font                =  tag \"FONT\"\n"
"form                =  tag \"FORM\"\n"
"frame               =  tag \"FRAME\"\n"
"frameset            =  tag \"FRAMESET\"\n"
"h1                  =  tag \"H1\"\n"
"h2                  =  tag \"H2\"\n"
"h3                  =  tag \"H3\"\n"
"h4                  =  tag \"H4\"\n"
"h5                  =  tag \"H5\"\n"
"h6                  =  tag \"H6\"\n"
"header              =  tag \"HEAD\"\n"
"hr                  = itag \"HR\"\n"
"image               = itag \"IMG\"\n"
"input               = itag \"INPUT\"\n"
"italics             =  tag \"I\"\n"
"keyboard            =  tag \"KBD\"\n"
"legend              =  tag \"LEGEND\"\n"
"li                  =  tag \"LI\"\n"
"meta                = itag \"META\"\n"
"noframes            =  tag \"NOFRAMES\"\n"
"olist               =  tag \"OL\"\n"
"option              =  tag \"OPTION\"\n"
"paragraph           =  tag \"P\"\n"
"param               = itag \"PARAM\"\n"
"pre                 =  tag \"PRE\"\n"
"sample              =  tag \"SAMP\"\n"
"select              =  tag \"SELECT\"\n"
"small               =  tag \"SMALL\"\n"
"strong              =  tag \"STRONG\"\n"
"style               =  tag \"STYLE\"\n"
"sub                 =  tag \"SUB\"\n"
"sup                 =  tag \"SUP\"\n"
"table               =  tag \"TABLE\"\n"
"td                  =  tag \"TD\"\n"
"textarea            =  tag \"TEXTAREA\"\n"
"th                  =  tag \"TH\"\n"
"thebase             = itag \"BASE\"\n"
"thecode             =  tag \"CODE\"\n"
"thediv              =  tag \"DIV\"\n"
"thehtml             =  tag \"HTML\"\n"
"thelink             =  tag \"LINK\"\n"
"themap              =  tag \"MAP\"\n"
"thespan             =  tag \"SPAN\"\n"
"thetitle            =  tag \"TITLE\"\n"
"tr                  =  tag \"TR\"\n"
"tt                  =  tag \"TT\"\n"
"ulist               =  tag \"UL\"\n"
"underline           =  tag \"U\"\n"
"variable            =  tag \"VAR\"\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Html Attributes\n"
"\n"
"-- (automatically generated)\n"
"\n"
"action              :: String -> HtmlAttr\n"
"align               :: String -> HtmlAttr\n"
"alink               :: String -> HtmlAttr\n"
"alt                 :: String -> HtmlAttr\n"
"altcode             :: String -> HtmlAttr\n"
"archive             :: String -> HtmlAttr\n"
"background          :: String -> HtmlAttr\n"
"base                :: String -> HtmlAttr\n"
"bgcolor             :: String -> HtmlAttr\n"
"border              :: Int    -> HtmlAttr\n"
"bordercolor         :: String -> HtmlAttr\n"
"cellpadding         :: Int    -> HtmlAttr\n"
"cellspacing         :: Int    -> HtmlAttr\n"
"checked             ::           HtmlAttr\n"
"clear               :: String -> HtmlAttr\n"
"code                :: String -> HtmlAttr\n"
"codebase            :: String -> HtmlAttr\n"
"color               :: String -> HtmlAttr\n"
"cols                :: String -> HtmlAttr\n"
"colspan             :: Int    -> HtmlAttr\n"
"compact             ::           HtmlAttr\n"
"content             :: String -> HtmlAttr\n"
"coords              :: String -> HtmlAttr\n"
"enctype             :: String -> HtmlAttr\n"
"face                :: String -> HtmlAttr\n"
"frameborder         :: Int    -> HtmlAttr\n"
"height              :: Int    -> HtmlAttr\n"
"href                :: String -> HtmlAttr\n"
"hspace              :: Int    -> HtmlAttr\n"
"httpequiv           :: String -> HtmlAttr\n"
"identifier          :: String -> HtmlAttr\n"
"ismap               ::           HtmlAttr\n"
"lang                :: String -> HtmlAttr\n"
"link                :: String -> HtmlAttr\n"
"marginheight        :: Int    -> HtmlAttr\n"
"marginwidth         :: Int    -> HtmlAttr\n"
"maxlength           :: Int    -> HtmlAttr\n"
"method              :: String -> HtmlAttr\n"
"multiple            ::           HtmlAttr\n"
"name                :: String -> HtmlAttr\n"
"nohref              ::           HtmlAttr\n"
"noresize            ::           HtmlAttr\n"
"noshade             ::           HtmlAttr\n"
"nowrap              ::           HtmlAttr\n"
"rel                 :: String -> HtmlAttr\n"
"rev                 :: String -> HtmlAttr\n"
"rows                :: String -> HtmlAttr\n"
"rowspan             :: Int    -> HtmlAttr\n"
"rules               :: String -> HtmlAttr\n"
"scrolling           :: String -> HtmlAttr\n"
"selected            ::           HtmlAttr\n"
"shape               :: String -> HtmlAttr\n"
"size                :: String -> HtmlAttr\n"
"src                 :: String -> HtmlAttr\n"
"start               :: Int    -> HtmlAttr\n"
"target              :: String -> HtmlAttr\n"
"text                :: String -> HtmlAttr\n"
"theclass            :: String -> HtmlAttr\n"
"thestyle            :: String -> HtmlAttr\n"
"thetype             :: String -> HtmlAttr\n"
"title               :: String -> HtmlAttr\n"
"usemap              :: String -> HtmlAttr\n"
"valign              :: String -> HtmlAttr\n"
"value               :: String -> HtmlAttr\n"
"version             :: String -> HtmlAttr\n"
"vlink               :: String -> HtmlAttr\n"
"vspace              :: Int    -> HtmlAttr\n"
"width               :: String -> HtmlAttr\n"
"\n"
"action              =   strAttr \"ACTION\"\n"
"align               =   strAttr \"ALIGN\"\n"
"alink               =   strAttr \"ALINK\"\n"
"alt                 =   strAttr \"ALT\"\n"
"altcode             =   strAttr \"ALTCODE\"\n"
"archive             =   strAttr \"ARCHIVE\"\n"
"background          =   strAttr \"BACKGROUND\"\n"
"base                =   strAttr \"BASE\"\n"
"bgcolor             =   strAttr \"BGCOLOR\"\n"
"border              =   intAttr \"BORDER\"\n"
"bordercolor         =   strAttr \"BORDERCOLOR\"\n"
"cellpadding         =   intAttr \"CELLPADDING\"\n"
"cellspacing         =   intAttr \"CELLSPACING\"\n"
"checked             = emptyAttr \"CHECKED\"\n"
"clear               =   strAttr \"CLEAR\"\n"
"code                =   strAttr \"CODE\"\n"
"codebase            =   strAttr \"CODEBASE\"\n"
"color               =   strAttr \"COLOR\"\n"
"cols                =   strAttr \"COLS\"\n"
"colspan             =   intAttr \"COLSPAN\"\n"
"compact             = emptyAttr \"COMPACT\"\n"
"content             =   strAttr \"CONTENT\"\n"
"coords              =   strAttr \"COORDS\"\n"
"enctype             =   strAttr \"ENCTYPE\"\n"
"face                =   strAttr \"FACE\"\n"
"frameborder         =   intAttr \"FRAMEBORDER\"\n"
"height              =   intAttr \"HEIGHT\"\n"
"href                =   strAttr \"HREF\"\n"
"hspace              =   intAttr \"HSPACE\"\n"
"httpequiv           =   strAttr \"HTTPEQUIV\"\n"
"identifier          =   strAttr \"ID\"\n"
"ismap               = emptyAttr \"ISMAP\"\n"
"lang                =   strAttr \"LANG\"\n"
"link                =   strAttr \"LINK\"\n"
"marginheight        =   intAttr \"MARGINHEIGHT\"\n"
"marginwidth         =   intAttr \"MARGINWIDTH\"\n"
"maxlength           =   intAttr \"MAXLENGTH\"\n"
"method              =   strAttr \"METHOD\"\n"
"multiple            = emptyAttr \"MULTIPLE\"\n"
"name                =   strAttr \"NAME\"\n"
"nohref              = emptyAttr \"NOHREF\"\n"
"noresize            = emptyAttr \"NORESIZE\"\n"
"noshade             = emptyAttr \"NOSHADE\"\n"
"nowrap              = emptyAttr \"NOWRAP\"\n"
"rel                 =   strAttr \"REL\"\n"
"rev                 =   strAttr \"REV\"\n"
"rows                =   strAttr \"ROWS\"\n"
"rowspan             =   intAttr \"ROWSPAN\"\n"
"rules               =   strAttr \"RULES\"\n"
"scrolling           =   strAttr \"SCROLLING\"\n"
"selected            = emptyAttr \"SELECTED\"\n"
"shape               =   strAttr \"SHAPE\"\n"
"size                =   strAttr \"SIZE\"\n"
"src                 =   strAttr \"SRC\"\n"
"start               =   intAttr \"START\"\n"
"target              =   strAttr \"TARGET\"\n"
"text                =   strAttr \"TEXT\"\n"
"theclass            =   strAttr \"CLASS\"\n"
"thestyle            =   strAttr \"STYLE\"\n"
"thetype             =   strAttr \"TYPE\"\n"
"title               =   strAttr \"TITLE\"\n"
"usemap              =   strAttr \"USEMAP\"\n"
"valign              =   strAttr \"VALIGN\"\n"
"value               =   strAttr \"VALUE\"\n"
"version             =   strAttr \"VERSION\"\n"
"vlink               =   strAttr \"VLINK\"\n"
"vspace              =   intAttr \"VSPACE\"\n"
"width               =   strAttr \"WIDTH\"\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Html Constructors\n"
"\n"
"-- (automatically generated)\n"
"\n"
"validHtmlTags :: [String]\n"
"validHtmlTags = [\n"
"      \"ADDRESS\",\n"
"      \"A\",\n"
"      \"APPLET\",\n"
"      \"BIG\",\n"
"      \"BLOCKQUOTE\",\n"
"      \"BODY\",\n"
"      \"B\",\n"
"      \"CAPTION\",\n"
"      \"CENTER\",\n"
"      \"CITE\",\n"
"      \"DD\",\n"
"      \"DFN\",\n"
"      \"DL\",\n"
"      \"DT\",\n"
"      \"EM\",\n"
"      \"FIELDSET\",\n"
"      \"FONT\",\n"
"      \"FORM\",\n"
"      \"FRAME\",\n"
"      \"FRAMESET\",\n"
"      \"H1\",\n"
"      \"H2\",\n"
"      \"H3\",\n"
"      \"H4\",\n"
"      \"H5\",\n"
"      \"H6\",\n"
"      \"HEAD\",\n"
"      \"I\",\n"
"      \"KBD\",\n"
"      \"LEGEND\",\n"
"      \"LI\",\n"
"      \"NOFRAMES\",\n"
"      \"OL\",\n"
"      \"OPTION\",\n"
"      \"P\",\n"
"      \"PRE\",\n"
"      \"SAMP\",\n"
"      \"SELECT\",\n"
"      \"SMALL\",\n"
"      \"STRONG\",\n"
"      \"STYLE\",\n"
"      \"SUB\",\n"
"      \"SUP\",\n"
"      \"TABLE\",\n"
"      \"TD\",\n"
"      \"TEXTAREA\",\n"
"      \"TH\",\n"
"      \"CODE\",\n"
"      \"DIV\",\n"
"      \"HTML\",\n"
"      \"LINK\",\n"
"      \"MAP\",\n"
"      \"TITLE\",\n"
"      \"TR\",\n"
"      \"TT\",\n"
"      \"UL\",\n"
"      \"U\",\n"
"      \"VAR\"]\n"
"\n"
"validHtmlITags :: [String]\n"
"validHtmlITags = [\n"
"      \"AREA\",\n"
"      \"BASEFONT\",\n"
"      \"BR\",\n"
"      \"HR\",\n"
"      \"IMG\",\n"
"      \"INPUT\",\n"
"      \"META\",\n"
"      \"PARAM\",\n"
"      \"BASE\"]\n"
"\n"
"validHtmlAttrs :: [String]\n"
"validHtmlAttrs = [\n"
"      \"ACTION\",\n"
"      \"ALIGN\",\n"
"      \"ALINK\",\n"
"      \"ALT\",\n"
"      \"ALTCODE\",\n"
"      \"ARCHIVE\",\n"
"      \"BACKGROUND\",\n"
"      \"BASE\",\n"
"      \"BGCOLOR\",\n"
"      \"BORDER\",\n"
"      \"BORDERCOLOR\",\n"
"      \"CELLPADDING\",\n"
"      \"CELLSPACING\",\n"
"      \"CHECKED\",\n"
"      \"CLEAR\",\n"
"      \"CODE\",\n"
"      \"CODEBASE\",\n"
"      \"COLOR\",\n"
"      \"COLS\",\n"
"      \"COLSPAN\",\n"
"      \"COMPACT\",\n"
"      \"CONTENT\",\n"
"      \"COORDS\",\n"
"      \"ENCTYPE\",\n"
"      \"FACE\",\n"
"      \"FRAMEBORDER\",\n"
"      \"HEIGHT\",\n"
"      \"HREF\",\n"
"      \"HSPACE\",\n"
"      \"HTTPEQUIV\",\n"
"      \"ID\",\n"
"      \"ISMAP\",\n"
"      \"LANG\",\n"
"      \"LINK\",\n"
"      \"MARGINHEIGHT\",\n"
"      \"MARGINWIDTH\",\n"
"      \"MAXLENGTH\",\n"
"      \"METHOD\",\n"
"      \"MULTIPLE\",\n"
"      \"NAME\",\n"
"      \"NOHREF\",\n"
"      \"NORESIZE\",\n"
"      \"NOSHADE\",\n"
"      \"NOWRAP\",\n"
"      \"REL\",\n"
"      \"REV\",\n"
"      \"ROWS\",\n"
"      \"ROWSPAN\",\n"
"      \"RULES\",\n"
"      \"SCROLLING\",\n"
"      \"SELECTED\",\n"
"      \"SHAPE\",\n"
"      \"SIZE\",\n"
"      \"SRC\",\n"
"      \"START\",\n"
"      \"TARGET\",\n"
"      \"TEXT\",\n"
"      \"CLASS\",\n"
"      \"STYLE\",\n"
"      \"TYPE\",\n"
"      \"TITLE\",\n"
"      \"USEMAP\",\n"
"      \"VALIGN\",\n"
"      \"VALUE\",\n"
"      \"VERSION\",\n"
"      \"VLINK\",\n"
"      \"VSPACE\",\n"
"      \"WIDTH\"]\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Html colors\n"
"\n"
"aqua          :: String\n"
"black         :: String\n"
"blue          :: String\n"
"fuchsia       :: String\n"
"gray          :: String\n"
"green         :: String\n"
"lime          :: String\n"
"maroon        :: String\n"
"navy          :: String\n"
"olive         :: String\n"
"purple        :: String\n"
"red           :: String\n"
"silver        :: String\n"
"teal          :: String\n"
"yellow        :: String\n"
"white         :: String\n"
"\n"
"aqua          = \"aqua\"\n"
"black         = \"black\"\n"
"blue          = \"blue\"\n"
"fuchsia       = \"fuchsia\"\n"
"gray          = \"gray\"\n"
"green         = \"green\"\n"
"lime          = \"lime\"\n"
"maroon        = \"maroon\"\n"
"navy          = \"navy\"\n"
"olive         = \"olive\"\n"
"purple        = \"purple\"\n"
"red           = \"red\"\n"
"silver        = \"silver\"\n"
"teal          = \"teal\"\n"
"yellow        = \"yellow\"\n"
"white         = \"white\"\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Basic Combinators\n"
"\n"
"linesToHtml :: [String]       -> Html\n"
"\n"
"linesToHtml []     = noHtml\n"
"linesToHtml (x:[]) = lineToHtml x\n"
"linesToHtml (x:xs) = lineToHtml x +++ br +++ linesToHtml xs\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Html abbriviations\n"
"\n"
"primHtmlChar  :: String -> Html\n"
"copyright     :: Html\n"
"spaceHtml     :: Html\n"
"bullet        :: Html\n"
"p             :: Html -> Html\n"
"\n"
"primHtmlChar  = \\ x -> primHtml (\"&\" ++ x ++ \";\")\n"
"copyright     = primHtmlChar \"copy\"\n"
"spaceHtml     = primHtmlChar \"nbsp\"\n"
"bullet        = primHtmlChar \"#149\"\n"
"\n"
"p             = paragraph\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Html tables\n"
"\n"
"class HTMLTABLE ht where\n"
"      cell :: ht -> HtmlTable\n"
"\n"
"instance HTMLTABLE HtmlTable where\n"
"      cell = id\n"
"\n"
"instance HTMLTABLE Html where\n"
"      cell h = \n"
"         let\n"
"              cellFn x y = h ! (add x colspan $ add y rowspan $ [])\n"
"              add 1 fn rest = rest\n"
"              add n fn rest = fn n : rest\n"
"              r = BT.single cellFn\n"
"         in \n"
"              mkHtmlTable r\n"
"\n"
"-- We internally represent the Cell inside a Table with an\n"
"-- object of the type\n"
"-- \\pre{\n"
"-- 	   Int -> Int -> Html\n"
"-- } 	\n"
"-- When we render it later, we find out how many columns\n"
"-- or rows this cell will span over, and can\n"
"-- include the correct colspan/rowspan command.\n"
"\n"
"newtype HtmlTable \n"
"      = HtmlTable (BT.BlockTable (Int -> Int -> Html))\n"
"\n"
"(</>),above,(<->),beside :: (HTMLTABLE ht1,HTMLTABLE ht2)\n"
"                       => ht1 -> ht2 -> HtmlTable\n"
"aboves,besides                 :: (HTMLTABLE ht) => [ht] -> HtmlTable\n"
"simpleTable            :: [HtmlAttr] -> [HtmlAttr] -> [[Html]] -> Html\n"
"\n"
"mkHtmlTable :: BT.BlockTable (Int -> Int -> Html) -> HtmlTable\n"
"mkHtmlTable r = HtmlTable r\n"
"\n"
"-- We give both infix and nonfix, take your pick.\n"
"-- Notice that there is no concept of a row/column\n"
"-- of zero items.\n"
"\n"
"above   a b = combine BT.above (cell a) (cell b)\n"
"(</>)         = above\n"
"beside  a b = combine BT.beside (cell a) (cell b)\n"
"(<->) = beside\n"
"\n"
"combine fn (HtmlTable a) (HtmlTable b) = mkHtmlTable (a `fn` b)\n"
"\n"
"-- Both aboves and besides presume a non-empty list.\n"
"-- here is no concept of a empty row or column in these\n"
"-- table combinators.\n"
"\n"
"aboves []  = error \"aboves []\"\n"
"aboves xs  = foldr1 (</>) (map cell xs)\n"
"besides [] = error \"besides []\"\n"
"besides xs = foldr1 (<->) (map cell xs)\n"
"\n"
"-- renderTable takes the HtmlTable, and renders it back into\n"
"-- and Html object.\n"
"\n"
"renderTable :: BT.BlockTable (Int -> Int -> Html) -> Html\n"
"renderTable theTable\n"
"      = concatHtml\n"
"          [tr << [theCell x y | (theCell,(x,y)) <- theRow ]\n"
"                      | theRow <- BT.getMatrix theTable]\n"
"\n"
"instance HTML HtmlTable where\n"
"      toHtml (HtmlTable tab) = renderTable tab\n"
"\n"
"instance Show HtmlTable where\n"
"      showsPrec _ (HtmlTable tab) = shows (renderTable tab)\n"
"\n"
"-- If you can't be bothered with the above, then you\n"
"-- can build simple tables with simpleTable.\n"
"-- Just provide the attributes for the whole table,\n"
"-- attributes for the cells (same for every cell),\n"
"-- and a list of lists of cell contents,\n"
"-- and this function will build the table for you.\n"
"-- It does presume that all the lists are non-empty,\n"
"-- and there is at least one list.\n"
"--  \n"
"-- Different length lists means that the last cell\n"
"-- gets padded. If you want more power, then\n"
"-- use the system above, or build tables explicitly.\n"
"\n"
"simpleTable attr cellAttr lst\n"
"      = table ! attr \n"
"          <<  (aboves \n"
"              . map (besides . map ((td ! cellAttr) . toHtml))\n"
"              ) lst\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Tree Displaying Combinators\n"
" \n"
"-- The basic idea is you render your structure in the form\n"
"-- of this tree, and then use treeHtml to turn it into a Html\n"
"-- object with the structure explicit.\n"
"\n"
"data HtmlTree\n"
"      = HtmlLeaf Html\n"
"      | HtmlNode Html [HtmlTree] Html\n"
"\n"
"treeHtml :: [String] -> HtmlTree -> Html\n"
"treeHtml colors h = table ! [\n"
"                    border 0,\n"
"                    cellpadding 0,\n"
"                    cellspacing 2] << treeHtml' colors h\n"
"     where\n"
"      manycolors = scanr (:) []\n"
"\n"
"      treeHtmls :: [[String]] -> [HtmlTree] -> HtmlTable\n"
"      treeHtmls c ts = aboves (zipWith treeHtml' c ts)\n"
"\n"
"      treeHtml' :: [String] -> HtmlTree -> HtmlTable\n"
"      treeHtml' (c:_) (HtmlLeaf leaf) = cell\n"
"                                         (td ! [width \"100%\"] \n"
"                                            << bold  \n"
"                                               << leaf)\n"
"      treeHtml' (c:cs@(c2:_)) (HtmlNode hopen ts hclose) =\n"
"          if null ts && isNoHtml hclose\n"
"          then\n"
"              cell hd \n"
"          else if null ts\n"
"          then\n"
"              hd </> bar `beside` (td ! [bgcolor c2] << spaceHtml)\n"
"                 </> tl\n"
"          else\n"
"              hd </> (bar `beside` treeHtmls morecolors ts)\n"
"                 </> tl\n"
"        where\n"
"              -- This stops a column of colors being the same\n"
"              -- color as the immeduately outside nesting bar.\n"
"              morecolors = filter ((/= c).head) (manycolors cs)\n"
"              bar = td ! [bgcolor c,width \"10\"] << spaceHtml\n"
"              hd = td ! [bgcolor c] << hopen\n"
"              tl = td ! [bgcolor c] << hclose\n"
"      treeHtml' _ _ = error \"The imposible happens\"\n"
"\n"
"instance HTML HtmlTree where\n"
"      toHtml x = treeHtml treeColors x\n"
"\n"
"-- type \"length treeColors\" to see how many colors are here.\n"
"treeColors = [\"#88ccff\",\"#ffffaa\",\"#ffaaff\",\"#ccffff\"] ++ treeColors\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Html Debugging Combinators\n"
" \n"
"-- This uses the above tree rendering function, and displays the\n"
"-- Html as a tree structure, allowing debugging of what is\n"
"-- actually getting produced.\n"
"\n"
"debugHtml :: (HTML a) => a -> Html\n"
"debugHtml obj = table ! [border 0] << \n"
"                  ( th ! [bgcolor \"#008888\"] \n"
"                     << underline\n"
"                       << \"Debugging Output\"\n"
"               </>  td << (toHtml (debug' (toHtml obj)))\n"
"              )\n"
"  where\n"
"\n"
"      debug' :: Html -> [HtmlTree]\n"
"      debug' (Html markups) = map debug markups\n"
"\n"
"      debug :: HtmlElement -> HtmlTree\n"
"      debug (HtmlString str) = HtmlLeaf (spaceHtml +++\n"
"                                              linesToHtml (lines str))\n"
"      debug (HtmlTag {\n"
"              markupTag = markupTag,\n"
"              markupContent = markupContent,\n"
"              markupAttrs  = markupAttrs\n"
"              }) =\n"
"              case markupContent of\n"
"                Html [] -> HtmlNode hd [] noHtml\n"
"                Html xs -> HtmlNode hd (map debug xs) tl\n"
"        where\n"
"              args = if null markupAttrs\n"
"                     then \"\"\n"
"                     else \"  \" ++ unwords (map show markupAttrs) \n"
"              hd = font ! [size \"1\"] << (\"<\" ++ markupTag ++ args ++ \">\")\n"
"              tl = font ! [size \"1\"] << (\"</\" ++ markupTag ++ \">\")\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Hotlink datatype\n"
"\n"
"data HotLink = HotLink {\n"
"      hotLinkURL        :: URL,\n"
"      hotLinkContents   :: [Html],\n"
"      hotLinkAttributes :: [HtmlAttr]\n"
"      } deriving Show\n"
"\n"
"instance HTML HotLink where\n"
"      toHtml hl = anchor ! (href (hotLinkURL hl) : hotLinkAttributes hl)\n"
"                      << hotLinkContents hl\n"
"\n"
"hotlink :: URL -> [Html] -> HotLink\n"
"hotlink url h = HotLink {\n"
"      hotLinkURL = url,\n"
"      hotLinkContents = h,\n"
"      hotLinkAttributes = [] }\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- More Combinators\n"
"\n"
"-- (Abridged from Erik Meijer's Original Html library)\n"
"\n"
"ordList   :: (HTML a) => [a] -> Html\n"
"ordList items = olist << map (li <<) items\n"
"\n"
"unordList :: (HTML a) => [a] -> Html\n"
"unordList items = ulist << map (li <<) items\n"
"\n"
"defList   :: (HTML a,HTML b) => [(a,b)] -> Html\n"
"defList items\n"
" = dlist << [ [ dterm << bold << dt, ddef << dd ] | (dt,dd) <- items ]\n"
"\n"
"widget :: String -> String -> [HtmlAttr] -> Html\n"
"widget w n markupAttrs = input ! ([thetype w,name n] ++ markupAttrs)\n"
"\n"
"checkbox :: String -> String -> Html\n"
"hidden   :: String -> String -> Html\n"
"radio    :: String -> String -> Html\n"
"reset    :: String -> String -> Html\n"
"submit   :: String -> String -> Html\n"
"password :: String           -> Html\n"
"textfield :: String          -> Html\n"
"afile    :: String           -> Html\n"
"clickmap :: String           -> Html\n"
"\n"
"checkbox n v = widget \"CHECKBOX\" n [value v]\n"
"hidden   n v = widget \"HIDDEN\"   n [value v]\n"
"radio    n v = widget \"RADIO\"    n [value v]\n"
"reset    n v = widget \"RESET\"    n [value v]\n"
"submit   n v = widget \"SUBMIT\"   n [value v]\n"
"password n   = widget \"PASSWORD\" n []\n"
"textfield n  = widget \"TEXT\"     n []\n"
"afile    n   = widget \"FILE\"     n []\n"
"clickmap n   = widget \"IMAGE\"    n []\n"
"\n"
"menu :: String -> [Html] -> Html\n"
"menu n choices\n"
"   = select ! [name n] << [ option << p << choice | choice <- choices ]\n"
"\n"
"gui :: String -> Html -> Html\n"
"gui act = form ! [action act,method \"POST\"]\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Html Rendering\n"
" \n"
"-- Uses the append trick to optimize appending.\n"
"-- The output is quite messy, because space matters in\n"
"-- HTML, so we must not generate needless spaces.\n"
"\n"
"renderHtml :: (HTML html) => html -> String\n"
"renderHtml theHtml =\n"
"      renderMessage ++ \n"
"         foldr (.) id (map (renderHtml' 0)\n"
"                           (getHtmlElements (tag \"HTML\" << theHtml))) \"\\n\"\n"
"\n"
"renderMessage =\n"
"      \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 3.2 FINAL//EN\\\">\\n\" ++\n"
"      \"<!--Rendered using the Haskell Html Library v0.2-->\\n\"\n"
"\n"
"-- Warning: spaces matters in HTML. You are better using renderHtml.\n"
"-- This is intentually very inefficent to \"encorage\" this,\n"
"-- but the neater version in easier when debugging.\n"
"\n"
"-- Local Utilities\n"
"prettyHtml :: (HTML html) => html -> String\n"
"prettyHtml theHtml = \n"
"        unlines\n"
"      $ concat\n"
"      $ map prettyHtml'\n"
"      $ getHtmlElements\n"
"      $ toHtml theHtml\n"
"\n"
"renderHtml' :: Int -> HtmlElement -> ShowS\n"
"renderHtml' _ (HtmlString str) = (++) str\n"
"renderHtml' n (HtmlTag\n"
"              { markupTag = name,\n"
"                markupContent = html,\n"
"                markupAttrs = markupAttrs })\n"
"      = if isNoHtml html && elem name validHtmlITags\n"
"        then renderTag True name markupAttrs n\n"
"        else (renderTag True name markupAttrs n\n"
"             . foldr (.) id (map (renderHtml' (n+2)) (getHtmlElements html))\n"
"             . renderTag False name [] n)\n"
"\n"
"prettyHtml' :: HtmlElement -> [String]\n"
"prettyHtml' (HtmlString str) = [str]\n"
"prettyHtml' (HtmlTag\n"
"              { markupTag = name,\n"
"                markupContent = html,\n"
"                markupAttrs = markupAttrs })\n"
"      = if isNoHtml html && elem name validHtmlITags\n"
"        then \n"
"         [rmNL (renderTag True name markupAttrs 0 \"\")]\n"
"        else\n"
"         [rmNL (renderTag True name markupAttrs 0 \"\")] ++ \n"
"          shift (concat (map prettyHtml' (getHtmlElements html))) ++\n"
"         [rmNL (renderTag False name [] 0 \"\")]\n"
"  where\n"
"      shift = map (\\x -> \"   \" ++ x)\n"
"rmNL = filter (/= '\\n')\n"
"\n"
"-- This prints the Tags The lack of spaces in intentunal, because Html is\n"
"-- actually space dependant.\n"
"\n"
"renderTag :: Bool -> String -> [HtmlAttr] -> Int -> ShowS\n"
"renderTag x name markupAttrs n r\n"
"      = open ++ name ++ rest markupAttrs ++ \">\" ++ r\n"
"  where\n"
"      open = if x then \"<\" else \"</\"\n"
"      \n"
"      nl = \"\\n\" ++ replicate (n `div` 8) '\\t' \n"
"                ++ replicate (n `mod` 8) ' '\n"
"\n"
"      rest []   = nl\n"
"      rest attr = \" \" ++ unwords (map showPair attr) ++ nl\n"
"\n"
"      showPair :: HtmlAttr -> String\n"
"      showPair (HtmlAttr tag val)\n"
"              = tag ++ \" = \\\"\" ++ val  ++ \"\\\"\"\n"
"\n";
const char *Text_Show = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.Show\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- The Show class and associated functions.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.Show (\n"
"   ShowS,	 	-- String -> String\n"
"   Show(\n"
"      showsPrec,	-- :: Int -> a -> ShowS\n"
"      show,		-- :: a   -> String\n"
"      showList		-- :: [a] -> ShowS \n"
"    ),\n"
"   shows,		-- :: (Show a) => a -> ShowS\n"
"   showChar,		-- :: Char -> ShowS\n"
"   showString,		-- :: String -> ShowS\n"
"   showParen,		-- :: Bool -> ShowS -> ShowS\n"
"   showListWith,	-- :: (a -> ShowS) -> [a] -> ShowS \n"
" ) where\n"
"\n"
"showListWith :: (a -> ShowS) -> [a] -> ShowS \n"
"showListWith = showList__\n"
"\n"
"showList__ :: (a -> ShowS) ->  [a] -> ShowS\n"
"showList__ _     []     s = \"[]\" ++ s\n"
"showList__ showx (x:xs) s = '[' : showx x (showl xs)\n"
"  where\n"
"    showl []     = ']' : s\n"
"    showl (y:ys) = ',' : showx y (showl ys)\n";
const char *Text_Regex = "\n"
"{-# OPTIONS -cpp #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.Regex\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (only on platforms that provide a regex lib)\n"
"--\n"
"-- Regular expression matching.  Uses the POSIX regular expression\n"
"-- interface in \"Text.Regex.Posix\".\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.Regex (\n"
"    -- * Regular expressions\n"
"    Regex,\n"
"    mkRegex,\n"
"    mkRegexWithOpts,\n"
"    matchRegex,\n"
"    matchRegexAll\n"
"  ) where\n"
"\n"
"import Prelude\n"
"import qualified Text.Regex.Posix as RE\n"
"import Text.Regex.Posix ( Regex )\n"
"import System.IO.Unsafe\n"
"\n"
"-- | Makes a regular expression with the default options (multi-line,\n"
"-- case-sensitive).  The syntax of regular expressions is\n"
"-- otherwise that of @egrep@ (i.e. POSIX \\\"extended\\\" regular\n"
"-- expressions).\n"
"mkRegex :: String -> Regex\n"
"mkRegex s = unsafePerformIO (RE.regcomp s RE.regExtended)\n"
"\n"
"-- | Makes a regular expression, where the multi-line and\n"
"-- case-sensitve options can be changed from the default settings.\n"
"mkRegexWithOpts\n"
"   :: String  -- ^ The regular expression to compile\n"
"   -> Bool    -- ^ 'True' @\\<=>@ @\\'^\\'@ and @\\'$\\'@ match the beginning and \n"
"	      -- end of individual lines respectively, and @\\'.\\'@ does /not/\n"
"	      -- match the newline character.\n"
"   -> Bool    -- ^ 'True' @\\<=>@ matching is case-sensitive\n"
"   -> Regex   -- ^ Returns: the compiled regular expression\n"
"\n"
"mkRegexWithOpts s single_line case_sensitive\n"
"   = unsafePerformIO (RE.regcomp s (RE.regExtended + newline + igcase))\n"
"   where\n"
"	newline | single_line = RE.regNewline\n"
"		| otherwise   = 0\n"
"\n"
"	igcase  | case_sensitive = 0 \n"
"		| otherwise 	 = RE.regIgnoreCase\n"
"\n"
"-- | Match a regular expression against a string\n"
"matchRegex\n"
"   :: Regex	-- ^ The regular expression\n"
"   -> String	-- ^ The string to match against\n"
"   -> Maybe [String]	-- ^ Returns: @'Just' strs@ if the match succeeded\n"
"			-- (and @strs@ is the list of subexpression matches),\n"
"			-- or 'Nothing' otherwise.\n"
"matchRegex p str = \n"
"  case (unsafePerformIO (RE.regexec p str)) of\n"
"	Nothing -> Nothing\n"
"	Just (before, match, after, sub_strs) -> Just sub_strs\n"
"\n"
"-- | Match a regular expression against a string, returning more information\n"
"-- about the match.\n"
"matchRegexAll\n"
"   :: Regex	-- ^ The regular expression\n"
"   -> String	-- ^ The string to match against\n"
"   -> Maybe ( String, String, String, [String] )\n"
"		-- ^ Returns: 'Nothing' if the match failed, or:\n"
"		-- \n"
"		-- >  Just ( everything before match,\n"
"		-- >         portion matched,\n"
"		-- >         everything after the match,\n"
"		-- >         subexpression matches )\n"
"\n"
"matchRegexAll p str = unsafePerformIO (RE.regexec p str)\n"
"\n";
const char *Text_Regex_Posix = "{-# LINE 1 \"Posix.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"{-# LINE 2 \"Posix.hsc\" #-}\n"
"-- |\n"
"-- Module      :  Text.Regex.Posix\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (needs POSIX regexps)\n"
"--\n"
"-- Interface to the POSIX regular expression library.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- ToDo: should have an interface using PackedStrings.\n"
"\n"
"{-# LINE 17 \"Posix.hsc\" #-}\n"
"\n"
"module Text.Regex.Posix (\n"
"	-- * The @Regex@ type\n"
"	Regex,	 	-- abstract\n"
"\n"
"\n"
"{-# LINE 23 \"Posix.hsc\" #-}\n"
"	-- * Compiling a regular expression\n"
"	regcomp, 	-- :: String -> Int -> IO Regex\n"
"\n"
"	-- ** Flags for regcomp\n"
"	regExtended,	-- (flag to regcomp) use extended regex syntax\n"
"	regIgnoreCase,	-- (flag to regcomp) ignore case when matching\n"
"	regNewline,	-- (flag to regcomp) '.' doesn't match newline\n"
"\n"
"	-- * Matching a regular expression\n"
"	regexec, 	-- :: Regex		     -- pattern\n"
"	         	-- -> String		     -- string to match\n"
"	         	-- -> IO (Maybe (String,     -- everything before match\n"
"	         	-- 	 	 String,     -- matched portion\n"
"	         	--		 String,     -- everything after match\n"
"	         	-- 	 	 [String]))  -- subexpression matches\n"
"\n"
"\n"
"{-# LINE 40 \"Posix.hsc\" #-}\n"
"  ) where\n"
"\n"
"\n"
"{-# LINE 43 \"Posix.hsc\" #-}\n"
"\n"
"{-# LINE 44 \"Posix.hsc\" #-}\n"
"\n"
"{-# LINE 45 \"Posix.hsc\" #-}\n"
"\n"
"{-# LINE 46 \"Posix.hsc\" #-}\n"
"\n"
"import Prelude\n"
"\n"
"import Foreign\n"
"import Foreign.C\n"
"\n"
"type CRegex    = ()\n"
"\n"
"-- | A compiled regular expression\n"
"newtype Regex = Regex (ForeignPtr CRegex)\n"
"\n"
"\n"
"{-# LINE 58 \"Posix.hsc\" #-}\n"
"-- to the end\n"
"-- -----------------------------------------------------------------------------\n"
"-- regcomp\n"
"\n"
"-- | Compiles a regular expression\n"
"regcomp\n"
"  :: String  	-- ^ The regular expression to compile\n"
"  -> Int    	-- ^ Flags (summed together)\n"
"  -> IO Regex  	-- ^ Returns: the compiled regular expression\n"
"regcomp pattern flags = do\n"
"  regex_fptr <- mallocForeignPtrBytes (64)\n"
"{-# LINE 69 \"Posix.hsc\" #-}\n"
"  r <- withCString pattern $ \\cstr ->\n"
"    	 withForeignPtr regex_fptr $ \\p ->\n"
"           c_regcomp p cstr (fromIntegral flags)\n"
"  if (r == 0)\n"
"     then do addForeignPtrFinalizer ptr_regfree regex_fptr\n"
"	     return (Regex regex_fptr)\n"
"     else error \"Text.Regex.Posix.regcomp: error in pattern\" -- ToDo\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- regexec\n"
"\n"
"-- | Matches a regular expression against a string\n"
"regexec :: Regex			-- ^ Compiled regular expression\n"
"	-> String			-- ^ String to match against\n"
"	-> IO (Maybe (String, String, String, [String]))\n"
"	 	-- ^ Returns: 'Nothing' if the regex did not match the\n"
"		-- string, or:\n"
"		--\n"
"		-- @\n"
"		--   'Just' (everything before match,\n"
"		--         matched portion,\n"
"		--         everything after match,\n"
"		--         subexpression matches)\n"
"		-- @\n"
"\n"
"regexec (Regex regex_fptr) str = do\n"
"  withCString str $ \\cstr -> do\n"
"    withForeignPtr regex_fptr $ \\regex_ptr -> do\n"
"      nsub <- ((\\hsc_ptr -> peekByteOff hsc_ptr 48)) regex_ptr\n"
"{-# LINE 98 \"Posix.hsc\" #-}\n"
"      let nsub_int = fromIntegral (nsub :: CSize)\n"
"      allocaBytes ((1 + nsub_int) * (8)) $ \\p_match -> do\n"
"{-# LINE 100 \"Posix.hsc\" #-}\n"
"		-- add one because index zero covers the whole match\n"
"        r <- c_regexec regex_ptr cstr (1 + nsub) p_match 0{-no flags for now-}\n"
"\n"
"        if (r /= 0) then return Nothing else do \n"
"\n"
"        (before,match,after) <- matched_parts str p_match\n"
"\n"
"        sub_strs <- \n"
"	  mapM (unpack str) $ take nsub_int $ tail $\n"
"	     iterate (`plusPtr` (8)) p_match\n"
"{-# LINE 110 \"Posix.hsc\" #-}\n"
"\n"
"        return (Just (before, match, after, sub_strs))\n"
"\n"
"matched_parts :: String -> Ptr CRegMatch -> IO (String, String, String)\n"
"matched_parts string p_match = do\n"
"  start <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0)) p_match :: IO (Int32)\n"
"{-# LINE 116 \"Posix.hsc\" #-}\n"
"  end   <- ((\\hsc_ptr -> peekByteOff hsc_ptr 4)) p_match :: IO (Int32)\n"
"{-# LINE 117 \"Posix.hsc\" #-}\n"
"  let s = fromIntegral start; e = fromIntegral end\n"
"  return ( take s string, \n"
"	   take (e-s) (drop s string),\n"
"	   drop e string )  \n"
"\n"
"unpack :: String -> Ptr CRegMatch -> IO (String)\n"
"unpack string p_match = do\n"
"  start <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0)) p_match :: IO (Int32)\n"
"{-# LINE 125 \"Posix.hsc\" #-}\n"
"  end   <- ((\\hsc_ptr -> peekByteOff hsc_ptr 4)) p_match :: IO (Int32)\n"
"{-# LINE 126 \"Posix.hsc\" #-}\n"
"  -- the subexpression may not have matched at all, perhaps because it\n"
"  -- was optional.  In this case, the offsets are set to -1.\n"
"  if (start == -1) then return \"\" else do\n"
"  return (take (fromIntegral (end-start)) (drop (fromIntegral start) string))\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- The POSIX regex C interface\n"
"\n"
"-- Flags for regexec\n"
"regNotbol :: Int\n"
"regNotbol =  1\n"
"regNoteol :: Int\n"
"regNoteol =  2\n"
"\n"
"{-# LINE 138 \"Posix.hsc\" #-}\n"
"\n"
"-- Return values from regexec\n"
"regNomatch :: Int\n"
"regNomatch =  1\n"
"\n"
"{-# LINE 142 \"Posix.hsc\" #-}\n"
"--	REG_ESPACE\n"
"\n"
"-- Flags for regcomp\n"
"regExtended :: Int\n"
"regExtended =  1\n"
"regIgnoreCase  :: Int\n"
"regIgnoreCase  =  2\n"
"regNosub :: Int\n"
"regNosub =  8\n"
"regNewline :: Int\n"
"regNewline =  4\n"
"\n"
"{-# LINE 150 \"Posix.hsc\" #-}\n"
"\n"
"-- Error codes from regcomp\n"
"regBadbr :: Int\n"
"regBadbr =  10\n"
"regBadpat :: Int\n"
"regBadpat =  2\n"
"regBadrpt :: Int\n"
"regBadrpt =  13\n"
"regEcollate :: Int\n"
"regEcollate =  3\n"
"regEctype :: Int\n"
"regEctype =  4\n"
"regEescape :: Int\n"
"regEescape =  5\n"
"regEsubreg :: Int\n"
"regEsubreg =  6\n"
"regEbrack :: Int\n"
"regEbrack =  7\n"
"regEparen :: Int\n"
"regEparen =  8\n"
"regEbrace :: Int\n"
"regEbrace =  9\n"
"regErange :: Int\n"
"regErange =  11\n"
"regEspace :: Int\n"
"regEspace =  12\n"
"\n"
"{-# LINE 165 \"Posix.hsc\" #-}\n"
"\n"
"type CRegMatch = ()\n"
"\n"
"foreign import ccall unsafe \"Posix_inc.h regcomp\"\n"
"  c_regcomp :: Ptr CRegex -> CString -> CInt -> IO CInt\n"
"\n"
"foreign import ccall  unsafe \"Posix_inc.h &regfree\"\n"
"  ptr_regfree :: FunPtr (Ptr CRegex -> IO ())\n"
"\n"
"foreign import ccall unsafe \"Posix_inc.h regexec\"\n"
"  c_regexec :: Ptr CRegex -> CString -> CSize\n"
"	    -> Ptr CRegMatch -> CInt -> IO CInt\n"
"\n"
"\n"
"{-# LINE 179 \"Posix.hsc\" #-}\n";
const char *Text_PrettyPrint_HughesPJ = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.PrettyPrint.HughesPJ\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- John Hughes's and Simon Peyton Jones's Pretty Printer Combinators\n"
"-- \n"
"-- Based on /The Design of a Pretty-printing Library/\n"
"-- in Advanced Functional Programming,\n"
"-- Johan Jeuring and Erik Meijer (eds), LNCS 925\n"
"-- <http://www.cs.chalmers.se/~rjmh/Papers/pretty.ps>\n"
"--\n"
"-- Heavily modified by Simon Peyton Jones, Dec 96\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"{-\n"
"Version 3.0     28 May 1997\n"
"  * Cured massive performance bug.  If you write\n"
"\n"
"        foldl <> empty (map (text.show) [1..10000])\n"
"\n"
"    you get quadratic behaviour with V2.0.  Why?  For just the same\n"
"    reason as you get quadratic behaviour with left-associated (++)\n"
"    chains.\n"
"\n"
"    This is really bad news.  One thing a pretty-printer abstraction\n"
"    should certainly guarantee is insensivity to associativity.  It\n"
"    matters: suddenly GHC's compilation times went up by a factor of\n"
"    100 when I switched to the new pretty printer.\n"
"\n"
"    I fixed it with a bit of a hack (because I wanted to get GHC back\n"
"    on the road).  I added two new constructors to the Doc type, Above\n"
"    and Beside:\n"
"\n"
"         <> = Beside\n"
"         $$ = Above\n"
"\n"
"    Then, where I need to get to a \"TextBeside\" or \"NilAbove\" form I\n"
"    \"force\" the Doc to squeeze out these suspended calls to Beside and\n"
"    Above; but in so doing I re-associate. It's quite simple, but I'm\n"
"    not satisfied that I've done the best possible job.  I'll send you\n"
"    the code if you are interested.\n"
"\n"
"  * Added new exports:\n"
"        punctuate, hang\n"
"        int, integer, float, double, rational,\n"
"        lparen, rparen, lbrack, rbrack, lbrace, rbrace,\n"
"\n"
"  * fullRender's type signature has changed.  Rather than producing a\n"
"    string it now takes an extra couple of arguments that tells it how\n"
"    to glue fragments of output together:\n"
"\n"
"        fullRender :: Mode\n"
"                   -> Int                       -- Line length\n"
"                   -> Float                     -- Ribbons per line\n"
"                   -> (TextDetails -> a -> a)   -- What to do with text\n"
"                   -> a                         -- What to do at the end\n"
"                   -> Doc\n"
"                   -> a                         -- Result\n"
"\n"
"    The \"fragments\" are encapsulated in the TextDetails data type:\n"
"\n"
"        data TextDetails = Chr  Char\n"
"                         | Str  String\n"
"                         | PStr FAST_STRING\n"
"\n"
"    The Chr and Str constructors are obvious enough.  The PStr\n"
"    constructor has a packed string (FAST_STRING) inside it.  It's\n"
"    generated by using the new \"ptext\" export.\n"
"\n"
"    An advantage of this new setup is that you can get the renderer to\n"
"    do output directly (by passing in a function of type (TextDetails\n"
"    -> IO () -> IO ()), rather than producing a string that you then\n"
"    print.\n"
"\n"
"Version 2.0     24 April 1997\n"
"  * Made empty into a left unit for <> as well as a right unit;\n"
"    it is also now true that\n"
"        nest k empty = empty\n"
"    which wasn't true before.\n"
"\n"
"  * Fixed an obscure bug in sep that occassionally gave very weird behaviour\n"
"\n"
"  * Added $+$\n"
"\n"
"  * Corrected and tidied up the laws and invariants\n"
"\n"
"======================================================================\n"
"Relative to John's original paper, there are the following new features:\n"
"\n"
"1.  There's an empty document, \"empty\".  It's a left and right unit for \n"
"    both <> and $$, and anywhere in the argument list for\n"
"    sep, hcat, hsep, vcat, fcat etc.\n"
"\n"
"    It is Really Useful in practice.\n"
"\n"
"2.  There is a paragraph-fill combinator, fsep, that's much like sep,\n"
"    only it keeps fitting things on one line until it can't fit any more.\n"
"\n"
"3.  Some random useful extra combinators are provided.  \n"
"        <+> puts its arguments beside each other with a space between them,\n"
"            unless either argument is empty in which case it returns the other\n"
"\n"
"        hcat is a list version of <>\n"
"        hsep is a list version of <+>\n"
"        vcat is a list version of $$\n"
"\n"
"        sep (separate) is either like hsep or like vcat, depending on what fits\n"
"\n"
"        cat  behaves like sep,  but it uses <> for horizontal conposition\n"
"        fcat behaves like fsep, but it uses <> for horizontal conposition\n"
"\n"
"        These new ones do the obvious things:\n"
"                char, semi, comma, colon, space,\n"
"                parens, brackets, braces, \n"
"                quotes, doubleQuotes\n"
"\n"
"4.  The \"above\" combinator, $$, now overlaps its two arguments if the\n"
"    last line of the top argument stops before the first line of the\n"
"    second begins.\n"
"\n"
"        For example:  text \"hi\" $$ nest 5 \"there\"\n"
"        lays out as\n"
"                        hi   there\n"
"        rather than\n"
"                        hi\n"
"                             there\n"
"\n"
"        There are two places this is really useful\n"
"\n"
"        a) When making labelled blocks, like this:\n"
"                Left ->   code for left\n"
"                Right ->  code for right\n"
"                LongLongLongLabel ->\n"
"                          code for longlonglonglabel\n"
"           The block is on the same line as the label if the label is\n"
"           short, but on the next line otherwise.\n"
"\n"
"        b) When laying out lists like this:\n"
"                [ first\n"
"                , second\n"
"                , third\n"
"                ]\n"
"           which some people like.  But if the list fits on one line\n"
"           you want [first, second, third].  You can't do this with\n"
"           John's original combinators, but it's quite easy with the\n"
"           new $$.\n"
"\n"
"        The combinator $+$ gives the original \"never-overlap\" behaviour.\n"
"\n"
"5.      Several different renderers are provided:\n"
"                * a standard one\n"
"                * one that uses cut-marks to avoid deeply-nested documents \n"
"                        simply piling up in the right-hand margin\n"
"                * one that ignores indentation (fewer chars output; good for machines)\n"
"                * one that ignores indentation and newlines (ditto, only more so)\n"
"\n"
"6.      Numerous implementation tidy-ups\n"
"        Use of unboxed data types to speed up the implementation\n"
"-}\n"
"\n"
"module Text.PrettyPrint.HughesPJ (\n"
"\n"
"	-- * The document type\n"
"        Doc,            -- Abstract\n"
"\n"
"	-- * Primitive Documents\n"
"        empty,\n"
"        semi, comma, colon, space, equals,\n"
"        lparen, rparen, lbrack, rbrack, lbrace, rbrace,\n"
"\n"
"	-- * Converting values into documents\n"
"        text, char, ptext,\n"
"        int, integer, float, double, rational,\n"
"\n"
"	-- * Wrapping documents in delimiters\n"
"        parens, brackets, braces, quotes, doubleQuotes,\n"
"\n"
"	-- * Combining documents\n"
"        (<>), (<+>), hcat, hsep, \n"
"        ($$), ($+$), vcat, \n"
"        sep, cat, \n"
"        fsep, fcat, \n"
"	nest,\n"
"        hang, punctuate,\n"
"        \n"
"	-- * Predicates on documents\n"
"	isEmpty,\n"
"\n"
"	-- * Rendering documents\n"
"\n"
"	-- ** Default rendering\n"
"	render, \n"
"\n"
"	-- ** Rendering with a particular style\n"
"	Style(..),\n"
"	style,\n"
"        renderStyle,\n"
"\n"
"	-- ** General rendering\n"
"        fullRender,\n"
"        Mode(..), TextDetails(..),\n"
"\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"infixl 6 <> \n"
"infixl 6 <+>\n"
"infixl 5 $$, $+$\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- The interface\n"
"\n"
"-- The primitive Doc values\n"
"\n"
"isEmpty :: Doc    -> Bool;  -- ^ Returns 'True' if the document is empty\n"
"\n"
"empty   :: Doc;			-- ^ An empty document\n"
"semi	:: Doc;			-- ^ A ';' character\n"
"comma	:: Doc;			-- ^ A ',' character\n"
"colon	:: Doc;			-- ^ A ':' character\n"
"space	:: Doc;			-- ^ A space character\n"
"equals	:: Doc;			-- ^ A '=' character\n"
"lparen	:: Doc;			-- ^ A '(' character\n"
"rparen	:: Doc;			-- ^ A ')' character\n"
"lbrack	:: Doc;			-- ^ A '[' character\n"
"rbrack	:: Doc;			-- ^ A ']' character\n"
"lbrace	:: Doc;			-- ^ A '{' character\n"
"rbrace	:: Doc;			-- ^ A '}' character\n"
"\n"
"text	 :: String   -> Doc\n"
"ptext	 :: String   -> Doc\n"
"char 	 :: Char     -> Doc\n"
"int      :: Int      -> Doc\n"
"integer  :: Integer  -> Doc\n"
"float    :: Float    -> Doc\n"
"double   :: Double   -> Doc\n"
"rational :: Rational -> Doc\n"
"\n"
"parens       :: Doc -> Doc; 	-- ^ Wrap document in @(...)@\n"
"brackets     :: Doc -> Doc;  	-- ^ Wrap document in @[...]@\n"
"braces	     :: Doc -> Doc;   	-- ^ Wrap document in @{...}@\n"
"quotes	     :: Doc -> Doc;	-- ^ Wrap document in @\\'...\\'@\n"
"doubleQuotes :: Doc -> Doc;	-- ^ Wrap document in @\\\"...\\\"@\n"
"\n"
"-- Combining @Doc@ values\n"
"\n"
"(<>)   :: Doc -> Doc -> Doc;     -- ^Beside\n"
"hcat   :: [Doc] -> Doc;          -- ^List version of '<>'\n"
"(<+>)  :: Doc -> Doc -> Doc;     -- ^Beside, separated by space\n"
"hsep   :: [Doc] -> Doc;          -- ^List version of '<+>'\n"
"\n"
"($$)   :: Doc -> Doc -> Doc;     -- ^Above; if there is no\n"
"                                -- overlap it \\\"dovetails\\\" the two\n"
"($+$)   :: Doc -> Doc -> Doc;	 -- ^Above, without dovetailing.\n"
"vcat   :: [Doc] -> Doc;          -- ^List version of '$$'\n"
"\n"
"cat    :: [Doc] -> Doc;          -- ^ Either hcat or vcat\n"
"sep    :: [Doc] -> Doc;          -- ^ Either hsep or vcat\n"
"fcat   :: [Doc] -> Doc;          -- ^ \\\"Paragraph fill\\\" version of cat\n"
"fsep   :: [Doc] -> Doc;          -- ^ \\\"Paragraph fill\\\" version of sep\n"
"\n"
"nest   :: Int -> Doc -> Doc;     -- ^ Nested\n"
"\n"
"-- GHC-specific ones.\n"
"\n"
"hang :: Doc -> Int -> Doc -> Doc;	-- ^ @hang d1 n d2 = sep [d1, nest n d2]@\n"
"punctuate :: Doc -> [Doc] -> [Doc];      -- ^ @punctuate p [d1, ... dn] = [d1 \\<> p, d2 \\<> p, ... dn-1 \\<> p, dn]@\n"
"\n"
"-- Displaying @Doc@ values. \n"
"\n"
"instance Show Doc where\n"
"  showsPrec prec doc cont = showDoc doc cont\n"
"\n"
"-- | Renders the document as a string using the default style\n"
"render     :: Doc -> String\n"
"\n"
"-- | The general rendering interface\n"
"fullRender :: Mode			-- ^Rendering mode\n"
"           -> Int                       -- ^Line length\n"
"           -> Float                     -- ^Ribbons per line\n"
"           -> (TextDetails -> a -> a)   -- ^What to do with text\n"
"           -> a                         -- ^What to do at the end\n"
"           -> Doc			-- ^The document\n"
"           -> a                         -- ^Result\n"
"\n"
"-- | Render the document as a string using a specified style\n"
"renderStyle  :: Style -> Doc -> String\n"
"\n"
"-- | A rendering style\n"
"data Style\n"
" = Style { mode           :: Mode     -- ^ The rendering mode\n"
" 	 , lineLength     :: Int      -- ^ Length of line, in chars\n"
"         , ribbonsPerLine :: Float    -- ^ Ratio of ribbon length to line length\n"
"         }\n"
"\n"
"-- | The default style (@mode=PageMode, lineLength=100, ribbonsPerLine=1.5@)\n"
"style :: Style\n"
"style = Style { lineLength = 100, ribbonsPerLine = 1.5, mode = PageMode }\n"
"\n"
"-- | Rendering mode\n"
"data Mode = PageMode            -- ^Normal \n"
"          | ZigZagMode          -- ^With zig-zag cuts\n"
"          | LeftMode            -- ^No indentation, infinitely long lines\n"
"          | OneLineMode         -- ^All on one line\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- The Doc calculus\n"
"\n"
"-- The Doc combinators satisfy the following laws:\n"
"\n"
"{-\n"
"Laws for $$\n"
"~~~~~~~~~~~\n"
"<a1>    (x $$ y) $$ z   = x $$ (y $$ z)\n"
"<a2>    empty $$ x      = x\n"
"<a3>    x $$ empty      = x\n"
"\n"
"        ...ditto $+$...\n"
"\n"
"Laws for <>\n"
"~~~~~~~~~~~\n"
"<b1>    (x <> y) <> z   = x <> (y <> z)\n"
"<b2>    empty <> x      = empty\n"
"<b3>    x <> empty      = x\n"
"\n"
"        ...ditto <+>...\n"
"\n"
"Laws for text\n"
"~~~~~~~~~~~~~\n"
"<t1>    text s <> text t        = text (s++t)\n"
"<t2>    text \"\" <> x            = x, if x non-empty\n"
"\n"
"Laws for nest\n"
"~~~~~~~~~~~~~\n"
"<n1>    nest 0 x                = x\n"
"<n2>    nest k (nest k' x)      = nest (k+k') x\n"
"<n3>    nest k (x <> y)         = nest k z <> nest k y\n"
"<n4>    nest k (x $$ y)         = nest k x $$ nest k y\n"
"<n5>    nest k empty            = empty\n"
"<n6>    x <> nest k y           = x <> y, if x non-empty\n"
"\n"
"** Note the side condition on <n6>!  It is this that\n"
"** makes it OK for empty to be a left unit for <>.\n"
"\n"
"Miscellaneous\n"
"~~~~~~~~~~~~~\n"
"<m1>    (text s <> x) $$ y = text s <> ((text \"\" <> x)) $$ \n"
"                                         nest (-length s) y)\n"
"\n"
"<m2>    (x $$ y) <> z = x $$ (y <> z)\n"
"        if y non-empty\n"
"\n"
"Laws for list versions\n"
"~~~~~~~~~~~~~~~~~~~~~~\n"
"<l1>    sep (ps++[empty]++qs)   = sep (ps ++ qs)\n"
"        ...ditto hsep, hcat, vcat, fill...\n"
"\n"
"<l2>    nest k (sep ps) = sep (map (nest k) ps)\n"
"        ...ditto hsep, hcat, vcat, fill...\n"
"\n"
"Laws for oneLiner\n"
"~~~~~~~~~~~~~~~~~\n"
"<o1>    oneLiner (nest k p) = nest k (oneLiner p)\n"
"<o2>    oneLiner (x <> y)   = oneLiner x <> oneLiner y \n"
"\n"
"You might think that the following verion of <m1> would\n"
"be neater:\n"
"\n"
"<3 NO>  (text s <> x) $$ y = text s <> ((empty <> x)) $$ \n"
"                                         nest (-length s) y)\n"
"\n"
"But it doesn't work, for if x=empty, we would have\n"
"\n"
"        text s $$ y = text s <> (empty $$ nest (-length s) y)\n"
"                    = text s <> nest (-length s) y\n"
"-}\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Simple derived definitions\n"
"\n"
"semi  = char ';'\n"
"colon = char ':'\n"
"comma = char ','\n"
"space = char ' '\n"
"equals = char '='\n"
"lparen = char '('\n"
"rparen = char ')'\n"
"lbrack = char '['\n"
"rbrack = char ']'\n"
"lbrace = char '{'\n"
"rbrace = char '}'\n"
"\n"
"int      n = text (show n)\n"
"integer  n = text (show n)\n"
"float    n = text (show n)\n"
"double   n = text (show n)\n"
"rational n = text (show n)\n"
"-- SIGBJORN wrote instead:\n"
"-- rational n = text (show (fromRationalX n))\n"
"\n"
"quotes p        = char '`' <> p <> char '\\''\n"
"doubleQuotes p  = char '\"' <> p <> char '\"'\n"
"parens p        = char '(' <> p <> char ')'\n"
"brackets p      = char '[' <> p <> char ']'\n"
"braces p        = char '{' <> p <> char '}'\n"
"\n"
"hcat = foldr (<>)  empty\n"
"hsep = foldr (<+>) empty\n"
"vcat = foldr ($$)  empty\n"
"\n"
"hang d1 n d2 = sep [d1, nest n d2]\n"
"\n"
"punctuate p []     = []\n"
"punctuate p (d:ds) = go d ds\n"
"                   where\n"
"                     go d [] = [d]\n"
"                     go d (e:es) = (d <> p) : go e es\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- The Doc data type\n"
"\n"
"-- A Doc represents a *set* of layouts.  A Doc with\n"
"-- no occurrences of Union or NoDoc represents just one layout.\n"
"\n"
"-- | The abstract type of documents\n"
"data Doc\n"
" = Empty                                -- empty\n"
" | NilAbove Doc                         -- text \"\" $$ x\n"
" | TextBeside TextDetails !Int Doc      -- text s <> x  \n"
" | Nest !Int Doc                        -- nest k x\n"
" | Union Doc Doc                        -- ul `union` ur\n"
" | NoDoc                                -- The empty set of documents\n"
" | Beside Doc Bool Doc                  -- True <=> space between\n"
" | Above  Doc Bool Doc                  -- True <=> never overlap\n"
"\n"
"type RDoc = Doc         -- RDoc is a \"reduced Doc\", guaranteed not to have a top-level Above or Beside\n"
"\n"
"reduceDoc :: Doc -> RDoc\n"
"reduceDoc (Beside p g q) = beside p g (reduceDoc q)\n"
"reduceDoc (Above  p g q) = above  p g (reduceDoc q)\n"
"reduceDoc p              = p\n"
"\n"
"data TextDetails = Chr  Char\n"
"                 | Str  String\n"
"                 | PStr String\n"
"space_text = Chr ' '\n"
"nl_text    = Chr '\\n'\n"
"\n"
"{-\n"
"  Here are the invariants:\n"
"  \n"
"  * The argument of NilAbove is never Empty. Therefore\n"
"    a NilAbove occupies at least two lines.\n"
"  \n"
"  * The arugment of @TextBeside@ is never @Nest@.\n"
"  \n"
"  \n"
"  * The layouts of the two arguments of @Union@ both flatten to the same \n"
"    string.\n"
"  \n"
"  * The arguments of @Union@ are either @TextBeside@, or @NilAbove@.\n"
"  \n"
"  * The right argument of a union cannot be equivalent to the empty set\n"
"    (@NoDoc@).  If the left argument of a union is equivalent to the\n"
"    empty set (@NoDoc@), then the @NoDoc@ appears in the first line.\n"
"  \n"
"  * An empty document is always represented by @Empty@.  It can't be\n"
"    hidden inside a @Nest@, or a @Union@ of two @Empty@s.\n"
"  \n"
"  * The first line of every layout in the left argument of @Union@ is\n"
"    longer than the first line of any layout in the right argument.\n"
"    (1) ensures that the left argument has a first line.  In view of\n"
"    (3), this invariant means that the right argument must have at\n"
"    least two lines.\n"
"-}\n"
"\n"
"        -- Arg of a NilAbove is always an RDoc\n"
"nilAbove_ p = NilAbove p\n"
"\n"
"        -- Arg of a TextBeside is always an RDoc\n"
"textBeside_ s sl p = TextBeside s sl p\n"
"\n"
"        -- Arg of Nest is always an RDoc\n"
"nest_ k p = Nest k p\n"
"\n"
"        -- Args of union are always RDocs\n"
"union_ p q = Union p q\n"
"\n"
"-- Notice the difference between\n"
"-- 	   * NoDoc (no documents)\n"
"-- 	   * Empty (one empty document; no height and no width)\n"
"-- 	   * text \"\" (a document containing the empty string;\n"
"-- 		      one line high, but has no width)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- @empty@, @text@, @nest@, @union@\n"
"\n"
"empty = Empty\n"
"\n"
"isEmpty Empty = True\n"
"isEmpty _     = False\n"
"\n"
"char  c = textBeside_ (Chr c) 1 Empty\n"
"text  s = case length   s of {sl -> textBeside_ (Str s)  sl Empty}\n"
"ptext s = case length s of {sl -> textBeside_ (PStr s) sl Empty}\n"
"\n"
"nest k  p = mkNest k (reduceDoc p)        -- Externally callable version\n"
"\n"
"-- mkNest checks for Nest's invariant that it doesn't have an Empty inside it\n"
"mkNest k       _           | k `seq` False = undefined\n"
"mkNest k       (Nest k1 p) = mkNest (k + k1) p\n"
"mkNest k       NoDoc       = NoDoc\n"
"mkNest k       Empty       = Empty\n"
"mkNest 0       p           = p                  -- Worth a try!\n"
"mkNest k       p           = nest_ k p\n"
"\n"
"-- mkUnion checks for an empty document\n"
"mkUnion Empty q = Empty\n"
"mkUnion p q     = p `union_` q\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Vertical composition @$$@\n"
"\n"
"p $$  q = Above p False q\n"
"p $+$ q = Above p True q\n"
"\n"
"above :: Doc -> Bool -> RDoc -> RDoc\n"
"above (Above p g1 q1)  g2 q2 = above p g1 (above q1 g2 q2)\n"
"above p@(Beside _ _ _) g  q  = aboveNest (reduceDoc p) g 0 (reduceDoc q)\n"
"above p g q                  = aboveNest p             g 0 (reduceDoc q)\n"
"\n"
"aboveNest :: RDoc -> Bool -> Int -> RDoc -> RDoc\n"
"-- Specfication: aboveNest p g k q = p $g$ (nest k q)\n"
"\n"
"aboveNest _                   _ k _ | k `seq` False = undefined\n"
"aboveNest NoDoc               g k q = NoDoc\n"
"aboveNest (p1 `Union` p2)     g k q = aboveNest p1 g k q `union_` \n"
"                                      aboveNest p2 g k q\n"
"                                \n"
"aboveNest Empty               g k q = mkNest k q\n"
"aboveNest (Nest k1 p)         g k q = nest_ k1 (aboveNest p g (k - k1) q)\n"
"                                  -- p can't be Empty, so no need for mkNest\n"
"                                \n"
"aboveNest (NilAbove p)        g k q = nilAbove_ (aboveNest p g k q)\n"
"aboveNest (TextBeside s sl p) g k q = k1 `seq` textBeside_ s sl rest\n"
"                                    where\n"
"                                      k1   = k - sl\n"
"                                      rest = case p of\n"
"                                                Empty -> nilAboveNest g k1 q\n"
"                                                other -> aboveNest  p g k1 q\n"
"\n"
"nilAboveNest :: Bool -> Int -> RDoc -> RDoc\n"
"-- Specification: text s <> nilaboveNest g k q \n"
"--              = text s <> (text \"\" $g$ nest k q)\n"
"\n"
"nilAboveNest _ k _           | k `seq` False = undefined\n"
"nilAboveNest g k Empty       = Empty    -- Here's why the \"text s <>\" is in the spec!\n"
"nilAboveNest g k (Nest k1 q) = nilAboveNest g (k + k1) q\n"
"\n"
"nilAboveNest g k q           | (not g) && (k > 0)        -- No newline if no overlap\n"
"                             = textBeside_ (Str (spaces k)) k q\n"
"                             | otherwise                        -- Put them really above\n"
"                             = nilAbove_ (mkNest k q)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Horizontal composition @<>@\n"
"\n"
"p <>  q = Beside p False q\n"
"p <+> q = Beside p True  q\n"
"\n"
"beside :: Doc -> Bool -> RDoc -> RDoc\n"
"-- Specification: beside g p q = p <g> q\n"
" \n"
"beside NoDoc               g q   = NoDoc\n"
"beside (p1 `Union` p2)     g q   = (beside p1 g q) `union_` (beside p2 g q)\n"
"beside Empty               g q   = q\n"
"beside (Nest k p)          g q   = nest_ k (beside p g q)       -- p non-empty\n"
"beside p@(Beside p1 g1 q1) g2 q2 \n"
"           {- (A `op1` B) `op2` C == A `op1` (B `op2` C)  iff op1 == op2 \n"
"                                                 [ && (op1 == <> || op1 == <+>) ] -}\n"
"         | g1 == g2              = beside p1 g1 (beside q1 g2 q2)\n"
"         | otherwise             = beside (reduceDoc p) g2 q2\n"
"beside p@(Above _ _ _)     g q   = beside (reduceDoc p) g q\n"
"beside (NilAbove p)        g q   = nilAbove_ (beside p g q)\n"
"beside (TextBeside s sl p) g q   = textBeside_ s sl rest\n"
"                               where\n"
"                                  rest = case p of\n"
"                                           Empty -> nilBeside g q\n"
"                                           other -> beside p g q\n"
"\n"
"nilBeside :: Bool -> RDoc -> RDoc\n"
"-- Specification: text \"\" <> nilBeside g p \n"
"--              = text \"\" <g> p\n"
"\n"
"nilBeside g Empty      = Empty  -- Hence the text \"\" in the spec\n"
"nilBeside g (Nest _ p) = nilBeside g p\n"
"nilBeside g p          | g         = textBeside_ space_text 1 p\n"
"                       | otherwise = p\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Separate, @sep@, Hughes version\n"
"\n"
"-- Specification: sep ps  = oneLiner (hsep ps)\n"
"--                         `union`\n"
"--                          vcat ps\n"
"\n"
"sep = sepX True         -- Separate with spaces\n"
"cat = sepX False        -- Don't\n"
"\n"
"sepX x []     = empty\n"
"sepX x (p:ps) = sep1 x (reduceDoc p) 0 ps\n"
"\n"
"-- Specification: sep1 g k ys = sep (x : map (nest k) ys)\n"
"--                            = oneLiner (x <g> nest k (hsep ys))\n"
"--                              `union` x $$ nest k (vcat ys)\n"
"\n"
"sep1 :: Bool -> RDoc -> Int -> [Doc] -> RDoc\n"
"sep1 g _                   k ys | k `seq` False = undefined\n"
"sep1 g NoDoc               k ys = NoDoc\n"
"sep1 g (p `Union` q)       k ys = sep1 g p k ys\n"
"                                  `union_`\n"
"                                  (aboveNest q False k (reduceDoc (vcat ys)))\n"
"\n"
"sep1 g Empty               k ys = mkNest k (sepX g ys)\n"
"sep1 g (Nest n p)          k ys = nest_ n (sep1 g p (k - n) ys)\n"
"\n"
"sep1 g (NilAbove p)        k ys = nilAbove_ (aboveNest p False k (reduceDoc (vcat ys)))\n"
"sep1 g (TextBeside s sl p) k ys = textBeside_ s sl (sepNB g p (k - sl) ys)\n"
"\n"
"-- Specification: sepNB p k ys = sep1 (text \"\" <> p) k ys\n"
"-- Called when we have already found some text in the first item\n"
"-- We have to eat up nests\n"
"\n"
"sepNB g (Nest _ p)  k ys  = sepNB g p k ys\n"
"\n"
"sepNB g Empty k ys        = oneLiner (nilBeside g (reduceDoc rest))\n"
"                                `mkUnion` \n"
"                            nilAboveNest False k (reduceDoc (vcat ys))\n"
"                          where\n"
"                            rest | g         = hsep ys\n"
"                                 | otherwise = hcat ys\n"
"\n"
"sepNB g p k ys            = sep1 g p k ys\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- @fill@\n"
"\n"
"fsep = fill True\n"
"fcat = fill False\n"
"\n"
"-- Specification: \n"
"--   fill []  = empty\n"
"--   fill [p] = p\n"
"--   fill (p1:p2:ps) = oneLiner p1 <#> nest (length p1) \n"
"--                                          (fill (oneLiner p2 : ps))\n"
"--                     `union`\n"
"--                      p1 $$ fill ps\n"
"\n"
"fill g []     = empty\n"
"fill g (p:ps) = fill1 g (reduceDoc p) 0 ps\n"
"\n"
"fill1 :: Bool -> RDoc -> Int -> [Doc] -> Doc\n"
"fill1 g _                   k ys | k `seq` False = undefined\n"
"fill1 g NoDoc               k ys = NoDoc\n"
"fill1 g (p `Union` q)       k ys = fill1 g p k ys\n"
"                                   `union_`\n"
"                                   (aboveNest q False k (fill g ys))\n"
"\n"
"fill1 g Empty               k ys = mkNest k (fill g ys)\n"
"fill1 g (Nest n p)          k ys = nest_ n (fill1 g p (k - n) ys)\n"
"\n"
"fill1 g (NilAbove p)        k ys = nilAbove_ (aboveNest p False k (fill g ys))\n"
"fill1 g (TextBeside s sl p) k ys = textBeside_ s sl (fillNB g p (k - sl) ys)\n"
"\n"
"fillNB g _           k ys | k `seq` False = undefined\n"
"fillNB g (Nest _ p)  k ys  = fillNB g p k ys\n"
"fillNB g Empty k []        = Empty\n"
"fillNB g Empty k (y:ys)    = nilBeside g (fill1 g (oneLiner (reduceDoc y)) k1 ys)\n"
"                             `mkUnion` \n"
"                             nilAboveNest False k (fill g (y:ys))\n"
"                           where\n"
"                             k1 | g         = k - 1\n"
"                                | otherwise = k\n"
"\n"
"fillNB g p k ys            = fill1 g p k ys\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Selecting the best layout\n"
"\n"
"best :: Mode\n"
"     -> Int             -- Line length\n"
"     -> Int             -- Ribbon length\n"
"     -> RDoc\n"
"     -> RDoc            -- No unions in here!\n"
"\n"
"best OneLineMode w r p\n"
"  = get p\n"
"  where\n"
"    get Empty               = Empty\n"
"    get NoDoc               = NoDoc\n"
"    get (NilAbove p)        = nilAbove_ (get p)\n"
"    get (TextBeside s sl p) = textBeside_ s sl (get p)\n"
"    get (Nest k p)          = get p             -- Elide nest\n"
"    get (p `Union` q)       = first (get p) (get q)\n"
"\n"
"best mode w r p\n"
"  = get w p\n"
"  where\n"
"    get :: Int          -- (Remaining) width of line\n"
"        -> Doc -> Doc\n"
"    get w _ | w==0 && False   = undefined\n"
"    get w Empty               = Empty\n"
"    get w NoDoc               = NoDoc\n"
"    get w (NilAbove p)        = nilAbove_ (get w p)\n"
"    get w (TextBeside s sl p) = textBeside_ s sl (get1 w sl p)\n"
"    get w (Nest k p)          = nest_ k (get (w - k) p)\n"
"    get w (p `Union` q)       = nicest w r (get w p) (get w q)\n"
"\n"
"    get1 :: Int         -- (Remaining) width of line\n"
"         -> Int         -- Amount of first line already eaten up\n"
"         -> Doc         -- This is an argument to TextBeside => eat Nests\n"
"         -> Doc         -- No unions in here!\n"
"\n"
"    get1 w _ _ | w==0 && False = undefined\n"
"    get1 w sl Empty               = Empty\n"
"    get1 w sl NoDoc               = NoDoc\n"
"    get1 w sl (NilAbove p)        = nilAbove_ (get (w - sl) p)\n"
"    get1 w sl (TextBeside t tl p) = textBeside_ t tl (get1 w (sl + tl) p)\n"
"    get1 w sl (Nest k p)          = get1 w sl p\n"
"    get1 w sl (p `Union` q)       = nicest1 w r sl (get1 w sl p) \n"
"                                                   (get1 w sl q)\n"
"\n"
"nicest w r p q = nicest1 w r 0 p q\n"
"nicest1 w r sl p q | fits ((w `minn` r) - sl) p = p\n"
"                   | otherwise                   = q\n"
"\n"
"fits :: Int     -- Space available\n"
"     -> Doc\n"
"     -> Bool    -- True if *first line* of Doc fits in space available\n"
" \n"
"fits n p    | n < 0 = False\n"
"fits n NoDoc               = False\n"
"fits n Empty               = True\n"
"fits n (NilAbove _)        = True\n"
"fits n (TextBeside _ sl p) = fits (n - sl) p\n"
"\n"
"minn x y | x < y    = x\n"
"         | otherwise = y\n"
"\n"
"-- @first@ and @nonEmptySet@ are similar to @nicest@ and @fits@, only simpler.\n"
"-- @first@ returns its first argument if it is non-empty, otherwise its second.\n"
"\n"
"first p q | nonEmptySet p = p \n"
"          | otherwise     = q\n"
"\n"
"nonEmptySet NoDoc           = False\n"
"nonEmptySet (p `Union` q)      = True\n"
"nonEmptySet Empty              = True\n"
"nonEmptySet (NilAbove p)       = True           -- NoDoc always in first line\n"
"nonEmptySet (TextBeside _ _ p) = nonEmptySet p\n"
"nonEmptySet (Nest _ p)         = nonEmptySet p\n"
"\n"
"-- @oneLiner@ returns the one-line members of the given set of @Doc@s.\n"
"\n"
"oneLiner :: Doc -> Doc\n"
"oneLiner NoDoc               = NoDoc\n"
"oneLiner Empty               = Empty\n"
"oneLiner (NilAbove p)        = NoDoc\n"
"oneLiner (TextBeside s sl p) = textBeside_ s sl (oneLiner p)\n"
"oneLiner (Nest k p)          = nest_ k (oneLiner p)\n"
"oneLiner (p `Union` q)       = oneLiner p\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Displaying the best layout\n"
"\n"
"renderStyle style doc \n"
"  = fullRender (mode style)\n"
"               (lineLength style)\n"
"	       (ribbonsPerLine style)\n"
"	       string_txt\n"
"	       \"\"\n"
"	       doc\n"
"\n"
"render doc       = showDoc doc \"\"\n"
"showDoc doc rest = fullRender PageMode 100 1.5 string_txt rest doc\n"
"\n"
"string_txt (Chr c)   s  = c:s\n"
"string_txt (Str s1)  s2 = s1 ++ s2\n"
"string_txt (PStr s1) s2 = s1 ++ s2\n"
"\n"
"fullRender OneLineMode _ _ txt end doc = easy_display space_text txt end (reduceDoc doc)\n"
"fullRender LeftMode    _ _ txt end doc = easy_display nl_text    txt end (reduceDoc doc)\n"
"\n"
"fullRender mode line_length ribbons_per_line txt end doc\n"
"  = display mode line_length ribbon_length txt end best_doc\n"
"  where \n"
"    best_doc = best mode hacked_line_length ribbon_length (reduceDoc doc)\n"
"\n"
"    hacked_line_length, ribbon_length :: Int\n"
"    ribbon_length = round (fromIntegral line_length / ribbons_per_line)\n"
"    hacked_line_length = case mode of { ZigZagMode -> maxBound; other -> line_length }\n"
"\n"
"display mode page_width ribbon_width txt end doc\n"
"  = case page_width - ribbon_width of { gap_width ->\n"
"    case gap_width `quot` 2 of { shift ->\n"
"    let\n"
"        lay k _            | k `seq` False = undefined\n"
"        lay k (Nest k1 p)  = lay (k + k1) p\n"
"        lay k Empty        = end\n"
"    \n"
"        lay k (NilAbove p) = nl_text `txt` lay k p\n"
"    \n"
"        lay k (TextBeside s sl p)\n"
"            = case mode of\n"
"                    ZigZagMode |  k >= gap_width\n"
"                               -> nl_text `txt` (\n"
"                                  Str (multi_ch shift '/') `txt` (\n"
"                                  nl_text `txt` (\n"
"                                  lay1 (k - shift) s sl p)))\n"
"\n"
"                               |  k < 0\n"
"                               -> nl_text `txt` (\n"
"                                  Str (multi_ch shift '\\\\') `txt` (\n"
"                                  nl_text `txt` (\n"
"                                  lay1 (k + shift) s sl p )))\n"
"\n"
"                    other -> lay1 k s sl p\n"
"    \n"
"        lay1 k _ sl _ | k+sl `seq` False = undefined\n"
"        lay1 k s sl p = Str (indent k) `txt` (s `txt` lay2 (k + sl) p)\n"
"    \n"
"        lay2 k _ | k `seq` False = undefined\n"
"        lay2 k (NilAbove p)        = nl_text `txt` lay k p\n"
"        lay2 k (TextBeside s sl p) = s `txt` (lay2 (k + sl) p)\n"
"        lay2 k (Nest _ p)          = lay2 k p\n"
"        lay2 k Empty               = end\n"
"    in\n"
"    lay 0 doc\n"
"    }}\n"
"\n"
"cant_fail = error \"easy_display: NoDoc\"\n"
"easy_display nl_text txt end doc \n"
"  = lay doc cant_fail\n"
"  where\n"
"    lay NoDoc               no_doc = no_doc\n"
"    lay (Union p q)         no_doc = {- lay p -} (lay q cant_fail)              -- Second arg can't be NoDoc\n"
"    lay (Nest k p)          no_doc = lay p no_doc\n"
"    lay Empty               no_doc = end\n"
"    lay (NilAbove p)        no_doc = nl_text `txt` lay p cant_fail      -- NoDoc always on first line\n"
"    lay (TextBeside s sl p) no_doc = s `txt` lay p no_doc\n"
"\n"
"indent n | n >= 8 = '\\t' : indent (n - 8)\n"
"         | otherwise      = spaces n\n"
"\n"
"multi_ch 0 ch = \"\"\n"
"multi_ch n       ch = ch : multi_ch (n - 1) ch\n"
"\n"
"-- (spaces n) generates a list of n spaces\n"
"--\n"
"-- It should never be called with 'n' < 0, but that can happen for reasons I don't understand\n"
"-- Here's a test case:\n"
"--	ncat x y = nest 4 $ cat [ x, y ]\n"
"--	d1 = foldl1 ncat $ take 50 $ repeat $ char 'a'\n"
"--	d2 = parens $  sep [ d1, text \"+\" , d1 ]\n"
"--	main = print d2\n"
"-- I don't feel motivated enough to find the Real Bug, so meanwhile we just test for n<=0\n"
"spaces n | n <= 0    = \"\"\n"
"	 | otherwise = ' ' : spaces (n - 1)\n"
"\n"
"{- Comments from Johannes Waldmann about what the problem might be:\n"
"\n"
"   In the example above, d2 and d1 are deeply nested, but `text \"+\"' is not, \n"
"   so the layout function tries to \"out-dent\" it.\n"
"   \n"
"   when I look at the Doc values that are generated, there are lots of\n"
"   Nest constructors with negative arguments.  see this sample output of\n"
"   d1 (obtained with hugs, :s -u)\n"
"   \n"
"   tBeside (TextDetails_Chr 'a') 1 Doc_Empty) (Doc_NilAbove (Doc_Nest\n"
"   (-241) (Doc_TextBeside (TextDetails_Chr 'a') 1 Doc_Empty)))))\n"
"   (Doc_NilAbove (Doc_Nest (-236) (Doc_TextBeside (TextDetails_Chr 'a') 1\n"
"   (Doc_NilAbove (Doc_Nest (-5) (Doc_TextBeside (TextDetails_Chr 'a') 1\n"
"   Doc_Empty)))))))) (Doc_NilAbove (Doc_Nest (-231) (Doc_TextBeside\n"
"   (TextDetails_Chr 'a') 1 (Doc_NilAbove (Doc_Nest (-5) (Doc_TextBeside\n"
"   (TextDetails_Chr 'a') 1 (Doc_NilAbove (Doc_Nest (-5) (Doc_TextBeside\n"
"   (TextDetails_Chr 'a') 1 Doc_Empty))))))))))) (Doc_NilAbove (Doc_Nest\n"
"-}\n";
const char *Text_Show_Functions = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.Show.Functions\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Optional instance of 'Text.Show.Show' for functions:\n"
"--\n"
"-- > instance Show (a -> b) where\n"
"-- > 	showsPrec _ _ = showString \\\"\\<function\\>\\\"\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.Show.Functions () where\n"
"\n"
"import Prelude\n"
"\n"
"instance Show (a -> b) where\n"
"	showsPrec _ _ = showString \"<function>\"\n";
const char *Text_Html_BlockTable = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.Html.BlockTable\n"
"-- Copyright   :  (c) Andy Gill, and the Oregon Graduate Institute of \n"
"--		  Science and Technology, 1999-2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  Andy Gill <andy@galconn.com>\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- An Html combinator library\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.Html.BlockTable (\n"
"\n"
"-- Datatypes:\n"
"\n"
"      BlockTable,             -- abstract\n"
"\n"
"-- Contruction Functions: \n"
"\n"
"      single,\n"
"      above,\n"
"      beside,\n"
"\n"
"-- Investigation Functions: \n"
"\n"
"      getMatrix,\n"
"      showsTable,\n"
"      showTable,\n"
"\n"
"      ) where\n"
"\n"
"import Prelude\n"
"\n"
"infixr 4 `beside`\n"
"infixr 3 `above`\n"
"\n"
"-- These combinators can be used to build formated 2D tables.\n"
"-- The specific target useage is for HTML table generation.\n"
"\n"
"{-\n"
"   Examples of use:\n"
"\n"
"  	> table1 :: BlockTable String\n"
"  	> table1 = single \"Hello\"	+-----+\n"
"					|Hello|\n"
"	  This is a 1x1 cell		+-----+\n"
"	  Note: single has type\n"
"	 \n"
"		single :: a -> BlockTable a\n"
"	\n"
"	  So the cells can contain anything.\n"
"	\n"
"	> table2 :: BlockTable String\n"
"	> table2 = single \"World\"	+-----+\n"
"					|World|\n"
"					+-----+\n"
"\n"
"	> table3 :: BlockTable String\n"
"	> table3 = table1 %-% table2	+-----%-----+\n"
"					|Hello%World|\n"
"	 % is used to indicate		+-----%-----+\n"
"	 the join edge between\n"
"	 the two Tables.  \n"
"\n"
"	> table4 :: BlockTable String\n"
"	> table4 = table3 %/% table2	+-----+-----+\n"
"					|Hello|World|\n"
"	  Notice the padding on the	%%%%%%%%%%%%%\n"
"	  smaller (bottom) cell to	|World      |\n"
"	  force the table to be a	+-----------+\n"
"	  rectangle.\n"
"\n"
"	> table5 :: BlockTable String\n"
"	> table5 = table1 %-% table4	+-----%-----+-----+\n"
"					|Hello%Hello|World|\n"
"	  Notice the padding on the	|     %-----+-----+\n"
"	  leftmost cell, again to	|     %World      |\n"
"	  force the table to be a	+-----%-----------+\n"
"	  rectangle.\n"
" \n"
"   Now the table can be rendered with processTable, for example:\n"
"	Main> processTable table5\n"
"	[[(\"Hello\",(1,2)),\n"
"	  (\"Hello\",(1,1)),\n"
"	  (\"World\",(1,1))],\n"
"	 [(\"World\",(2,1))]] :: [[([Char],(Int,Int))]]\n"
"	Main> \n"
"-}\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Contruction Functions\n"
"\n"
"-- Perhaps one day I'll write the Show instance\n"
"-- to show boxes aka the above ascii renditions.\n"
"\n"
"instance (Show a) => Show (BlockTable a) where\n"
"      showsPrec p = showsTable\n"
"\n"
"type TableI a = [[(a,(Int,Int))]] -> [[(a,(Int,Int))]]\n"
"\n"
"data BlockTable a = Table (Int -> Int -> TableI a) Int Int\n"
"\n"
"-- You can create a (1x1) table entry\n"
"\n"
"single :: a -> BlockTable a\n"
"single a = Table (\\ x y z -> [(a,(x+1,y+1))] : z) 1 1\n"
"\n"
"-- You can compose tables, horizonally and vertically\n"
"\n"
"above  :: BlockTable a -> BlockTable a -> BlockTable a\n"
"beside :: BlockTable a -> BlockTable a -> BlockTable a\n"
"\n"
"t1 `above` t2 = trans (combine (trans t1) (trans t2) (.))\n"
"\n"
"t1 `beside` t2 = combine t1 t2 (\\ lst1 lst2 r ->\n"
"    let\n"
"      -- Note this depends on the fact that\n"
"      -- that the result has the same number\n"
"      -- of lines as the y dimention; one list\n"
"      -- per line. This is not true in general\n"
"      -- but is always true for these combinators.\n"
"      -- I should assert this!\n"
"      -- I should even prove this.\n"
"      beside (x:xs) (y:ys) = (x ++ y) : beside xs ys\n"
"      beside (x:xs) []     = x        : xs ++ r\n"
"      beside []     (y:ys) = y        : ys ++ r\n"
"      beside []     []     =                  r\n"
"    in\n"
"      beside (lst1 []) (lst2 []))\n"
"\n"
"-- trans flips (transposes) over the x and y axis of\n"
"-- the table. It is only used internally, and typically\n"
"-- in pairs, ie. (flip ... munge ... (un)flip).\n"
"\n"
"trans :: BlockTable a -> BlockTable a\n"
"trans (Table f1 x1 y1) = Table (flip f1) y1 x1\n"
"\n"
"combine :: BlockTable a \n"
"      -> BlockTable b \n"
"      -> (TableI a -> TableI b -> TableI c) \n"
"      -> BlockTable c\n"
"combine (Table f1 x1 y1) (Table f2 x2 y2) comb = Table new_fn (x1+x2) max_y\n"
"    where\n"
"      max_y = max y1 y2\n"
"      new_fn x y =\n"
"         case compare y1 y2 of\n"
"          EQ -> comb (f1 0 y)             (f2 x y)\n"
"          GT -> comb (f1 0 y)             (f2 x (y + y1 - y2))\n"
"          LT -> comb (f1 0 (y + y2 - y1)) (f2 x y)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Investigation Functions\n"
"\n"
"-- This is the other thing you can do with a Table;\n"
"-- turn it into a 2D list, tagged with the (x,y)\n"
"-- sizes of each cell in the table.\n"
"\n"
"getMatrix :: BlockTable a -> [[(a,(Int,Int))]]\n"
"getMatrix (Table r _ _) = r 0 0 []\n"
"\n"
"-- You can also look at a table\n"
"\n"
"showsTable :: (Show a) => BlockTable a -> ShowS\n"
"showsTable table = shows (getMatrix table)\n"
"\n"
"showTable :: (Show a) => BlockTable a -> String\n"
"showTable table = showsTable table \"\"\n";
const char *Text_Read_Lex = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.Read.Lex\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (uses Text.ParserCombinators.ReadP)\n"
"--\n"
"-- The cut-down Haskell lexer, used by Text.Read\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.Read.Lex\n"
"  -- lexing types\n"
"  ( Lexeme(..)  -- :: *; Show, Eq\n"
"  		\n"
"  -- lexer	\n"
"  , lex         -- :: ReadP Lexeme	Skips leading spaces\n"
"  , hsLex	-- :: ReadP String\n"
"  , lexChar	-- :: ReadP Char	Reads just one char, with H98 escapes\n"
"  \n"
"  , readIntP    -- :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a\n"
"  , readOctP    -- :: Num a => ReadP a \n"
"  , readDecP    -- :: Num a => ReadP a\n"
"  , readHexP    -- :: Num a => ReadP a\n"
"  )\n"
" where\n"
"\n"
"import Text.ParserCombinators.ReadP\n"
"\n"
"import Prelude hiding ( lex )\n"
"import Data.Char( chr, ord, isSpace, isAlpha, isAlphaNum )\n"
"import Data.Ratio( Ratio, (%) )\n"
"import Hugs.Prelude( Ratio(..) )\n"
"import Data.Maybe\n"
"import Control.Monad\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Lexing types\n"
"\n"
"data Lexeme\n"
"  = Char   Char		-- Quotes removed, \n"
"  | String String	-- 	escapes interpreted\n"
"  | Punc   String 	-- Punctuation, eg \"(\", \"::\"\n"
"  | Ident  String	-- Haskell identifiers, e.g. foo, baz\n"
"  | Symbol String	-- Haskell symbols, e.g. >>, %\n"
"  | Int Integer\n"
"  | Rat Rational\n"
"  | EOF\n"
" deriving (Eq, Show)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Lexing\n"
"\n"
"lex :: ReadP Lexeme\n"
"lex = skipSpaces >> lexToken\n"
"\n"
"hsLex :: ReadP String\n"
"-- ^ Haskell lexer: returns the lexed string, rather than the lexeme\n"
"hsLex = do skipSpaces \n"
"	   (s,_) <- gather lexToken\n"
"	   return s\n"
"\n"
"lexToken :: ReadP Lexeme\n"
"lexToken = lexEOF     +++\n"
"      	   lexLitChar +++ \n"
"      	   lexString  +++ \n"
"      	   lexPunc    +++ \n"
"      	   lexSymbol  +++ \n"
"      	   lexId      +++ \n"
"      	   lexNumber\n"
"\n"
"-- ----------------------------------------------------------------------\n"
"-- End of file\n"
"lexEOF :: ReadP Lexeme\n"
"lexEOF = do s <- look\n"
"	    guard (null s)\n"
"	    return EOF\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Single character lexemes\n"
"\n"
"lexPunc :: ReadP Lexeme\n"
"lexPunc =\n"
"  do c <- satisfy isPuncChar\n"
"     return (Punc [c])\n"
" where\n"
"  isPuncChar c = c `elem` \",;()[]{}`\"\n"
"\n"
"-- ----------------------------------------------------------------------\n"
"-- Symbols\n"
"\n"
"lexSymbol :: ReadP Lexeme\n"
"lexSymbol =\n"
"  do s <- munch1 isSymbolChar\n"
"     if s `elem` reserved_ops then \n"
"	return (Punc s)		-- Reserved-ops count as punctuation\n"
"      else\n"
"	return (Symbol s)\n"
" where\n"
"  isSymbolChar c = c `elem` \"!@#$%&*+./<=>?\\\\^|:-~\"\n"
"  reserved_ops   = [\"..\", \"::\", \"=\", \"\\\\\", \"|\", \"<-\", \"->\", \"@\", \"~\", \"=>\"]\n"
"\n"
"-- ----------------------------------------------------------------------\n"
"-- identifiers\n"
"\n"
"lexId :: ReadP Lexeme\n"
"lexId = lex_nan <++ lex_id\n"
"  where\n"
"	-- NaN and Infinity look like identifiers, so\n"
"	-- we parse them first.  \n"
"    lex_nan = (string \"NaN\"      >> return (Rat notANumber)) +++\n"
"  	      (string \"Infinity\" >> return (Rat infinity))\n"
"  \n"
"    lex_id = do c <- satisfy isIdsChar\n"
"  		s <- munch isIdfChar\n"
"  		return (Ident (c:s))\n"
"\n"
"  	  -- Identifiers can start with a '_'\n"
"    isIdsChar c = isAlpha c || c == '_'\n"
"    isIdfChar c = isAlphaNum c || c `elem` \"_'\"\n"
"\n"
"infinity, notANumber :: Rational\n"
"infinity   = 1 :% 0\n"
"notANumber = 0 :% 0\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Lexing character literals\n"
"\n"
"lexLitChar :: ReadP Lexeme\n"
"lexLitChar =\n"
"  do char '\\''\n"
"     (c,esc) <- lexCharE\n"
"     guard (esc || c /= '\\'')	-- Eliminate '' possibility\n"
"     char '\\''\n"
"     return (Char c)\n"
"\n"
"lexChar :: ReadP Char\n"
"lexChar = do { (c,_) <- lexCharE; return c }\n"
"\n"
"lexCharE :: ReadP (Char, Bool)  -- \"escaped or not\"?\n"
"lexCharE =\n"
"  do c <- get\n"
"     if c == '\\\\'\n"
"       then do c <- lexEsc; return (c, True)\n"
"       else do return (c, False)\n"
" where \n"
"  lexEsc =\n"
"    lexEscChar\n"
"      +++ lexNumeric\n"
"        +++ lexCntrlChar\n"
"          +++ lexAscii\n"
"  \n"
"  lexEscChar =\n"
"    do c <- get\n"
"       case c of\n"
"         'a'  -> return '\\a'\n"
"         'b'  -> return '\\b'\n"
"         'f'  -> return '\\f'\n"
"         'n'  -> return '\\n'\n"
"         'r'  -> return '\\r'\n"
"         't'  -> return '\\t'\n"
"         'v'  -> return '\\v'\n"
"         '\\\\' -> return '\\\\'\n"
"         '\\\"' -> return '\\\"'\n"
"         '\\'' -> return '\\''\n"
"         _    -> pfail\n"
"  \n"
"  lexNumeric =\n"
"    do base <- lexBaseChar <++ return 10\n"
"       n    <- lexInteger base\n"
"       guard (n <= toInteger (ord maxBound))\n"
"       return (chr (fromInteger n))\n"
"\n"
"  lexCntrlChar =\n"
"    do char '^'\n"
"       c <- get\n"
"       case c of\n"
"         '@'  -> return '\\^@'\n"
"         'A'  -> return '\\^A'\n"
"         'B'  -> return '\\^B'\n"
"         'C'  -> return '\\^C'\n"
"         'D'  -> return '\\^D'\n"
"         'E'  -> return '\\^E'\n"
"         'F'  -> return '\\^F'\n"
"         'G'  -> return '\\^G'\n"
"         'H'  -> return '\\^H'\n"
"         'I'  -> return '\\^I'\n"
"         'J'  -> return '\\^J'\n"
"         'K'  -> return '\\^K'\n"
"         'L'  -> return '\\^L'\n"
"         'M'  -> return '\\^M'\n"
"         'N'  -> return '\\^N'\n"
"         'O'  -> return '\\^O'\n"
"         'P'  -> return '\\^P'\n"
"         'Q'  -> return '\\^Q'\n"
"         'R'  -> return '\\^R'\n"
"         'S'  -> return '\\^S'\n"
"         'T'  -> return '\\^T'\n"
"         'U'  -> return '\\^U'\n"
"         'V'  -> return '\\^V'\n"
"         'W'  -> return '\\^W'\n"
"         'X'  -> return '\\^X'\n"
"         'Y'  -> return '\\^Y'\n"
"         'Z'  -> return '\\^Z'\n"
"         '['  -> return '\\^['\n"
"         '\\\\' -> return '\\^\\'\n"
"         ']'  -> return '\\^]'\n"
"         '^'  -> return '\\^^'\n"
"         '_'  -> return '\\^_'\n"
"         _    -> pfail\n"
"\n"
"  lexAscii =\n"
"    do choice\n"
"         [ (string \"SOH\" >> return '\\SOH') <++\n"
"	   (string \"SO\"  >> return '\\SO') \n"
"		-- \\SO and \\SOH need maximal-munch treatment\n"
"		-- See the Haskell report Sect 2.6\n"
"\n"
"         , string \"NUL\" >> return '\\NUL'\n"
"         , string \"STX\" >> return '\\STX'\n"
"         , string \"ETX\" >> return '\\ETX'\n"
"         , string \"EOT\" >> return '\\EOT'\n"
"         , string \"ENQ\" >> return '\\ENQ'\n"
"         , string \"ACK\" >> return '\\ACK'\n"
"         , string \"BEL\" >> return '\\BEL'\n"
"         , string \"BS\"  >> return '\\BS'\n"
"         , string \"HT\"  >> return '\\HT'\n"
"         , string \"LF\"  >> return '\\LF'\n"
"         , string \"VT\"  >> return '\\VT'\n"
"         , string \"FF\"  >> return '\\FF'\n"
"         , string \"CR\"  >> return '\\CR'\n"
"         , string \"SI\"  >> return '\\SI'\n"
"         , string \"DLE\" >> return '\\DLE'\n"
"         , string \"DC1\" >> return '\\DC1'\n"
"         , string \"DC2\" >> return '\\DC2'\n"
"         , string \"DC3\" >> return '\\DC3'\n"
"         , string \"DC4\" >> return '\\DC4'\n"
"         , string \"NAK\" >> return '\\NAK'\n"
"         , string \"SYN\" >> return '\\SYN'\n"
"         , string \"ETB\" >> return '\\ETB'\n"
"         , string \"CAN\" >> return '\\CAN'\n"
"         , string \"EM\"  >> return '\\EM'\n"
"         , string \"SUB\" >> return '\\SUB'\n"
"         , string \"ESC\" >> return '\\ESC'\n"
"         , string \"FS\"  >> return '\\FS'\n"
"         , string \"GS\"  >> return '\\GS'\n"
"         , string \"RS\"  >> return '\\RS'\n"
"         , string \"US\"  >> return '\\US'\n"
"         , string \"SP\"  >> return '\\SP'\n"
"         , string \"DEL\" >> return '\\DEL'\n"
"         ]\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- string literal\n"
"\n"
"lexString :: ReadP Lexeme\n"
"lexString =\n"
"  do char '\"'\n"
"     body id\n"
" where\n"
"  body f =\n"
"    do (c,esc) <- lexStrItem\n"
"       if c /= '\"' || esc\n"
"         then body (f.(c:))\n"
"         else let s = f \"\" in\n"
"	      return (String s)\n"
"\n"
"  lexStrItem = (lexEmpty >> lexStrItem)\n"
"	       +++ lexCharE\n"
"  \n"
"  lexEmpty =\n"
"    do char '\\\\'\n"
"       c <- get\n"
"       case c of\n"
"         '&'           -> do return ()\n"
"         _ | isSpace c -> do skipSpaces; char '\\\\'; return ()\n"
"         _             -> do pfail\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"--  Lexing numbers\n"
"\n"
"type Base   = Int\n"
"type Digits = [Int]\n"
"\n"
"lexNumber :: ReadP Lexeme\n"
"lexNumber \n"
"  = lexHexOct  <++	-- First try for hex or octal 0x, 0o etc\n"
"			-- If that fails, try for a decimal number\n"
"    lexDecNumber 	-- Start with ordinary digits\n"
"		\n"
"lexHexOct :: ReadP Lexeme\n"
"lexHexOct\n"
"  = do	char '0'\n"
"	base <- lexBaseChar\n"
"	digits <- lexDigits base\n"
"	return (Int (val (fromIntegral base) 0 digits))\n"
"\n"
"lexBaseChar :: ReadP Int\n"
"-- Lex a single character indicating the base; fail if not there\n"
"lexBaseChar = do { c <- get;\n"
"		   case c of\n"
"		   	'o' -> return 8\n"
"	           	'O' -> return 8\n"
"	           	'x' -> return 16\n"
"        	   	'X' -> return 16\n"
"	           	_   -> pfail } \n"
"\n"
"lexDecNumber :: ReadP Lexeme\n"
"lexDecNumber =\n"
"  do xs    <- lexDigits 10\n"
"     mFrac <- lexFrac <++ return Nothing\n"
"     mExp  <- lexExp  <++ return Nothing\n"
"     return (value xs mFrac mExp)\n"
" where\n"
"  value xs mFrac mExp = valueFracExp (val 10 0 xs) mFrac mExp\n"
"  \n"
"  valueFracExp :: Integer -> Maybe Digits -> Maybe Integer \n"
"	       -> Lexeme\n"
"  valueFracExp a Nothing Nothing	\n"
"    = Int a						-- 43\n"
"  valueFracExp a Nothing (Just exp)\n"
"    | exp >= 0  = Int (a * (10 ^ exp))			-- 43e7\n"
"    | otherwise = Rat (valExp (fromInteger a) exp)	-- 43e-7\n"
"  valueFracExp a (Just fs) mExp \n"
"     = case mExp of\n"
"	 Nothing  -> Rat rat				-- 4.3\n"
"	 Just exp -> Rat (valExp rat exp)		-- 4.3e-4\n"
"     where\n"
"	rat :: Rational\n"
"	rat = fromInteger a + frac 10 0 1 fs\n"
"\n"
"  valExp :: Rational -> Integer -> Rational\n"
"  valExp rat exp = rat * (10 ^^ exp)\n"
"\n"
"lexFrac :: ReadP (Maybe Digits)\n"
"-- Read the fractional part; fail if it doesn't\n"
"-- start \".d\" where d is a digit\n"
"lexFrac = do char '.'\n"
"	     frac <- lexDigits 10\n"
"	     return (Just frac)\n"
"\n"
"lexExp :: ReadP (Maybe Integer)\n"
"lexExp = do char 'e' +++ char 'E'\n"
"            exp <- signedExp +++ lexInteger 10\n"
"	    return (Just exp)\n"
" where\n"
"   signedExp \n"
"     = do c <- char '-' +++ char '+'\n"
"          n <- lexInteger 10\n"
"          return (if c == '-' then -n else n)\n"
"\n"
"lexDigits :: Int -> ReadP Digits\n"
"-- Lex a non-empty sequence of digits in specified base\n"
"lexDigits base =\n"
"  do s  <- look\n"
"     xs <- scan s id\n"
"     guard (not (null xs))\n"
"     return xs\n"
" where\n"
"  scan (c:cs) f = case valDig base c of\n"
"                    Just n  -> do get; scan cs (f.(n:))\n"
"                    Nothing -> do return (f [])\n"
"  scan []     f = do return (f [])\n"
"\n"
"lexInteger :: Base -> ReadP Integer\n"
"lexInteger base =\n"
"  do xs <- lexDigits base\n"
"     return (val (fromIntegral base) 0 xs)\n"
"\n"
"val :: Num a => a -> a -> Digits -> a\n"
"-- val base y [d1,..,dn] = y ++ [d1,..,dn], as it were\n"
"val base y []     = y\n"
"val base y (x:xs) = y' `seq` val base y' xs\n"
" where\n"
"  y' = y * base + fromIntegral x\n"
"\n"
"frac :: Integral a => a -> a -> a -> Digits -> Ratio a\n"
"frac base a b []     = a % b\n"
"frac base a b (x:xs) = a' `seq` b' `seq` frac base a' b' xs\n"
" where\n"
"  a' = a * base + fromIntegral x\n"
"  b' = b * base\n"
"\n"
"valDig :: Num a => a -> Char -> Maybe Int\n"
"valDig 8 c\n"
"  | '0' <= c && c <= '7' = Just (ord c - ord '0')\n"
"  | otherwise            = Nothing\n"
"\n"
"valDig 10 c = valDecDig c\n"
"\n"
"valDig 16 c\n"
"  | '0' <= c && c <= '9' = Just (ord c - ord '0')\n"
"  | 'a' <= c && c <= 'f' = Just (ord c - ord 'a' + 10)\n"
"  | 'A' <= c && c <= 'F' = Just (ord c - ord 'A' + 10)\n"
"  | otherwise            = Nothing\n"
"\n"
"valDecDig c\n"
"  | '0' <= c && c <= '9' = Just (ord c - ord '0')\n"
"  | otherwise            = Nothing\n"
"\n"
"-- ----------------------------------------------------------------------\n"
"-- other numeric lexing functions\n"
"\n"
"readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a\n"
"readIntP base isDigit valDigit =\n"
"  do s <- munch1 isDigit\n"
"     return (val base 0 (map valDigit s))\n"
"\n"
"readIntP' :: Num a => a -> ReadP a\n"
"readIntP' base = readIntP base isDigit valDigit\n"
" where\n"
"  isDigit  c = maybe False (const True) (valDig base c)\n"
"  valDigit c = maybe 0     id           (valDig base c)\n"
"\n"
"readOctP, readDecP, readHexP :: Num a => ReadP a\n"
"readOctP = readIntP' 8\n"
"readDecP = readIntP' 10\n"
"readHexP = readIntP' 16\n";
const char *Text_ParserCombinators_ReadP = "\n"
"{-# OPTIONS -fglasgow-exts -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.ParserCombinators.ReadP\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (local universal quantification)\n"
"--\n"
"-- This is a library of parser combinators, originally written by Koen Claessen.\n"
"-- It parses all alternatives in parallel, so it never keeps hold of \n"
"-- the beginning of the input string, a common source of space leaks with\n"
"-- other parsers.  The '(+++)' choice combinator is genuinely commutative;\n"
"-- it makes no difference which branch is \\\"shorter\\\".\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.ParserCombinators.ReadP\n"
"  ( \n"
"  -- * The 'ReadP' type\n"
"  ReadP,      -- :: * -> *; instance Functor, Monad, MonadPlus\n"
"  \n"
"  -- * Primitive operations\n"
"  get,        -- :: ReadP Char\n"
"  look,       -- :: ReadP String\n"
"  (+++),      -- :: ReadP a -> ReadP a -> ReadP a\n"
"  (<++),      -- :: ReadP a -> ReadP a -> ReadP a\n"
"  gather,     -- :: ReadP a -> ReadP (String, a)\n"
"  \n"
"  -- * Other operations\n"
"  pfail,      -- :: ReadP a\n"
"  satisfy,    -- :: (Char -> Bool) -> ReadP Char\n"
"  char,       -- :: Char -> ReadP Char\n"
"  string,     -- :: String -> ReadP String\n"
"  munch,      -- :: (Char -> Bool) -> ReadP String\n"
"  munch1,     -- :: (Char -> Bool) -> ReadP String\n"
"  skipSpaces, -- :: ReadP ()\n"
"  choice,     -- :: [ReadP a] -> ReadP a\n"
"  \n"
"  -- * Running a parser\n"
"  ReadS,      -- :: *; = String -> [(a,String)]\n"
"  readP_to_S, -- :: ReadP a -> ReadS a\n"
"  readS_to_P, -- :: ReadS a -> ReadP a\n"
"  \n"
"  -- * Properties\n"
"  -- $properties\n"
"  )\n"
" where\n"
"\n"
"import Control.Monad( MonadPlus(..) )\n"
"import Data.Char( isSpace )\n"
"\n"
"infixr 5 +++, <++\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- The P type\n"
"-- is representation type -- should be kept abstract\n"
"\n"
"data P a\n"
"  = Get (Char -> P a)\n"
"  | Look (String -> P a)\n"
"  | Fail\n"
"  | Result a (P a)\n"
"  | Final [(a,String)] -- invariant: list is non-empty!\n"
"\n"
"-- Monad, MonadPlus\n"
"\n"
"instance Monad P where\n"
"  return x = Result x Fail\n"
"\n"
"  (Get f)      >>= k = Get (\\c -> f c >>= k)\n"
"  (Look f)     >>= k = Look (\\s -> f s >>= k)\n"
"  Fail         >>= k = Fail\n"
"  (Result x p) >>= k = k x `mplus` (p >>= k)\n"
"  (Final r)    >>= k = final [ys' | (x,s) <- r, ys' <- run (k x) s]\n"
"\n"
"  fail _ = Fail\n"
"\n"
"instance MonadPlus P where\n"
"  mzero = Fail\n"
"\n"
"  -- most common case: two gets are combined\n"
"  Get f1     `mplus` Get f2     = Get (\\c -> f1 c `mplus` f2 c)\n"
"  \n"
"  -- results are delivered as soon as possible\n"
"  Result x p `mplus` q          = Result x (p `mplus` q)\n"
"  p          `mplus` Result x q = Result x (p `mplus` q)\n"
"\n"
"  -- fail disappears\n"
"  Fail       `mplus` p          = p\n"
"  p          `mplus` Fail       = p\n"
"\n"
"  -- two finals are combined\n"
"  -- final + look becomes one look and one final (=optimization)\n"
"  -- final + sthg else becomes one look and one final\n"
"  Final r    `mplus` Final t    = Final (r ++ t)\n"
"  Final r    `mplus` Look f     = Look (\\s -> Final (r ++ run (f s) s))\n"
"  Final r    `mplus` p          = Look (\\s -> Final (r ++ run p s))\n"
"  Look f     `mplus` Final r    = Look (\\s -> Final (run (f s) s ++ r))\n"
"  p          `mplus` Final r    = Look (\\s -> Final (run p s ++ r))\n"
"\n"
"  -- two looks are combined (=optimization)\n"
"  -- look + sthg else floats upwards\n"
"  Look f     `mplus` Look g     = Look (\\s -> f s `mplus` g s)\n"
"  Look f     `mplus` p          = Look (\\s -> f s `mplus` p)\n"
"  p          `mplus` Look f     = Look (\\s -> p `mplus` f s)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- The ReadP type\n"
"\n"
"newtype ReadP a = R (forall b . (a -> P b) -> P b)\n"
"\n"
"-- Functor, Monad, MonadPlus\n"
"\n"
"instance Functor ReadP where\n"
"  fmap h (R f) = R (\\k -> f (k . h))\n"
"\n"
"instance Monad ReadP where\n"
"  return x  = R (\\k -> k x)\n"
"  fail _    = R (\\_ -> Fail)\n"
"  R m >>= f = R (\\k -> m (\\a -> let R m' = f a in m' k))\n"
"\n"
"instance MonadPlus ReadP where\n"
"  mzero = pfail\n"
"  mplus = (+++)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Operations over P\n"
"\n"
"final :: [(a,String)] -> P a\n"
"-- Maintains invariant for Final constructor\n"
"final [] = Fail\n"
"final r  = Final r\n"
"\n"
"run :: P a -> ReadS a\n"
"run (Get f)      (c:s) = run (f c) s\n"
"run (Look f)     s     = run (f s) s\n"
"run (Result x p) s     = (x,s) : run p s\n"
"run (Final r)    _     = r\n"
"run _            _     = []\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Operations over ReadP\n"
"\n"
"get :: ReadP Char\n"
"-- ^ Consumes and returns the next character.\n"
"--   Fails if there is no input left.\n"
"get = R Get\n"
"\n"
"look :: ReadP String\n"
"-- ^ Look-ahead: returns the part of the input that is left, without\n"
"--   consuming it.\n"
"look = R Look\n"
"\n"
"pfail :: ReadP a\n"
"-- ^ Always fails.\n"
"pfail = R (\\_ -> Fail)\n"
"\n"
"(+++) :: ReadP a -> ReadP a -> ReadP a\n"
"-- ^ Symmetric choice.\n"
"R f1 +++ R f2 = R (\\k -> f1 k `mplus` f2 k)\n"
"\n"
"(<++) :: ReadP a -> ReadP a -> ReadP a\n"
"-- ^ Local, exclusive, left-biased choice: If left parser\n"
"--   locally produces any result at all, then right parser is\n"
"--   not used.\n"
"R f <++ q =\n"
"  do s <- look\n"
"     probe (f return) s 0\n"
" where\n"
"  probe (Get f)        (c:s) n = probe (f c) s (n+1)\n"
"  probe (Look f)       s     n = probe (f s) s n\n"
"  probe p@(Result _ _) _     n = discard n >> R (p >>=)\n"
"  probe (Final r)      _     _ = R (Final r >>=)\n"
"  probe _              _     _ = q\n"
"\n"
"  discard 0 = return ()\n"
"  discard n  = get >> discard (n-1)\n"
"\n"
"gather :: ReadP a -> ReadP (String, a)\n"
"-- ^ Transforms a parser into one that does the same, but\n"
"--   in addition returns the exact characters read.\n"
"--   IMPORTANT NOTE: 'gather' gives a runtime error if its first argument\n"
"--   is built using any occurrences of readS_to_P. \n"
"gather (R m) =\n"
"  R (\\k -> gath id (m (\\a -> return (\\s -> k (s,a)))))  \n"
" where\n"
"  gath l (Get f)      = Get (\\c -> gath (l.(c:)) (f c))\n"
"  gath l Fail         = Fail\n"
"  gath l (Look f)     = Look (\\s -> gath l (f s))\n"
"  gath l (Result k p) = k (l []) `mplus` gath l p\n"
"  gath l (Final r)    = error \"do not use readS_to_P in gather!\"\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Derived operations\n"
"\n"
"satisfy :: (Char -> Bool) -> ReadP Char\n"
"-- ^ Consumes and returns the next character, if it satisfies the\n"
"--   specified predicate.\n"
"satisfy p = do c <- get; if p c then return c else pfail\n"
"\n"
"char :: Char -> ReadP Char\n"
"-- ^ Parses and returns the specified character.\n"
"char c = satisfy (c ==)\n"
"\n"
"string :: String -> ReadP String\n"
"-- ^ Parses and returns the specified string.\n"
"string this = do s <- look; scan this s\n"
" where\n"
"  scan []     _               = do return this\n"
"  scan (x:xs) (y:ys) | x == y = do get; scan xs ys\n"
"  scan _      _               = do pfail\n"
"\n"
"munch :: (Char -> Bool) -> ReadP String\n"
"-- ^ Parses the first zero or more characters satisfying the predicate.\n"
"munch p =\n"
"  do s <- look\n"
"     scan s\n"
" where\n"
"  scan (c:cs) | p c = do get; s <- scan cs; return (c:s)\n"
"  scan _            = do return \"\"\n"
"\n"
"munch1 :: (Char -> Bool) -> ReadP String\n"
"-- ^ Parses the first one or more characters satisfying the predicate.\n"
"munch1 p =\n"
"  do c <- get\n"
"     if p c then do s <- munch p; return (c:s) else pfail\n"
"\n"
"choice :: [ReadP a] -> ReadP a\n"
"-- ^ Combines all parsers in the specified list.\n"
"choice []     = pfail\n"
"choice [p]    = p\n"
"choice (p:ps) = p +++ choice ps\n"
"\n"
"skipSpaces :: ReadP ()\n"
"-- ^ Skips all whitespace.\n"
"skipSpaces =\n"
"  do s <- look\n"
"     skip s\n"
" where\n"
"  skip (c:s) | isSpace c = do get; skip s\n"
"  skip _                 = do return ()\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Converting between ReadP and Read\n"
"\n"
"readP_to_S :: ReadP a -> ReadS a\n"
"-- ^ Converts a parser into a Haskell ReadS-style function.\n"
"--   This is the main way in which you can \\\"run\\\" a 'ReadP' parser:\n"
"--   the expanded type is\n"
"-- @ readP_to_S :: ReadP a -> String -> [(a,String)] @\n"
"readP_to_S (R f) = run (f return)\n"
"\n"
"readS_to_P :: ReadS a -> ReadP a\n"
"-- ^ Converts a Haskell ReadS-style function into a parser.\n"
"--   Warning: This introduces local backtracking in the resulting\n"
"--   parser, and therefore a possible inefficiency.\n"
"readS_to_P r =\n"
"  R (\\k -> Look (\\s -> final [bs'' | (a,s') <- r s, bs'' <- run (k a) s']))\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- QuickCheck properties that hold for the combinators\n"
"\n"
"{- $properties\n"
"The following are QuickCheck specifications of what the combinators do.\n"
"These can be seen as formal specifications of the behavior of the\n"
"combinators.\n"
"\n"
"We use bags to give semantics to the combinators.\n"
"\n"
">  type Bag a = [a]\n"
"\n"
"Equality on bags does not care about the order of elements.\n"
"\n"
">  (=~) :: Ord a => Bag a -> Bag a -> Bool\n"
">  xs =~ ys = sort xs == sort ys\n"
"\n"
"A special equality operator to avoid unresolved overloading\n"
"when testing the properties.\n"
"\n"
">  (=~.) :: Bag (Int,String) -> Bag (Int,String) -> Bool\n"
">  (=~.) = (=~)\n"
"\n"
"Here follow the properties:\n"
"\n"
">  prop_Get_Nil =\n"
">    readP_to_S get [] =~ []\n"
">\n"
">  prop_Get_Cons c s =\n"
">    readP_to_S get (c:s) =~ [(c,s)]\n"
">\n"
">  prop_Look s =\n"
">    readP_to_S look s =~ [(s,s)]\n"
">\n"
">  prop_Fail s =\n"
">    readP_to_S pfail s =~. []\n"
">\n"
">  prop_Return x s =\n"
">    readP_to_S (return x) s =~. [(x,s)]\n"
">\n"
">  prop_Bind p k s =\n"
">    readP_to_S (p >>= k) s =~.\n"
">      [ ys''\n"
">      | (x,s') <- readP_to_S p s\n"
">      , ys''   <- readP_to_S (k (x::Int)) s'\n"
">      ]\n"
">\n"
">  prop_Plus p q s =\n"
">    readP_to_S (p +++ q) s =~.\n"
">      (readP_to_S p s ++ readP_to_S q s)\n"
">\n"
">  prop_LeftPlus p q s =\n"
">    readP_to_S (p <++ q) s =~.\n"
">      (readP_to_S p s +<+ readP_to_S q s)\n"
">   where\n"
">    [] +<+ ys = ys\n"
">    xs +<+ _  = xs\n"
">\n"
">  prop_Gather s =\n"
">    forAll readPWithoutReadS $ \\p -> \n"
">      readP_to_S (gather p) s =~\n"
">	 [ ((pre,x::Int),s')\n"
">	 | (x,s') <- readP_to_S p s\n"
">	 , let pre = take (length s - length s') s\n"
">	 ]\n"
">\n"
">  prop_String_Yes this s =\n"
">    readP_to_S (string this) (this ++ s) =~\n"
">      [(this,s)]\n"
">\n"
">  prop_String_Maybe this s =\n"
">    readP_to_S (string this) s =~\n"
">      [(this, drop (length this) s) | this `isPrefixOf` s]\n"
">\n"
">  prop_Munch p s =\n"
">    readP_to_S (munch p) s =~\n"
">      [(takeWhile p s, dropWhile p s)]\n"
">\n"
">  prop_Munch1 p s =\n"
">    readP_to_S (munch1 p) s =~\n"
">      [(res,s') | let (res,s') = (takeWhile p s, dropWhile p s), not (null res)]\n"
">\n"
">  prop_Choice ps s =\n"
">    readP_to_S (choice ps) s =~.\n"
">      readP_to_S (foldr (+++) pfail ps) s\n"
">\n"
">  prop_ReadS r s =\n"
">    readP_to_S (readS_to_P r) s =~. r s\n"
"-}\n";
const char *Text_ParserCombinators_ReadPrec = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.ParserCombinators.ReadPrec\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (uses Text.ParserCombinators.ReadP)\n"
"--\n"
"-- This library defines parser combinators for precedence parsing.\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.ParserCombinators.ReadPrec\n"
"  ( \n"
"  ReadPrec,      -- :: * -> *; instance Functor, Monad, MonadPlus\n"
"  \n"
"  -- * Precedences\n"
"  Prec,          -- :: *; = Int\n"
"  minPrec,       -- :: Prec; = 0\n"
"\n"
"  -- * Precedence operations\n"
"  lift,          -- :: ReadP a -> ReadPrec a\n"
"  prec,          -- :: Prec -> ReadPrec a -> ReadPrec a\n"
"  step,          -- :: ReadPrec a -> ReadPrec a\n"
"  reset,         -- :: ReadPrec a -> ReadPrec a\n"
"\n"
"  -- * Other operations\n"
"  -- All are based directly on their similarly-naned 'ReadP' counterparts.\n"
"  get,           -- :: ReadPrec Char\n"
"  look,          -- :: ReadPrec String\n"
"  (+++),         -- :: ReadPrec a -> ReadPrec a -> ReadPrec a\n"
"  (<++),         -- :: ReadPrec a -> ReadPrec a -> ReadPrec a\n"
"  pfail,         -- :: ReadPrec a\n"
"  choice,        -- :: [ReadPrec a] -> ReadPrec a\n"
"\n"
"  -- * Converters\n"
"  readPrec_to_P, -- :: ReadPrec a       -> (Int -> ReadP a)\n"
"  readP_to_Prec, -- :: (Int -> ReadP a) -> ReadPrec a\n"
"  readPrec_to_S, -- :: ReadPrec a       -> (Int -> ReadS a)\n"
"  readS_to_Prec, -- :: (Int -> ReadS a) -> ReadPrec a\n"
"  )\n"
" where\n"
"\n"
"import Text.ParserCombinators.ReadP\n"
"  ( ReadP\n"
"  , ReadS\n"
"  , readP_to_S\n"
"  , readS_to_P\n"
"  )\n"
"\n"
"import qualified Text.ParserCombinators.ReadP as ReadP\n"
"  ( get\n"
"  , look\n"
"  , (+++), (<++)\n"
"  , pfail\n"
"  )\n"
"\n"
"import Control.Monad( MonadPlus(..) )\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- The readPrec type\n"
"\n"
"newtype ReadPrec a = P { unP :: Prec -> ReadP a }\n"
"\n"
"-- Functor, Monad, MonadPlus\n"
"\n"
"instance Functor ReadPrec where\n"
"  fmap h (P f) = P (\\n -> fmap h (f n))\n"
"\n"
"instance Monad ReadPrec where\n"
"  return x  = P (\\_ -> return x)\n"
"  fail s    = P (\\_ -> fail s)\n"
"  P f >>= k = P (\\n -> do a <- f n; let P f' = k a in f' n)\n"
"  \n"
"instance MonadPlus ReadPrec where\n"
"  mzero = pfail\n"
"  mplus = (+++)\n"
"\n"
"-- precedences\n"
"  \n"
"type Prec = Int\n"
"\n"
"minPrec :: Prec\n"
"minPrec = 0\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Operations over ReadPrec\n"
"\n"
"lift :: ReadP a -> ReadPrec a\n"
"-- ^ Lift a predence-insensitive 'ReadP' to a 'ReadPrec'\n"
"lift m = P (\\_ -> m)\n"
"\n"
"step :: ReadPrec a -> ReadPrec a\n"
"-- ^ Increases the precedence context by one\n"
"step (P f) = P (\\n -> f (n+1))\n"
"\n"
"reset :: ReadPrec a -> ReadPrec a\n"
"-- ^ Resets the precedence context to zero\n"
"reset (P f) = P (\\n -> f minPrec)\n"
"\n"
"prec :: Prec -> ReadPrec a -> ReadPrec a\n"
"-- ^ @(prec n p)@ checks that the precedence context is \n"
"--			  less than or equal to n,\n"
"--   * if not, fails\n"
"--   * if so, parses p in context n\n"
"prec n (P f) = P (\\c -> if c <= n then f n else ReadP.pfail)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Derived operations\n"
"\n"
"get :: ReadPrec Char\n"
"get = lift ReadP.get\n"
"\n"
"look :: ReadPrec String\n"
"look = lift ReadP.look\n"
"\n"
"(+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a\n"
"P f1 +++ P f2 = P (\\n -> f1 n ReadP.+++ f2 n)\n"
"\n"
"(<++) :: ReadPrec a -> ReadPrec a -> ReadPrec a\n"
"P f1 <++ P f2 = P (\\n -> f1 n ReadP.<++ f2 n)\n"
"\n"
"pfail :: ReadPrec a\n"
"pfail = lift ReadP.pfail\n"
"\n"
"choice :: [ReadPrec a] -> ReadPrec a\n"
"choice ps = foldr (+++) pfail ps\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Converting between ReadPrec and Read\n"
"\n"
"readPrec_to_P :: ReadPrec a -> (Int -> ReadP a)\n"
"readPrec_to_P (P f) = f\n"
"\n"
"readP_to_Prec :: (Int -> ReadP a) -> ReadPrec a\n"
"readP_to_Prec f = P f\n"
"\n"
"readPrec_to_S :: ReadPrec a -> (Int -> ReadS a)\n"
"readPrec_to_S (P f) n = readP_to_S (f n)\n"
"\n"
"readS_to_Prec :: (Int -> ReadS a) -> ReadPrec a\n"
"readS_to_Prec f = P (\\n -> readS_to_P (f n))\n";
const char *Text_ParserCombinators_Parsec = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.ParserCombinators.Parsec\n"
"-- Copyright   :  (c) Daan Leijen 1999-2001\n"
"-- License     :  BSD-style (see the file libraries/parsec/LICENSE)\n"
"-- \n"
"-- Maintainer  :  daan@cs.uu.nl\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Parsec, the Fast Monadic Parser combinator library, see\n"
"-- <http://www.cs.uu.nl/people/daan/parsec.html>.\n"
"--\n"
"-- Inspired by:\n"
"--\n"
"-- * Graham Hutton and Erik Meijer:\n"
"--   Monadic Parser Combinators.\n"
"--   Technical report NOTTCS-TR-96-4. \n"
"--   Department of Computer Science, University of Nottingham, 1996. \n"
"--   <http://www.cs.nott.ac.uk/~gmh/monparsing.ps>\n"
"--\n"
"-- * Andrew Partridge, David Wright: \n"
"--   Predictive parser combinators need four values to report errors.\n"
"--   Journal of Functional Programming 6(2): 355-364, 1996\n"
"--\n"
"-- This helper module exports elements from the basic libraries.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.ParserCombinators.Parsec\n"
"               ( -- complete modules\n"
"                 module Text.ParserCombinators.Parsec.Prim\n"
"               , module Text.ParserCombinators.Parsec.Combinator\n"
"               , module Text.ParserCombinators.Parsec.Char\n"
"               \n"
"               -- module Text.ParserCombinators.Parsec.Error\n"
"               , ParseError   \n"
"               , errorPos   \n"
"               \n"
"               -- module Text.ParserCombinators.Parsec.Pos\n"
"               , SourcePos\n"
"               , SourceName, Line, Column             \n"
"               , sourceName, sourceLine, sourceColumn             \n"
"               , incSourceLine, incSourceColumn\n"
"               , setSourceLine, setSourceColumn, setSourceName\n"
"\n"
"             ) where\n"
"\n"
"import Text.ParserCombinators.Parsec.Pos            -- textual positions\n"
"import Text.ParserCombinators.Parsec.Error          -- parse errors\n"
"import Text.ParserCombinators.Parsec.Prim           -- primitive combinators\n"
"import Text.ParserCombinators.Parsec.Combinator     -- derived combinators\n"
"import Text.ParserCombinators.Parsec.Char           -- character parsers\n"
"\n";
const char *Text_ParserCombinators_Parsec_Language = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.ParserCombinators.Parsec.Language\n"
"-- Copyright   :  (c) Daan Leijen 1999-2001\n"
"-- License     :  BSD-style (see the file libraries/parsec/LICENSE)\n"
"-- \n"
"-- Maintainer  :  daan@cs.uu.nl\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (uses non-portable module Text.ParserCombinators.Parsec.Token)\n"
"--\n"
"-- A helper module that defines some language definitions that can be used\n"
"-- to instantiate a token parser (see \"Text.ParserCombinators.Parsec.Token\").\n"
"-- \n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.ParserCombinators.Parsec.Language\n"
"                     ( haskellDef, haskell\n"
"                     , mondrianDef, mondrian\n"
"                   \n"
"                     , emptyDef\n"
"                     , haskellStyle\n"
"                     , javaStyle   \n"
"                     , LanguageDef (..)                \n"
"                     ) where\n"
"import Text.ParserCombinators.Parsec\n"
"import Text.ParserCombinators.Parsec.Token \n"
"\n"
"           \n"
"-----------------------------------------------------------\n"
"-- Styles: haskellStyle, javaStyle\n"
"-----------------------------------------------------------               \n"
"haskellStyle :: LanguageDef st\n"
"haskellStyle= emptyDef                      \n"
"                { commentStart   = \"{-\"\n"
"                , commentEnd     = \"-}\"\n"
"                , commentLine    = \"--\"\n"
"                , nestedComments = True\n"
"                , identStart     = letter\n"
"                , identLetter	 = alphaNum <|> oneOf \"_'\"\n"
"                , opStart	 = opLetter haskellStyle\n"
"                , opLetter	 = oneOf \":!#$%&*+./<=>?@\\\\^|-~\"              \n"
"                , reservedOpNames= []\n"
"                , reservedNames  = []\n"
"                , caseSensitive  = True                                   \n"
"                }         \n"
"                           \n"
"javaStyle  :: LanguageDef st\n"
"javaStyle   = emptyDef\n"
"		{ commentStart	 = \"/*\"\n"
"		, commentEnd	 = \"*/\"\n"
"		, commentLine	 = \"//\"\n"
"		, nestedComments = True\n"
"		, identStart	 = letter\n"
"		, identLetter	 = alphaNum <|> oneOf \"_'\"		\n"
"		, reservedNames  = []\n"
"		, reservedOpNames= []	\n"
"                , caseSensitive  = False				  \n"
"		}\n"
"\n"
"-----------------------------------------------------------\n"
"-- minimal language definition\n"
"-----------------------------------------------------------                \n"
"emptyDef   :: LanguageDef st\n"
"emptyDef    = LanguageDef \n"
"               { commentStart   = \"\"\n"
"               , commentEnd     = \"\"\n"
"               , commentLine    = \"\"\n"
"               , nestedComments = True\n"
"               , identStart     = letter <|> char '_'\n"
"               , identLetter    = alphaNum <|> oneOf \"_'\"\n"
"               , opStart        = opLetter emptyDef\n"
"               , opLetter       = oneOf \":!#$%&*+./<=>?@\\\\^|-~\"\n"
"               , reservedOpNames= []\n"
"               , reservedNames  = []\n"
"               , caseSensitive  = True\n"
"               }\n"
"                \n"
"\n"
"-----------------------------------------------------------\n"
"-- Haskell\n"
"-----------------------------------------------------------               \n"
"haskell :: TokenParser st\n"
"haskell      = makeTokenParser haskellDef\n"
"\n"
"haskellDef  :: LanguageDef st\n"
"haskellDef   = haskell98Def\n"
"	        { identLetter	 = identLetter haskell98Def <|> char '#'\n"
"	        , reservedNames	 = reservedNames haskell98Def ++ \n"
"    				   [\"foreign\",\"import\",\"export\",\"primitive\"\n"
"    				   ,\"_ccall_\",\"_casm_\"\n"
"    				   ,\"forall\"\n"
"    				   ]\n"
"                }\n"
"			    \n"
"haskell98Def :: LanguageDef st\n"
"haskell98Def = haskellStyle\n"
"                { reservedOpNames= [\"::\",\"..\",\"=\",\"\\\\\",\"|\",\"<-\",\"->\",\"@\",\"~\",\"=>\"]\n"
"                , reservedNames  = [\"let\",\"in\",\"case\",\"of\",\"if\",\"then\",\"else\",\n"
"                                    \"data\",\"type\",\n"
"                                    \"class\",\"default\",\"deriving\",\"do\",\"import\",\n"
"                                    \"infix\",\"infixl\",\"infixr\",\"instance\",\"module\",\n"
"                                    \"newtype\",\"where\",\n"
"                                    \"primitive\"\n"
"                                    -- \"as\",\"qualified\",\"hiding\"\n"
"                                   ]\n"
"                }         \n"
"                \n"
"                \n"
"-----------------------------------------------------------\n"
"-- Mondrian\n"
"-----------------------------------------------------------               \n"
"mondrian :: TokenParser st\n"
"mondrian    = makeTokenParser mondrianDef\n"
"\n"
"mondrianDef :: LanguageDef st\n"
"mondrianDef = javaStyle\n"
"		{ reservedNames = [ \"case\", \"class\", \"default\", \"extends\"\n"
"				  , \"import\", \"in\", \"let\", \"new\", \"of\", \"package\"\n"
"				  ]	\n"
"                , caseSensitive  = True				  \n"
"		}\n"
"\n"
"				\n";
const char *Text_ParserCombinators_Parsec_Char = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.ParserCombinators.Parsec.Char\n"
"-- Copyright   :  (c) Daan Leijen 1999-2001\n"
"-- License     :  BSD-style (see the file libraries/parsec/LICENSE)\n"
"-- \n"
"-- Maintainer  :  daan@cs.uu.nl\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Commonly used character parsers.\n"
"-- \n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.ParserCombinators.Parsec.Char\n"
"                  ( CharParser\n"
"                  , spaces, space\n"
"                  , newline, tab\n"
"                  , upper, lower, alphaNum, letter\n"
"                  , digit, hexDigit, octDigit\n"
"                  , char, string\n"
"                  , anyChar, oneOf, noneOf\n"
"                  , satisfy\n"
"                  ) where\n"
"\n"
"import Prelude\n"
"import Data.Char\n"
"import Text.ParserCombinators.Parsec.Pos( updatePosChar, updatePosString )\n"
"import Text.ParserCombinators.Parsec.Prim\n"
"\n"
"-----------------------------------------------------------\n"
"-- Type of character parsers\n"
"-----------------------------------------------------------\n"
"type CharParser st a    = GenParser Char st a\n"
"\n"
"-----------------------------------------------------------\n"
"-- Character parsers\n"
"-----------------------------------------------------------\n"
"oneOf, noneOf :: [Char] -> CharParser st Char\n"
"oneOf cs            = satisfy (\\c -> elem c cs)\n"
"noneOf cs           = satisfy (\\c -> not (elem c cs))\n"
"\n"
"spaces :: CharParser st ()\n"
"spaces              = skipMany space        <?> \"white space\"          \n"
"\n"
"space, newline, tab :: CharParser st Char\n"
"space               = satisfy (isSpace)     <?> \"space\"\n"
"newline             = char '\\n'             <?> \"new-line\"\n"
"tab                 = char '\\t'             <?> \"tab\"\n"
"\n"
"upper, lower, alphaNum, letter, digit, hexDigit, octDigit :: CharParser st Char\n"
"upper               = satisfy (isUpper)     <?> \"uppercase letter\"\n"
"lower               = satisfy (isLower)     <?> \"lowercase letter\"\n"
"alphaNum            = satisfy (isAlphaNum)  <?> \"letter or digit\"\n"
"letter              = satisfy (isAlpha)     <?> \"letter\"\n"
"digit               = satisfy (isDigit)     <?> \"digit\"\n"
"hexDigit            = satisfy (isHexDigit)  <?> \"hexadecimal digit\"\n"
"octDigit            = satisfy (isOctDigit)  <?> \"octal digit\"\n"
"\n"
"char :: Char -> CharParser st Char\n"
"char c              = satisfy (==c)  <?> show [c]\n"
"\n"
"anyChar :: CharParser st Char\n"
"anyChar             = satisfy (const True)\n"
"\n"
"-----------------------------------------------------------\n"
"-- Primitive character parsers\n"
"-----------------------------------------------------------\n"
"satisfy :: (Char -> Bool) -> CharParser st Char\n"
"satisfy f           = tokenPrim (\\c -> show [c]) \n"
"                                (\\pos c cs -> updatePosChar pos c) \n"
"                                (\\c -> if f c then Just c else Nothing)\n"
"\n"
"string :: String -> CharParser st String\n"
"string s            = tokens show updatePosString s\n";
const char *Text_ParserCombinators_Parsec_Token = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.ParserCombinators.Parsec.Token\n"
"-- Copyright   :  (c) Daan Leijen 1999-2001\n"
"-- License     :  BSD-style (see the file libraries/parsec/LICENSE)\n"
"-- \n"
"-- Maintainer  :  daan@cs.uu.nl\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (uses existentially quantified data constructors)\n"
"--\n"
"-- A helper module to parse lexical elements (tokens).\n"
"-- \n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.ParserCombinators.Parsec.Token\n"
"                  ( LanguageDef (..)\n"
"                  , TokenParser (..)\n"
"                  , makeTokenParser\n"
"                  ) where\n"
"\n"
"import Data.Char (isAlpha,toLower,toUpper,isSpace,digitToInt)\n"
"import Data.List (nub,sort)\n"
"import Text.ParserCombinators.Parsec\n"
"\n"
"-----------------------------------------------------------\n"
"-- Language Definition\n"
"-----------------------------------------------------------\n"
"data LanguageDef st  \n"
"    = LanguageDef \n"
"    { commentStart   :: String\n"
"    , commentEnd     :: String\n"
"    , commentLine    :: String\n"
"    , nestedComments :: Bool                  \n"
"    , identStart     :: CharParser st Char\n"
"    , identLetter    :: CharParser st Char\n"
"    , opStart        :: CharParser st Char\n"
"    , opLetter       :: CharParser st Char\n"
"    , reservedNames  :: [String]\n"
"    , reservedOpNames:: [String]\n"
"    , caseSensitive  :: Bool\n"
"    }                           \n"
"           \n"
"-----------------------------------------------------------\n"
"-- A first class module: TokenParser\n"
"-----------------------------------------------------------\n"
"data TokenParser st\n"
"    = TokenParser{ identifier       :: CharParser st String\n"
"                 , reserved         :: String -> CharParser st ()\n"
"                 , operator         :: CharParser st String\n"
"                 , reservedOp       :: String -> CharParser st ()\n"
"                        \n"
"                 , charLiteral      :: CharParser st Char\n"
"                 , stringLiteral    :: CharParser st String\n"
"                 , natural          :: CharParser st Integer\n"
"                 , integer          :: CharParser st Integer\n"
"                 , float            :: CharParser st Double\n"
"                 , naturalOrFloat   :: CharParser st (Either Integer Double)\n"
"                 , decimal          :: CharParser st Integer\n"
"                 , hexadecimal      :: CharParser st Integer\n"
"                 , octal            :: CharParser st Integer\n"
"            \n"
"                 , symbol           :: String -> CharParser st String\n"
"                 , lexeme           :: forall a. CharParser st a -> CharParser st a\n"
"                 , whiteSpace       :: CharParser st ()     \n"
"             \n"
"                 , parens           :: forall a. CharParser st a -> CharParser st a \n"
"                 , braces           :: forall a. CharParser st a -> CharParser st a\n"
"                 , angles           :: forall a. CharParser st a -> CharParser st a\n"
"                 , brackets         :: forall a. CharParser st a -> CharParser st a\n"
"                 -- \"squares\" is deprecated\n"
"                 , squares          :: forall a. CharParser st a -> CharParser st a \n"
"\n"
"                 , semi             :: CharParser st String\n"
"                 , comma            :: CharParser st String\n"
"                 , colon            :: CharParser st String\n"
"                 , dot              :: CharParser st String\n"
"                 , semiSep          :: forall a . CharParser st a -> CharParser st [a]\n"
"                 , semiSep1         :: forall a . CharParser st a -> CharParser st [a]\n"
"                 , commaSep         :: forall a . CharParser st a -> CharParser st [a]\n"
"                 , commaSep1        :: forall a . CharParser st a -> CharParser st [a]                \n"
"                 }\n"
"\n"
"-----------------------------------------------------------\n"
"-- Given a LanguageDef, create a token parser.\n"
"-----------------------------------------------------------\n"
"makeTokenParser :: LanguageDef st -> TokenParser st\n"
"makeTokenParser languageDef\n"
"    = TokenParser{ identifier = identifier\n"
"                 , reserved = reserved\n"
"                 , operator = operator\n"
"                 , reservedOp = reservedOp\n"
"                        \n"
"                 , charLiteral = charLiteral\n"
"                 , stringLiteral = stringLiteral\n"
"                 , natural = natural\n"
"                 , integer = integer\n"
"                 , float = float\n"
"                 , naturalOrFloat = naturalOrFloat\n"
"                 , decimal = decimal\n"
"                 , hexadecimal = hexadecimal\n"
"                 , octal = octal\n"
"            \n"
"                 , symbol = symbol\n"
"                 , lexeme = lexeme\n"
"                 , whiteSpace = whiteSpace\n"
"             \n"
"                 , parens = parens\n"
"                 , braces = braces\n"
"                 , angles = angles\n"
"                 , brackets = brackets\n"
"                 , squares = brackets\n"
"                 , semi = semi\n"
"                 , comma = comma\n"
"                 , colon = colon\n"
"                 , dot = dot\n"
"                 , semiSep = semiSep\n"
"                 , semiSep1 = semiSep1\n"
"                 , commaSep = commaSep\n"
"                 , commaSep1 = commaSep1\n"
"                 }\n"
"    where\n"
"     \n"
"    -----------------------------------------------------------\n"
"    -- Bracketing\n"
"    -----------------------------------------------------------\n"
"    parens p        = between (symbol \"(\") (symbol \")\") p\n"
"    braces p        = between (symbol \"{\") (symbol \"}\") p\n"
"    angles p        = between (symbol \"<\") (symbol \">\") p\n"
"    brackets p      = between (symbol \"[\") (symbol \"]\") p\n"
"\n"
"    semi            = symbol \";\" \n"
"    comma           = symbol \",\"\n"
"    dot             = symbol \".\"\n"
"    colon           = symbol \":\"\n"
"\n"
"    commaSep p      = sepBy p comma\n"
"    semiSep p       = sepBy p semi\n"
"\n"
"    commaSep1 p     = sepBy1 p comma\n"
"    semiSep1 p      = sepBy1 p semi\n"
"\n"
"    -----------------------------------------------------------\n"
"    -- Chars & Strings\n"
"    -----------------------------------------------------------\n"
"    -- charLiteral :: CharParser st Char\n"
"    charLiteral     = lexeme (between (char '\\'') \n"
"                                      (char '\\'' <?> \"end of character\")\n"
"                                      characterChar )\n"
"                    <?> \"character\"\n"
"\n"
"    characterChar   = charLetter <|> charEscape \n"
"                    <?> \"literal character\"\n"
"\n"
"    charEscape      = do{ char '\\\\'; escapeCode }\n"
"    charLetter      = satisfy (\\c -> (c /= '\\'') && (c /= '\\\\') && (c > '\\026'))\n"
"\n"
"    -- stringLiteral :: CharParser st String\n"
"    stringLiteral   = lexeme (\n"
"                      do{ str <- between (char '\"')                   \n"
"                                         (char '\"' <?> \"end of string\")\n"
"                                         (many stringChar) \n"
"                        ; return (foldr (maybe id (:)) \"\" str)\n"
"                        }\n"
"                      <?> \"literal string\")\n"
"\n"
"    -- stringChar :: CharParser st (Maybe Char)\n"
"    stringChar      =   do{ c <- stringLetter; return (Just c) }\n"
"                    <|> stringEscape \n"
"                    <?> \"string character\"\n"
"                \n"
"    stringLetter    = satisfy (\\c -> (c /= '\"') && (c /= '\\\\') && (c > '\\026'))\n"
"\n"
"    stringEscape    = do{ char '\\\\'\n"
"                        ;     do{ escapeGap  ; return Nothing }\n"
"                          <|> do{ escapeEmpty; return Nothing }\n"
"                          <|> do{ esc <- escapeCode; return (Just esc) }\n"
"                        }\n"
"                        \n"
"    escapeEmpty     = char '&'\n"
"    escapeGap       = do{ many1 space\n"
"                        ; char '\\\\' <?> \"end of string gap\"\n"
"                        }\n"
"                        \n"
"                        \n"
"                        \n"
"    -- escape codes\n"
"    escapeCode      = charEsc <|> charNum <|> charAscii <|> charControl\n"
"                    <?> \"escape code\"\n"
"\n"
"    -- charControl :: CharParser st Char\n"
"    charControl     = do{ char '^'\n"
"                        ; code <- upper\n"
"                        ; return (toEnum (fromEnum code - fromEnum 'A'))\n"
"                        }\n"
"\n"
"    -- charNum :: CharParser st Char                    \n"
"    charNum         = do{ code <- decimal \n"
"                                  <|> do{ char 'o'; number 8 octDigit }\n"
"                                  <|> do{ char 'x'; number 16 hexDigit }\n"
"                        ; return (toEnum (fromInteger code))\n"
"                        }\n"
"\n"
"    charEsc         = choice (map parseEsc escMap)\n"
"                    where\n"
"                      parseEsc (c,code)     = do{ char c; return code }\n"
"                      \n"
"    charAscii       = choice (map parseAscii asciiMap)\n"
"                    where\n"
"                      parseAscii (asc,code) = try (do{ string asc; return code })\n"
"\n"
"    -- escape code tables\n"
"    escMap          = zip (\"abfnrtv\\\\\\\"\\'\") (\"\\a\\b\\f\\n\\r\\t\\v\\\\\\\"\\'\")\n"
"    asciiMap        = zip (ascii3codes ++ ascii2codes) (ascii3 ++ ascii2) \n"
"\n"
"    ascii2codes     = [\"BS\",\"HT\",\"LF\",\"VT\",\"FF\",\"CR\",\"SO\",\"SI\",\"EM\",\n"
"                       \"FS\",\"GS\",\"RS\",\"US\",\"SP\"]\n"
"    ascii3codes     = [\"NUL\",\"SOH\",\"STX\",\"ETX\",\"EOT\",\"ENQ\",\"ACK\",\"BEL\",\n"
"                       \"DLE\",\"DC1\",\"DC2\",\"DC3\",\"DC4\",\"NAK\",\"SYN\",\"ETB\",\n"
"                       \"CAN\",\"SUB\",\"ESC\",\"DEL\"]\n"
"\n"
"    ascii2          = ['\\BS','\\HT','\\LF','\\VT','\\FF','\\CR','\\SO','\\SI',\n"
"                       '\\EM','\\FS','\\GS','\\RS','\\US','\\SP']\n"
"    ascii3          = ['\\NUL','\\SOH','\\STX','\\ETX','\\EOT','\\ENQ','\\ACK',\n"
"                       '\\BEL','\\DLE','\\DC1','\\DC2','\\DC3','\\DC4','\\NAK',\n"
"                       '\\SYN','\\ETB','\\CAN','\\SUB','\\ESC','\\DEL']\n"
"\n"
"    -----------------------------------------------------------\n"
"    -- Numbers\n"
"    -----------------------------------------------------------\n"
"    -- naturalOrFloat :: CharParser st (Either Integer Double)\n"
"    naturalOrFloat  = lexeme (natFloat) <?> \"number\"\n"
"\n"
"    float           = lexeme floating   <?> \"float\"\n"
"    integer         = lexeme int        <?> \"integer\"\n"
"    natural         = lexeme nat        <?> \"natural\"\n"
"\n"
"    -- floats\n"
"    floating        = do{ n <- decimal \n"
"                        ; fractExponent n\n"
"                        }\n"
"\n"
"    natFloat        = do{ char '0'\n"
"                        ; zeroNumFloat\n"
"                        }\n"
"                      <|> decimalFloat\n"
"                      \n"
"    zeroNumFloat    =  do{ n <- hexadecimal <|> octal\n"
"                         ; return (Left n)\n"
"                         }\n"
"                    <|> decimalFloat\n"
"                    <|> fractFloat 0\n"
"                    <|> return (Left 0)                  \n"
"                      \n"
"    decimalFloat    = do{ n <- decimal\n"
"                        ; option (Left n) \n"
"                                 (fractFloat n)\n"
"                        }\n"
"\n"
"    fractFloat n    = do{ f <- fractExponent n\n"
"                        ; return (Right f)\n"
"                        }\n"
"                        \n"
"    fractExponent n = do{ fract <- fraction\n"
"                        ; expo  <- option 1.0 exponent'\n"
"                        ; return ((fromInteger n + fract)*expo)\n"
"                        }\n"
"                    <|>\n"
"                      do{ expo <- exponent'\n"
"                        ; return ((fromInteger n)*expo)\n"
"                        }\n"
"\n"
"    fraction        = do{ char '.'\n"
"                        ; digits <- many1 digit <?> \"fraction\"\n"
"                        ; return (foldr op 0.0 digits)\n"
"                        }\n"
"                      <?> \"fraction\"\n"
"                    where\n"
"                      op d f    = (f + fromIntegral (digitToInt d))/10.0\n"
"                        \n"
"    exponent'       = do{ oneOf \"eE\"\n"
"                        ; f <- sign\n"
"                        ; e <- decimal <?> \"exponent\"\n"
"                        ; return (power (f e))\n"
"                        }\n"
"                      <?> \"exponent\"\n"
"                    where\n"
"                       power e  | e < 0      = 1.0/power(-e)\n"
"                                | otherwise  = fromInteger (10^e)\n"
"\n"
"    -- integers and naturals\n"
"    int             = do{ f <- lexeme sign\n"
"                        ; n <- nat\n"
"                        ; return (f n)\n"
"                        }\n"
"                        \n"
"    -- sign            :: CharParser st (Integer -> Integer)\n"
"    sign            =   (char '-' >> return negate) \n"
"                    <|> (char '+' >> return id)     \n"
"                    <|> return id\n"
"\n"
"    nat             = zeroNumber <|> decimal\n"
"        \n"
"    zeroNumber      = do{ char '0'\n"
"                        ; hexadecimal <|> octal <|> decimal <|> return 0\n"
"                        }\n"
"                      <?> \"\"       \n"
"\n"
"    decimal         = number 10 digit        \n"
"    hexadecimal     = do{ oneOf \"xX\"; number 16 hexDigit }\n"
"    octal           = do{ oneOf \"oO\"; number 8 octDigit  }\n"
"\n"
"    -- number :: Integer -> CharParser st Char -> CharParser st Integer\n"
"    number base baseDigit\n"
"        = do{ digits <- many1 baseDigit\n"
"            ; let n = foldl (\\x d -> base*x + toInteger (digitToInt d)) 0 digits\n"
"            ; seq n (return n)\n"
"            }          \n"
"\n"
"    -----------------------------------------------------------\n"
"    -- Operators & reserved ops\n"
"    -----------------------------------------------------------\n"
"    reservedOp name =   \n"
"        lexeme $ try $\n"
"        do{ string name\n"
"          ; notFollowedBy (opLetter languageDef) <?> (\"end of \" ++ show name)\n"
"          }\n"
"\n"
"    operator =\n"
"        lexeme $ try $\n"
"        do{ name <- oper\n"
"          ; if (isReservedOp name)\n"
"             then unexpected (\"reserved operator \" ++ show name)\n"
"             else return name\n"
"          }\n"
"          \n"
"    oper =\n"
"        do{ c <- (opStart languageDef)\n"
"          ; cs <- many (opLetter languageDef)\n"
"          ; return (c:cs)\n"
"          }\n"
"        <?> \"operator\"\n"
"        \n"
"    isReservedOp name =\n"
"        isReserved (sort (reservedOpNames languageDef)) name          \n"
"        \n"
"        \n"
"    -----------------------------------------------------------\n"
"    -- Identifiers & Reserved words\n"
"    -----------------------------------------------------------\n"
"    reserved name =\n"
"        lexeme $ try $\n"
"        do{ caseString name\n"
"          ; notFollowedBy (identLetter languageDef) <?> (\"end of \" ++ show name)\n"
"          }\n"
"\n"
"    caseString name\n"
"        | caseSensitive languageDef  = string name\n"
"        | otherwise               = do{ walk name; return name }\n"
"        where\n"
"          walk []     = return ()\n"
"          walk (c:cs) = do{ caseChar c <?> msg; walk cs }\n"
"          \n"
"          caseChar c  | isAlpha c  = char (toLower c) <|> char (toUpper c)\n"
"                      | otherwise  = char c\n"
"          \n"
"          msg         = show name\n"
"          \n"
"\n"
"    identifier =\n"
"        lexeme $ try $\n"
"        do{ name <- ident\n"
"          ; if (isReservedName name)\n"
"             then unexpected (\"reserved word \" ++ show name)\n"
"             else return name\n"
"          }\n"
"        \n"
"        \n"
"    ident           \n"
"        = do{ c <- identStart languageDef\n"
"            ; cs <- many (identLetter languageDef)\n"
"            ; return (c:cs)\n"
"            }\n"
"        <?> \"identifier\"\n"
"\n"
"    isReservedName name\n"
"        = isReserved theReservedNames caseName\n"
"        where\n"
"          caseName      | caseSensitive languageDef  = name\n"
"                        | otherwise               = map toLower name\n"
"\n"
"        \n"
"    isReserved names name    \n"
"        = scan names\n"
"        where\n"
"          scan []       = False\n"
"          scan (r:rs)   = case (compare r name) of\n"
"                            LT  -> scan rs\n"
"                            EQ  -> True\n"
"                            GT  -> False\n"
"\n"
"    theReservedNames\n"
"        | caseSensitive languageDef  = sortedNames\n"
"        | otherwise               = map (map toLower) sortedNames\n"
"        where\n"
"          sortedNames   = sort (reservedNames languageDef)\n"
"                                 \n"
"\n"
"    -----------------------------------------------------------\n"
"    -- White space & symbols\n"
"    -----------------------------------------------------------\n"
"    symbol name\n"
"        = lexeme (string name)\n"
"\n"
"    lexeme p       \n"
"        = do{ x <- p; whiteSpace; return x  }\n"
"      \n"
"      \n"
"    --whiteSpace    \n"
"    whiteSpace \n"
"        | noLine && noMulti  = skipMany (simpleSpace <?> \"\")\n"
"        | noLine             = skipMany (simpleSpace <|> multiLineComment <?> \"\")\n"
"        | noMulti            = skipMany (simpleSpace <|> oneLineComment <?> \"\")\n"
"        | otherwise          = skipMany (simpleSpace <|> oneLineComment <|> multiLineComment <?> \"\")\n"
"        where\n"
"          noLine  = null (commentLine languageDef)\n"
"          noMulti = null (commentStart languageDef)   \n"
"          \n"
"          \n"
"    simpleSpace =\n"
"        skipMany1 (satisfy isSpace)    \n"
"        \n"
"    oneLineComment =\n"
"        do{ try (string (commentLine languageDef))\n"
"          ; skipMany (satisfy (/= '\\n'))\n"
"          ; return ()\n"
"          }\n"
"\n"
"    multiLineComment =\n"
"        do { try (string (commentStart languageDef))\n"
"           ; inComment\n"
"           }\n"
"\n"
"    inComment \n"
"        | nestedComments languageDef  = inCommentMulti\n"
"        | otherwise                = inCommentSingle\n"
"        \n"
"    inCommentMulti \n"
"        =   do{ try (string (commentEnd languageDef)) ; return () }\n"
"        <|> do{ multiLineComment                     ; inCommentMulti }\n"
"        <|> do{ skipMany1 (noneOf startEnd)          ; inCommentMulti }\n"
"        <|> do{ oneOf startEnd                       ; inCommentMulti }\n"
"        <?> \"end of comment\"  \n"
"        where\n"
"          startEnd   = nub (commentEnd languageDef ++ commentStart languageDef)\n"
"\n"
"    inCommentSingle\n"
"        =   do{ try (string (commentEnd languageDef)); return () }\n"
"        <|> do{ skipMany1 (noneOf startEnd)         ; inCommentSingle }\n"
"        <|> do{ oneOf startEnd                      ; inCommentSingle }\n"
"        <?> \"end of comment\"\n"
"        where\n"
"          startEnd   = nub (commentEnd languageDef ++ commentStart languageDef)\n"
"\n";
const char *Text_ParserCombinators_Parsec_Error = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.ParserCombinators.Parsec.Error\n"
"-- Copyright   :  (c) Daan Leijen 1999-2001\n"
"-- License     :  BSD-style (see the file libraries/parsec/LICENSE)\n"
"-- \n"
"-- Maintainer  :  daan@cs.uu.nl\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Parse errors\n"
"-- \n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.ParserCombinators.Parsec.Error\n"
"                  ( Message(SysUnExpect,UnExpect,Expect,Message)\n"
"                  , messageString, messageCompare, messageEq\n"
"                  \n"
"                  , ParseError, errorPos, errorMessages, errorIsUnknown\n"
"                  , showErrorMessages\n"
"                  \n"
"                  , newErrorMessage, newErrorUnknown\n"
"                  , addErrorMessage, setErrorPos, setErrorMessage\n"
"                  , mergeError\n"
"                  )\n"
"                  where\n"
"\n"
"import Prelude\n"
"import Data.List (nub,sortBy)\n"
"import Text.ParserCombinators.Parsec.Pos \n"
"                          \n"
"-----------------------------------------------------------\n"
"-- Messages\n"
"-----------------------------------------------------------                         \n"
"data Message        = SysUnExpect !String   --library generated unexpect            \n"
"                    | UnExpect    !String   --unexpected something     \n"
"                    | Expect      !String   --expecting something\n"
"                    | Message     !String   --raw message\n"
"                    \n"
"messageToEnum msg\n"
"    = case msg of SysUnExpect _ -> 0\n"
"                  UnExpect _    -> 1\n"
"                  Expect _      -> 2\n"
"                  Message _     -> 3                                  \n"
"                                      \n"
"messageCompare :: Message -> Message -> Ordering\n"
"messageCompare msg1 msg2\n"
"    = compare (messageToEnum msg1) (messageToEnum msg2)\n"
"  \n"
"messageString :: Message -> String\n"
"messageString msg\n"
"    = case msg of SysUnExpect s -> s\n"
"                  UnExpect s    -> s\n"
"                  Expect s      -> s\n"
"                  Message s     -> s                                  \n"
"\n"
"messageEq :: Message -> Message -> Bool\n"
"messageEq msg1 msg2\n"
"    = (messageCompare msg1 msg2 == EQ)\n"
"    \n"
"    \n"
"-----------------------------------------------------------\n"
"-- Parse Errors\n"
"-----------------------------------------------------------                           \n"
"data ParseError     = ParseError !SourcePos [Message]\n"
"\n"
"errorPos :: ParseError -> SourcePos\n"
"errorPos (ParseError pos msgs)\n"
"    = pos\n"
"                  \n"
"errorMessages :: ParseError -> [Message]\n"
"errorMessages (ParseError pos msgs)\n"
"    = sortBy messageCompare msgs      \n"
"        \n"
"errorIsUnknown :: ParseError -> Bool\n"
"errorIsUnknown (ParseError pos msgs)\n"
"    = null msgs\n"
"            \n"
"            \n"
"-----------------------------------------------------------\n"
"-- Create parse errors\n"
"-----------------------------------------------------------                         \n"
"newErrorUnknown :: SourcePos -> ParseError\n"
"newErrorUnknown pos\n"
"    = ParseError pos []\n"
"    \n"
"newErrorMessage :: Message -> SourcePos -> ParseError\n"
"newErrorMessage msg pos  \n"
"    = ParseError pos [msg]\n"
"\n"
"addErrorMessage :: Message -> ParseError -> ParseError\n"
"addErrorMessage msg (ParseError pos msgs)\n"
"    = ParseError pos (msg:msgs)\n"
"    \n"
"setErrorPos :: SourcePos -> ParseError -> ParseError\n"
"setErrorPos pos (ParseError _ msgs)\n"
"    = ParseError pos msgs\n"
"    \n"
"setErrorMessage :: Message -> ParseError -> ParseError\n"
"setErrorMessage msg (ParseError pos msgs)\n"
"    = ParseError pos (msg:filter (not . messageEq msg) msgs)\n"
" \n"
"    \n"
"mergeError :: ParseError -> ParseError -> ParseError\n"
"mergeError (ParseError pos msgs1) (ParseError _ msgs2)\n"
"    = ParseError pos (msgs1 ++ msgs2)\n"
"    \n"
"\n"
"-----------------------------------------------------------\n"
"-- Show Parse Errors\n"
"-----------------------------------------------------------                         \n"
"instance Show ParseError where\n"
"  show err\n"
"    = show (errorPos err) ++ \":\" ++ \n"
"      showErrorMessages \"or\" \"unknown parse error\" \n"
"                        \"expecting\" \"unexpected\" \"end of input\"\n"
"                       (errorMessages err)\n"
"\n"
"-- | Language independent show function\n"
"showErrorMessages ::\n"
"    String -> String -> String -> String -> String -> [Message] -> String\n"
"showErrorMessages msgOr msgUnknown msgExpecting msgUnExpected msgEndOfInput msgs\n"
"    | null msgs = msgUnknown\n"
"    | otherwise = concat $ map (\"\\n\"++) $ clean $\n"
"                 [showSysUnExpect,showUnExpect,showExpect,showMessages]\n"
"    where\n"
"      (sysUnExpect,msgs1)   = span (messageEq (SysUnExpect \"\")) msgs\n"
"      (unExpect,msgs2)      = span (messageEq (UnExpect \"\")) msgs1\n"
"      (expect,messages)     = span (messageEq (Expect \"\")) msgs2\n"
"    \n"
"      showExpect        = showMany msgExpecting expect\n"
"      showUnExpect      = showMany msgUnExpected unExpect\n"
"      showSysUnExpect   | not (null unExpect) ||\n"
"                          null sysUnExpect       = \"\"\n"
"                        | null firstMsg          = msgUnExpected ++ \" \" ++ msgEndOfInput\n"
"                        | otherwise              = msgUnExpected ++ \" \" ++ firstMsg\n"
"                        where\n"
"                          firstMsg  = messageString (head sysUnExpect)\n"
"                        \n"
"      showMessages      = showMany \"\" messages\n"
"\n"
"      \n"
"      --helpers                                                                                                                                        \n"
"      showMany pre msgs = case (clean (map messageString msgs)) of\n"
"                            [] -> \"\"\n"
"                            ms | null pre  -> commasOr ms\n"
"                               | otherwise -> pre ++ \" \" ++ commasOr ms\n"
"                            \n"
"      commasOr []       = \"\"                \n"
"      commasOr [m]      = m                \n"
"      commasOr ms       = commaSep (init ms) ++ \" \" ++ msgOr ++ \" \" ++ last ms\n"
"        \n"
"      commaSep          = seperate \", \" . clean\n"
"      semiSep           = seperate \"; \" . clean       \n"
"        \n"
"      seperate sep []   = \"\"\n"
"      seperate sep [m]  = m\n"
"      seperate sep (m:ms) = m ++ sep ++ seperate sep ms                            \n"
"      \n"
"      clean             = nub . filter (not.null)                  \n"
"      \n";
const char *Text_ParserCombinators_Parsec_Pos = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.ParserCombinators.Parsec.Pos\n"
"-- Copyright   :  (c) Daan Leijen 1999-2001\n"
"-- License     :  BSD-style (see the file libraries/parsec/LICENSE)\n"
"-- \n"
"-- Maintainer  :  daan@cs.uu.nl\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Textual source positions.\n"
"-- \n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.ParserCombinators.Parsec.Pos\n"
"                  ( SourceName, Line, Column                 \n"
"                  , SourcePos\n"
"                  , sourceLine, sourceColumn, sourceName\n"
"                  , incSourceLine, incSourceColumn\n"
"                  , setSourceLine, setSourceColumn, setSourceName\n"
"                  , newPos, initialPos\n"
"                  , updatePosChar, updatePosString\n"
"                  ) where\n"
"\n"
"-----------------------------------------------------------\n"
"-- Source Positions, a file name, a line and a column.\n"
"-- upper left is (1,1)\n"
"-----------------------------------------------------------                         \n"
"type SourceName     = String\n"
"type Line           = Int\n"
"type Column         = Int\n"
"\n"
"data SourcePos      = SourcePos SourceName !Line !Column\n"
"		     deriving (Eq,Ord)\n"
"		\n"
"\n"
"newPos :: SourceName -> Line -> Column -> SourcePos\n"
"newPos sourceName line column\n"
"    = SourcePos sourceName line column\n"
"\n"
"initialPos sourceName\n"
"    = newPos sourceName 1 1\n"
"\n"
"sourceName   (SourcePos name line column)   = name    \n"
"sourceLine   (SourcePos name line column)   = line    \n"
"sourceColumn (SourcePos name line column)   = column\n"
"\n"
"incSourceLine   (SourcePos name line column) n    = SourcePos name (line+n) column\n"
"incSourceColumn (SourcePos name line column) n    = SourcePos name line (column+n)\n"
"\n"
"setSourceName   (SourcePos name line column) n    = SourcePos n line column\n"
"setSourceLine   (SourcePos name line column) n    = SourcePos name n column\n"
"setSourceColumn (SourcePos name line column) n    = SourcePos name line n\n"
"\n"
"-----------------------------------------------------------\n"
"-- Update source positions on characters\n"
"-----------------------------------------------------------                         \n"
"updatePosString :: SourcePos -> String -> SourcePos\n"
"updatePosString pos string\n"
"    = forcePos (foldl updatePosChar pos string)\n"
"\n"
"updatePosChar   :: SourcePos -> Char -> SourcePos\n"
"updatePosChar pos@(SourcePos name line column) c   \n"
"    = forcePos $\n"
"      case c of\n"
"        '\\n' -> SourcePos name (line+1) 1\n"
"        '\\t' -> SourcePos name line (column + 8 - ((column-1) `mod` 8))\n"
"        _    -> SourcePos name line (column + 1)\n"
"        \n"
"\n"
"forcePos :: SourcePos -> SourcePos      \n"
"forcePos pos@(SourcePos name line column)\n"
"    = seq line (seq column (pos))\n"
"\n"
"-----------------------------------------------------------\n"
"-- Show positions \n"
"-----------------------------------------------------------                                                 \n"
"instance Show SourcePos where\n"
"  show (SourcePos name line column)\n"
"    | null name = showLineColumn\n"
"    | otherwise = \"\\\"\" ++ name ++ \"\\\" \" ++ showLineColumn\n"
"    where\n"
"      showLineColumn    = \"(line \" ++ show line ++\n"
"                          \", column \" ++ show column ++\n"
"                          \")\" \n";
const char *Text_ParserCombinators_Parsec_Expr = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.ParserCombinators.Parsec.Expr\n"
"-- Copyright   :  (c) Daan Leijen 1999-2001\n"
"-- License     :  BSD-style (see the file libraries/parsec/LICENSE)\n"
"-- \n"
"-- Maintainer  :  daan@cs.uu.nl\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- A helper module to parse \\\"expressions\\\".\n"
"-- Builds a parser given a table of operators and associativities.\n"
"-- \n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.ParserCombinators.Parsec.Expr\n"
"                 ( Assoc(..), Operator(..), OperatorTable\n"
"                 , buildExpressionParser\n"
"                 ) where\n"
"\n"
"import Text.ParserCombinators.Parsec.Prim\n"
"import Text.ParserCombinators.Parsec.Combinator\n"
"\n"
"-----------------------------------------------------------\n"
"-- Assoc and OperatorTable\n"
"-----------------------------------------------------------\n"
"data Assoc                = AssocNone \n"
"                          | AssocLeft\n"
"                          | AssocRight\n"
"                        \n"
"data Operator t st a      = Infix (GenParser t st (a -> a -> a)) Assoc\n"
"                          | Prefix (GenParser t st (a -> a))\n"
"                          | Postfix (GenParser t st (a -> a))\n"
"\n"
"type OperatorTable t st a = [[Operator t st a]]\n"
"\n"
"-----------------------------------------------------------\n"
"-- Convert an OperatorTable and basic term parser into\n"
"-- a full fledged expression parser\n"
"-----------------------------------------------------------\n"
"buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a\n"
"buildExpressionParser operators simpleExpr\n"
"    = foldl (makeParser) simpleExpr operators\n"
"    where\n"
"      makeParser term ops\n"
"        = let (rassoc,lassoc,nassoc\n"
"               ,prefix,postfix)      = foldr splitOp ([],[],[],[],[]) ops\n"
"              \n"
"              rassocOp   = choice rassoc\n"
"              lassocOp   = choice lassoc\n"
"              nassocOp   = choice nassoc\n"
"              prefixOp   = choice prefix  <?> \"\"\n"
"              postfixOp  = choice postfix <?> \"\"\n"
"              \n"
"              ambigious assoc op= try $\n"
"                                  do{ op; fail (\"ambiguous use of a \" ++ assoc \n"
"                                                 ++ \" associative operator\")\n"
"                                    }\n"
"              \n"
"              ambigiousRight    = ambigious \"right\" rassocOp\n"
"              ambigiousLeft     = ambigious \"left\" lassocOp\n"
"              ambigiousNon      = ambigious \"non\" nassocOp \n"
"              \n"
"              termP      = do{ pre  <- prefixP\n"
"                             ; x    <- term     \n"
"                             ; post <- postfixP\n"
"                             ; return (post (pre x))\n"
"                             }\n"
"              \n"
"              postfixP   = postfixOp <|> return id\n"
"              \n"
"              prefixP    = prefixOp <|> return id\n"
"                                         \n"
"              rassocP x  = do{ f <- rassocOp\n"
"                             ; y  <- do{ z <- termP; rassocP1 z }\n"
"                             ; return (f x y)\n"
"                             }\n"
"                           <|> ambigiousLeft\n"
"                           <|> ambigiousNon\n"
"                           -- <|> return x\n"
"                           \n"
"              rassocP1 x = rassocP x  <|> return x                           \n"
"                           \n"
"              lassocP x  = do{ f <- lassocOp\n"
"                             ; y <- termP\n"
"                             ; lassocP1 (f x y)\n"
"                             }\n"
"                           <|> ambigiousRight\n"
"                           <|> ambigiousNon\n"
"                           -- <|> return x\n"
"                           \n"
"              lassocP1 x = lassocP x <|> return x                           \n"
"                           \n"
"              nassocP x  = do{ f <- nassocOp\n"
"                             ; y <- termP\n"
"                             ;    ambigiousRight\n"
"                              <|> ambigiousLeft\n"
"                              <|> ambigiousNon\n"
"                              <|> return (f x y)\n"
"                             }                                                          \n"
"                           -- <|> return x                                                      \n"
"                           \n"
"           in  do{ x <- termP\n"
"                 ; rassocP x <|> lassocP  x <|> nassocP x <|> return x\n"
"                   <?> \"operator\"\n"
"                 }\n"
"                \n"
"\n"
"      splitOp (Infix op assoc) (rassoc,lassoc,nassoc,prefix,postfix)\n"
"        = case assoc of\n"
"            AssocNone  -> (rassoc,lassoc,op:nassoc,prefix,postfix)\n"
"            AssocLeft  -> (rassoc,op:lassoc,nassoc,prefix,postfix)\n"
"            AssocRight -> (op:rassoc,lassoc,nassoc,prefix,postfix)\n"
"            \n"
"      splitOp (Prefix op) (rassoc,lassoc,nassoc,prefix,postfix)\n"
"        = (rassoc,lassoc,nassoc,op:prefix,postfix)\n"
"        \n"
"      splitOp (Postfix op) (rassoc,lassoc,nassoc,prefix,postfix)\n"
"        = (rassoc,lassoc,nassoc,prefix,op:postfix)\n"
"      \n";
const char *Text_ParserCombinators_Parsec_Prim = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.ParserCombinators.Parsec.Prim\n"
"-- Copyright   :  (c) Daan Leijen 1999-2001\n"
"-- License     :  BSD-style (see the file libraries/parsec/LICENSE)\n"
"-- \n"
"-- Maintainer  :  daan@cs.uu.nl\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- The primitive parser combinators.\n"
"-- \n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.ParserCombinators.Parsec.Prim\n"
"                   ( -- operators: label a parser, alternative\n"
"                     (<?>), (<|>)\n"
"\n"
"                   -- basic types\n"
"                   , Parser, GenParser\n"
"                   , runParser, parse, parseFromFile, parseTest\n"
"                   \n"
"                   -- primitive parsers:\n"
"                   -- instance Functor Parser     : fmap\n"
"                   -- instance Monad Parser       : return, >>=, fail\n"
"                   -- instance MonadPlus Parser   : mzero (pzero), mplus (<|>)\n"
"                   , token, tokens, tokenPrim, tokenPrimEx\n"
"                   , try, label, labels, unexpected, pzero\n"
"\n"
"                   -- primitive because of space behaviour\n"
"                   , many, skipMany\n"
"                                \n"
"                   -- user state manipulation\n"
"                   , getState, setState, updateState\n"
"\n"
"                   -- state manipulation\n"
"                   , getPosition, setPosition\n"
"                   , getInput, setInput                   \n"
"                   , getParserState, setParserState \n"
"                 ) where\n"
"\n"
"import Prelude\n"
"import Text.ParserCombinators.Parsec.Pos\n"
"import Text.ParserCombinators.Parsec.Error\n"
"import Control.Monad\n"
"\n"
"{-# INLINE parsecMap    #-}\n"
"{-# INLINE parsecReturn #-}\n"
"{-# INLINE parsecBind   #-}\n"
"{-# INLINE parsecZero   #-}\n"
"{-# INLINE parsecPlus   #-}\n"
"{-# INLINE token        #-}\n"
"{-# INLINE tokenPrim    #-}\n"
"\n"
"-----------------------------------------------------------\n"
"-- Operators:\n"
"-- <?>  gives a name to a parser (which is used in error messages)\n"
"-- <|>  is the choice operator\n"
"-----------------------------------------------------------\n"
"infix  0 <?>\n"
"infixr 1 <|>\n"
"\n"
"(<?>) :: GenParser tok st a -> String -> GenParser tok st a\n"
"p <?> msg           = label p msg\n"
"\n"
"(<|>) :: GenParser tok st a -> GenParser tok st a -> GenParser tok st a\n"
"p1 <|> p2           = mplus p1 p2\n"
"\n"
"-----------------------------------------------------------\n"
"-- User state combinators\n"
"-----------------------------------------------------------\n"
"getState :: GenParser tok st st\n"
"getState        = do{ state <- getParserState\n"
"                    ; return (stateUser state)\n"
"                    }\n"
"\n"
"setState :: st -> GenParser tok st ()\n"
"setState st     = do{ updateParserState (\\(State input pos _) -> State input pos st)\n"
"                    ; return ()\n"
"                    }\n"
"\n"
"updateState :: (st -> st) -> GenParser tok st ()\n"
"updateState f   = do{ updateParserState (\\(State input pos user) -> State input pos (f user))\n"
"                    ; return ()\n"
"                    }\n"
"\n"
"-----------------------------------------------------------\n"
"-- Parser state combinators\n"
"-----------------------------------------------------------\n"
"getPosition :: GenParser tok st SourcePos\n"
"getPosition         = do{ state <- getParserState; return (statePos state) }\n"
"\n"
"getInput :: GenParser tok st [tok]\n"
"getInput            = do{ state <- getParserState; return (stateInput state) }\n"
"\n"
"setPosition :: SourcePos -> GenParser tok st ()\n"
"setPosition pos     = do{ updateParserState (\\(State input _ user) -> State input pos user)\n"
"                        ; return ()\n"
"                        }\n"
"                        \n"
"setInput :: [tok] -> GenParser tok st ()\n"
"setInput input      = do{ updateParserState (\\(State _ pos user) -> State input pos user)\n"
"                        ; return ()\n"
"                        }\n"
"\n"
"getParserState	    :: GenParser tok st (State tok st)\n"
"getParserState      =  updateParserState id    \n"
"\n"
"setParserState	    :: State tok st -> GenParser tok st (State tok st)\n"
"setParserState st   = updateParserState (const st)\n"
"\n"
"-----------------------------------------------------------\n"
"-- Parser definition.\n"
"-- GenParser tok st a:\n"
"--  General parser for tokens of type \"tok\", \n"
"--  a user state \"st\" and a result type \"a\"\n"
"-----------------------------------------------------------\n"
"type Parser a           = GenParser Char () a\n"
"\n"
"newtype GenParser tok st a = Parser (State tok st -> Consumed (Reply tok st a))\n"
"runP (Parser p)            = p\n"
"\n"
"data Consumed a         = Consumed a                --input is consumed\n"
"                        | Empty !a                  --no input is consumed\n"
"                    \n"
"data Reply tok st a     = Ok !a !(State tok st) ParseError    --parsing succeeded with \"a\"\n"
"                        | Error ParseError                    --parsing failed\n"
"\n"
"data State tok st       = State { stateInput :: [tok]\n"
"                                , statePos   :: !SourcePos\n"
"                                , stateUser  :: !st\n"
"                                }\n"
"\n"
"-----------------------------------------------------------\n"
"-- run a parser\n"
"-----------------------------------------------------------\n"
"parseFromFile :: Parser a -> SourceName -> IO (Either ParseError a)\n"
"parseFromFile p fname\n"
"    = do{ input <- readFile fname\n"
"        ; return (parse p fname input)\n"
"        }\n"
"\n"
"parseTest :: Show a => GenParser tok () a -> [tok] -> IO ()\n"
"parseTest p input\n"
"    = case (runParser p () \"\" input) of\n"
"        Left err -> do{ putStr \"parse error at \"\n"
"                      ; print err\n"
"                      }\n"
"        Right x  -> print x\n"
"\n"
"parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a\n"
"parse p name input\n"
"    = runParser p () name input\n"
"\n"
"runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a\n"
"runParser p st name input\n"
"    = case parserReply (runP p (State input (initialPos name) st)) of\n"
"        Ok x _ _    -> Right x\n"
"        Error err   -> Left err\n"
"\n"
"parserReply result     \n"
"    = case result of\n"
"        Consumed reply -> reply\n"
"        Empty reply    -> reply\n"
"\n"
"-----------------------------------------------------------\n"
"-- Functor: fmap\n"
"-----------------------------------------------------------\n"
"instance Functor (GenParser tok st) where\n"
"  fmap f p  = parsecMap f p\n"
"\n"
"parsecMap :: (a -> b) -> GenParser tok st a -> GenParser tok st b\n"
"parsecMap f (Parser p)\n"
"    = Parser (\\state -> \n"
"        case (p state) of\n"
"          Consumed reply -> Consumed (mapReply reply)\n"
"          Empty    reply -> Empty    (mapReply reply)\n"
"      )\n"
"    where\n"
"      mapReply reply\n"
"        = case reply of\n"
"            Ok x state err -> let fx = f x \n"
"                              in seq fx (Ok fx state err)\n"
"            Error err      -> Error err\n"
"           \n"
"\n"
"-----------------------------------------------------------\n"
"-- Monad: return, sequence (>>=) and fail\n"
"-----------------------------------------------------------    \n"
"instance Monad (GenParser tok st) where\n"
"  return x   = parsecReturn x  \n"
"  p >>= f    = parsecBind p f\n"
"  fail msg   = parsecFail msg\n"
"\n"
"parsecReturn :: a -> GenParser tok st a\n"
"parsecReturn x\n"
"  = Parser (\\state -> Empty (Ok x state (unknownError state)))   \n"
"\n"
"parsecBind :: GenParser tok st a -> (a -> GenParser tok st b) -> GenParser tok st b\n"
"parsecBind (Parser p) f\n"
"    = Parser (\\state ->\n"
"        case (p state) of                 \n"
"          Consumed reply1 \n"
"            -> Consumed $\n"
"               case (reply1) of\n"
"                 Ok x state1 err1 -> case runP (f x) state1 of\n"
"                                       Empty reply2    -> mergeErrorReply err1 reply2\n"
"                                       Consumed reply2 -> reply2\n"
"                 Error err1       -> Error err1\n"
"\n"
"          Empty reply1    \n"
"            -> case (reply1) of\n"
"                 Ok x state1 err1 -> case runP (f x) state1 of\n"
"                                       Empty reply2 -> Empty (mergeErrorReply err1 reply2)\n"
"                                       other        -> other                                                    \n"
"                 Error err1       -> Empty (Error err1)\n"
"      )                                                              \n"
"\n"
"mergeErrorReply err1 reply\n"
"  = case reply of\n"
"      Ok x state err2 -> Ok x state (mergeError err1 err2)\n"
"      Error err2      -> Error (mergeError err1 err2)\n"
"\n"
"parsecFail :: String -> GenParser tok st a\n"
"parsecFail msg\n"
"  = Parser (\\state -> \n"
"      Empty (Error (newErrorMessage (Message msg) (statePos state))))\n"
"\n"
"-----------------------------------------------------------\n"
"-- MonadPlus: alternative (mplus) and mzero\n"
"-----------------------------------------------------------\n"
"instance MonadPlus (GenParser tok st) where\n"
"  mzero         = parsecZero\n"
"  mplus p1 p2   = parsecPlus p1 p2\n"
"      \n"
"\n"
"pzero :: GenParser tok st a\n"
"pzero = parsecZero\n"
"\n"
"parsecZero :: GenParser tok st a\n"
"parsecZero\n"
"    = Parser (\\state -> Empty (Error (unknownError state)))\n"
"\n"
"parsecPlus :: GenParser tok st a -> GenParser tok st a -> GenParser tok st a\n"
"parsecPlus (Parser p1) (Parser p2)\n"
"    = Parser (\\state ->\n"
"        case (p1 state) of        \n"
"          Empty (Error err) -> case (p2 state) of\n"
"                                 Empty reply -> Empty (mergeErrorReply err reply)\n"
"                                 consumed    -> consumed\n"
"          other             -> other\n"
"      )\n"
"\n"
"{- \n"
"-- variant that favors a consumed reply over an empty one, even it is not the first alternative.\n"
"          empty@(Empty reply) -> case reply of\n"
"                                   Error err ->\n"
"                                     case (p2 state) of\n"
"                                       Empty reply -> Empty (mergeErrorReply err reply)\n"
"                                       consumed    -> consumed\n"
"                                   ok ->\n"
"                                     case (p2 state) of\n"
"                                       Empty reply -> empty\n"
"                                       consumed    -> consumed\n"
"          consumed  -> consumed\n"
"-}\n"
"\n"
"-----------------------------------------------------------\n"
"-- Primitive Parsers: \n"
"--  try, token(Prim), label, unexpected and updateState\n"
"-----------------------------------------------------------\n"
"try :: GenParser tok st a -> GenParser tok st a\n"
"try (Parser p)\n"
"    = Parser (\\state@(State input pos user) ->     \n"
"        case (p state) of\n"
"          Consumed (Error err)  -> Empty (Error (setErrorPos pos err))\n"
"          Consumed ok           -> Consumed ok    -- was: Empty ok\n"
"          empty                 -> empty\n"
"      )\n"
"\n"
"     \n"
"token :: (tok -> String) -> (tok -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a    \n"
"token show tokpos test\n"
"  = tokenPrim show nextpos test\n"
"  where\n"
"    nextpos _ _   (tok:toks)  = tokpos tok\n"
"    nextpos _ tok []          = tokpos tok\n"
"\n"
"tokenPrim :: (tok -> String) -> (SourcePos -> tok -> [tok] -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a\n"
"tokenPrim show nextpos test\n"
"    = tokenPrimEx show nextpos Nothing test\n"
"\n"
"-- | The most primitive token recogniser. The expression @tokenPrimEx show nextpos mbnextstate test@,\n"
"-- recognises tokens when @test@ returns @Just x@ (and returns the value @x@). Tokens are shown in\n"
"-- error messages using @show@. The position is calculated using @nextpos@, and finally, @mbnextstate@,\n"
"-- can hold a function that updates the user state on every token recognised (nice to count tokens :-).\n"
"-- The function is packed into a 'Maybe' type for performance reasons.\n"
"tokenPrimEx :: (tok -> String) -> \n"
"               (SourcePos -> tok -> [tok] -> SourcePos) -> \n"
"               Maybe (SourcePos -> tok -> [tok] -> st -> st) ->\n"
"               (tok -> Maybe a) -> \n"
"               GenParser tok st a\n"
"tokenPrimEx show nextpos mbNextState test\n"
"    = case mbNextState of\n"
"        Nothing \n"
"          -> Parser (\\state@(State input pos user) -> \n"
"              case input of\n"
"                (c:cs) -> case test c of\n"
"                            Just x  -> let newpos   = nextpos pos c cs\n"
"                                           newstate = State cs newpos user\n"
"                                       in seq newpos $ seq newstate $ \n"
"                                          Consumed (Ok x newstate (newErrorUnknown newpos))\n"
"                            Nothing -> Empty (sysUnExpectError (show c) pos)\n"
"                []     -> Empty (sysUnExpectError \"\" pos)\n"
"             )\n"
"        Just nextState\n"
"          -> Parser (\\state@(State input pos user) -> \n"
"              case input of\n"
"                (c:cs) -> case test c of\n"
"                            Just x  -> let newpos   = nextpos pos c cs\n"
"                                           newuser  = nextState pos c cs user\n"
"                                           newstate = State cs newpos newuser\n"
"                                       in seq newpos $ seq newstate $ \n"
"                                          Consumed (Ok x newstate (newErrorUnknown newpos))\n"
"                            Nothing -> Empty (sysUnExpectError (show c) pos)\n"
"                []     -> Empty (sysUnExpectError \"\" pos)\n"
"             )\n"
"\n"
"label :: GenParser tok st a -> String -> GenParser tok st a    \n"
"label p msg\n"
"  = labels p [msg]\n"
"\n"
"labels :: GenParser tok st a -> [String] -> GenParser tok st a\n"
"labels (Parser p) msgs\n"
"    = Parser (\\state -> \n"
"        case (p state) of\n"
"          Empty reply -> Empty $ \n"
"                         case (reply) of\n"
"                           Error err        -> Error (setExpectErrors err msgs)\n"
"                           Ok x state1 err  | errorIsUnknown err -> reply\n"
"                                            | otherwise -> Ok x state1 (setExpectErrors err msgs)\n"
"          other       -> other\n"
"      )\n"
"\n"
"updateParserState :: (State tok st -> State tok st) -> GenParser tok st (State tok st)\n"
"updateParserState f \n"
"    = Parser (\\state -> let newstate = f state\n"
"                        in Empty (Ok state newstate (unknownError newstate)))\n"
"    \n"
"    \n"
"unexpected :: String -> GenParser tok st a\n"
"unexpected msg\n"
"    = Parser (\\state -> Empty (Error (newErrorMessage (UnExpect msg) (statePos state))))\n"
"    \n"
"\n"
"setExpectErrors err []         = setErrorMessage (Expect \"\") err\n"
"setExpectErrors err [msg]      = setErrorMessage (Expect msg) err\n"
"setExpectErrors err (msg:msgs) = foldr (\\msg err -> addErrorMessage (Expect msg) err) \n"
"                                       (setErrorMessage (Expect msg) err) msgs\n"
"\n"
"sysUnExpectError msg pos  = Error (newErrorMessage (SysUnExpect msg) pos)\n"
"unknownError state        = newErrorUnknown (statePos state)\n"
"\n"
"-----------------------------------------------------------\n"
"-- Parsers unfolded for space:\n"
"-- if many and skipMany are not defined as primitives,\n"
"-- they will overflow the stack on large inputs\n"
"-----------------------------------------------------------    \n"
"many :: GenParser tok st a -> GenParser tok st [a]\n"
"many p\n"
"  = do{ xs <- manyAccum (:) p\n"
"      ; return (reverse xs)\n"
"      }\n"
"\n"
"skipMany :: GenParser tok st a -> GenParser tok st ()\n"
"skipMany p\n"
"  = do{ manyAccum (\\x xs -> []) p\n"
"      ; return ()\n"
"      }\n"
"\n"
"manyAccum :: (a -> [a] -> [a]) -> GenParser tok st a -> GenParser tok st [a]\n"
"manyAccum accum (Parser p)\n"
"  = Parser (\\state -> \n"
"    let walk xs state r = case r of\n"
"                           Empty (Error err)          -> Ok xs state err\n"
"                           Empty ok                   -> error \"Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.\"\n"
"                           Consumed (Error err)       -> Error err\n"
"                           Consumed (Ok x state' err) -> let ys = accum x xs\n"
"                                                         in seq ys (walk ys state' (p state'))\n"
"    in case (p state) of\n"
"         Empty reply  -> case reply of\n"
"                           Ok x state' err -> error \"Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.\"\n"
"                           Error err       -> Empty (Ok [] state err)\n"
"         consumed     -> Consumed $ walk [] state consumed)\n"
"\n"
"-----------------------------------------------------------\n"
"-- Parsers unfolded for speed: \n"
"--  tokens\n"
"-----------------------------------------------------------    \n"
"\n"
"{- specification of @tokens@:\n"
"tokens showss nextposs s\n"
"  = scan s\n"
"  where\n"
"    scan []       = return s\n"
"    scan (c:cs)   = do{ token show nextpos c <?> shows s; scan cs }                      \n"
"\n"
"    show c        = shows [c]\n"
"    nextpos pos c = nextposs pos [c]\n"
"-}\n"
"\n"
"tokens :: Eq tok => ([tok] -> String) -> (SourcePos -> [tok] -> SourcePos) -> [tok] -> GenParser tok st [tok]\n"
"tokens shows nextposs s\n"
"    = Parser (\\state@(State input pos user) -> \n"
"       let\n"
"        ok cs             = let newpos   = nextposs pos s\n"
"                                newstate = State cs newpos user\n"
"                            in seq newpos $ seq newstate $ \n"
"                               (Ok s newstate (newErrorUnknown newpos))\n"
"                               \n"
"        errEof            = Error (setErrorMessage (Expect (shows s))\n"
"                                     (newErrorMessage (SysUnExpect \"\") pos))\n"
"        errExpect c       = Error (setErrorMessage (Expect (shows s))\n"
"                                     (newErrorMessage (SysUnExpect (shows [c])) pos))\n"
"\n"
"        walk [] cs        = ok cs\n"
"        walk xs []        = errEof\n"
"        walk (x:xs) (c:cs)| x == c        = walk xs cs\n"
"                          | otherwise     = errExpect c\n"
"\n"
"        walk1 [] cs        = Empty (ok cs)\n"
"        walk1 xs []        = Empty (errEof)\n"
"        walk1 (x:xs) (c:cs)| x == c        = Consumed (walk xs cs)\n"
"                           | otherwise     = Empty (errExpect c)\n"
"\n"
"       in walk1 s input)\n"
"\n";
const char *Text_ParserCombinators_Parsec_Combinator = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.ParserCombinators.Parsec.Combinator\n"
"-- Copyright   :  (c) Daan Leijen 1999-2001\n"
"-- License     :  BSD-style (see the file libraries/parsec/LICENSE)\n"
"-- \n"
"-- Maintainer  :  daan@cs.uu.nl\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Commonly used generic combinators\n"
"-- \n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.ParserCombinators.Parsec.Combinator\n"
"                        ( choice\n"
"                        , count\n"
"                        , between\n"
"                        , option, optional\n"
"                        , skipMany1\n"
"                        , many1\n"
"                        , sepBy, sepBy1\n"
"                        , endBy, endBy1\n"
"                        , sepEndBy, sepEndBy1\n"
"                        , chainl, chainl1\n"
"                        , chainr, chainr1\n"
"                        , eof, notFollowedBy\n"
"                        \n"
"                        -- tricky combinators\n"
"                        , manyTill, lookAhead, anyToken\n"
"                        ) where\n"
"\n"
"import Control.Monad\n"
"import Text.ParserCombinators.Parsec.Prim\n"
"\n"
"----------------------------------------------------------------\n"
"--\n"
"----------------------------------------------------------------\n"
"choice :: [GenParser tok st a] -> GenParser tok st a\n"
"choice ps           = foldr (<|>) mzero ps\n"
"\n"
"option :: a -> GenParser tok st a -> GenParser tok st a\n"
"option x p          = p <|> return x\n"
"\n"
"optional :: GenParser tok st a -> GenParser tok st ()\n"
"optional p          = do{ p; return ()} <|> return ()\n"
"\n"
"between :: GenParser tok st open -> GenParser tok st close \n"
"            -> GenParser tok st a -> GenParser tok st a\n"
"between open close p\n"
"                    = do{ open; x <- p; close; return x }\n"
"                \n"
"                \n"
"skipMany1 :: GenParser tok st a -> GenParser tok st ()\n"
"skipMany1 p         = do{ p; skipMany p }\n"
"{-\n"
"skipMany p          = scan\n"
"                    where\n"
"                      scan  = do{ p; scan } <|> return ()\n"
"-}\n"
"\n"
"many1 :: GenParser tok st a -> GenParser tok st [a]\n"
"many1 p             = do{ x <- p; xs <- many p; return (x:xs) }\n"
"{-\n"
"many p              = scan id\n"
"                    where\n"
"                      scan f    = do{ x <- p\n"
"                                    ; scan (\\tail -> f (x:tail))\n"
"                                    }\n"
"                                <|> return (f [])\n"
"-}\n"
"\n"
"sepBy1,sepBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]\n"
"sepBy p sep         = sepBy1 p sep <|> return []\n"
"sepBy1 p sep        = do{ x <- p\n"
"                        ; xs <- many (sep >> p)\n"
"                        ; return (x:xs)\n"
"                        }\n"
"\n"
"sepEndBy1, sepEndBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]\n"
"sepEndBy1 p sep     = do{ x <- p\n"
"                        ; do{ sep\n"
"                            ; xs <- sepEndBy p sep\n"
"                            ; return (x:xs)\n"
"                            }\n"
"                          <|> return [x]\n"
"                        }\n"
"        \n"
"sepEndBy p sep      = sepEndBy1 p sep <|> return []\n"
"\n"
"endBy1,endBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]\n"
"endBy1 p sep        = many1 (do{ x <- p; sep; return x })\n"
"endBy p sep         = many (do{ x <- p; sep; return x })\n"
"\n"
"count :: Int -> GenParser tok st a -> GenParser tok st [a]\n"
"count n p           | n <= 0    = return []\n"
"                    | otherwise = sequence (replicate n p)\n"
"\n"
"chainr,chainl :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a\n"
"chainr p op x       = chainr1 p op <|> return x\n"
"chainl p op x       = chainl1 p op <|> return x\n"
"\n"
"chainr1,chainl1 :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> GenParser tok st a\n"
"chainl1 p op        = do{ x <- p; rest x }\n"
"                    where\n"
"                      rest x    = do{ f <- op\n"
"                                    ; y <- p\n"
"                                    ; rest (f x y)\n"
"                                    }\n"
"                                <|> return x\n"
"                              \n"
"chainr1 p op        = scan\n"
"                    where\n"
"                      scan      = do{ x <- p; rest x }\n"
"                      \n"
"                      rest x    = do{ f <- op\n"
"                                    ; y <- scan\n"
"                                    ; return (f x y)\n"
"                                    }\n"
"                                <|> return x\n"
"\n"
"-----------------------------------------------------------\n"
"-- Tricky combinators\n"
"-----------------------------------------------------------\n"
"anyToken :: Show tok => GenParser tok st tok\n"
"anyToken            = tokenPrim show (\\pos tok toks -> pos) Just\n"
"\n"
"eof :: Show tok => GenParser tok st ()\n"
"eof                 = notFollowedBy anyToken <?> \"end of input\"   \n"
"\n"
"notFollowedBy :: Show tok => GenParser tok st tok -> GenParser tok st ()   \n"
"notFollowedBy p     = try (do{ c <- p; unexpected (show [c]) }\n"
"                           <|> return ()\n"
"                          )\n"
"\n"
"manyTill :: GenParser tok st a -> GenParser tok st end -> GenParser tok st [a]\n"
"manyTill p end      = scan\n"
"                    where\n"
"                      scan  = do{ end; return [] }\n"
"                            <|>\n"
"                              do{ x <- p; xs <- scan; return (x:xs) }\n"
"\n"
"lookAhead :: GenParser tok st a -> GenParser tok st a\n"
"lookAhead p         = do{ state <- getParserState\n"
"                        ; x <- p\n"
"                        ; setParserState state\n"
"                        ; return x\n"
"                        }\n";
const char *Text_ParserCombinators_Parsec_Perm = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Text.ParserCombinators.Parsec.Perm\n"
"-- Copyright   :  (c) Daan Leijen 1999-2001\n"
"-- License     :  BSD-style (see the file libraries/parsec/LICENSE)\n"
"-- \n"
"-- Maintainer  :  daan@cs.uu.nl\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (uses existentially quantified data constructors)\n"
"--\n"
"-- This module implements permutation parsers. The algorithm used\n"
"-- is fairly complex since we push the type system to its limits :-)\n"
"-- The algorithm is described in:\n"
"--\n"
"-- /Parsing Permutation Phrases,/\n"
"-- by Arthur Baars, Andres Loh and Doaitse Swierstra.\n"
"-- Published as a functional pearl at the Haskell Workshop 2001.\n"
"-- \n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Text.ParserCombinators.Parsec.Perm\n"
"                  ( PermParser  -- abstract\n"
"\n"
"                  , permute\n"
"                  , (<||>), (<$$>)\n"
"                  , (<|?>), (<$?>)\n"
"                  ) where\n"
"\n"
"import Text.ParserCombinators.Parsec\n"
"\n"
"{---------------------------------------------------------------\n"
"\n"
"---------------------------------------------------------------}\n"
"infixl 1 <||>, <|?>\n"
"infixl 2 <$$>, <$?>\n"
"\n"
"{---------------------------------------------------------------\n"
"  test -- parse a permutation of \n"
"  * an optional string of 'a's\n"
"  * a required 'b'\n"
"  * an optional 'c'\n"
"---------------------------------------------------------------}\n"
"test input\n"
"  = parse (do{ x <- ptest; eof; return x }) \"\" input\n"
"\n"
"ptest :: Parser (String,Char,Char)\n"
"ptest  \n"
"  = permute $\n"
"    (,,) <$?> (\"\",many1 (char 'a'))\n"
"         <||> char 'b' \n"
"         <|?> ('_',char 'c')\n"
"\n"
"{---------------------------------------------------------------\n"
"  Building a permutation parser\n"
"---------------------------------------------------------------}\n"
"(<||>) :: PermParser tok st (a -> b) -> GenParser tok st a -> PermParser tok st b\n"
"(<||>) perm p     = add perm p                  \n"
"\n"
"(<$$>) :: (a -> b) -> GenParser tok st a -> PermParser tok st b\n"
"(<$$>) f p        = newperm f <||> p\n"
"\n"
"(<|?>) :: PermParser tok st (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b\n"
"(<|?>) perm (x,p) = addopt perm x p\n"
"\n"
"(<$?>) :: (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b\n"
"(<$?>) f (x,p)    = newperm f <|?> (x,p)\n"
"\n"
"{---------------------------------------------------------------\n"
"  The permutation tree\n"
"---------------------------------------------------------------}\n"
"data PermParser tok st a = Perm (Maybe a) [Branch tok st a]\n"
"data Branch tok st a     = forall b. Branch (PermParser tok st (b -> a)) (GenParser tok st b)\n"
"\n"
"-- transform a permutation tree into a normal parser\n"
"permute :: PermParser tok st a -> GenParser tok st a\n"
"permute (Perm def xs)\n"
"  = choice (map branch xs ++ empty)\n"
"  where\n"
"    empty\n"
"      = case def of\n"
"          Nothing -> []\n"
"          Just x  -> [return x]\n"
"\n"
"    branch (Branch perm p)\n"
"      = do{ x <- p\n"
"          ; f <- permute perm\n"
"          ; return (f x)\n"
"          }\n"
"\n"
"-- build permutation trees\n"
"newperm :: (a -> b) -> PermParser tok st (a -> b)\n"
"newperm f\n"
"  = Perm (Just f) []\n"
"\n"
"add :: PermParser tok st (a -> b) -> GenParser tok st a -> PermParser tok st b\n"
"add perm@(Perm mf fs) p\n"
"  = Perm Nothing (first:map insert fs)\n"
"  where\n"
"    first   = Branch perm p\n"
"    insert (Branch perm' p')\n"
"            = Branch (add (mapPerms flip perm') p) p'\n"
"\n"
"addopt :: PermParser tok st (a -> b) -> a -> GenParser tok st a -> PermParser tok st b\n"
"addopt perm@(Perm mf fs) x p\n"
"  = Perm (fmap ($ x) mf) (first:map insert fs)\n"
"  where\n"
"    first   = Branch perm p\n"
"    insert (Branch perm' p')\n"
"            = Branch (addopt (mapPerms flip perm') x p) p'\n"
"\n"
"mapPerms :: (a -> b) -> PermParser tok st a -> PermParser tok st b\n"
"mapPerms f (Perm x xs)\n"
"  = Perm (fmap f x) (map (mapBranch f) xs)\n"
"  where\n"
"    mapBranch f (Branch perm p)\n"
"      = Branch (mapPerms (f.) perm) p\n";
const char *Data_Monoid = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Monoid\n"
"-- Copyright   :  (c) Andy Gill 2001,\n"
"--		  (c) Oregon Graduate Institute of Science and Technology, 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (requires extended type classes)\n"
"--\n"
"-- Declaration of the Monoid class, and instances for list and functions.\n"
"--\n"
"--	  Inspired by the paper\n"
"--	  /Functional Programming with Overloading and\n"
"--	      Higher-Order Polymorphism/, \n"
"--	    Mark P Jones (<http://www.cse.ogi.edu/~mpj/>)\n"
"--		  Advanced School of Functional Programming, 1995.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Monoid (\n"
" 	Monoid(..)\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- | The monoid class.\n"
"-- A minimal complete definition must supply 'mempty' and 'mappend',\n"
"-- and these should satisfy the monoid laws.\n"
"\n"
"class Monoid a where\n"
"	mempty  :: a\n"
"	-- ^ Identity of 'mappend'\n"
"	mappend :: a -> a -> a\n"
"	-- ^ An associative operation\n"
"	mconcat :: [a] -> a\n"
"\n"
"	-- ^ Fold a list using the monoid.\n"
"	-- For most types, the default definition for 'mconcat' will be\n"
"	-- used, but the function is included in the class definition so\n"
"	-- that an optimized version can be provided for specific types.\n"
"\n"
"	mconcat = foldr mappend mempty\n"
"\n"
"-- Monoid instances.\n"
"\n"
"instance Monoid [a] where\n"
"	mempty  = []\n"
"	mappend = (++)\n"
"\n"
"instance Monoid (a -> a) where\n"
"	mempty  = id\n"
"	mappend = (.)\n"
"\n"
"instance Monoid () where\n"
"	-- Should it be strict?\n"
"	mempty        = ()\n"
"	_ `mappend` _ = ()\n"
"	mconcat _     = ()\n";
const char *Data_Ratio = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Ratio\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Standard functions on rational numbers\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Ratio\n"
"    ( Ratio\n"
"    , Rational\n"
"    , (%)		-- :: (Integral a) => a -> a -> Ratio a\n"
"    , numerator		-- :: (Integral a) => Ratio a -> a\n"
"    , denominator	-- :: (Integral a) => Ratio a -> a\n"
"    , approxRational	-- :: (RealFrac a) => a -> a -> Rational\n"
"\n"
"    -- Ratio instances: \n"
"    --   (Integral a) => Eq   (Ratio a)\n"
"    --   (Integral a) => Ord  (Ratio a)\n"
"    --   (Integral a) => Num  (Ratio a)\n"
"    --   (Integral a) => Real (Ratio a)\n"
"    --   (Integral a) => Fractional (Ratio a)\n"
"    --   (Integral a) => RealFrac (Ratio a)\n"
"    --   (Integral a) => Enum	  (Ratio a)\n"
"    --   (Read a, Integral a) => Read (Ratio a)\n"
"    --   (Integral a) => Show	  (Ratio a)\n"
"\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Hugs.Prelude(Ratio(..), (%), numerator, denominator)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- approxRational\n"
"\n"
"-- @approxRational@, applied to two real fractional numbers x and epsilon,\n"
"-- returns the simplest rational number within epsilon of x.  A rational\n"
"-- number n%d in reduced form is said to be simpler than another n'%d' if\n"
"-- abs n <= abs n' && d <= d'.  Any real interval contains a unique\n"
"-- simplest rational; here, for simplicity, we assume a closed rational\n"
"-- interval.  If such an interval includes at least one whole number, then\n"
"-- the simplest rational is the absolutely least whole number.  Otherwise,\n"
"-- the bounds are of the form q%1 + r%d and q%1 + r'%d', where abs r < d\n"
"-- and abs r' < d', and the simplest rational is q%1 + the reciprocal of\n"
"-- the simplest rational between d'%r' and d%r.\n"
"\n"
"approxRational		:: (RealFrac a) => a -> a -> Rational\n"
"approxRational rat eps	=  simplest (rat-eps) (rat+eps)\n"
"	where simplest x y | y < x	=  simplest y x\n"
"			   | x == y	=  xr\n"
"			   | x > 0	=  simplest' n d n' d'\n"
"			   | y < 0	=  - simplest' (-n') d' (-n) d\n"
"			   | otherwise	=  0 :% 1\n"
"					where xr  = toRational x\n"
"					      n   = numerator xr\n"
"					      d   = denominator xr\n"
"					      nd' = toRational y\n"
"					      n'  = numerator nd'\n"
"					      d'  = denominator nd'\n"
"\n"
"	      simplest' n d n' d'	-- assumes 0 < n%d < n'%d'\n"
"			| r == 0     =	q :% 1\n"
"			| q /= q'    =	(q+1) :% 1\n"
"			| otherwise  =	(q*n''+d'') :% n''\n"
"				     where (q,r)      =	 quotRem n d\n"
"					   (q',r')    =	 quotRem n' d'\n"
"					   nd''       =  simplest' d' r' d r\n"
"					   n''        =  numerator nd''\n"
"					   d''        =	 denominator nd''\n";
const char *Data_Maybe = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Maybe\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- The Maybe type, and associated operations.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Maybe\n"
"   (\n"
"     Maybe(Nothing,Just)-- instance of: Eq, Ord, Show, Read,\n"
"			--		Functor, Monad, MonadPlus\n"
"\n"
"   , maybe		-- :: b -> (a -> b) -> Maybe a -> b\n"
"\n"
"   , isJust		-- :: Maybe a -> Bool\n"
"   , isNothing		-- :: Maybe a -> Bool\n"
"   , fromJust		-- :: Maybe a -> a\n"
"   , fromMaybe		-- :: a -> Maybe a -> a\n"
"   , listToMaybe        -- :: [a] -> Maybe a\n"
"   , maybeToList	-- :: Maybe a -> [a]\n"
"   , catMaybes		-- :: [Maybe a] -> [a]\n"
"   , mapMaybe		-- :: (a -> Maybe b) -> [a] -> [b]\n"
"   ) where\n"
"\n"
"-- | The 'isJust' function returns 'True' iff its argument is of the\n"
"-- form @Just _@.\n"
"isJust         :: Maybe a -> Bool\n"
"isJust Nothing = False\n"
"isJust _       = True\n"
"\n"
"-- | The 'isNothing' function returns 'True' iff its argument is 'Nothing'.\n"
"isNothing         :: Maybe a -> Bool\n"
"isNothing Nothing = True\n"
"isNothing _       = False\n"
"\n"
"-- | The 'fromJust' function extracts the element out of a 'Just' and\n"
"-- throws an error if its argument is 'Nothing'.\n"
"fromJust          :: Maybe a -> a\n"
"fromJust Nothing  = error \"Maybe.fromJust: Nothing\" -- yuck\n"
"fromJust (Just x) = x\n"
"\n"
"-- | The 'fromMaybe' function takes a default value and and 'Maybe'\n"
"-- value.  If the 'Maybe' is 'Nothing', it returns the default values;\n"
"-- otherwise, it returns the value contained in the 'Maybe'.\n"
"fromMaybe     :: a -> Maybe a -> a\n"
"fromMaybe d x = case x of {Nothing -> d;Just v  -> v}\n"
"\n"
"-- | The 'maybeToList' function returns an empty list when given\n"
"-- 'Nothing' or a singleton list when not given 'Nothing'.\n"
"maybeToList            :: Maybe a -> [a]\n"
"maybeToList  Nothing   = []\n"
"maybeToList  (Just x)  = [x]\n"
"\n"
"-- | The 'listToMaybe' function returns 'Nothing' on an empty list\n"
"-- or @'Just' a@ where @a@ is the first element of the list.\n"
"listToMaybe           :: [a] -> Maybe a\n"
"listToMaybe []        =  Nothing\n"
"listToMaybe (a:_)     =  Just a\n"
"\n"
"-- | The 'catMaybes' function takes a list of 'Maybe's and returns\n"
"-- a list of all the 'Just' values. \n"
"catMaybes              :: [Maybe a] -> [a]\n"
"catMaybes ls = [x | Just x <- ls]\n"
"\n"
"-- | The 'mapMaybe' function is a version of 'map' which can throw\n"
"-- out elements.  In particular, the functional argument returns\n"
"-- something of type @'Maybe' b@.  If this is 'Nothing', no element\n"
"-- is added on to the result list.  If it just @'Just' a@, then @a@ is\n"
"-- added on to the result.\n"
"mapMaybe          :: (a -> Maybe b) -> [a] -> [b]\n"
"mapMaybe _ []     = []\n"
"mapMaybe f (x:xs) =\n"
" let rs = mapMaybe f xs in\n"
" case f x of\n"
"  Nothing -> rs\n"
"  Just r  -> r:rs\n"
"\n";
const char *Data_Graph = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Graph\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (requires non-portable module ST)\n"
"--\n"
"-- A version of the graph algorithms described in:\n"
"--\n"
"--   /Lazy Depth-First Search and Linear Graph Algorithms in Haskell/,\n"
"--   by David King and John Launchbury.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Graph(\n"
"\n"
"	-- * External interface\n"
"\n"
"	-- At present the only one with a \"nice\" external interface\n"
"	stronglyConnComp, stronglyConnCompR, SCC(..), flattenSCC, flattenSCCs,\n"
"\n"
"	-- * Graphs\n"
"\n"
"	Graph, Table, Bounds, Edge, Vertex,\n"
"\n"
"	-- ** Building graphs\n"
"\n"
"	graphFromEdges, buildG, transposeG,\n"
"	-- reverseE,\n"
"\n"
"	-- ** Graph properties\n"
"\n"
"	vertices, edges,\n"
"	outdegree, indegree,\n"
"\n"
"	-- * Algorithms\n"
"\n"
"	dfs, dff,\n"
"	topSort,\n"
"	components,\n"
"	scc,\n"
"	bcc,\n"
"	-- tree, back, cross, forward,\n"
"	reachable, path,\n"
"\n"
"	module Data.Tree\n"
"\n"
"    ) where\n"
"\n"
"-- Extensions\n"
"import Control.Monad.ST\n"
"import Data.Array.ST (STArray, newArray, readArray, writeArray)\n"
"import Data.Tree (Tree(Node), Forest)\n"
"\n"
"-- std interfaces\n"
"import Data.Maybe\n"
"import Data.Array\n"
"import Data.List\n"
"\n"
"-------------------------------------------------------------------------\n"
"--									-\n"
"--	External interface\n"
"--									-\n"
"-------------------------------------------------------------------------\n"
"\n"
"-- | Strongly connected component.\n"
"data SCC vertex = AcyclicSCC vertex	-- ^ A single vertex that is not\n"
"					-- in any cycle.\n"
"	        | CyclicSCC  [vertex]	-- ^ A maximal set of mutually\n"
"					-- reachable vertices.\n"
"\n"
"-- | The vertices of a list of strongly connected components.\n"
"flattenSCCs :: [SCC a] -> [a]\n"
"flattenSCCs = concatMap flattenSCC\n"
"\n"
"-- | The vertices of a strongly connected component.\n"
"flattenSCC :: SCC vertex -> [vertex]\n"
"flattenSCC (AcyclicSCC v) = [v]\n"
"flattenSCC (CyclicSCC vs) = vs\n"
"\n"
"-- | The strongly connected components of a directed graph, topologically\n"
"-- sorted.\n"
"stronglyConnComp\n"
"	:: Ord key\n"
"	=> [(node, key, [key])]\n"
"		-- ^ The graph: a list of nodes uniquely identified by keys,\n"
"		-- with a list of keys of nodes this node has edges to.\n"
"		-- The out-list may contain keys that don't correspond to\n"
"		-- nodes of the graph; such edges are ignored.\n"
"	-> [SCC node]\n"
"\n"
"stronglyConnComp edges0\n"
"  = map get_node (stronglyConnCompR edges0)\n"
"  where\n"
"    get_node (AcyclicSCC (n, _, _)) = AcyclicSCC n\n"
"    get_node (CyclicSCC triples)     = CyclicSCC [n | (n,_,_) <- triples]\n"
"\n"
"-- | The strongly connected components of a directed graph, topologically\n"
"-- sorted.  The function is the same as 'stronglyConnComp', except that\n"
"-- all the information about each node retained.\n"
"-- This interface is used when you expect to apply 'SCC' to\n"
"-- (some of) the result of 'SCC', so you don't want to lose the\n"
"-- dependency information.\n"
"stronglyConnCompR\n"
"	:: Ord key\n"
"	=> [(node, key, [key])]\n"
"		-- ^ The graph: a list of nodes uniquely identified by keys,\n"
"		-- with a list of keys of nodes this node has edges to.\n"
"		-- The out-list may contain keys that don't correspond to\n"
"		-- nodes of the graph; such edges are ignored.\n"
"	-> [SCC (node, key, [key])]	-- ^ Topologically sorted\n"
"\n"
"stronglyConnCompR [] = []  -- added to avoid creating empty array in graphFromEdges -- SOF\n"
"stronglyConnCompR edges0\n"
"  = map decode forest\n"
"  where\n"
"    (graph, vertex_fn) = graphFromEdges edges0\n"
"    forest	       = scc graph\n"
"    decode (Node v []) | mentions_itself v = CyclicSCC [vertex_fn v]\n"
"		       | otherwise	   = AcyclicSCC (vertex_fn v)\n"
"    decode other = CyclicSCC (dec other [])\n"
"		 where\n"
"		   dec (Node v ts) vs = vertex_fn v : foldr dec vs ts\n"
"    mentions_itself v = v `elem` (graph ! v)\n"
"\n"
"-------------------------------------------------------------------------\n"
"--									-\n"
"--	Graphs\n"
"--									-\n"
"-------------------------------------------------------------------------\n"
"\n"
"-- | Abstract representation of vertices.\n"
"type Vertex  = Int\n"
"-- | Table indexed by a contiguous set of vertices.\n"
"type Table a = Array Vertex a\n"
"-- | Adjacency list representation of a graph, mapping each vertex to its\n"
"-- list of successors.\n"
"type Graph   = Table [Vertex]\n"
"-- | The bounds of a 'Table'.\n"
"type Bounds  = (Vertex, Vertex)\n"
"-- | An edge from the first vertex to the second.\n"
"type Edge    = (Vertex, Vertex)\n"
"\n"
"-- | All vertices of a graph.\n"
"vertices :: Graph -> [Vertex]\n"
"vertices  = indices\n"
"\n"
"-- | All edges of a graph.\n"
"edges    :: Graph -> [Edge]\n"
"edges g   = [ (v, w) | v <- vertices g, w <- g!v ]\n"
"\n"
"mapT    :: (Vertex -> a -> b) -> Table a -> Table b\n"
"mapT f t = array (bounds t) [ (,) v (f v (t!v)) | v <- indices t ]\n"
"\n"
"-- | Build a graph from a list of edges.\n"
"buildG :: Bounds -> [Edge] -> Graph\n"
"buildG bounds0 edges0 = accumArray (flip (:)) [] bounds0 edges0\n"
"\n"
"-- | The graph obtained by reversing all edges.\n"
"transposeG  :: Graph -> Graph\n"
"transposeG g = buildG (bounds g) (reverseE g)\n"
"\n"
"reverseE    :: Graph -> [Edge]\n"
"reverseE g   = [ (w, v) | (v, w) <- edges g ]\n"
"\n"
"-- | A table of the count of edges from each node.\n"
"outdegree :: Graph -> Table Int\n"
"outdegree  = mapT numEdges\n"
"             where numEdges _ ws = length ws\n"
"\n"
"-- | A table of the count of edges into each node.\n"
"indegree :: Graph -> Table Int\n"
"indegree  = outdegree . transposeG\n"
"\n"
"-- | Build a graph from a list of nodes uniquely identified by keys,\n"
"-- with a list of keys of nodes this node should have edges to.\n"
"-- The out-list may contain keys that don't correspond to\n"
"-- nodes of the graph; they are ignored.\n"
"graphFromEdges\n"
"	:: Ord key\n"
"	=> [(node, key, [key])]\n"
"	-> (Graph, Vertex -> (node, key, [key]))\n"
"graphFromEdges edges0\n"
"  = (graph, \\v -> vertex_map ! v)\n"
"  where\n"
"    max_v      	    = length edges0 - 1\n"
"    bounds0         = (0,max_v) :: (Vertex, Vertex)\n"
"    sorted_edges    = sortBy lt edges0\n"
"    edges1	    = zipWith (,) [0..] sorted_edges\n"
"\n"
"    graph	    = array bounds0 [(,) v (mapMaybe key_vertex ks) | (,) v (_,    _, ks) <- edges1]\n"
"    key_map	    = array bounds0 [(,) v k			   | (,) v (_,    k, _ ) <- edges1]\n"
"    vertex_map	    = array bounds0 edges1\n"
"\n"
"    (_,k1,_) `lt` (_,k2,_) = k1 `compare` k2\n"
"\n"
"    -- key_vertex :: key -> Maybe Vertex\n"
"    -- 	returns Nothing for non-interesting vertices\n"
"    key_vertex k   = findVertex 0 max_v\n"
"		   where\n"
"		     findVertex a b | a > b\n"
"			      = Nothing\n"
"		     findVertex a b = case compare k (key_map ! mid) of\n"
"				   LT -> findVertex a (mid-1)\n"
"				   EQ -> Just mid\n"
"				   GT -> findVertex (mid+1) b\n"
"			      where\n"
"			 	mid = (a + b) `div` 2\n"
"\n"
"-------------------------------------------------------------------------\n"
"--									-\n"
"--	Depth first search\n"
"--									-\n"
"-------------------------------------------------------------------------\n"
"\n"
"type Set s    = STArray s Vertex Bool\n"
"\n"
"mkEmpty      :: Bounds -> ST s (Set s)\n"
"mkEmpty bnds  = newArray bnds False\n"
"\n"
"contains     :: Set s -> Vertex -> ST s Bool\n"
"contains m v  = readArray m v\n"
"\n"
"include      :: Set s -> Vertex -> ST s ()\n"
"include m v   = writeArray m v True\n"
"\n"
"-- | A spanning forest of the graph, obtained from a depth-first search of\n"
"-- the graph starting from each vertex in an unspecified order.\n"
"dff          :: Graph -> Forest Vertex\n"
"dff g         = dfs g (vertices g)\n"
"\n"
"-- | A spanning forest of the part of the graph reachable from the listed\n"
"-- vertices, obtained from a depth-first search of the graph starting at\n"
"-- each of the listed vertices in order.\n"
"dfs          :: Graph -> [Vertex] -> Forest Vertex\n"
"dfs g vs      = prune (bounds g) (map (generate g) vs)\n"
"\n"
"generate     :: Graph -> Vertex -> Tree Vertex\n"
"generate g v  = Node v (map (generate g) (g!v))\n"
"\n"
"prune        :: Bounds -> Forest Vertex -> Forest Vertex\n"
"prune bnds ts = runST (mkEmpty bnds  >>= \\m ->\n"
"                       chop m ts)\n"
"\n"
"chop         :: Set s -> Forest Vertex -> ST s (Forest Vertex)\n"
"chop _ []     = return []\n"
"chop m (Node v ts : us)\n"
"              = contains m v >>= \\visited ->\n"
"                if visited then\n"
"                  chop m us\n"
"                else\n"
"                  include m v >>= \\_  ->\n"
"                  chop m ts   >>= \\as ->\n"
"                  chop m us   >>= \\bs ->\n"
"                  return (Node v as : bs)\n"
"\n"
"-------------------------------------------------------------------------\n"
"--									-\n"
"--	Algorithms\n"
"--									-\n"
"-------------------------------------------------------------------------\n"
"\n"
"------------------------------------------------------------\n"
"-- Algorithm 1: depth first search numbering\n"
"------------------------------------------------------------\n"
"\n"
"preorder            :: Tree a -> [a]\n"
"preorder (Node a ts) = a : preorderF ts\n"
"\n"
"preorderF           :: Forest a -> [a]\n"
"preorderF ts         = concat (map preorder ts)\n"
"\n"
"tabulate        :: Bounds -> [Vertex] -> Table Int\n"
"tabulate bnds vs = array bnds (zipWith (,) vs [1..])\n"
"\n"
"preArr          :: Bounds -> Forest Vertex -> Table Int\n"
"preArr bnds      = tabulate bnds . preorderF\n"
"\n"
"------------------------------------------------------------\n"
"-- Algorithm 2: topological sorting\n"
"------------------------------------------------------------\n"
"\n"
"postorder :: Tree a -> [a]\n"
"postorder (Node a ts) = postorderF ts ++ [a]\n"
"\n"
"postorderF   :: Forest a -> [a]\n"
"postorderF ts = concat (map postorder ts)\n"
"\n"
"postOrd      :: Graph -> [Vertex]\n"
"postOrd       = postorderF . dff\n"
"\n"
"-- | A topological sort of the graph.\n"
"-- The order is partially specified by the condition that a vertex /i/\n"
"-- precedes /j/ whenever /j/ is reachable from /i/ but not vice versa.\n"
"topSort      :: Graph -> [Vertex]\n"
"topSort       = reverse . postOrd\n"
"\n"
"------------------------------------------------------------\n"
"-- Algorithm 3: connected components\n"
"------------------------------------------------------------\n"
"\n"
"-- | The connected components of a graph.\n"
"-- Two vertices are connected if there is a path between them, traversing\n"
"-- edges in either direction.\n"
"components   :: Graph -> Forest Vertex\n"
"components    = dff . undirected\n"
"\n"
"undirected   :: Graph -> Graph\n"
"undirected g  = buildG (bounds g) (edges g ++ reverseE g)\n"
"\n"
"-- Algorithm 4: strongly connected components\n"
"\n"
"-- | The strongly connected components of a graph.\n"
"scc  :: Graph -> Forest Vertex\n"
"scc g = dfs g (reverse (postOrd (transposeG g)))\n"
"\n"
"------------------------------------------------------------\n"
"-- Algorithm 5: Classifying edges\n"
"------------------------------------------------------------\n"
"\n"
"tree              :: Bounds -> Forest Vertex -> Graph\n"
"tree bnds ts       = buildG bnds (concat (map flat ts))\n"
" where flat (Node v ts) = [ (v, w) | Node w _us <- ts ] ++ concat (map flat ts)\n"
"\n"
"back              :: Graph -> Table Int -> Graph\n"
"back g post        = mapT select g\n"
" where select v ws = [ w | w <- ws, post!v < post!w ]\n"
"\n"
"cross             :: Graph -> Table Int -> Table Int -> Graph\n"
"cross g pre post   = mapT select g\n"
" where select v ws = [ w | w <- ws, post!v > post!w, pre!v > pre!w ]\n"
"\n"
"forward           :: Graph -> Graph -> Table Int -> Graph\n"
"forward g tree pre = mapT select g\n"
" where select v ws = [ w | w <- ws, pre!v < pre!w ] \\\\ tree!v\n"
"\n"
"------------------------------------------------------------\n"
"-- Algorithm 6: Finding reachable vertices\n"
"------------------------------------------------------------\n"
"\n"
"-- | A list of vertices reachable from a given vertex.\n"
"reachable    :: Graph -> Vertex -> [Vertex]\n"
"reachable g v = preorderF (dfs g [v])\n"
"\n"
"-- | Is the second vertex reachable from the first?\n"
"path         :: Graph -> Vertex -> Vertex -> Bool\n"
"path g v w    = w `elem` (reachable g v)\n"
"\n"
"------------------------------------------------------------\n"
"-- Algorithm 7: Biconnected components\n"
"------------------------------------------------------------\n"
"\n"
"-- | The biconnected components of a graph.\n"
"-- An undirected graph is biconnected if the deletion of any vertex\n"
"-- leaves it connected.\n"
"bcc :: Graph -> Forest [Vertex]\n"
"bcc g = (concat . map bicomps . map (do_label g dnum)) forest\n"
" where forest = dff g\n"
"       dnum   = preArr (bounds g) forest\n"
"\n"
"do_label :: Graph -> Table Int -> Tree Vertex -> Tree (Vertex,Int,Int)\n"
"do_label g dnum (Node v ts) = Node (v,dnum!v,lv) us\n"
" where us = map (do_label g dnum) ts\n"
"       lv = minimum ([dnum!v] ++ [dnum!w | w <- g!v]\n"
"                     ++ [lu | Node (u,du,lu) xs <- us])\n"
"\n"
"bicomps :: Tree (Vertex,Int,Int) -> Forest [Vertex]\n"
"bicomps (Node (v,_,_) ts)\n"
"      = [ Node (v:vs) us | (l,Node vs us) <- map collect ts]\n"
"\n"
"collect :: Tree (Vertex,Int,Int) -> (Int, Tree [Vertex])\n"
"collect (Node (v,dv,lv) ts) = (lv, Node (v:vs) cs)\n"
" where collected = map collect ts\n"
"       vs = concat [ ws | (lw, Node ws us) <- collected, lw<dv]\n"
"       cs = concat [ if lw<dv then us else [Node (v:ws) us]\n"
"                        | (lw, Node ws us) <- collected ]\n";
const char *Data_PackedString = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.PackedString\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- An efficient implementation of strings.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- Original GHC implementation by Bryan O\\'Sullivan, \n"
"-- rewritten to use UArray by Simon Marlow.\n"
"\n"
"module Data.PackedString (\n"
"	-- * The @PackedString@ type\n"
"        PackedString,      -- abstract, instances: Eq, Ord, Show, Typeable\n"
"\n"
"         -- * Converting to and from @PackedString@s\n"
"	packString,  -- :: String -> PackedString\n"
"	unpackPS,    -- :: PackedString -> String\n"
"\n"
"	-- * I\\/O with @PackedString@s	\n"
"	hPutPS,      -- :: Handle -> PackedString -> IO ()\n"
"	hGetPS,      -- :: Handle -> Int -> IO PackedString\n"
"\n"
"	-- * List-like manipulation functions\n"
"	nilPS,       -- :: PackedString\n"
"	consPS,      -- :: Char -> PackedString -> PackedString\n"
"	headPS,      -- :: PackedString -> Char\n"
"	tailPS,      -- :: PackedString -> PackedString\n"
"	nullPS,      -- :: PackedString -> Bool\n"
"	appendPS,    -- :: PackedString -> PackedString -> PackedString\n"
"	lengthPS,    -- :: PackedString -> Int\n"
"	indexPS,     -- :: PackedString -> Int -> Char\n"
"	mapPS,       -- :: (Char -> Char) -> PackedString -> PackedString\n"
"	filterPS,    -- :: (Char -> Bool) -> PackedString -> PackedString\n"
"	reversePS,   -- :: PackedString -> PackedString\n"
"	concatPS,    -- :: [PackedString] -> PackedString\n"
"	elemPS,      -- :: Char -> PackedString -> Bool\n"
"	substrPS,    -- :: PackedString -> Int -> Int -> PackedString\n"
"	takePS,      -- :: Int -> PackedString -> PackedString\n"
"	dropPS,      -- :: Int -> PackedString -> PackedString\n"
"	splitAtPS,   -- :: Int -> PackedString -> (PackedString, PackedString)\n"
"\n"
"	foldlPS,     -- :: (a -> Char -> a) -> a -> PackedString -> a\n"
"	foldrPS,     -- :: (Char -> a -> a) -> a -> PackedString -> a\n"
"	takeWhilePS, -- :: (Char -> Bool) -> PackedString -> PackedString\n"
"	dropWhilePS, -- :: (Char -> Bool) -> PackedString -> PackedString\n"
"	spanPS,      -- :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)\n"
"	breakPS,     -- :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)\n"
"	linesPS,     -- :: PackedString -> [PackedString]\n"
"	unlinesPS,   -- :: [PackedString] -> PackedString\n"
"	wordsPS,     -- :: PackedString -> [PackedString]\n"
"	unwordsPS,   -- :: [PackedString] -> PackedString\n"
"	splitPS,     -- :: Char -> PackedString -> [PackedString]\n"
"	splitWithPS, -- :: (Char -> Bool) -> PackedString -> [PackedString]\n"
"\n"
"	joinPS,      -- :: PackedString -> [PackedString] -> PackedString\n"
"\n"
"    ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Array.Unboxed\n"
"import Data.Array.IO\n"
"import Data.Typeable\n"
"import Data.Char\n"
"\n"
"import System.IO\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- PackedString type declaration\n"
"\n"
"-- | A space-efficient representation of a 'String', which supports various\n"
"-- efficient operations.  A 'PackedString' contains full Unicode 'Char's.\n"
"newtype PackedString = PS (UArray Int Char)\n"
"\n"
"instance Eq PackedString where\n"
"   (PS x) == (PS y)  =  x == y\n"
"\n"
"instance Ord PackedString where\n"
"    compare (PS x) (PS y) = compare x y\n"
"\n"
"--instance Read PackedString: ToDo\n"
"\n"
"instance Show PackedString where\n"
"    showsPrec p ps r = showsPrec p (unpackPS ps) r\n"
"\n"
"packedStringTc = mkTyCon \"PackedString\"; instance Typeable PackedString where { typeOf _ = mkAppTy packedStringTc [] }\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Constructor functions\n"
"\n"
"-- | The 'nilPS' value is the empty string.\n"
"nilPS :: PackedString\n"
"nilPS = PS (array (0,-1) [])\n"
"\n"
"-- | The 'consPS' function prepends the given character to the\n"
"-- given string.\n"
"consPS :: Char -> PackedString -> PackedString\n"
"consPS c cs = packString (c : (unpackPS cs)) -- ToDo:better\n"
"\n"
"-- | Convert a 'String' into a 'PackedString'\n"
"packString :: String -> PackedString\n"
"packString str = packNChars (length str) str\n"
"\n"
"-- | The 'packNChars' function creates a 'PackedString' out of the\n"
"-- first @len@ elements of the given 'String'.\n"
"packNChars :: Int -> [Char] -> PackedString\n"
"packNChars len str = PS (array (0,len-1) (zip [0..] str))\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Destructor functions (taking PackedStrings apart)\n"
"\n"
"-- | Convert a 'PackedString' into a 'String'\n"
"unpackPS :: PackedString -> String\n"
"unpackPS (PS ps) = elems ps\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- List-mimicking functions for PackedStrings\n"
"\n"
"-- | The 'lengthPS' function returns the length of the input list.  Analogous to 'length'.\n"
"lengthPS :: PackedString -> Int\n"
"lengthPS (PS ps) = rangeSize (bounds ps)\n"
"\n"
"-- | The 'indexPS' function returns the character in the string at the given position.\n"
"indexPS :: PackedString -> Int -> Char\n"
"indexPS (PS ps) i = ps ! i\n"
"\n"
"-- | The 'headPS' function returns the first element of a 'PackedString' or throws an\n"
"-- error if the string is empty.\n"
"headPS :: PackedString -> Char\n"
"headPS ps\n"
"  | nullPS ps = error \"Data.PackedString.headPS: head []\"\n"
"  | otherwise  = indexPS ps 0\n"
"\n"
"-- | The 'tailPS' function returns the tail of a 'PackedString' or throws an error\n"
"-- if the string is empty.\n"
"tailPS :: PackedString -> PackedString\n"
"tailPS ps\n"
"  | len <= 0 = error \"Data.PackedString.tailPS: tail []\"\n"
"  | len == 1 = nilPS\n"
"  | otherwise  = substrPS ps 1 (len - 1)\n"
"  where\n"
"    len = lengthPS ps\n"
"\n"
"-- | The 'nullPS' function returns True iff the argument is null.\n"
"nullPS :: PackedString -> Bool\n"
"nullPS (PS ps) = rangeSize (bounds ps) == 0\n"
"\n"
"-- | The 'appendPS' function appends the second string onto the first.\n"
"appendPS :: PackedString -> PackedString -> PackedString\n"
"appendPS xs ys\n"
"  | nullPS xs = ys\n"
"  | nullPS ys = xs\n"
"  | otherwise  = concatPS [xs,ys]\n"
"\n"
"-- | The 'mapPS' function applies a function to each character in the string.\n"
"mapPS :: (Char -> Char) -> PackedString -> PackedString\n"
"mapPS f (PS ps) = PS (amap f ps)\n"
"\n"
"-- | The 'filterPS' function filters out the appropriate substring.\n"
"filterPS :: (Char -> Bool) -> PackedString -> PackedString {-or String?-}\n"
"filterPS pred ps = packString (filter pred (unpackPS ps))\n"
"\n"
"-- | The 'foldlPS' function behaves like 'foldl' on 'PackedString's.\n"
"foldlPS :: (a -> Char -> a) -> a -> PackedString -> a\n"
"foldlPS f b ps = foldl f b (unpackPS ps)\n"
"\n"
"-- | The 'foldrPS' function behaves like 'foldr' on 'PackedString's.\n"
"foldrPS :: (Char -> a -> a) -> a -> PackedString -> a\n"
"foldrPS f v ps = foldr f v (unpackPS ps)\n"
"\n"
"-- | The 'takePS' function takes the first @n@ characters of a 'PackedString'.\n"
"takePS :: Int -> PackedString -> PackedString\n"
"takePS n ps = substrPS ps 0 (n-1)\n"
"\n"
"-- | The 'dropPS' function drops the first @n@ characters of a 'PackedString'.\n"
"dropPS	:: Int -> PackedString -> PackedString\n"
"dropPS n ps = substrPS ps n (lengthPS ps - 1)\n"
"\n"
"-- | The 'splitWithPS' function splits a 'PackedString' at a given index.\n"
"splitAtPS :: Int -> PackedString -> (PackedString, PackedString)\n"
"splitAtPS  n ps  = (takePS n ps, dropPS n ps)\n"
"\n"
"-- | The 'takeWhilePS' function is analogous to the 'takeWhile' function.\n"
"takeWhilePS :: (Char -> Bool) -> PackedString -> PackedString\n"
"takeWhilePS pred ps = packString (takeWhile pred (unpackPS ps))\n"
"\n"
"-- | The 'dropWhilePS' function is analogous to the 'dropWhile' function.\n"
"dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString\n"
"dropWhilePS pred ps = packString (dropWhile pred (unpackPS ps))\n"
"\n"
"-- | The 'elemPS' function returns True iff the given element is in the string.\n"
"elemPS :: Char -> PackedString -> Bool\n"
"elemPS c ps = c `elem` unpackPS ps\n"
"\n"
"-- | The 'spanPS' function returns a pair containing the result of\n"
"-- running both 'takeWhilePS' and 'dropWhilePS'.\n"
"spanPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)\n"
"spanPS  p ps = (takeWhilePS p ps, dropWhilePS p ps)\n"
"\n"
"-- | The 'breakPS' function breaks a string at the first position which\n"
"-- satisfies the predicate.\n"
"breakPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)\n"
"breakPS p ps = spanPS (not . p) ps\n"
"\n"
"-- | The 'linesPS' function splits the input on line-breaks.\n"
"linesPS :: PackedString -> [PackedString]\n"
"linesPS ps = splitPS '\\n' ps\n"
"\n"
"-- | The 'unlinesPS' function concatenates the input list after\n"
"-- interspersing newlines.\n"
"unlinesPS :: [PackedString] -> PackedString\n"
"unlinesPS = joinPS (packString \"\\n\")\n"
"\n"
"-- | The 'wordsPS' function is analogous to the 'words' function.\n"
"wordsPS :: PackedString -> [PackedString]\n"
"wordsPS ps = filter (not.nullPS) (splitWithPS isSpace ps)\n"
"\n"
"-- | The 'unwordsPS' function is analogous to the 'unwords' function.\n"
"unwordsPS :: [PackedString] -> PackedString\n"
"unwordsPS = joinPS (packString \" \")\n"
"\n"
"-- | The 'reversePS' function reverses the string.\n"
"reversePS :: PackedString -> PackedString\n"
"reversePS ps = packString (reverse (unpackPS ps))\n"
"\n"
"-- | The 'concatPS' function concatenates a list of 'PackedString's.\n"
"concatPS :: [PackedString] -> PackedString\n"
"concatPS pss = packString (concat (map unpackPS pss))\n"
"\n"
"------------------------------------------------------------\n"
"\n"
"-- | The 'joinPS' function takes a 'PackedString' and a list of 'PackedString's\n"
"-- and concatenates the list after interspersing the first argument between\n"
"-- each element of the list.\n"
"joinPS :: PackedString -> [PackedString] -> PackedString\n"
"joinPS filler pss = concatPS (splice pss)\n"
" where\n"
"  splice []  = []\n"
"  splice [x] = [x]\n"
"  splice (x:y:xs) = x:filler:splice (y:xs)\n"
"\n"
"-- ToDo: the obvious generalisation\n"
"{-\n"
"  Some properties that hold:\n"
"\n"
"  * splitPS x ls = ls'   \n"
"      where False = any (map (x `elemPS`) ls')\n"
"\n"
"  * joinPS (packString [x]) (splitPS x ls) = ls\n"
"-}\n"
"\n"
"-- | The 'splitPS' function splits the input string on each occurance of the given 'Char'.\n"
"splitPS :: Char -> PackedString -> [PackedString]\n"
"splitPS c = splitWithPS (== c)\n"
"\n"
"-- | The 'splitWithPS' function takes a character predicate and splits the input string\n"
"-- at each character which satisfies the predicate.\n"
"splitWithPS :: (Char -> Bool) -> PackedString -> [PackedString]\n"
"splitWithPS pred (PS ps) =\n"
" splitify 0\n"
" where\n"
"  len = lengthPS (PS ps)\n"
"  \n"
"  splitify n \n"
"   | n >= len = []\n"
"   | otherwise =\n"
"      let\n"
"       break_pt = first_pos_that_satisfies pred ps len n\n"
"      in\n"
"      if break_pt == n then -- immediate match, empty substring\n"
"         nilPS\n"
"	 : splitify (break_pt + 1)\n"
"      else \n"
"         substrPS (PS ps) n (break_pt - 1) -- leave out the matching character\n"
"         : splitify (break_pt + 1)\n"
"\n"
"first_pos_that_satisfies pred ps len n = \n"
"   case [ m | m <- [n..len-1], pred (ps ! m) ] of\n"
"	[]    -> len\n"
"	(m:_) -> m\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Local utility functions\n"
"\n"
"-- The definition of @_substrPS@ is essentially:\n"
"-- @take (end - begin + 1) (drop begin str)@.\n"
"\n"
"-- | The 'substrPS' function takes a 'PackedString' and two indices\n"
"-- and returns the substring of the input string between (and including)\n"
"-- these indices.\n"
"substrPS :: PackedString -> Int -> Int -> PackedString\n"
"substrPS (PS ps) begin end = packString [ ps ! i | i <- [begin..end] ]\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- hPutPS\n"
"\n"
"-- | Outputs a 'PackedString' to the specified 'Handle'.\n"
"--\n"
"-- NOTE: the representation of the 'PackedString' in the file is assumed to\n"
"-- be in the ISO-8859-1 encoding.  In other words, only the least signficant\n"
"-- byte is taken from each character in the 'PackedString'.\n"
"hPutPS :: Handle -> PackedString -> IO ()\n"
"hPutPS h (PS ps) = do\n"
"  let l = lengthPS (PS ps)\n"
"  arr <- newArray_ (0, l-1)\n"
"  sequence_ [ writeArray arr i (fromIntegral (ord (ps ! i))) | i <- [0..l-1] ]\n"
"  hPutArray h arr l\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- hGetPS\n"
"\n"
"-- | Read a 'PackedString' directly from the specified 'Handle'.\n"
"-- This is far more efficient than reading the characters into a 'String'\n"
"-- and then using 'packString'.  \n"
"--\n"
"-- NOTE: as with 'hPutPS', the string representation in the file is \n"
"-- assumed to be ISO-8859-1.\n"
"hGetPS :: Handle -> Int -> IO PackedString\n"
"hGetPS h i = do\n"
"  arr <- newArray_ (0, i-1)\n"
"  l <- hGetArray h arr i\n"
"  chars <- mapM (\\i -> readArray arr i >>= return.chr.fromIntegral) [0..l-1]\n"
"  return (packString chars)\n"
"\n";
const char *Data_STRef = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.STRef\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (requires non-portable module ST)\n"
"--\n"
"-- Mutable references in the (strict) ST monad.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.STRef (\n"
"	-- * STRefs\n"
"	STRef,		-- abstract, instance Eq\n"
"	newSTRef,	-- :: a -> ST s (STRef s a)\n"
"	readSTRef,	-- :: STRef s a -> ST s a\n"
"	writeSTRef,	-- :: STRef s a -> a -> ST s ()\n"
"	modifySTRef	-- :: STRef s a -> (a -> a) -> ST s ()\n"
" ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Hugs.ST\n"
"\n"
"import Data.Typeable\n"
"\n"
"stRefTc = mkTyCon \"STRef\"; instance (Typeable a, Typeable b) => Typeable (STRef a b) where {   typeOf x = mkAppTy stRefTc [typeOf ((undefined :: STRef a b -> a) x), 			     typeOf ((undefined :: STRef a b -> b) x)] }\n"
"\n"
"-- |Mutate the contents of an 'STRef'\n"
"modifySTRef :: STRef s a -> (a -> a) -> ST s ()\n"
"modifySTRef ref f = writeSTRef ref . f =<< readSTRef ref\n";
const char *Data_Bool = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Bool\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- The 'Bool' type and related functions.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Bool (\n"
"   -- * Booleans\n"
"   Bool(..),\n"
"   -- ** Operations \n"
"   (&&),	-- :: Bool -> Bool -> Bool\n"
"   (||),	-- :: Bool -> Bool -> Bool\n"
"   not,		-- :: Bool -> Bool\n"
"   otherwise,	-- :: Bool\n"
"  ) where\n"
"\n";
const char *Data_Dynamic = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Dynamic\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- The Dynamic interface provides basic support for dynamic types.\n"
"-- \n"
"-- Operations for injecting values of arbitrary type into\n"
"-- a dynamically typed value, Dynamic, are provided, together\n"
"-- with operations for converting dynamic values into a concrete\n"
"-- (monomorphic) type.\n"
"-- \n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Dynamic\n"
"  (\n"
"\n"
"	-- Module Data.Typeable re-exported for convenience\n"
"	module Data.Typeable,\n"
"\n"
"	-- * The @Dynamic@ type\n"
"	Dynamic,	-- abstract, instance of: Show, Typeable\n"
"\n"
"	-- * Converting to and from @Dynamic@\n"
"	toDyn,		-- :: Typeable a => a -> Dynamic\n"
"	fromDyn,	-- :: Typeable a => Dynamic -> a -> a\n"
"	fromDynamic,	-- :: Typeable a => Dynamic -> Maybe a\n"
"	\n"
"	-- * Applying functions of dynamic type\n"
"	dynApply,\n"
"	dynApp\n"
"\n"
"  ) where\n"
"\n"
"import Data.Typeable\n"
"import Data.Maybe\n"
"\n"
"import Hugs.Prelude\n"
"import Hugs.IO\n"
"import Hugs.IORef\n"
"import Hugs.IOExts\n"
"\n"
"-------------------------------------------------------------\n"
"--\n"
"--		The type Dynamic\n"
"--\n"
"-------------------------------------------------------------\n"
"\n"
"{-|\n"
"  A value of type 'Dynamic' is an object encapsulated together with its type.\n"
"\n"
"  A 'Dynamic' may only represent a monomorphic value; an attempt to\n"
"  create a value of type 'Dynamic' from a polymorphically-typed\n"
"  expression will result in an ambiguity error (see 'toDyn').\n"
"\n"
"  'Show'ing a value of type 'Dynamic' returns a pretty-printed representation\n"
"  of the object\\'s type; useful for debugging.\n"
"-}\n"
"\n"
"dynamicTc = mkTyCon \"Dynamic\"; instance Typeable Dynamic where { typeOf _ = mkAppTy dynamicTc [] }\n"
"\n"
"instance Show Dynamic where\n"
"   -- the instance just prints the type representation.\n"
"   showsPrec _ (Dynamic t _) = \n"
"          showString \"<<\" . \n"
"	  showsPrec 0 t   . \n"
"	  showString \">>\"\n"
"\n"
"-- | Converts an arbitrary value into an object of type 'Dynamic'.  \n"
"--\n"
"-- The type of the object must be an instance of 'Typeable', which\n"
"-- ensures that only monomorphically-typed objects may be converted to\n"
"-- 'Dynamic'.  To convert a polymorphic object into 'Dynamic', give it\n"
"-- a monomorphic type signature.  For example:\n"
"--\n"
"-- >    toDyn (id :: Int -> Int)\n"
"--\n"
"toDyn :: Typeable a => a -> Dynamic\n"
"toDyn v = Dynamic (typeOf v) (unsafeCoerce v)\n"
"\n"
"-- | Converts a 'Dynamic' object back into an ordinary Haskell value of\n"
"-- the correct type.  See also 'fromDynamic'.\n"
"fromDyn :: Typeable a\n"
" 	=> Dynamic 	-- ^ the dynamically-typed object\n"
"	-> a		-- ^ a default value \n"
"	-> a		-- ^ returns: the value of the first argument, if\n"
"			-- it has the correct type, otherwise the value of\n"
"			-- the second argument.\n"
"fromDyn (Dynamic t v) def\n"
"  | typeOf def == t = unsafeCoerce v\n"
"  | otherwise       = def\n"
"\n"
"-- | Converts a 'Dynamic' object back into an ordinary Haskell value of\n"
"-- the correct type.  See also 'fromDyn'.\n"
"fromDynamic\n"
"	:: Typeable a\n"
"	=> Dynamic	-- ^ the dynamically-typed object\n"
"	-> Maybe a	-- ^ returns: @'Just' a@, if the dyanmically-typed\n"
"			-- object has the correct type (and @a@ is its value), \n"
"			-- or 'Nothing' otherwise.\n"
"fromDynamic (Dynamic t v) =\n"
"  case unsafeCoerce v of \n"
"    r | t == typeOf r -> Just r\n"
"      | otherwise     -> Nothing\n"
"\n"
"-- (f::(a->b)) `dynApply` (x::a) = (f a)::b\n"
"dynApply :: Dynamic -> Dynamic -> Maybe Dynamic\n"
"dynApply (Dynamic t1 f) (Dynamic t2 x) =\n"
"  case applyTy t1 t2 of\n"
"    Just t3 -> Just (Dynamic t3 ((unsafeCoerce f) x))\n"
"    Nothing -> Nothing\n"
"\n"
"dynApp :: Dynamic -> Dynamic -> Dynamic\n"
"dynApp f x = case dynApply f x of \n"
"             Just r -> r\n"
"             Nothing -> error (\"Type error in dynamic application.\\n\" ++\n"
"                               \"Can't apply function \" ++ show f ++\n"
"                               \" to argument \" ++ show x)\n";
const char *Data_Word = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Word\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- Unsigned integer types.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Word\n"
"  ( \n"
"	-- * Unsigned integral types\n"
"\n"
"	Word,\n"
"	Word8, Word16, Word32, Word64,\n"
"	\n"
"	-- * Notes\n"
"	\n"
"	-- $notes\n"
"	) where\n"
"\n"
"import Hugs.Word\n"
"\n"
"{- $notes\n"
"\n"
"* All arithmetic is performed modulo 2^n, where n is the number of\n"
"  bits in the type.  One non-obvious consequence of this is that 'negate'\n"
"  should /not/ raise an error on negative arguments.\n"
"\n"
"* For coercing between any two integer types, use\n"
"  'fromIntegral', which is specialized for all the\n"
"  common cases so should be fast enough.  Coercing word types to and\n"
"  from integer types preserves representation, not sign.\n"
"\n"
"* It would be very natural to add a type 'Natural' providing an unbounded \n"
"  size unsigned integer, just as 'Integer' provides unbounded\n"
"  size signed integers.  We do not do that yet since there is no demand\n"
"  for it.\n"
"\n"
"* The rules that hold for 'Enum' instances over a bounded type\n"
"  such as 'Int' (see the section of the Haskell report dealing\n"
"  with arithmetic sequences) also hold for the 'Enum' instances\n"
"  over the various 'Word' types defined here.\n"
"\n"
"* Right and left shifts by amounts greater than or equal to the width\n"
"  of the type result in a zero result.  This is contrary to the\n"
"  behaviour in C, which is undefined; a common interpretation is to\n"
"  truncate the shift count to the width of the type, for example @1 \\<\\<\n"
"  32 == 1@ in some C implementations. \n"
"-}\n";
const char *Data_List = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.List\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Operations on lists.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.List\n"
"   ( \n"
"\n"
"   -- * Basic functions\n"
"\n"
"     (++)	       -- :: [a] -> [a] -> [a]\n"
"   , head	       -- :: [a] -> a\n"
"   , last	       -- :: [a] -> a\n"
"   , tail	       -- :: [a] -> [a]\n"
"   , init              -- :: [a] -> [a]\n"
"   , null	       -- :: [a] -> Bool\n"
"   , length	       -- :: [a] -> Int\n"
"\n"
"   -- * List transformations\n"
"   , map               -- :: (a -> b) -> [a] -> [b]\n"
"   , reverse           -- :: [a] -> [a]\n"
"\n"
"   , intersperse       -- :: a -> [a] -> [a]\n"
"   , transpose         -- :: [[a]] -> [[a]]\n"
"\n"
"   -- * Reducing lists (folds)\n"
"\n"
"   , foldl	       -- :: (a -> b -> a) -> a -> [b] -> a\n"
"   , foldl'	       -- :: (a -> b -> a) -> a -> [b] -> a\n"
"   , foldl1	       -- :: (a -> a -> a) -> [a] -> a\n"
"   , foldr             -- :: (a -> b -> b) -> b -> [a] -> b\n"
"   , foldr1            -- :: (a -> a -> a) -> [a] -> a\n"
"\n"
"   -- ** Special folds\n"
"\n"
"   , concat            -- :: [[a]] -> [a]\n"
"   , concatMap         -- :: (a -> [b]) -> [a] -> [b]\n"
"   , and	       -- :: [Bool] -> Bool\n"
"   , or                -- :: [Bool] -> Bool\n"
"   , any               -- :: (a -> Bool) -> [a] -> Bool\n"
"   , all               -- :: (a -> Bool) -> [a] -> Bool\n"
"   , sum               -- :: (Num a) => [a] -> a\n"
"   , product           -- :: (Num a) => [a] -> a\n"
"   , maximum           -- :: (Ord a) => [a] -> a\n"
"   , minimum           -- :: (Ord a) => [a] -> a\n"
"\n"
"   -- * Building lists\n"
"\n"
"   -- ** Scans\n"
"   , scanl             -- :: (a -> b -> a) -> a -> [b] -> [a]\n"
"   , scanl1            -- :: (a -> a -> a) -> [a] -> [a]\n"
"   , scanr             -- :: (a -> b -> b) -> b -> [a] -> [b]\n"
"   , scanr1            -- :: (a -> a -> a) -> [a] -> [a]\n"
"\n"
"   -- ** Accumulating maps\n"
"   , mapAccumL         -- :: (a -> b -> (a,c)) -> a -> [b] -> (a,[c])\n"
"   , mapAccumR         -- :: (a -> b -> (a,c)) -> a -> [b] -> (a,[c])\n"
"\n"
"   -- ** Infinite lists\n"
"   , iterate           -- :: (a -> a) -> a -> [a]\n"
"   , repeat            -- :: a -> [a]\n"
"   , replicate         -- :: Int -> a -> [a]\n"
"   , cycle             -- :: [a] -> [a]\n"
"\n"
"   -- ** Unfolding\n"
"   , unfoldr	       -- :: (b -> Maybe (a, b)) -> b -> [a]\n"
"\n"
"   -- * Sublists\n"
"\n"
"   -- ** Extracting sublists\n"
"   , take              -- :: Int -> [a] -> [a]\n"
"   , drop              -- :: Int -> [a] -> [a]\n"
"   , splitAt           -- :: Int -> [a] -> ([a], [a])\n"
"\n"
"   , takeWhile         -- :: (a -> Bool) -> [a] -> [a]\n"
"   , dropWhile         -- :: (a -> Bool) -> [a] -> [a]\n"
"   , span              -- :: (a -> Bool) -> [a] -> ([a], [a])\n"
"   , break             -- :: (a -> Bool) -> [a] -> ([a], [a])\n"
"\n"
"   , group             -- :: Eq a => [a] -> [[a]]\n"
"\n"
"   , inits             -- :: [a] -> [[a]]\n"
"   , tails             -- :: [a] -> [[a]]\n"
"\n"
"   -- ** Predicates\n"
"   , isPrefixOf        -- :: (Eq a) => [a] -> [a] -> Bool\n"
"   , isSuffixOf        -- :: (Eq a) => [a] -> [a] -> Bool\n"
"\n"
"   -- * Searching lists\n"
"\n"
"   -- ** Searching by equality\n"
"   , elem              -- :: a -> [a] -> Bool\n"
"   , notElem           -- :: a -> [a] -> Bool\n"
"   , lookup            -- :: (Eq a) => a -> [(a,b)] -> Maybe b\n"
"\n"
"   -- ** Searching with a predicate\n"
"   , find	       -- :: (a -> Bool) -> [a] -> Maybe a\n"
"   , filter	       -- :: (a -> Bool) -> [a] -> [a]\n"
"   , partition         -- :: (a -> Bool) -> [a] -> ([a], [a])\n"
"\n"
"   -- * Indexing lists\n"
"   -- | These functions treat a list @xs@ as a indexed collection,\n"
"   -- with indices ranging from 0 to @'length' xs - 1@.\n"
"\n"
"   , (!!)	       -- :: [a] -> Int -> a\n"
"\n"
"   , elemIndex	       -- :: (Eq a) => a -> [a] -> Maybe Int\n"
"   , elemIndices       -- :: (Eq a) => a -> [a] -> [Int]\n"
"\n"
"   , findIndex	       -- :: (a -> Bool) -> [a] -> Maybe Int\n"
"   , findIndices       -- :: (a -> Bool) -> [a] -> [Int]\n"
"\n"
"   -- * Zipping and unzipping lists\n"
"\n"
"   , zip               -- :: [a] -> [b] -> [(a,b)]\n"
"   , zip3  \n"
"   , zip4, zip5, zip6, zip7\n"
"\n"
"   , zipWith           -- :: (a -> b -> c) -> [a] -> [b] -> [c]\n"
"   , zipWith3\n"
"   , zipWith4, zipWith5, zipWith6, zipWith7\n"
"\n"
"   , unzip             -- :: [(a,b)] -> ([a],[b])\n"
"   , unzip3\n"
"   , unzip4, unzip5, unzip6, unzip7\n"
"\n"
"   -- * Special lists\n"
"\n"
"   -- ** Functions on strings\n"
"   , lines	       -- :: String   -> [String]\n"
"   , words	       -- :: String   -> [String]\n"
"   , unlines           -- :: [String] -> String\n"
"   , unwords           -- :: [String] -> String\n"
"\n"
"   -- ** \\\"Set\\\" operations\n"
"   \n"
"   , nub               -- :: (Eq a) => [a] -> [a]\n"
"\n"
"   , delete            -- :: (Eq a) => a -> [a] -> [a]\n"
"   , (\\\\)              -- :: (Eq a) => [a] -> [a] -> [a]\n"
"   \n"
"   , union             -- :: (Eq a) => [a] -> [a] -> [a]\n"
"   , intersect         -- :: (Eq a) => [a] -> [a] -> [a]\n"
"\n"
"   -- ** Ordered lists\n"
"   , sort              -- :: (Ord a) => [a] -> [a]\n"
"   , insert            -- :: (Ord a) => a -> [a] -> [a]\n"
"\n"
"   -- * Generalized functions\n"
"\n"
"   -- ** The \\\"@By@\\\" operations\n"
"   -- | By convention, overloaded functions have a non-overloaded\n"
"   -- counterpart whose name is suffixed with \\`@By@\\'.\n"
"\n"
"   -- *** User-supplied equality (replacing an @Eq@ context)\n"
"   -- | The predicate is assumed to define an equivalence.\n"
"   , nubBy             -- :: (a -> a -> Bool) -> [a] -> [a]\n"
"   , deleteBy          -- :: (a -> a -> Bool) -> a -> [a] -> [a]\n"
"   , deleteFirstsBy    -- :: (a -> a -> Bool) -> [a] -> [a] -> [a]\n"
"   , unionBy           -- :: (a -> a -> Bool) -> [a] -> [a] -> [a]\n"
"   , intersectBy       -- :: (a -> a -> Bool) -> [a] -> [a] -> [a]\n"
"   , groupBy           -- :: (a -> a -> Bool) -> [a] -> [[a]]\n"
"\n"
"   -- *** User-supplied comparison (replacing an @Ord@ context)\n"
"   -- | The function is assumed to define a total ordering.\n"
"   , sortBy            -- :: (a -> a -> Ordering) -> [a] -> [a]\n"
"   , insertBy          -- :: (a -> a -> Ordering) -> a -> [a] -> [a]\n"
"   , maximumBy	       -- :: (a -> a -> Ordering) -> [a] -> a\n"
"   , minimumBy         -- :: (a -> a -> Ordering) -> [a] -> a\n"
"\n"
"   -- ** The \\\"@generic@\\\" operations\n"
"   -- | The prefix \\`@generic@\\' indicates an overloaded function that\n"
"   -- is a generalized version of a \"Prelude\" function.\n"
"\n"
"   , genericLength     -- :: (Integral a) => [b] -> a\n"
"   , genericTake       -- :: (Integral a) => a -> [b] -> [b]\n"
"   , genericDrop       -- :: (Integral a) => a -> [b] -> [b]\n"
"   , genericSplitAt    -- :: (Integral a) => a -> [b] -> ([b], [b])\n"
"   , genericIndex      -- :: (Integral a) => [b] -> a -> b\n"
"   , genericReplicate  -- :: (Integral a) => a -> b -> [b]\n"
"\n"
"   ) where\n"
"\n"
"import Data.Maybe\n"
"import Data.Char	( isSpace )\n"
"\n"
"-- HACK: remove operator, since it seems to be getting emitted as \n"
"-- \"infix 5 \\\"\n"
"-- infix 5 \\\n"
"-- -----------------------------------------------------------------------------\n"
"-- List functions\n"
"\n"
"-- | The 'elemIndex' function returns the index of the first element\n"
"-- in the given list which is equal (by '==') to the query element,\n"
"-- or 'Nothing' if there is no such element.\n"
"elemIndex	:: Eq a => a -> [a] -> Maybe Int\n"
"elemIndex x     = findIndex (x==)\n"
"\n"
"-- | The 'elemIndices' function extends 'elemIndex', by returning the\n"
"-- indices of all elements equal to the query element, in ascending order.\n"
"elemIndices     :: Eq a => a -> [a] -> [Int]\n"
"elemIndices x   = findIndices (x==)\n"
"\n"
"-- | The 'find' function takes a predicate and a list and returns the\n"
"-- first element in the list matching the predicate, or 'Nothing' if\n"
"-- there is no such element.\n"
"find		:: (a -> Bool) -> [a] -> Maybe a\n"
"find p          = listToMaybe . filter p\n"
"\n"
"-- | The 'findIndex' function takes a predicate and a list and returns\n"
"-- the index of the first element in the list satisfying the predicate,\n"
"-- or 'Nothing' if there is no such element.\n"
"findIndex       :: (a -> Bool) -> [a] -> Maybe Int\n"
"findIndex p     = listToMaybe . findIndices p\n"
"\n"
"-- | The 'findIndices' function extends 'findIndex', by returning the\n"
"-- indices of all elements satisfying the predicate, in ascending order.\n"
"findIndices      :: (a -> Bool) -> [a] -> [Int]\n"
"\n"
"findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]\n"
"\n"
"-- | The 'isPrefixOf' function takes two lists and returns 'True'\n"
"-- iff the first list is a prefix of the second.\n"
"isPrefixOf              :: (Eq a) => [a] -> [a] -> Bool\n"
"isPrefixOf [] _         =  True\n"
"isPrefixOf _  []        =  False\n"
"isPrefixOf (x:xs) (y:ys)=  x == y && isPrefixOf xs ys\n"
"\n"
"-- | The 'isSuffixOf' function takes two lists and returns 'True'\n"
"-- iff the first list is a suffix of the second.\n"
"-- Both lists must be finite.\n"
"isSuffixOf              :: (Eq a) => [a] -> [a] -> Bool\n"
"isSuffixOf x y          =  reverse x `isPrefixOf` reverse y\n"
"\n"
"-- | The 'nub' function removes duplicate elements from a list.\n"
"-- In particular, it keeps only the first occurrence of each element.\n"
"-- (The name 'nub' means \\`essence\\'.)\n"
"-- It is a special case of 'nubBy', which allows the programmer to supply\n"
"-- their own equality test.\n"
"nub                     :: (Eq a) => [a] -> [a]\n"
"-- stolen from HBC\n"
"nub l                   = nub' l []		-- '\n"
"  where\n"
"    nub' [] _		= []			-- '\n"
"    nub' (x:xs) ls				-- '\n"
"	| x `elem` ls   = nub' xs ls		-- '\n"
"	| otherwise     = x : nub' xs (x:ls)	-- '\n"
"\n"
"-- | The 'nubBy' function behaves just like 'nub', except it uses a\n"
"-- user-supplied equality predicate instead of the overloaded '=='\n"
"-- function.\n"
"nubBy			:: (a -> a -> Bool) -> [a] -> [a]\n"
"nubBy eq l              = nubBy' l []\n"
"  where\n"
"    nubBy' [] _		= []\n"
"    nubBy' (y:ys) xs\n"
"       | elem_by eq y xs = nubBy' ys xs \n"
"       | otherwise	 = y : nubBy' ys (y:xs)\n"
"\n"
"-- Not exported:\n"
"-- Note that we keep the call to `eq` with arguments in the\n"
"-- same order as in the reference implementation\n"
"-- 'xs' is the list of things we've seen so far, \n"
"-- 'y' is the potential new element\n"
"elem_by :: (a -> a -> Bool) -> a -> [a] -> Bool\n"
"elem_by _  _ []		=  False\n"
"elem_by eq y (x:xs)	=  x `eq` y || elem_by eq y xs\n"
"\n"
"-- | 'delete' @x@ removes the first occurrence of @x@ from its list argument.\n"
"-- For example,\n"
"--\n"
"-- > delete 'a' \"banana\" == \"bnana\"\n"
"--\n"
"-- It is a special case of 'deleteBy', which allows the programmer to\n"
"-- supply their own equality test.\n"
"\n"
"delete                  :: (Eq a) => a -> [a] -> [a]\n"
"delete                  =  deleteBy (==)\n"
"\n"
"-- | The 'deleteBy' function behaves like 'delete', but takes a\n"
"-- user-supplied equality predicate.\n"
"deleteBy                :: (a -> a -> Bool) -> a -> [a] -> [a]\n"
"deleteBy _  _ []        = []\n"
"deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys\n"
"\n"
"-- | The '\\\\' function is list difference ((non-associative).\n"
"-- In the result of @xs@ '\\\\' @ys@, the first occurrence of each element of\n"
"-- @ys@ in turn (if any) has been removed from @xs@.  Thus\n"
"--\n"
"-- > (xs ++ ys) \\\\ xs == ys.\n"
"--\n"
"-- It is a special case of 'deleteFirstsBy', which allows the programmer\n"
"-- to supply their own equality test.\n"
"\n"
"(\\\\)			:: (Eq a) => [a] -> [a] -> [a]\n"
"(\\\\)		        =  foldl (flip delete)\n"
"\n"
"-- | The 'union' function returns the list union of the two lists.\n"
"-- For example,\n"
"--\n"
"-- > \"dog\" `union` \"cow\" == \"dogcw\"\n"
"--\n"
"-- Duplicates, and elements of the first list, are removed from the\n"
"-- the second list, but if the first list contains duplicates, so will\n"
"-- the result.\n"
"-- It is a special case of 'unionBy', which allows the programmer to supply\n"
"-- their own equality test.\n"
"\n"
"union			:: (Eq a) => [a] -> [a] -> [a]\n"
"union 			= unionBy (==)\n"
"\n"
"-- | The 'unionBy' function is the non-overloaded version of 'union'.\n"
"unionBy                 :: (a -> a -> Bool) -> [a] -> [a] -> [a]\n"
"unionBy eq xs ys        =  xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs\n"
"\n"
"-- | The 'intersect' function takes the list intersection of two lists.\n"
"-- For example,\n"
"--\n"
"-- > [1,2,3,4] `intersect` [2,4,6,8] == [2,4]\n"
"--\n"
"-- If the first list contains duplicates, so will the result.\n"
"-- It is a special case of 'intersectBy', which allows the programmer to\n"
"-- supply their own equality test.\n"
"\n"
"intersect               :: (Eq a) => [a] -> [a] -> [a]\n"
"intersect               =  intersectBy (==)\n"
"\n"
"-- | The 'intersectBy' function is the non-overloaded version of 'intersect'.\n"
"intersectBy             :: (a -> a -> Bool) -> [a] -> [a] -> [a]\n"
"intersectBy eq xs ys    =  [x | x <- xs, any (eq x) ys]\n"
"\n"
"-- | The 'intersperse' function takes an element and a list and\n"
"-- \\`intersperses\\' that element between the elements of the list.\n"
"-- For example,\n"
"--\n"
"-- > intersperse ',' \"abcde\" == \"a,b,c,d,e\"\n"
"\n"
"intersperse		:: a -> [a] -> [a]\n"
"intersperse _   []      = []\n"
"intersperse _   [x]     = [x]\n"
"intersperse sep (x:xs)  = x : sep : intersperse sep xs\n"
"\n"
"-- | The 'transpose' function transposes the rows and columns of its argument.\n"
"-- For example,\n"
"--\n"
"-- > transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]\n"
"\n"
"transpose		:: [[a]] -> [[a]]\n"
"transpose []		 = []\n"
"transpose ([]	: xss)   = transpose xss\n"
"transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])\n"
"\n"
"-- | The 'partition' function takes a predicate a list and returns\n"
"-- the pair of lists of elements which do and do not satisfy the\n"
"-- predicate, respectively; i.e.,\n"
"--\n"
"-- > partition p xs == (filter p xs, filter (not . p) xs)\n"
"\n"
"partition		:: (a -> Bool) -> [a] -> ([a],[a])\n"
"{-# INLINE partition #-}\n"
"partition p xs = foldr (select p) ([],[]) xs\n"
"\n"
"select p x (ts,fs) | p x       = (x:ts,fs)\n"
"                   | otherwise = (ts, x:fs)\n"
"\n"
"-- | The 'mapAccumL' function behaves like a combination of 'map' and\n"
"-- 'foldl'; it applies a function to each element of a list, passing\n"
"-- an accumulating parameter from left to right, and returning a final\n"
"-- value of this accumulator together with the new list.\n"
"mapAccumL :: (acc -> x -> (acc, y)) -- Function of elt of input list\n"
"				    -- and accumulator, returning new\n"
"				    -- accumulator and elt of result list\n"
"   	  -> acc	    -- Initial accumulator \n"
"	  -> [x]	    -- Input list\n"
"	  -> (acc, [y])	    -- Final accumulator and result list\n"
"mapAccumL _ s []     	=  (s, [])\n"
"mapAccumL f s (x:xs) 	=  (s'',y:ys)\n"
"		           where (s', y ) = f s x\n"
"			         (s'',ys) = mapAccumL f s' xs\n"
"\n"
"-- | The 'mapAccumR' function behaves like a combination of 'map' and\n"
"-- 'foldr'; it applies a function to each element of a list, passing\n"
"-- an accumulating parameter from right to left, and returning a final\n"
"-- value of this accumulator together with the new list.\n"
"mapAccumR :: (acc -> x -> (acc, y)) 	-- Function of elt of input list\n"
"					-- and accumulator, returning new\n"
"					-- accumulator and elt of result list\n"
"	    -> acc 		-- Initial accumulator\n"
"	    -> [x] 		-- Input list\n"
"	    -> (acc, [y])		-- Final accumulator and result list\n"
"mapAccumR _ s []     	=  (s, [])\n"
"mapAccumR f s (x:xs)	=  (s'', y:ys)\n"
"		           where (s'',y ) = f s' x\n"
"			         (s', ys) = mapAccumR f s xs\n"
"\n"
"-- | The 'insert' function takes an element and a list and inserts the\n"
"-- element into the list at the last position where it is still less\n"
"-- than or equal to the next element.  In particular, if the list\n"
"-- is sorted before the call, the result will also be sorted.\n"
"-- It is a special case of 'insertBy', which allows the programmer to\n"
"-- supply their own comparison function.\n"
"insert :: Ord a => a -> [a] -> [a]\n"
"insert e ls = insertBy (compare) e ls\n"
"\n"
"-- | The non-overloaded version of 'insert'.\n"
"insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]\n"
"insertBy _   x [] = [x]\n"
"insertBy cmp x ys@(y:ys')\n"
" = case cmp x y of\n"
"     GT -> y : insertBy cmp x ys'\n"
"     _  -> x : ys\n"
"\n"
"-- | The 'maximumBy' function takes a comparison function and a list\n"
"-- and returns the greatest element of the list by the comparison function.\n"
"-- The list must be finite and non-empty.\n"
"maximumBy		:: (a -> a -> Ordering) -> [a] -> a\n"
"maximumBy _ []		=  error \"List.maximumBy: empty list\"\n"
"maximumBy cmp xs	=  foldl1 max xs\n"
"			where\n"
"			   max x y = case cmp x y of\n"
"					GT -> x\n"
"					_  -> y\n"
"\n"
"-- | The 'minimumBy' function takes a comparison function and a list\n"
"-- and returns the least element of the list by the comparison function.\n"
"-- The list must be finite and non-empty.\n"
"minimumBy		:: (a -> a -> Ordering) -> [a] -> a\n"
"minimumBy _ []		=  error \"List.minimumBy: empty list\"\n"
"minimumBy cmp xs	=  foldl1 min xs\n"
"			where\n"
"			   min x y = case cmp x y of\n"
"					GT -> y\n"
"					_  -> x\n"
"\n"
"-- | The 'genericLength' function is an overloaded version of 'length'.  In\n"
"-- particular, instead of returning an 'Int', it returns any type which is\n"
"-- an instance of 'Num'.  It is, however, less efficient than 'length'.\n"
"genericLength           :: (Num i) => [b] -> i\n"
"genericLength []        =  0\n"
"genericLength (_:l)     =  1 + genericLength l\n"
"\n"
"-- | The 'genericTake' function is an overloaded version of 'take', which\n"
"-- accepts any 'Integral' value as the number of elements to take.\n"
"genericTake		:: (Integral i) => i -> [a] -> [a]\n"
"genericTake 0 _         =  []\n"
"genericTake _ []        =  []\n"
"genericTake n (x:xs) | n > 0  =  x : genericTake (n-1) xs\n"
"genericTake _  _        =  error \"List.genericTake: negative argument\"\n"
"\n"
"-- | The 'genericDrop' function is an overloaded version of 'drop', which\n"
"-- accepts any 'Integral' value as the number of elements to drop.\n"
"genericDrop		:: (Integral i) => i -> [a] -> [a]\n"
"genericDrop 0 xs        =  xs\n"
"genericDrop _ []        =  []\n"
"genericDrop n (_:xs) | n > 0  =  genericDrop (n-1) xs\n"
"genericDrop _ _		=  error \"List.genericDrop: negative argument\"\n"
"\n"
"-- | The 'genericSplitAt' function is an overloaded version of 'splitAt', which\n"
"-- accepts any 'Integral' value as the position at which to split.\n"
"genericSplitAt          :: (Integral i) => i -> [b] -> ([b],[b])\n"
"genericSplitAt 0 xs     =  ([],xs)\n"
"genericSplitAt _ []     =  ([],[])\n"
"genericSplitAt n (x:xs) | n > 0  =  (x:xs',xs'') where\n"
"                               (xs',xs'') = genericSplitAt (n-1) xs\n"
"genericSplitAt _ _      =  error \"List.genericSplitAt: negative argument\"\n"
"\n"
"-- | The 'genericIndex' function is an overloaded version of '!!', which\n"
"-- accepts any 'Integral' value as the index.\n"
"genericIndex :: (Integral a) => [b] -> a -> b\n"
"genericIndex (x:_)  0 = x\n"
"genericIndex (_:xs) n \n"
" | n > 0     = genericIndex xs (n-1)\n"
" | otherwise = error \"List.genericIndex: negative argument.\"\n"
"genericIndex _ _      = error \"List.genericIndex: index too large.\"\n"
"\n"
"-- | The 'genericReplicate' function is an overloaded version of 'replicate',\n"
"-- which accepts any 'Integral' value as the number of repetitions to make.\n"
"genericReplicate	:: (Integral i) => i -> a -> [a]\n"
"genericReplicate n x	=  genericTake n (repeat x)\n"
"\n"
"-- | The 'zip4' function takes four lists and returns a list of\n"
"-- quadruples, analogous to 'zip'.\n"
"zip4			:: [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]\n"
"zip4			=  zipWith4 (,,,)\n"
"\n"
"-- | The 'zip5' function takes five lists and returns a list of\n"
"-- five-tuples, analogous to 'zip'.\n"
"zip5			:: [a] -> [b] -> [c] -> [d] -> [e] -> [(a,b,c,d,e)]\n"
"zip5			=  zipWith5 (,,,,)\n"
"\n"
"-- | The 'zip6' function takes six lists and returns a list of six-tuples,\n"
"-- analogous to 'zip'.\n"
"zip6			:: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> \n"
"                              [(a,b,c,d,e,f)]\n"
"zip6			=  zipWith6 (,,,,,)\n"
"\n"
"-- | The 'zip7' function takes seven lists and returns a list of\n"
"-- seven-tuples, analogous to 'zip'.\n"
"zip7			:: [a] -> [b] -> [c] -> [d] -> [e] -> [f] ->\n"
"                              [g] -> [(a,b,c,d,e,f,g)]\n"
"zip7			=  zipWith7 (,,,,,,)\n"
"\n"
"-- | The 'zipWith4' function takes a function which combines four\n"
"-- elements, as well as four lists and returns a list of their point-wise\n"
"-- combination, analogous to 'zipWith'.\n"
"zipWith4		:: (a->b->c->d->e) -> [a]->[b]->[c]->[d]->[e]\n"
"zipWith4 z (a:as) (b:bs) (c:cs) (d:ds)\n"
"			=  z a b c d : zipWith4 z as bs cs ds\n"
"zipWith4 _ _ _ _ _	=  []\n"
"\n"
"-- | The 'zipWith5' function takes a function which combines five\n"
"-- elements, as well as five lists and returns a list of their point-wise\n"
"-- combination, analogous to 'zipWith'.\n"
"zipWith5		:: (a->b->c->d->e->f) -> \n"
"                           [a]->[b]->[c]->[d]->[e]->[f]\n"
"zipWith5 z (a:as) (b:bs) (c:cs) (d:ds) (e:es)\n"
"			=  z a b c d e : zipWith5 z as bs cs ds es\n"
"zipWith5 _ _ _ _ _ _	= []\n"
"\n"
"-- | The 'zipWith6' function takes a function which combines six\n"
"-- elements, as well as six lists and returns a list of their point-wise\n"
"-- combination, analogous to 'zipWith'.\n"
"zipWith6		:: (a->b->c->d->e->f->g) ->\n"
"                           [a]->[b]->[c]->[d]->[e]->[f]->[g]\n"
"zipWith6 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs)\n"
"			=  z a b c d e f : zipWith6 z as bs cs ds es fs\n"
"zipWith6 _ _ _ _ _ _ _	= []\n"
"\n"
"-- | The 'zipWith7' function takes a function which combines seven\n"
"-- elements, as well as seven lists and returns a list of their point-wise\n"
"-- combination, analogous to 'zipWith'.\n"
"zipWith7		:: (a->b->c->d->e->f->g->h) ->\n"
"                           [a]->[b]->[c]->[d]->[e]->[f]->[g]->[h]\n"
"zipWith7 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs)\n"
"		   =  z a b c d e f g : zipWith7 z as bs cs ds es fs gs\n"
"zipWith7 _ _ _ _ _ _ _ _ = []\n"
"\n"
"-- | The 'unzip4' function takes a list of quadruples and returns four\n"
"-- lists, analogous to 'unzip'.\n"
"unzip4			:: [(a,b,c,d)] -> ([a],[b],[c],[d])\n"
"unzip4			=  foldr (\\(a,b,c,d) ~(as,bs,cs,ds) ->\n"
"					(a:as,b:bs,c:cs,d:ds))\n"
"				 ([],[],[],[])\n"
"\n"
"-- | The 'unzip5' function takes a list of five-tuples and returns five\n"
"-- lists, analogous to 'unzip'.\n"
"unzip5			:: [(a,b,c,d,e)] -> ([a],[b],[c],[d],[e])\n"
"unzip5			=  foldr (\\(a,b,c,d,e) ~(as,bs,cs,ds,es) ->\n"
"					(a:as,b:bs,c:cs,d:ds,e:es))\n"
"				 ([],[],[],[],[])\n"
"\n"
"-- | The 'unzip6' function takes a list of six-tuples and returns six\n"
"-- lists, analogous to 'unzip'.\n"
"unzip6			:: [(a,b,c,d,e,f)] -> ([a],[b],[c],[d],[e],[f])\n"
"unzip6			=  foldr (\\(a,b,c,d,e,f) ~(as,bs,cs,ds,es,fs) ->\n"
"					(a:as,b:bs,c:cs,d:ds,e:es,f:fs))\n"
"				 ([],[],[],[],[],[])\n"
"\n"
"-- | The 'unzip7' function takes a list of seven-tuples and returns\n"
"-- seven lists, analogous to 'unzip'.\n"
"unzip7		:: [(a,b,c,d,e,f,g)] -> ([a],[b],[c],[d],[e],[f],[g])\n"
"unzip7		=  foldr (\\(a,b,c,d,e,f,g) ~(as,bs,cs,ds,es,fs,gs) ->\n"
"				(a:as,b:bs,c:cs,d:ds,e:es,f:fs,g:gs))\n"
"			 ([],[],[],[],[],[],[])\n"
"\n"
"-- | The 'deleteFirstsBy' function takes a predicate and two lists and\n"
"-- returns the first list with the first occurrence of each element of\n"
"-- the second list removed.\n"
"deleteFirstsBy          :: (a -> a -> Bool) -> [a] -> [a] -> [a]\n"
"deleteFirstsBy eq       =  foldl (flip (deleteBy eq))\n"
"\n"
"-- | The 'group' function takes a list and returns a list of lists such\n"
"-- that the concatenation of the result is equal to the argument.  Moreover,\n"
"-- each sublist in the result contains only equal elements.  For example,\n"
"--\n"
"-- > group \"Mississippi\" = [\"M\",\"i\",\"ss\",\"i\",\"ss\",\"i\",\"pp\",\"i\"]\n"
"--\n"
"-- It is a special case of 'groupBy', which allows the programmer to supply\n"
"-- their own equality test.\n"
"group	 		:: Eq a => [a] -> [[a]]\n"
"group                   =  groupBy (==)\n"
"\n"
"-- | The 'groupBy' function is the non-overloaded version of 'group'.\n"
"groupBy 		:: (a -> a -> Bool) -> [a] -> [[a]]\n"
"groupBy _  []		=  []\n"
"groupBy eq (x:xs)	=  (x:ys) : groupBy eq zs\n"
"                           where (ys,zs) = span (eq x) xs\n"
"\n"
"-- | The 'inits' function returns all initial segments of the argument,\n"
"-- shortest first.  For example,\n"
"--\n"
"-- > inits \"abc\" == [\"\",\"a\",\"ab\",\"abc\"]\n"
"--\n"
"inits 			:: [a] -> [[a]]\n"
"inits []		=  [[]]\n"
"inits (x:xs) 		=  [[]] ++ map (x:) (inits xs)\n"
"\n"
"-- | The 'tails' function returns all final segments of the argument,\n"
"-- longest first.  For example,\n"
"--\n"
"-- > tails \"abc\" == [\"abc\", \"bc\", \"c\",\"\"]\n"
"--\n"
"tails 			:: [a] -> [[a]]\n"
"tails []	        =  [[]]\n"
"tails xxs@(_:xs) 	=  xxs : tails xs\n"
"\n"
"------------------------------------------------------------------------------\n"
"-- Quick Sort algorithm taken from HBC's QSort library.\n"
"\n"
"-- | The 'sort' function implements a stable sorting algorithm.\n"
"-- It is a special case of 'sortBy', which allows the programmer to supply\n"
"-- their own comparison function.\n"
"sort :: (Ord a) => [a] -> [a]\n"
"\n"
"-- | The 'sortBy' function is the non-overloaded version of 'sort'.\n"
"sortBy :: (a -> a -> Ordering) -> [a] -> [a]\n"
"\n"
"sortBy cmp l = mergesort cmp l\n"
"sort l = mergesort compare l\n"
"\n"
"{-\n"
"Quicksort replaced by mergesort, 14/5/2002.\n"
"\n"
"From: Ian Lynagh <igloo@earth.li>\n"
"\n"
"I am curious as to why the List.sort implementation in GHC is a\n"
"quicksort algorithm rather than an algorithm that guarantees n log n\n"
"time in the worst case? I have attached a mergesort implementation along\n"
"with a few scripts to time it's performance, the results of which are\n"
"shown below (* means it didn't finish successfully - in all cases this\n"
"was due to a stack overflow).\n"
"\n"
"If I heap profile the random_list case with only 10000 then I see\n"
"random_list peaks at using about 2.5M of memory, whereas in the same\n"
"program using List.sort it uses only 100k.\n"
"\n"
"Input style     Input length     Sort data     Sort alg    User time\n"
"stdin           10000            random_list   sort        2.82\n"
"stdin           10000            random_list   mergesort   2.96\n"
"stdin           10000            sorted        sort        31.37\n"
"stdin           10000            sorted        mergesort   1.90\n"
"stdin           10000            revsorted     sort        31.21\n"
"stdin           10000            revsorted     mergesort   1.88\n"
"stdin           100000           random_list   sort        *\n"
"stdin           100000           random_list   mergesort   *\n"
"stdin           100000           sorted        sort        *\n"
"stdin           100000           sorted        mergesort   *\n"
"stdin           100000           revsorted     sort        *\n"
"stdin           100000           revsorted     mergesort   *\n"
"func            10000            random_list   sort        0.31\n"
"func            10000            random_list   mergesort   0.91\n"
"func            10000            sorted        sort        19.09\n"
"func            10000            sorted        mergesort   0.15\n"
"func            10000            revsorted     sort        19.17\n"
"func            10000            revsorted     mergesort   0.16\n"
"func            100000           random_list   sort        3.85\n"
"func            100000           random_list   mergesort   *\n"
"func            100000           sorted        sort        5831.47\n"
"func            100000           sorted        mergesort   2.23\n"
"func            100000           revsorted     sort        5872.34\n"
"func            100000           revsorted     mergesort   2.24\n"
"-}\n"
"\n"
"mergesort :: (a -> a -> Ordering) -> [a] -> [a]\n"
"mergesort cmp = mergesort' cmp . map wrap\n"
"\n"
"mergesort' :: (a -> a -> Ordering) -> [[a]] -> [a]\n"
"mergesort' cmp [] = []\n"
"mergesort' cmp [xs] = xs\n"
"mergesort' cmp xss = mergesort' cmp (merge_pairs cmp xss)\n"
"\n"
"merge_pairs :: (a -> a -> Ordering) -> [[a]] -> [[a]]\n"
"merge_pairs cmp [] = []\n"
"merge_pairs cmp [xs] = [xs]\n"
"merge_pairs cmp (xs:ys:xss) = merge cmp xs ys : merge_pairs cmp xss\n"
"\n"
"merge :: (a -> a -> Ordering) -> [a] -> [a] -> [a]\n"
"merge cmp xs [] = xs\n"
"merge cmp [] ys = ys\n"
"merge cmp (x:xs) (y:ys)\n"
" = case x `cmp` y of\n"
"        GT -> y : merge cmp (x:xs)   ys\n"
"        _  -> x : merge cmp    xs (y:ys)\n"
"\n"
"wrap :: a -> [a]\n"
"wrap x = [x]\n"
"\n"
"{-\n"
"OLD: qsort version\n"
"\n"
"-- qsort is stable and does not concatenate.\n"
"qsort :: (a -> a -> Ordering) -> [a] -> [a] -> [a]\n"
"qsort _   []     r = r\n"
"qsort _   [x]    r = x:r\n"
"qsort cmp (x:xs) r = qpart cmp x xs [] [] r\n"
"\n"
"-- qpart partitions and sorts the sublists\n"
"qpart :: (a -> a -> Ordering) -> a -> [a] -> [a] -> [a] -> [a] -> [a]\n"
"qpart cmp x [] rlt rge r =\n"
"    -- rlt and rge are in reverse order and must be sorted with an\n"
"    -- anti-stable sorting\n"
"    rqsort cmp rlt (x:rqsort cmp rge r)\n"
"qpart cmp x (y:ys) rlt rge r =\n"
"    case cmp x y of\n"
"	GT -> qpart cmp x ys (y:rlt) rge r\n"
"        _  -> qpart cmp x ys rlt (y:rge) r\n"
"\n"
"-- rqsort is as qsort but anti-stable, i.e. reverses equal elements\n"
"rqsort :: (a -> a -> Ordering) -> [a] -> [a] -> [a]\n"
"rqsort _   []     r = r\n"
"rqsort _   [x]    r = x:r\n"
"rqsort cmp (x:xs) r = rqpart cmp x xs [] [] r\n"
"\n"
"rqpart :: (a -> a -> Ordering) -> a -> [a] -> [a] -> [a] -> [a] -> [a]\n"
"rqpart cmp x [] rle rgt r =\n"
"    qsort cmp rle (x:qsort cmp rgt r)\n"
"rqpart cmp x (y:ys) rle rgt r =\n"
"    case cmp y x of\n"
"	GT -> rqpart cmp x ys rle (y:rgt) r\n"
"    	_  -> rqpart cmp x ys (y:rle) rgt r\n"
"-}\n"
"\n"
"-- | The 'unfoldr' function is a \\`dual\\' to 'foldr': while 'foldr'\n"
"-- reduces a list to a summary value, 'unfoldr' builds a list from\n"
"-- a seed value.  The function takes the element and returns 'Nothing'\n"
"-- if it is done producing the list or returns 'Just' @(a,b)@, in which\n"
"-- case, @a@ is a prepended to the list and @b@ is used as the next\n"
"-- element in a recursive call.  For example,\n"
"--\n"
"-- > iterate f == unfoldr (\\x -> Just (x, f x))\n"
"--\n"
"-- In some cases, 'unfoldr' can undo a 'foldr' operation:\n"
"--\n"
"-- > unfoldr f' (foldr f z xs) == xs\n"
"--\n"
"-- if the following holds:\n"
"--\n"
"-- > f' (f x y) = Just (x,y)\n"
"-- > f' z       = Nothing\n"
"\n"
"unfoldr      :: (b -> Maybe (a, b)) -> b -> [a]\n"
"unfoldr f b  =\n"
"  case f b of\n"
"   Just (a,new_b) -> a : unfoldr f new_b\n"
"   Nothing        -> []\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"\n"
"-- | A strict version of 'foldl'.\n"
"foldl'           :: (a -> b -> a) -> a -> [b] -> a\n"
"foldl' f a []     = a\n"
"foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs\n"
"\n";
const char *Data_Ix = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Ix\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Class of index types.\n"
"--\n"
"-- The 'Ix' class is used to map a continuous subrange of values in a type onto\n"
"-- integers. It is used primarily for array indexing (see Section 6\n"
"-- <http://www.haskell.org/onlinelibrary/array.html#arrays>). The 'Ix'\n"
"-- class contains the methods range, index, and inRange. The 'index' operation\n"
"-- maps a bounding pair, which defines the lower and upper bounds of the range,\n"
"-- and a subscript, to an integer. The 'range' operation enumerates all\n"
"-- subscripts; the 'inRange' operation tells whether a particular subscript\n"
"-- lies in the range defined by a bounding pair.\n"
"-- \n"
"-- An implementation is entitled to assume the following laws about these\n"
"-- operations: \n"
"-- \n"
"-- >        range (l,u) !! index (l,u) i == i   -- when i is in range\n"
"-- \n"
"-- >        inRange (l,u) i == i `elem` range (l,u)\n"
"-- \n"
"-----------------------------------------------------------------------------\n"
"module Data.Ix\n"
"    (\n"
"	Ix\n"
"	  ( range	-- :: (Ix a) => (a,a) -> [a]\n"
"	  , index       -- :: (Ix a) => (a,a) -> a   -> Int\n"
"	  , inRange     -- :: (Ix a) => (a,a) -> a   -> Bool\n"
"	  , rangeSize	-- :: (Ix a) => (a,a) -> Int\n"
"	  )\n"
"    -- Ix instances:\n"
"    --\n"
"    --  Ix Char\n"
"    --  Ix Int\n"
"    --  Ix Integer\n"
"    --  Ix Bool\n"
"    --  Ix Ordering\n"
"    --  Ix ()\n"
"    --  (Ix a, Ix b) => Ix (a, b)\n"
"    --  ...\n"
"\n"
"    -- Implementation checked wrt. Haskell 98 lib report, 1/99.\n"
"\n"
"    -- * Deriving Instances of Ix\n"
"    -- | Derived instance declarations for the class 'Ix' are only possible\n"
"    -- for enumerations (i.e. datatypes having only nullary constructors)\n"
"    -- and single-constructor datatypes, including arbitrarily large tuples,\n"
"    -- whose constituent types are instances of 'Ix'. \n"
"    -- \n"
"    -- * For an enumeration, the nullary constructors are assumed to be\n"
"    -- numbered left-to-right with the indices being 0 to n-1 inclusive. This\n"
"    -- is the same numbering defined by the 'Enum' class. For example, given\n"
"    -- the datatype: \n"
"    -- \n"
"    -- >	data Colour = Red | Orange | Yellow | Green | Blue | Indigo | Violet\n"
"    -- \n"
"    -- we would have: \n"
"    -- \n"
"    -- >	range   (Yellow,Blue)        ==  [Yellow,Green,Blue]\n"
"    -- >	index   (Yellow,Blue) Green  ==  1\n"
"    -- >	inRange (Yellow,Blue) Red    ==  False\n"
"    -- \n"
"    -- * For single-constructor datatypes, the derived instance declarations\n"
"    -- are as shown for tuples in Figure 1\n"
"    -- <http://www.haskell.org/onlinelibrary/ix.html#prelude-index>.\n"
"\n"
"    ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Hugs.Prelude( Ix(..) )\n"
"\n";
const char *Data_Char = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Char\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- The Char type and associated operations.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Char \n"
"    (\n"
"      Char\n"
"\n"
"    , String\n"
"\n"
"    -- * Character classification\n"
"    -- | Unicode characters are divided into letters, numbers, marks,\n"
"    -- punctuation, symbols, separators (including spaces) and others\n"
"    -- (including control characters).\n"
"    -- The full set of Unicode character attributes is not accessible\n"
"    -- in this library.\n"
"    , isAscii, isLatin1, isControl, isSpace\n"
"    , isLower, isUpper,  isAlpha,   isAlphaNum, isPrint\n"
"    , isDigit, isOctDigit, isHexDigit  -- :: Char -> Bool\n"
"\n"
"    -- * Case conversion\n"
"    , toUpper, toLower  -- :: Char -> Char\n"
"\n"
"    -- * Single digit characters\n"
"    , digitToInt        -- :: Char -> Int\n"
"    , intToDigit        -- :: Int  -> Char\n"
"\n"
"    -- * Numeric representations\n"
"    , ord               -- :: Char -> Int\n"
"    , chr               -- :: Int  -> Char\n"
"\n"
"    -- * String representations\n"
"    , showLitChar       -- :: Char -> ShowS\n"
"    , lexLitChar	-- :: ReadS String\n"
"    , readLitChar       -- :: ReadS Char \n"
"\n"
"     -- Implementation checked wrt. Haskell 98 lib report, 1/99.\n"
"    ) where\n"
"\n"
"import Hugs.Char\n"
"\n"
"-- | Convert a single digit 'Char' to the corresponding 'Int'.  \n"
"-- This function fails unless its argument satisfies 'isHexDigit',\n"
"-- but recognises both upper and lower-case hexadecimal digits\n"
"-- (i.e. @\\'0\\'@..@\\'9\\'@, @\\'a\\'@..@\\'f\\'@, @\\'A\\'@..@\\'F\\'@).\n"
"digitToInt :: Char -> Int\n"
"digitToInt c\n"
" | isDigit c		=  ord c - ord '0'\n"
" | c >= 'a' && c <= 'f' =  ord c - ord 'a' + 10\n"
" | c >= 'A' && c <= 'F' =  ord c - ord 'A' + 10\n"
" | otherwise	        =  error (\"Char.digitToInt: not a digit \" ++ show c) -- sigh\n";
const char *Data_Complex = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Complex\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Complex numbers.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Complex\n"
"	( Complex((:+))\n"
"	\n"
"	, realPart	-- :: (RealFloat a) => Complex a -> a\n"
"	, imagPart      -- :: (RealFloat a) => Complex a -> a\n"
"	, conjugate     -- :: (RealFloat a) => Complex a -> Complex a\n"
"	, mkPolar       -- :: (RealFloat a) => a -> a -> Complex a\n"
"	, cis           -- :: (RealFloat a) => a -> Complex a\n"
"	, polar         -- :: (RealFloat a) => Complex a -> (a,a)\n"
"	, magnitude     -- :: (RealFloat a) => Complex a -> a\n"
"	, phase         -- :: (RealFloat a) => Complex a -> a\n"
"	\n"
"	-- Complex instances:\n"
"	--\n"
"	--  (RealFloat a) => Eq         (Complex a)\n"
"	--  (RealFloat a) => Read       (Complex a)\n"
"	--  (RealFloat a) => Show       (Complex a)\n"
"	--  (RealFloat a) => Num        (Complex a)\n"
"	--  (RealFloat a) => Fractional (Complex a)\n"
"	--  (RealFloat a) => Floating   (Complex a)\n"
"	-- \n"
"        -- Implementation checked wrt. Haskell 98 lib report, 1/99.\n"
"\n"
"        )  where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Typeable\n"
"\n"
"import Hugs.Prelude(Num(fromInt), Fractional(fromDouble))\n"
"\n"
"infix  6  :+\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- The Complex type\n"
"\n"
"data  (RealFloat a)     => Complex a = !a :+ !a  deriving (Eq, Read, Show)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Functions over Complex\n"
"\n"
"realPart, imagPart :: (RealFloat a) => Complex a -> a\n"
"realPart (x :+ _) =  x\n"
"imagPart (_ :+ y) =  y\n"
"\n"
"{-# SPECIALISE conjugate :: Complex Double -> Complex Double #-}\n"
"conjugate	 :: (RealFloat a) => Complex a -> Complex a\n"
"conjugate (x:+y) =  x :+ (-y)\n"
"\n"
"{-# SPECIALISE mkPolar :: Double -> Double -> Complex Double #-}\n"
"mkPolar		 :: (RealFloat a) => a -> a -> Complex a\n"
"mkPolar r theta	 =  r * cos theta :+ r * sin theta\n"
"\n"
"{-# SPECIALISE cis :: Double -> Complex Double #-}\n"
"cis		 :: (RealFloat a) => a -> Complex a\n"
"cis theta	 =  cos theta :+ sin theta\n"
"\n"
"{-# SPECIALISE polar :: Complex Double -> (Double,Double) #-}\n"
"polar		 :: (RealFloat a) => Complex a -> (a,a)\n"
"polar z		 =  (magnitude z, phase z)\n"
"\n"
"{-# SPECIALISE magnitude :: Complex Double -> Double #-}\n"
"magnitude :: (RealFloat a) => Complex a -> a\n"
"magnitude (x:+y) =  scaleFloat k\n"
"		     (sqrt ((scaleFloat mk x)^(2::Int) + (scaleFloat mk y)^(2::Int)))\n"
"		    where k  = max (exponent x) (exponent y)\n"
"		          mk = - k\n"
"\n"
"{-# SPECIALISE phase :: Complex Double -> Double #-}\n"
"phase :: (RealFloat a) => Complex a -> a\n"
"phase (0 :+ 0)   = 0		-- SLPJ July 97 from John Peterson\n"
"phase (x:+y)	 = atan2 y x\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Instances of Complex\n"
"\n"
"complexTc = mkTyCon \"Complex\"; instance Typeable a => Typeable (Complex a) where {   typeOf x = mkAppTy complexTc [typeOf ((undefined :: Complex a -> a) x) ] }\n"
"\n"
"instance  (RealFloat a) => Num (Complex a)  where\n"
"    {-# SPECIALISE instance Num (Complex Float) #-}\n"
"    {-# SPECIALISE instance Num (Complex Double) #-}\n"
"    (x:+y) + (x':+y')	=  (x+x') :+ (y+y')\n"
"    (x:+y) - (x':+y')	=  (x-x') :+ (y-y')\n"
"    (x:+y) * (x':+y')	=  (x*x'-y*y') :+ (x*y'+y*x')\n"
"    negate (x:+y)	=  negate x :+ negate y\n"
"    abs z		=  magnitude z :+ 0\n"
"    signum 0		=  0\n"
"    signum z@(x:+y)	=  x/r :+ y/r  where r = magnitude z\n"
"    fromInteger n	=  fromInteger n :+ 0\n"
"    fromInt n		=  fromInt n :+ 0\n"
"\n"
"instance  (RealFloat a) => Fractional (Complex a)  where\n"
"    {-# SPECIALISE instance Fractional (Complex Float) #-}\n"
"    {-# SPECIALISE instance Fractional (Complex Double) #-}\n"
"    (x:+y) / (x':+y')	=  (x*x''+y*y'') / d :+ (y*x''-x*y'') / d\n"
"			   where x'' = scaleFloat k x'\n"
"				 y'' = scaleFloat k y'\n"
"				 k   = - max (exponent x') (exponent y')\n"
"				 d   = x'*x'' + y'*y''\n"
"\n"
"    fromRational a	=  fromRational a :+ 0\n"
"    fromDouble a	=  fromDouble a :+ 0\n"
"\n"
"instance  (RealFloat a) => Floating (Complex a)	where\n"
"    {-# SPECIALISE instance Floating (Complex Float) #-}\n"
"    {-# SPECIALISE instance Floating (Complex Double) #-}\n"
"    pi             =  pi :+ 0\n"
"    exp (x:+y)     =  expx * cos y :+ expx * sin y\n"
"                      where expx = exp x\n"
"    log z          =  log (magnitude z) :+ phase z\n"
"\n"
"    sqrt 0         =  0\n"
"    sqrt z@(x:+y)  =  u :+ (if y < 0 then -v else v)\n"
"                      where (u,v) = if x < 0 then (v',u') else (u',v')\n"
"                            v'    = abs y / (u'*2)\n"
"                            u'    = sqrt ((magnitude z + abs x) / 2)\n"
"\n"
"    sin (x:+y)     =  sin x * cosh y :+ cos x * sinh y\n"
"    cos (x:+y)     =  cos x * cosh y :+ (- sin x * sinh y)\n"
"    tan (x:+y)     =  (sinx*coshy:+cosx*sinhy)/(cosx*coshy:+(-sinx*sinhy))\n"
"                      where sinx  = sin x\n"
"                            cosx  = cos x\n"
"                            sinhy = sinh y\n"
"                            coshy = cosh y\n"
"\n"
"    sinh (x:+y)    =  cos y * sinh x :+ sin  y * cosh x\n"
"    cosh (x:+y)    =  cos y * cosh x :+ sin y * sinh x\n"
"    tanh (x:+y)    =  (cosy*sinhx:+siny*coshx)/(cosy*coshx:+siny*sinhx)\n"
"                      where siny  = sin y\n"
"                            cosy  = cos y\n"
"                            sinhx = sinh x\n"
"                            coshx = cosh x\n"
"\n"
"    asin z@(x:+y)  =  y':+(-x')\n"
"                      where  (x':+y') = log (((-y):+x) + sqrt (1 - z*z))\n"
"    acos z         =  y'':+(-x'')\n"
"                      where (x'':+y'') = log (z + ((-y'):+x'))\n"
"                            (x':+y')   = sqrt (1 - z*z)\n"
"    atan z@(x:+y)  =  y':+(-x')\n"
"                      where (x':+y') = log (((1-y):+x) / sqrt (1+z*z))\n"
"\n"
"    asinh z        =  log (z + sqrt (1+z*z))\n"
"    acosh z        =  log (z + (z+1) * sqrt ((z-1)/(z+1)))\n"
"    atanh z        =  log ((1+z) / sqrt (1-z*z))\n";
const char *Data_Set = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Set\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- An implementation of sets, based on the \"Data.FiniteMap\".\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Set (\n"
"	-- * The @Set@ type\n"
"	Set,            -- abstract, instance of: Eq\n"
"\n"
"	-- * Construction\n"
"	emptySet,       -- :: Set a\n"
"	mkSet,          -- :: Ord a => [a]  -> Set a\n"
"	setToList,      -- :: Set a -> [a] \n"
"	unitSet,        -- :: a -> Set a\n"
"\n"
"	-- * Inspection\n"
"	elementOf,      -- :: Ord a => a -> Set a -> Bool\n"
"	isEmptySet,     -- :: Set a -> Bool\n"
"	cardinality,    -- :: Set a -> Int\n"
"\n"
"	-- * Operations\n"
"	union,          -- :: Ord a => Set a -> Set a -> Set a\n"
"	unionManySets,  -- :: Ord a => [Set a] -> Set a\n"
"	minusSet,       -- :: Ord a => Set a -> Set a -> Set a\n"
"	mapSet,         -- :: Ord a => (b -> a) -> Set b -> Set a\n"
"	intersect,      -- :: Ord a => Set a -> Set a -> Set a\n"
"	addToSet,      	-- :: Ord a => Set a -> a -> Set a\n"
"	delFromSet,    	-- :: Ord a => Set a -> a -> Set a\n"
"    ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.FiniteMap\n"
"import Data.Maybe\n"
"\n"
"-- This can't be a type synonym if you want to use constructor classes.\n"
"newtype Set a = MkSet (FiniteMap a ())\n"
"\n"
"emptySet :: Set a\n"
"emptySet = MkSet emptyFM\n"
"\n"
"unitSet :: a -> Set a\n"
"unitSet x = MkSet (unitFM x ())\n"
"\n"
"setToList :: Set a -> [a]\n"
"setToList (MkSet set) = keysFM set\n"
"\n"
"mkSet :: Ord a => [a]  -> Set a\n"
"mkSet xs = MkSet (listToFM [ (x, ()) | x <- xs])\n"
"\n"
"union :: Ord a => Set a -> Set a -> Set a\n"
"union (MkSet set1) (MkSet set2) = MkSet (plusFM set1 set2)\n"
"\n"
"unionManySets :: Ord a => [Set a] -> Set a\n"
"unionManySets ss = foldr union emptySet ss\n"
"\n"
"minusSet  :: Ord a => Set a -> Set a -> Set a\n"
"minusSet (MkSet set1) (MkSet set2) = MkSet (minusFM set1 set2)\n"
"\n"
"intersect :: Ord a => Set a -> Set a -> Set a\n"
"intersect (MkSet set1) (MkSet set2) = MkSet (intersectFM set1 set2)\n"
"\n"
"addToSet :: Ord a => Set a -> a -> Set a\n"
"addToSet (MkSet set) a = MkSet (addToFM set a ())\n"
"\n"
"delFromSet :: Ord a => Set a -> a -> Set a\n"
"delFromSet (MkSet set) a = MkSet (delFromFM set a)\n"
"\n"
"elementOf :: Ord a => a -> Set a -> Bool\n"
"elementOf x (MkSet set) = isJust (lookupFM set x)\n"
"\n"
"isEmptySet :: Set a -> Bool\n"
"isEmptySet (MkSet set) = sizeFM set == 0\n"
"\n"
"mapSet :: Ord a => (b -> a) -> Set b -> Set a\n"
"mapSet f (MkSet set) = MkSet (listToFM [ (f key, ()) | key <- keysFM set ])\n"
"\n"
"cardinality :: Set a -> Int\n"
"cardinality (MkSet set) = sizeFM set\n"
"\n"
"-- fair enough...\n"
"instance (Eq a) => Eq (Set a) where\n"
"  (MkSet set_1) == (MkSet set_2) = set_1 == set_2\n"
"  (MkSet set_1) /= (MkSet set_2) = set_1 /= set_2\n"
"\n"
"-- but not so clear what the right thing to do is:\n"
"{- NO:\n"
"instance (Ord a) => Ord (Set a) where\n"
"  (MkSet set_1) <= (MkSet set_2) = set_1 <= set_2\n"
"-}\n";
const char *Data_Either = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Either\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- The Either type, and associated operations.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Either (\n"
"   Either(..),\n"
"   either	-- :: (a -> c) -> (b -> c) -> Either a b -> c\n"
" ) where\n"
"\n";
const char *Data_FiniteMap = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.FiniteMap\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- A finite map implementation, derived from the paper:\n"
"-- 	   /Efficient sets: a balancing act/, S. Adams,\n"
"-- 	   Journal of functional programming 3(4) Oct 1993, pp553-562\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- ToDo: clean up, remove the COMPILING_GHC stuff.\n"
"\n"
"-- The code is SPECIALIZEd to various highly-desirable types (e.g., Id)\n"
"-- near the end (only \\tr{#ifdef COMPILING_GHC}).\n"
"\n"
"module Data.FiniteMap (\n"
"	-- * The @FiniteMap@ type\n"
"	FiniteMap,		-- abstract type\n"
"\n"
"	-- * Construction\n"
"	emptyFM, unitFM, listToFM,\n"
"\n"
"	-- * Lookup operations\n"
"	lookupFM, lookupWithDefaultFM,\n"
"	elemFM,\n"
"\n"
"	-- * Adding elements\n"
"	addToFM,\n"
"	addToFM_C,\n"
"	addListToFM,\n"
"	addListToFM_C,\n"
"\n"
"	-- * Deleting elements\n"
"	delFromFM ,\n"
"	delListFromFM,\n"
"\n"
"	-- * Combination\n"
"	plusFM,\n"
"	plusFM_C,\n"
"\n"
"	-- * Extracting information\n"
"	fmToList, keysFM, eltsFM,\n"
"	sizeFM, isEmptyFM,\n"
"\n"
"	-- * Other operations\n"
"	minusFM,\n"
"	foldFM,\n"
"	intersectFM ,\n"
"	intersectFM_C ,\n"
"	mapFM , filterFM ,\n"
"\n"
"	foldFM_GE, fmToList_GE, keysFM_GE, eltsFM_GE,\n"
"	foldFM_LE, fmToList_LE, keysFM_LE, eltsFM_LE,\n"
"\n"
"        minFM, maxFM,\n"
"\n"
"    ) where\n"
"\n"
"import Data.Maybe ( isJust )\n"
"\n"
"-- SIGH: but we use unboxed \"sizes\"...\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- The signature of the module\n"
"\n"
"-- | An empty 'FiniteMap'.\n"
"emptyFM		:: FiniteMap key elt\n"
"\n"
"-- | A 'FiniteMap' containing a single mapping\n"
"unitFM		:: key -> elt -> FiniteMap key elt\n"
"\n"
"-- | Makes a 'FiniteMap' from a list of @(key,value)@ pairs. In the\n"
"-- case of duplicates, the last is taken\n"
"listToFM	:: (Ord key {--}) => [(key,elt)] -> FiniteMap key elt\n"
"\n"
"--	ADDING AND DELETING\n"
"\n"
"-- | Adds an element to a 'FiniteMap'.  Any previous mapping with the same\n"
"-- key is overwritten.\n"
"addToFM		:: (Ord key {--}) => FiniteMap key elt -> key -> elt  -> FiniteMap key elt\n"
"\n"
"-- | Adds a list of elements to a 'FiniteMap', in the order given in\n"
"-- the list.  Overwrites previous mappings.\n"
"addListToFM	:: (Ord key {--}) => FiniteMap key elt -> [(key,elt)] -> FiniteMap key elt\n"
"\n"
"		   -- Combines with previous binding\n"
"		   -- In the combining function, the first argument is the \"old\" element,\n"
"		   -- while the second is the \"new\" one.\n"
"\n"
"-- | Adds an element to a 'FiniteMap'.  If there is already an element\n"
"-- with the same key, then the specified combination function is used\n"
"-- to calculate the new value. The already present element is passed as\n"
"-- the first argument and the new element to add as second.\n"
"addToFM_C	:: (Ord key {--}) => (elt -> elt -> elt)\n"
"			   -> FiniteMap key elt -> key -> elt\n"
"			   -> FiniteMap key elt\n"
"\n"
"-- | A list version of 'addToFM_C'.  The elements are added in the\n"
"-- order given in the list.\n"
"addListToFM_C	:: (Ord key {--}) => (elt -> elt -> elt)\n"
"			   -> FiniteMap key elt -> [(key,elt)]\n"
"			   -> FiniteMap key elt\n"
"\n"
"-- | Deletes an element from a 'FiniteMap'.  If there is no element with\n"
"-- the specified key, then the original 'FiniteMap' is returned.\n"
"delFromFM	:: (Ord key {--}) => FiniteMap key elt -> key   -> FiniteMap key elt\n"
"\n"
"-- | List version of 'delFromFM'.\n"
"delListFromFM	:: (Ord key {--}) => FiniteMap key elt -> [key] -> FiniteMap key elt\n"
"\n"
"-- | Combine two 'FiniteMap's.  Mappings in the second argument shadow\n"
"-- those in the first.\n"
"plusFM		:: (Ord key {--}) => FiniteMap key elt -> FiniteMap key elt\n"
"			   -> FiniteMap key elt\n"
"\n"
"-- | Combine two 'FiniteMap's.  The specified combination function is\n"
"-- used to calculate the new value when there are two elements with\n"
"-- the same key.\n"
"plusFM_C	:: (Ord key {--}) => (elt -> elt -> elt)\n"
"			   -> FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt\n"
"\n"
"-- | @(minusFM a1 a2)@ deletes from @a1@ any mappings which are bound in @a2@\n"
"minusFM		:: (Ord key {--}) => FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt\n"
"\n"
"-- | @(intersectFM a1 a2)@ returns a new 'FiniteMap' containing\n"
"-- mappings from @a1@ for which @a2@ also has a mapping with the same\n"
"-- key.\n"
"intersectFM	:: (Ord key {--}) => FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt\n"
"\n"
"-- | Returns the interesction of two mappings, using the specified\n"
"-- combination function to combine values.\n"
"intersectFM_C	:: (Ord key {--}) => (elt1 -> elt2 -> elt3)\n"
"			   -> FiniteMap key elt1 -> FiniteMap key elt2 -> FiniteMap key elt3\n"
"\n"
"--	MAPPING, FOLDING, FILTERING\n"
"foldFM		:: (key -> elt -> a -> a) -> a -> FiniteMap key elt -> a\n"
"mapFM		:: (key -> elt1 -> elt2) -> FiniteMap key elt1 -> FiniteMap key elt2\n"
"filterFM	:: (Ord key {--}) => (key -> elt -> Bool)\n"
"			   -> FiniteMap key elt -> FiniteMap key elt\n"
"\n"
"--	INTERROGATING\n"
"sizeFM		:: FiniteMap key elt -> Int\n"
"isEmptyFM	:: FiniteMap key elt -> Bool\n"
"\n"
"-- | Returns 'True' if the specified @key@ has a mapping in this\n"
"-- 'FiniteMap', or 'False' otherwise.\n"
"elemFM		:: (Ord key {--}) => key -> FiniteMap key elt -> Bool\n"
"\n"
"-- | Looks up a key in a 'FiniteMap', returning @'Just' v@ if the key\n"
"-- was found with value @v@, or 'Nothing' otherwise.\n"
"lookupFM	:: (Ord key {--}) => FiniteMap key elt -> key -> Maybe elt\n"
"\n"
"-- | Looks up a key in a 'FiniteMap', returning @elt@ if the specified\n"
"-- @key@ was not found.\n"
"lookupWithDefaultFM\n"
"		:: (Ord key {--}) => FiniteMap key elt -> elt -> key -> elt\n"
"		-- lookupWithDefaultFM supplies a \"default\" elt\n"
"		-- to return for an unmapped key\n"
"\n"
"--	LISTIFYING\n"
"\n"
"-- | Convert a 'FiniteMap' to a @[(key, elt)]@ sorted by 'Ord' key\n"
"--\n"
"fmToList	:: FiniteMap key elt -> [(key,elt)]\n"
"\n"
"-- | Extract the keys from a 'FiniteMap', in the order of the keys, so\n"
"--\n"
"-- > keysFM == map fst . fmToList\n"
"--\n"
"keysFM		:: FiniteMap key elt -> [key]\n"
"\n"
"-- | Extract the elements from a 'FiniteMap', in the order of the keys, so\n"
"--\n"
"-- > eltsFM == map snd . fmToList\n"
"--\n"
"eltsFM		:: FiniteMap key elt -> [elt]\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- The @FiniteMap@ data type, and building of same\n"
"\n"
"-- Invariants about @FiniteMap@:\n"
"--\n"
"-- *  all keys in a FiniteMap are distinct\n"
"--\n"
"-- * all keys in left  subtree are $<$ key in Branch and\n"
"--   all keys in right subtree are $>$ key in Branch\n"
"-- \n"
"-- * size field of a Branch gives number of Branch nodes in the tree\n"
"-- \n"
"-- * size of left subtree is differs from size of right subtree by a\n"
"--   factor of at most \\tr{sIZE_RATIO}\n"
"\n"
"-- | A mapping from @key@s to @elt@s.\n"
"data FiniteMap key elt\n"
"  = EmptyFM\n"
"  | Branch key elt	    	-- Key and elt stored here\n"
"    Int{-STRICT-}	-- Size >= 1\n"
"    (FiniteMap key elt)	    	-- Children\n"
"    (FiniteMap key elt)\n"
"\n"
"emptyFM = EmptyFM\n"
"{-\n"
"emptyFM\n"
"  = Branch bottom bottom 0 bottom bottom\n"
"  where\n"
"    bottom = panic \"emptyFM\"\n"
"-}\n"
"\n"
"--  #define EmptyFM (Branch _ _ 0 _ _)\n"
"\n"
"unitFM key elt = Branch key elt 1 emptyFM emptyFM\n"
"\n"
"listToFM = addListToFM emptyFM\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Adding to and deleting from @FiniteMaps@\n"
"\n"
"addToFM fm key elt = addToFM_C (\\ old new -> new) fm key elt\n"
"\n"
"addToFM_C combiner EmptyFM key elt = unitFM key elt\n"
"addToFM_C combiner (Branch key elt size fm_l fm_r) new_key new_elt\n"
"  | new_key < key = mkBalBranch key elt (addToFM_C combiner fm_l new_key new_elt) fm_r\n"
"  | new_key > key = mkBalBranch key elt fm_l (addToFM_C combiner fm_r new_key new_elt)\n"
"  | otherwise	  = Branch new_key (combiner elt new_elt) size fm_l fm_r\n"
"\n"
"addListToFM fm key_elt_pairs = addListToFM_C (\\ old new -> new) fm key_elt_pairs\n"
"\n"
"addListToFM_C combiner fm key_elt_pairs\n"
"  = foldl add fm key_elt_pairs	-- foldl adds from the left\n"
"  where\n"
"    add fmap (key,elt) = addToFM_C combiner fmap key elt\n"
"\n"
"delFromFM EmptyFM del_key = emptyFM\n"
"delFromFM (Branch key elt size fm_l fm_r) del_key\n"
"  | del_key > key\n"
"  = mkBalBranch key elt fm_l (delFromFM fm_r del_key)\n"
"\n"
"  | del_key < key\n"
"  = mkBalBranch key elt (delFromFM fm_l del_key) fm_r\n"
"\n"
"  | key == del_key\n"
"  = glueBal fm_l fm_r\n"
"\n"
"delListFromFM fm keys = foldl delFromFM fm keys\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Combining @FiniteMaps@\n"
"\n"
"plusFM_C combiner EmptyFM fm2 = fm2\n"
"plusFM_C combiner fm1 EmptyFM = fm1\n"
"plusFM_C combiner fm1 (Branch split_key elt2 _ left right)\n"
"  = mkVBalBranch split_key new_elt\n"
"		 (plusFM_C combiner lts left)\n"
"		 (plusFM_C combiner gts right)\n"
"  where\n"
"    lts     = splitLT fm1 split_key\n"
"    gts     = splitGT fm1 split_key\n"
"    new_elt = case lookupFM fm1 split_key of\n"
"		Nothing   -> elt2\n"
"		Just elt1 -> combiner elt1 elt2\n"
"\n"
"-- It's worth doing plusFM specially, because we don't need\n"
"-- to do the lookup in fm1.\n"
"\n"
"plusFM EmptyFM fm2 = fm2\n"
"plusFM fm1 EmptyFM = fm1\n"
"plusFM fm1 (Branch split_key elt1 _ left right)\n"
"  = mkVBalBranch split_key elt1 (plusFM lts left) (plusFM gts right)\n"
"  where\n"
"    lts     = splitLT fm1 split_key\n"
"    gts     = splitGT fm1 split_key\n"
"\n"
"minusFM EmptyFM fm2 = emptyFM\n"
"minusFM fm1 EmptyFM = fm1\n"
"minusFM fm1 (Branch split_key elt _ left right)\n"
"  = glueVBal (minusFM lts left) (minusFM gts right)\n"
"	-- The two can be way different, so we need glueVBal\n"
"  where\n"
"    lts = splitLT fm1 split_key		-- NB gt and lt, so the equal ones\n"
"    gts = splitGT fm1 split_key		-- are not in either.\n"
"\n"
"intersectFM fm1 fm2 = intersectFM_C (\\ left right -> right) fm1 fm2\n"
"\n"
"intersectFM_C combiner fm1 EmptyFM = emptyFM\n"
"intersectFM_C combiner EmptyFM fm2 = emptyFM\n"
"intersectFM_C combiner fm1 (Branch split_key elt2 _ left right)\n"
"\n"
"  | isJust maybe_elt1	-- split_elt *is* in intersection\n"
"  = mkVBalBranch split_key (combiner elt1 elt2) (intersectFM_C combiner lts left)\n"
"						(intersectFM_C combiner gts right)\n"
"\n"
"  | otherwise			-- split_elt is *not* in intersection\n"
"  = glueVBal (intersectFM_C combiner lts left) (intersectFM_C combiner gts right)\n"
"\n"
"  where\n"
"    lts = splitLT fm1 split_key		-- NB gt and lt, so the equal ones\n"
"    gts = splitGT fm1 split_key		-- are not in either.\n"
"\n"
"    maybe_elt1 = lookupFM fm1 split_key\n"
"    Just elt1  = maybe_elt1\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Mapping, folding, and filtering with @FiniteMaps@\n"
"\n"
"foldFM k z EmptyFM = z\n"
"foldFM k z (Branch key elt _ fm_l fm_r)\n"
"  = foldFM k (k key elt (foldFM k z fm_r)) fm_l\n"
"\n"
"mapFM f EmptyFM = emptyFM\n"
"mapFM f (Branch key elt size fm_l fm_r)\n"
"  = Branch key (f key elt) size (mapFM f fm_l) (mapFM f fm_r)\n"
"\n"
"filterFM p EmptyFM = emptyFM\n"
"filterFM p (Branch key elt _ fm_l fm_r)\n"
"  | p key elt		-- Keep the item\n"
"  = mkVBalBranch key elt (filterFM p fm_l) (filterFM p fm_r)\n"
"\n"
"  | otherwise		-- Drop the item\n"
"  = glueVBal (filterFM p fm_l) (filterFM p fm_r)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Interrogating @FiniteMaps@\n"
"\n"
"--{-# INLINE sizeFM #-}\n"
"sizeFM EmptyFM		     = 0\n"
"sizeFM (Branch _ _ size _ _) =  size\n"
"\n"
"isEmptyFM fm = sizeFM fm == 0\n"
"\n"
"lookupFM EmptyFM key = Nothing\n"
"lookupFM (Branch key elt _ fm_l fm_r) key_to_find\n"
"  | key_to_find < key = lookupFM fm_l key_to_find\n"
"  | key_to_find > key = lookupFM fm_r key_to_find\n"
"  | otherwise	  = Just elt\n"
"\n"
"key `elemFM` fm\n"
"  = case (lookupFM fm key) of { Nothing -> False; Just elt -> True }\n"
"\n"
"lookupWithDefaultFM fm deflt key\n"
"  = case (lookupFM fm key) of { Nothing -> deflt; Just elt -> elt }\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Listifying @FiniteMaps@\n"
"\n"
"fmToList fm = foldFM (\\ key elt rest -> (key,elt) : rest) [] fm\n"
"keysFM fm   = foldFM (\\ key elt rest -> key : rest)       [] fm\n"
"eltsFM fm   = foldFM (\\ key elt rest -> elt : rest)       [] fm\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Bulk operations on all keys >= or <=	a certain threshold\n"
"\n"
"-- | Fold through all elements greater than or equal to the supplied key,\n"
"-- in increasing order.\n"
"foldFM_GE       :: Ord key => (key -> elt -> a -> a) -> a -> key ->\n"
"   FiniteMap key elt -> a\n"
"\n"
"foldFM_GE k z fr EmptyFM = z\n"
"foldFM_GE k z fr (Branch key elt _ fm_l fm_r)\n"
"  | key >= fr = foldFM_GE k (k key elt (foldFM_GE k z fr fm_r)) fr fm_l\n"
"  | otherwise = foldFM_GE k z fr fm_r\n"
"\n"
"-- | List elements greater than or equal to the supplied key, in increasing\n"
"-- order\n"
"fmToList_GE      :: Ord key => FiniteMap key elt -> key ->  [(key,elt)]\n"
"fmToList_GE fm fr = foldFM_GE (\\ key elt rest -> (key,elt) : rest) [] fr fm\n"
"\n"
"-- | List keys greater than or equal to the supplied key, in increasing order\n"
"keysFM_GE       :: Ord key => FiniteMap key elt -> key -> [key]\n"
"keysFM_GE fm fr  = foldFM_GE (\\ key elt rest -> key : rest)       [] fr fm\n"
"\n"
"-- | List elements corresponding to keys greater than or equal to the supplied\n"
"-- key, in increasing order of key.\n"
"eltsFM_GE       :: Ord key => FiniteMap key elt -> key -> [elt]\n"
"eltsFM_GE fm fr  = foldFM_GE (\\ key elt rest -> elt : rest)       [] fr fm\n"
"\n"
"-- | Fold through all elements less than or equal to the supplied key,\n"
"-- in decreasing order.\n"
"foldFM_LE       :: Ord key => (key -> elt -> a -> a) -> a -> key ->\n"
"   FiniteMap key elt -> a\n"
"foldFM_LE k z fr EmptyFM = z\n"
"foldFM_LE k z fr (Branch key elt _ fm_l fm_r)\n"
"  | key <= fr = foldFM_LE k (k key elt (foldFM_LE k z fr fm_l)) fr fm_r\n"
"  | otherwise = foldFM_LE k z fr fm_l\n"
"\n"
"-- | List elements greater than or equal to the supplied key, in decreasing\n"
"-- order\n"
"fmToList_LE      :: Ord key => FiniteMap key elt -> key ->  [(key,elt)]\n"
"fmToList_LE fm fr = foldFM_LE (\\ key elt rest -> (key,elt) : rest) [] fr fm\n"
"\n"
"-- | List keys greater than or equal to the supplied key, in decreasing order\n"
"keysFM_LE       :: Ord key => FiniteMap key elt -> key -> [key]\n"
"keysFM_LE fm fr  = foldFM_LE (\\ key elt rest -> key : rest)       [] fr fm\n"
"\n"
"-- | List elements corresponding to keys greater than or equal to the supplied\n"
"-- key, in decreasing order of key.\n"
"eltsFM_LE       :: Ord key => FiniteMap key elt -> key -> [elt]\n"
"eltsFM_LE fm fr  = foldFM_LE (\\ key elt rest -> elt : rest)       [] fr fm\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Getting minimum and maximum key out.\n"
"-- ---------------------------------------------------------------------------\n"
"\n"
"-- | Extract minimum key, or Nothing if the map is empty.\n"
"minFM :: Ord key => FiniteMap key elt -> Maybe key\n"
"minFM EmptyFM = Nothing\n"
"minFM (Branch key _ _ fm_l _) =\n"
"   case minFM fm_l of\n"
"      Nothing -> Just key\n"
"      Just key1 -> Just key1\n"
"\n"
"-- | Extract maximum key, or Nothing if the map is empty.\n"
"maxFM :: Ord key => FiniteMap key elt -> Maybe key\n"
"maxFM EmptyFM = Nothing\n"
"maxFM (Branch key _ _ _ fm_r) =\n"
"   case maxFM fm_r of\n"
"      Nothing -> Just key\n"
"      Just key1 -> Just key1\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- The implementation of balancing\n"
"\n"
"-- Basic construction of a @FiniteMap@:\n"
"\n"
"-- @mkBranch@ simply gets the size component right.  This is the ONLY\n"
"-- (non-trivial) place the Branch object is built, so the ASSERTion\n"
"-- recursively checks consistency.  (The trivial use of Branch is in\n"
"-- @unitFM@.)\n"
"\n"
"sIZE_RATIO :: Int\n"
"sIZE_RATIO = 5\n"
"\n"
"mkBranch :: (Ord key {--}) 		-- Used for the assertion checking only\n"
"	 => Int\n"
"	 -> key -> elt\n"
"	 -> FiniteMap key elt -> FiniteMap key elt\n"
"	 -> FiniteMap key elt\n"
"\n"
"mkBranch which key elt fm_l fm_r\n"
"  = --{--}\n"
"    let\n"
"	result = Branch key elt (unbox (1 + left_size + right_size)) fm_l fm_r\n"
"    in\n"
"--    if sizeFM result <= 8 then\n"
"	result\n"
"--    else\n"
"--	pprTrace (\"mkBranch:\"++(show which)) (ppr PprDebug result) (\n"
"--	result\n"
"--	)\n"
"  where\n"
"    left_ok  = case fm_l of\n"
"		EmptyFM		         -> True\n"
"		Branch left_key _ _ _ _  -> let\n"
"						biggest_left_key = fst (findMax fm_l)\n"
"					    in\n"
"					    biggest_left_key < key\n"
"    right_ok = case fm_r of\n"
"		EmptyFM		         -> True\n"
"		Branch right_key _ _ _ _ -> let\n"
"						smallest_right_key = fst (findMin fm_r)\n"
"					    in\n"
"					    key < smallest_right_key\n"
"    balance_ok = True -- sigh\n"
"{- LATER:\n"
"    balance_ok\n"
"      = -- Both subtrees have one or no elements...\n"
"	(left_size + right_size <= 1)\n"
"-- NO	      || left_size == 0  -- ???\n"
"-- NO	      || right_size == 0 -- ???\n"
"    	-- ... or the number of elements in a subtree does not exceed\n"
"	-- sIZE_RATIO times the number of elements in the other subtree\n"
"      || (left_size  * sIZE_RATIO >= right_size &&\n"
"    	  right_size * sIZE_RATIO >= left_size)\n"
"-}\n"
"\n"
"    left_size  = sizeFM fm_l\n"
"    right_size = sizeFM fm_r\n"
"\n"
"    unbox :: Int -> Int\n"
"    unbox x = x\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- {\\em Balanced} construction of a @FiniteMap@\n"
"\n"
"-- @mkBalBranch@ rebalances, assuming that the subtrees aren't too far\n"
"-- out of whack.\n"
"\n"
"mkBalBranch :: (Ord key {--})\n"
"	    => key -> elt\n"
"	    -> FiniteMap key elt -> FiniteMap key elt\n"
"	    -> FiniteMap key elt\n"
"\n"
"mkBalBranch key elt fm_L fm_R\n"
"\n"
"  | size_l + size_r < 2\n"
"  = mkBranch 1{-which-} key elt fm_L fm_R\n"
"\n"
"  | size_r > sIZE_RATIO * size_l	-- Right tree too big\n"
"  = case fm_R of\n"
"	Branch _ _ _ fm_rl fm_rr\n"
"		| sizeFM fm_rl < 2 * sizeFM fm_rr -> single_L fm_L fm_R\n"
"		| otherwise	   	          -> double_L fm_L fm_R\n"
"	-- Other case impossible\n"
"\n"
"  | size_l > sIZE_RATIO * size_r	-- Left tree too big\n"
"  = case fm_L of\n"
"	Branch _ _ _ fm_ll fm_lr\n"
"		| sizeFM fm_lr < 2 * sizeFM fm_ll -> single_R fm_L fm_R\n"
"		| otherwise		          -> double_R fm_L fm_R\n"
"	-- Other case impossible\n"
"\n"
"  | otherwise				-- No imbalance\n"
"  = mkBranch 2{-which-} key elt fm_L fm_R\n"
"\n"
"  where\n"
"    size_l   = sizeFM fm_L\n"
"    size_r   = sizeFM fm_R\n"
"\n"
"    single_L fm_l (Branch key_r elt_r _ fm_rl fm_rr)\n"
"	= mkBranch 3{-which-} key_r elt_r (mkBranch 4{-which-} key elt fm_l fm_rl) fm_rr\n"
"\n"
"    double_L fm_l (Branch key_r elt_r _ (Branch key_rl elt_rl _ fm_rll fm_rlr) fm_rr)\n"
"	= mkBranch 5{-which-} key_rl elt_rl (mkBranch 6{-which-} key   elt   fm_l   fm_rll)\n"
"				 (mkBranch 7{-which-} key_r elt_r fm_rlr fm_rr)\n"
"\n"
"    single_R (Branch key_l elt_l _ fm_ll fm_lr) fm_r\n"
"	= mkBranch 8{-which-} key_l elt_l fm_ll (mkBranch 9{-which-} key elt fm_lr fm_r)\n"
"\n"
"    double_R (Branch key_l elt_l _ fm_ll (Branch key_lr elt_lr _ fm_lrl fm_lrr)) fm_r\n"
"	= mkBranch 10{-which-} key_lr elt_lr (mkBranch 11{-which-} key_l elt_l fm_ll  fm_lrl)\n"
"				 (mkBranch 12{-which-} key   elt   fm_lrr fm_r)\n"
"\n"
"mkVBalBranch :: (Ord key {--})\n"
"	     => key -> elt\n"
"	     -> FiniteMap key elt -> FiniteMap key elt\n"
"	     -> FiniteMap key elt\n"
"\n"
"-- Assert: in any call to (mkVBalBranch_C comb key elt l r),\n"
"--	   (a) all keys in l are < all keys in r\n"
"--	   (b) all keys in l are < key\n"
"--	   (c) all keys in r are > key\n"
"\n"
"mkVBalBranch key elt EmptyFM fm_r = addToFM fm_r key elt\n"
"mkVBalBranch key elt fm_l EmptyFM = addToFM fm_l key elt\n"
"\n"
"mkVBalBranch key elt fm_l@(Branch key_l elt_l _ fm_ll fm_lr)\n"
"		     fm_r@(Branch key_r elt_r _ fm_rl fm_rr)\n"
"  | sIZE_RATIO * size_l < size_r\n"
"  = mkBalBranch key_r elt_r (mkVBalBranch key elt fm_l fm_rl) fm_rr\n"
"\n"
"  | sIZE_RATIO * size_r < size_l\n"
"  = mkBalBranch key_l elt_l fm_ll (mkVBalBranch key elt fm_lr fm_r)\n"
"\n"
"  | otherwise\n"
"  = mkBranch 13{-which-} key elt fm_l fm_r\n"
"\n"
"  where\n"
"    size_l = sizeFM fm_l\n"
"    size_r = sizeFM fm_r\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Gluing two trees together\n"
"\n"
"-- @glueBal@ assumes its two arguments aren't too far out of whack, just\n"
"-- like @mkBalBranch@.  But: all keys in first arg are $<$ all keys in\n"
"-- second.\n"
"\n"
"glueBal :: (Ord key {--})\n"
"	=> FiniteMap key elt -> FiniteMap key elt\n"
"	-> FiniteMap key elt\n"
"\n"
"glueBal EmptyFM fm2 = fm2\n"
"glueBal fm1 EmptyFM = fm1\n"
"glueBal fm1 fm2\n"
"	-- The case analysis here (absent in Adams' program) is really to deal\n"
"	-- with the case where fm2 is a singleton. Then deleting the minimum means\n"
"	-- we pass an empty tree to mkBalBranch, which breaks its invariant.\n"
"  | sizeFM fm2 > sizeFM fm1\n"
"  = mkBalBranch mid_key2 mid_elt2 fm1 (deleteMin fm2)\n"
"\n"
"  | otherwise\n"
"  = mkBalBranch mid_key1 mid_elt1 (deleteMax fm1) fm2\n"
"  where\n"
"    (mid_key1, mid_elt1) = findMax fm1\n"
"    (mid_key2, mid_elt2) = findMin fm2\n"
"\n"
"-- @glueVBal@ copes with arguments which can be of any size.\n"
"-- But: all keys in first arg are $<$ all keys in second.\n"
"\n"
"glueVBal :: (Ord key {--})\n"
"	 => FiniteMap key elt -> FiniteMap key elt\n"
"	 -> FiniteMap key elt\n"
"\n"
"glueVBal EmptyFM fm2 = fm2\n"
"glueVBal fm1 EmptyFM = fm1\n"
"glueVBal fm_l@(Branch key_l elt_l _ fm_ll fm_lr)\n"
"	 fm_r@(Branch key_r elt_r _ fm_rl fm_rr)\n"
"  | sIZE_RATIO * size_l < size_r\n"
"  = mkBalBranch key_r elt_r (glueVBal fm_l fm_rl) fm_rr\n"
"\n"
"  | sIZE_RATIO * size_r < size_l\n"
"  = mkBalBranch key_l elt_l fm_ll (glueVBal fm_lr fm_r)\n"
"\n"
"  | otherwise		-- We now need the same two cases as in glueBal above.\n"
"  = glueBal fm_l fm_r\n"
"  where\n"
"    size_l = sizeFM fm_l\n"
"    size_r = sizeFM fm_r\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Local utilities\n"
"\n"
"splitLT, splitGT :: (Ord key {--}) => FiniteMap key elt -> key -> FiniteMap key elt\n"
"\n"
"-- splitLT fm split_key  =  fm restricted to keys <  split_key\n"
"-- splitGT fm split_key  =  fm restricted to keys >  split_key\n"
"\n"
"splitLT EmptyFM split_key = emptyFM\n"
"splitLT (Branch key elt _ fm_l fm_r) split_key\n"
"  | split_key < key = splitLT fm_l split_key\n"
"  | split_key > key = mkVBalBranch key elt fm_l (splitLT fm_r split_key)\n"
"  | otherwise	    = fm_l\n"
"\n"
"splitGT EmptyFM split_key = emptyFM\n"
"splitGT (Branch key elt _ fm_l fm_r) split_key\n"
"  | split_key > key = splitGT fm_r split_key\n"
"  | split_key < key = mkVBalBranch key elt (splitGT fm_l split_key) fm_r\n"
"  | otherwise	    = fm_r\n"
"\n"
"findMin :: FiniteMap key elt -> (key,elt)\n"
"findMin (Branch key elt _ EmptyFM _) = (key,elt)\n"
"findMin (Branch key elt _ fm_l    _) = findMin fm_l\n"
"\n"
"deleteMin :: (Ord key {--}) => FiniteMap key elt -> FiniteMap key elt\n"
"deleteMin (Branch key elt _ EmptyFM fm_r) = fm_r\n"
"deleteMin (Branch key elt _ fm_l    fm_r) = mkBalBranch key elt (deleteMin fm_l) fm_r\n"
"\n"
"findMax :: FiniteMap key elt -> (key,elt)\n"
"findMax (Branch key elt _ _ EmptyFM) = (key,elt)\n"
"findMax (Branch key elt _ _    fm_r) = findMax fm_r\n"
"\n"
"deleteMax :: (Ord key {--}) => FiniteMap key elt -> FiniteMap key elt\n"
"deleteMax (Branch key elt _ fm_l EmptyFM) = fm_l\n"
"deleteMax (Branch key elt _ fm_l    fm_r) = mkBalBranch key elt fm_l (deleteMax fm_r)\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Output-ery\n"
"\n"
"instance (Eq key, Eq elt) => Eq (FiniteMap key elt) where\n"
"  fm_1 == fm_2 = (sizeFM   fm_1 == sizeFM   fm_2) &&   -- quick test\n"
"		 (fmToList fm_1 == fmToList fm_2)\n"
"\n"
"{- NO: not clear what The Right Thing to do is:\n"
"instance (Ord key, Ord elt) => Ord (FiniteMap key elt) where\n"
"  fm_1 <= fm_2 = (sizeFM   fm_1 <= sizeFM   fm_2) &&   -- quick test\n"
"		 (fmToList fm_1 <= fmToList fm_2)\n"
"-}\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Efficiency pragmas for GHC\n"
"\n"
"-- When the FiniteMap module is used in GHC, we specialise it for\n"
"-- \\tr{Uniques}, for dastardly efficiency reasons.\n"
"\n";
const char *Data_HashTable = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.HashTable\n"
"-- Copyright   :  (c) The University of Glasgow 2003\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"--\n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- An implementation of extensible hash tables, as described in\n"
"-- Per-Ake Larson, /Dynamic Hash Tables/, CACM 31(4), April 1988,\n"
"-- pp. 446--457.  The implementation is also derived from the one\n"
"-- in GHC's runtime system (@ghc\\/rts\\/Hash.{c,h}@).\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.HashTable (\n"
"	-- * Basic hash table operations\n"
"	HashTable, new, insert, delete, lookup,\n"
"	-- * Converting to and from lists\n"
"	fromList, toList,\n"
"	-- * Hash functions\n"
"	-- $hash_functions\n"
"	hashInt, hashString,\n"
"	prime,\n"
"	-- * Diagnostics\n"
"	longestChain\n"
" ) where\n"
"\n"
"-- This module is imported by Data.Dynamic, which is pretty low down in the\n"
"-- module hierarchy, so don't import \"high-level\" modules\n"
"\n"
"import Prelude	hiding	( lookup )\n"
"import Data.Tuple	( fst )\n"
"import Data.Bits\n"
"import Data.Maybe\n"
"import Data.List	( maximumBy, filter, length, concat )\n"
"import Data.Int		( Int32 )\n"
"\n"
"import Data.Char	( ord )\n"
"import Data.IORef	( IORef, newIORef, readIORef, writeIORef )\n"
"import Hugs.IOArray	( IOArray, newIOArray, readIOArray, writeIOArray,\n"
"			  unsafeReadIOArray, unsafeWriteIOArray )\n"
"import Control.Monad	( when, mapM, sequence_ )\n"
"\n"
"-----------------------------------------------------------------------\n"
"myReadArray  :: IOArray Int32 a -> Int32 -> IO a\n"
"myWriteArray :: IOArray Int32 a -> Int32 -> a -> IO ()\n"
"myReadArray arr i = unsafeReadIOArray arr (fromIntegral i)\n"
"myWriteArray arr i x = unsafeWriteIOArray arr (fromIntegral i) x\n"
"\n"
"-- | A hash table mapping keys of type @key@ to values of type @val@.\n"
"--\n"
"-- The implementation will grow the hash table as necessary, trying to\n"
"-- maintain a reasonable average load per bucket in the table.\n"
"--\n"
"newtype HashTable key val = HashTable (IORef (HT key val))\n"
"-- TODO: the IORef should really be an MVar.\n"
"\n"
"data HT key val\n"
"  = HT {\n"
"	split  :: !Int32, -- Next bucket to split when expanding\n"
"	max_bucket :: !Int32, -- Max bucket of smaller table\n"
"	mask1  :: !Int32, -- Mask for doing the mod of h_1 (smaller table)\n"
"	mask2  :: !Int32, -- Mask for doing the mod of h_2 (larger table)\n"
"	kcount :: !Int32, -- Number of keys\n"
"	bcount :: !Int32, -- Number of buckets\n"
"	dir    :: !(IOArray Int32 (IOArray Int32 [(key,val)])),\n"
"	hash_fn :: key -> Int32,\n"
"	cmp    :: key -> key -> Bool\n"
"   }\n"
"\n"
"{-\n"
"ALTERNATIVE IMPLEMENTATION:\n"
"\n"
"This works out slightly slower, because there's a tradeoff between\n"
"allocating a complete new HT structure each time a modification is\n"
"made (in the version above), and allocating new Int32s each time one\n"
"of them is modified, as below.  Using FastMutInt instead of IORef\n"
"Int32 helps, but yields an implementation which has about the same\n"
"performance as the version above (and is more complex).\n"
"\n"
"data HashTable key val\n"
"  = HashTable {\n"
"	split  :: !(IORef Int32), -- Next bucket to split when expanding\n"
"	max_bucket :: !(IORef Int32), -- Max bucket of smaller table\n"
"	mask1  :: !(IORef Int32), -- Mask for doing the mod of h_1 (smaller table)\n"
"	mask2  :: !(IORef Int32), -- Mask for doing the mod of h_2 (larger table)\n"
"	kcount :: !(IORef Int32), -- Number of keys\n"
"	bcount :: !(IORef Int32), -- Number of buckets\n"
"	dir    :: !(IOArray Int32 (IOArray Int32 [(key,val)])),\n"
"	hash_fn :: key -> Int32,\n"
"	cmp    :: key -> key -> Bool\n"
"   }\n"
"-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Sample hash functions\n"
"\n"
"-- $hash_functions\n"
"--\n"
"-- This implementation of hash tables uses the low-order /n/ bits of the hash\n"
"-- value for a key, where /n/ varies as the hash table grows.  A good hash\n"
"-- function therefore will give an even distribution regardless of /n/.\n"
"--\n"
"-- If your keyspace is integrals such that the low-order bits between\n"
"-- keys are highly variable, then you could get away with using 'id'\n"
"-- as the hash function.\n"
"--\n"
"-- We provide some sample hash functions for 'Int' and 'String' below.\n"
"\n"
"-- | A sample hash function for 'Int', implemented as simply @(x `mod` P)@\n"
"-- where P is a suitable prime (currently 1500007).  Should give\n"
"-- reasonable results for most distributions of 'Int' values, except\n"
"-- when the keys are all multiples of the prime!\n"
"--\n"
"hashInt :: Int -> Int32\n"
"hashInt = (`rem` prime) . fromIntegral\n"
"\n"
"-- | A sample hash function for 'String's.  The implementation is:\n"
"--\n"
"-- >    hashString = fromIntegral . foldr f 0\n"
"-- >      where f c m = ord c + (m * 128) `rem` 1500007\n"
"--\n"
"-- which seems to give reasonable results.\n"
"--\n"
"hashString :: String -> Int32\n"
"hashString = fromIntegral . foldr f 0\n"
"  where f c m = ord c + (m * 128) `rem` fromIntegral prime\n"
"\n"
"-- | A prime larger than the maximum hash table size\n"
"prime :: Int32\n"
"prime = 1500007\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Parameters\n"
"\n"
"sEGMENT_SIZE  = 1024  :: Int32  -- Size of a single hash table segment\n"
"sEGMENT_SHIFT = 10    :: Int  -- derived\n"
"sEGMENT_MASK  = 0x3ff :: Int32  -- derived\n"
"\n"
"dIR_SIZE = 1024  :: Int32  -- Size of the segment directory\n"
"	-- Maximum hash table size is sEGMENT_SIZE * dIR_SIZE\n"
"\n"
"hLOAD = 4 :: Int32 -- Maximum average load of a single hash bucket\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Creating a new hash table\n"
"\n"
"-- | Creates a new hash table\n"
"new\n"
"  :: (key -> key -> Bool)    -- ^ An equality comparison on keys\n"
"  -> (key -> Int32)	     -- ^ A hash function on keys\n"
"  -> IO (HashTable key val)  -- ^ Returns: an empty hash table\n"
"\n"
"new cmp hash_fn = do\n"
"  -- make a new hash table with a single, empty, segment\n"
"  dir     <- newIOArray (0,dIR_SIZE) undefined\n"
"  segment <- newIOArray (0,sEGMENT_SIZE-1) []\n"
"  myWriteArray dir 0 segment\n"
"\n"
"  let\n"
"    split  = 0\n"
"    max    = sEGMENT_SIZE\n"
"    mask1  = (sEGMENT_SIZE - 1)\n"
"    mask2  = (2 * sEGMENT_SIZE - 1)\n"
"    kcount = 0\n"
"    bcount = sEGMENT_SIZE\n"
"\n"
"    ht = HT {  dir=dir, split=split, max_bucket=max, mask1=mask1, mask2=mask2,\n"
"	       kcount=kcount, bcount=bcount, hash_fn=hash_fn, cmp=cmp\n"
"	  }\n"
"  \n"
"  table <- newIORef ht\n"
"  return (HashTable table)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Inserting a key\\/value pair into the hash table\n"
"\n"
"-- | Inserts an key\\/value mapping into the hash table.\n"
"insert :: HashTable key val -> key -> val -> IO ()\n"
"\n"
"insert (HashTable ref) key val = do\n"
"  table@HT{ kcount=k, bcount=b, dir=dir } <- readIORef ref\n"
"  let table1 = table{ kcount = k+1 }\n"
"  table2 <-\n"
"	if (k > hLOAD * b)\n"
"	   then expandHashTable table1\n"
"	   else return table1\n"
"  writeIORef ref table2\n"
"  (segment_index,segment_offset) <- tableLocation table key\n"
"  segment <- myReadArray dir segment_index\n"
"  bucket <- myReadArray segment segment_offset\n"
"  myWriteArray segment segment_offset ((key,val):bucket)\n"
"  return ()\n"
"\n"
"bucketIndex :: HT key val -> key -> IO Int32\n"
"bucketIndex HT{ hash_fn=hash_fn,\n"
"		split=split,\n"
"		mask1=mask1,\n"
"		mask2=mask2 } key = do\n"
"  let\n"
"    h = fromIntegral (hash_fn key)\n"
"    small_bucket = h .&. mask1\n"
"    large_bucket = h .&. mask2\n"
"  --\n"
"  if small_bucket < split\n"
"	then return large_bucket\n"
"  	else return small_bucket\n"
"\n"
"tableLocation :: HT key val -> key -> IO (Int32,Int32)\n"
"tableLocation table key = do\n"
"  bucket_index <- bucketIndex table key\n"
"  let\n"
"    segment_index  = bucket_index `shiftR` sEGMENT_SHIFT\n"
"    segment_offset = bucket_index .&. sEGMENT_MASK\n"
"  --\n"
"  return (segment_index,segment_offset)\n"
"\n"
"expandHashTable :: HT key val -> IO (HT key val)\n"
"expandHashTable\n"
"      table@HT{ dir=dir,\n"
"		split=split,\n"
"		max_bucket=max,\n"
"		mask2=mask2 } = do\n"
"  let\n"
"      oldsegment = split `shiftR` sEGMENT_SHIFT\n"
"      oldindex   = split .&. sEGMENT_MASK\n"
"\n"
"      newbucket  = max + split\n"
"      newsegment = newbucket `shiftR` sEGMENT_SHIFT\n"
"      newindex   = newbucket .&. sEGMENT_MASK\n"
"  --\n"
"  when (newindex == 0) $\n"
"	do segment <- newIOArray (0,sEGMENT_SIZE-1) []\n"
"	   myWriteArray dir newsegment segment\n"
"  --\n"
"  let table' =\n"
"  	if (split+1) < max\n"
"     	    then table{ split = split+1 }\n"
"     		-- we've expanded all the buckets in this table, so start from\n"
"		-- the beginning again.\n"
"     	    else table{ split = 0,\n"
"			max_bucket = max * 2,\n"
"			mask1 = mask2,\n"
"			mask2 = mask2 `shiftL` 1 .|. 1 }\n"
"  let\n"
"    split_bucket old new [] = do\n"
"	segment <- myReadArray dir oldsegment\n"
"	myWriteArray segment oldindex old\n"
"	segment <- myReadArray dir newsegment\n"
"	myWriteArray segment newindex new\n"
"    split_bucket old new ((k,v):xs) = do\n"
"	h <- bucketIndex table' k\n"
"	if h == newbucket\n"
"		then split_bucket old ((k,v):new) xs\n"
"		else split_bucket ((k,v):old) new xs\n"
"  --\n"
"  segment <- myReadArray dir oldsegment\n"
"  bucket <- myReadArray segment oldindex\n"
"  split_bucket [] [] bucket\n"
"  return table'\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Deleting a mapping from the hash table\n"
"\n"
"-- | Remove an entry from the hash table.\n"
"delete :: HashTable key val -> key -> IO ()\n"
"\n"
"delete (HashTable ref) key = do\n"
"  table@HT{ dir=dir, cmp=cmp } <- readIORef ref\n"
"  (segment_index,segment_offset) <- tableLocation table key\n"
"  segment <- myReadArray dir segment_index\n"
"  bucket <- myReadArray segment segment_offset\n"
"  myWriteArray segment segment_offset (filter (not.(key `cmp`).fst) bucket)\n"
"  return ()\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Looking up an entry in the hash table\n"
"\n"
"-- | Looks up the value of a key in the hash table.\n"
"lookup :: HashTable key val -> key -> IO (Maybe val)\n"
"\n"
"lookup (HashTable ref) key = do\n"
"  table@HT{ dir=dir, cmp=cmp } <- readIORef ref\n"
"  (segment_index,segment_offset) <- tableLocation table key\n"
"  segment <- myReadArray dir segment_index\n"
"  bucket <- myReadArray segment segment_offset\n"
"  case [ val | (key',val) <- bucket, cmp key key' ] of\n"
"	[] -> return Nothing\n"
"	(v:_) -> return (Just v)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Converting to/from lists\n"
"\n"
"-- | Convert a list of key\\/value pairs into a hash table.  Equality on keys\n"
"-- is taken from the Eq instance for the key type.\n"
"--\n"
"fromList :: Eq key => (key -> Int32) -> [(key,val)] -> IO (HashTable key val)\n"
"fromList hash_fn list = do\n"
"  table <- new (==) hash_fn\n"
"  sequence_ [ insert table k v | (k,v) <- list ]\n"
"  return table\n"
"\n"
"-- | Converts a hash table to a list of key\\/value pairs.\n"
"--\n"
"toList :: HashTable key val -> IO [(key,val)]\n"
"toList (HashTable ref) = do\n"
"  HT{ dir=dir, max_bucket=max, split=split } <- readIORef ref\n"
"  --\n"
"  let\n"
"    max_segment = (max + split - 1) `quot` sEGMENT_SIZE\n"
"  --\n"
"  segments <- mapM (segmentContents dir) [0 .. max_segment]\n"
"  return (concat segments)\n"
" where\n"
"   segmentContents dir seg_index = do\n"
"     segment <- myReadArray dir seg_index\n"
"     bs <- mapM (myReadArray segment) [0 .. sEGMENT_SIZE-1]\n"
"     return (concat bs)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Diagnostics\n"
"\n"
"-- | This function is useful for determining whether your hash function\n"
"-- is working well for your data set.  It returns the longest chain\n"
"-- of key\\/value pairs in the hash table for which all the keys hash to\n"
"-- the same bucket.  If this chain is particularly long (say, longer\n"
"-- than 10 elements), then it might be a good idea to try a different\n"
"-- hash function.\n"
"--\n"
"longestChain :: HashTable key val -> IO [(key,val)]\n"
"longestChain (HashTable ref) = do\n"
"  HT{ dir=dir, max_bucket=max, split=split } <- readIORef ref\n"
"  --\n"
"  let\n"
"    max_segment = (max + split - 1) `quot` sEGMENT_SIZE\n"
"  --\n"
"  --trace (\"maxChainLength: max = \" ++ show max ++ \", split = \" ++ show split ++ \", max_segment = \" ++ show max_segment) $ do\n"
"  segments <- mapM (segmentMaxChainLength dir) [0 .. max_segment]\n"
"  return (maximumBy lengthCmp segments)\n"
" where\n"
"   segmentMaxChainLength dir seg_index = do\n"
"     segment <- myReadArray dir seg_index\n"
"     bs <- mapM (myReadArray segment) [0 .. sEGMENT_SIZE-1]\n"
"     return (maximumBy lengthCmp bs)\n"
"\n"
"   lengthCmp x y = length x `compare` length y\n";
const char *Data_Tree = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Tree\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- Multi-way trees (/aka/ rose trees) and forests.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Tree(\n"
"	Tree(..), Forest,\n"
"	drawTree, drawForest,\n"
"	flatten, levels,\n"
"    ) where\n"
"\n"
"-- | Multi-way trees, also known as /rose trees/.\n"
"data Tree a   = Node a (Forest a) -- ^ a value and zero or more child trees.\n"
"  deriving (Eq, Read, Show)\n"
"type Forest a = [Tree a]\n"
"\n"
"instance Functor Tree where\n"
"  fmap = mapTree\n"
"\n"
"mapTree              :: (a -> b) -> (Tree a -> Tree b)\n"
"mapTree f (Node x ts) = Node (f x) (map (mapTree f) ts)\n"
"\n"
"-- | Neat 2-dimensional drawing of a tree.\n"
"drawTree :: Show a => Tree a -> String\n"
"drawTree  = unlines . draw . mapTree show\n"
"\n"
"-- | Neat 2-dimensional drawing of a forest.\n"
"drawForest :: Show a => Forest a -> String\n"
"drawForest  = unlines . map drawTree\n"
"\n"
"draw :: Tree String -> [String]\n"
"draw (Node x ts0) = grp this (space (length this)) (stLoop ts0)\n"
" where this          = s1 ++ x ++ \" \"\n"
"\n"
"       space n       = replicate n ' '\n"
"\n"
"       stLoop []     = [\"\"]\n"
"       stLoop [t]    = grp s2 \"  \" (draw t)\n"
"       stLoop (t:ts) = grp s3 s4 (draw t) ++ [s4] ++ rsLoop ts\n"
"\n"
"       rsLoop []     = error \"rsLoop:Unexpected empty list.\"\n"
"       rsLoop [t]    = grp s5 \"  \" (draw t)\n"
"       rsLoop (t:ts) = grp s6 s4 (draw t) ++ [s4] ++ rsLoop ts\n"
"\n"
"       grp fst0 rst  = zipWith (++) (fst0:repeat rst)\n"
"\n"
"       [s1,s2,s3,s4,s5,s6] = [\"- \", \"--\", \"-+\", \" |\", \" `\", \" +\"]\n"
"\n"
"-- | The elements of a tree in pre-order.\n"
"flatten :: Tree a -> [a]\n"
"flatten t = squish t []\n"
" where squish (Node x ts) xs = x:foldr squish xs ts\n"
"\n"
"-- | Lists of nodes at each level of the tree.\n"
"levels :: Tree a -> [[a]]\n"
"levels t = map (map root) $ takeWhile (not . null) $ iterate subforest [t]\n"
" where root (Node x _) = x\n"
"       subforest f     = [t | Node _ ts <- f, t <- ts]\n";
const char *Data_Array = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Array \n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Basic non-strict arrays.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module  Data.Array \n"
"\n"
"    ( \n"
"      module Data.Ix		-- export all of Ix \n"
"    , Array 			-- Array type is abstract\n"
"\n"
"    , array	    -- :: (Ix a) => (a,a) -> [(a,b)] -> Array a b\n"
"    , listArray     -- :: (Ix a) => (a,a) -> [b] -> Array a b\n"
"    , (!)           -- :: (Ix a) => Array a b -> a -> b\n"
"    , bounds        -- :: (Ix a) => Array a b -> (a,a)\n"
"    , indices       -- :: (Ix a) => Array a b -> [a]\n"
"    , elems         -- :: (Ix a) => Array a b -> [b]\n"
"    , assocs        -- :: (Ix a) => Array a b -> [(a,b)]\n"
"    , accumArray    -- :: (Ix a) => (b -> c -> b) -> b -> (a,a) -> [(a,c)] -> Array a b\n"
"    , (//)          -- :: (Ix a) => Array a b -> [(a,b)] -> Array a b\n"
"    , accum         -- :: (Ix a) => (b -> c -> b) -> Array a b -> [(a,c)] -> Array a b\n"
"    , ixmap         -- :: (Ix a, Ix b) => (a,a) -> (a -> b) -> Array b c -> Array a b\n"
"\n"
"    -- Array instances:\n"
"    --\n"
"    --   Ix a => Functor (Array a)\n"
"    --   (Ix a, Eq b)  => Eq   (Array a b)\n"
"    --   (Ix a, Ord b) => Ord  (Array a b)\n"
"    --   (Ix a, Show a, Show b) => Show (Array a b)\n"
"    --   (Ix a, Read a, Read b) => Read (Array a b)\n"
"    -- \n"
"\n"
"    -- Implementation checked wrt. Haskell 98 lib report, 1/99.\n"
"\n"
"    ) where\n"
"\n"
"import Data.Ix\n"
"\n"
"import Hugs.Array\n"
"\n"
"import Data.Typeable\n"
"\n"
"arrayTc = mkTyCon \"Array\"; instance (Typeable a, Typeable b) => Typeable (Array a b) where {   typeOf x = mkAppTy arrayTc [typeOf ((undefined :: Array a b -> a) x), 			     typeOf ((undefined :: Array a b -> b) x)] }\n";
const char *Data_Unique = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Unique\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- An abstract interface to a unique symbol generator.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Unique (\n"
"   -- * Unique objects\n"
"   Unique,		-- instance (Eq, Ord)\n"
"   newUnique, 		-- :: IO Unique\n"
"   hashUnique 		-- :: Unique -> Int\n"
" ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Control.Concurrent.MVar\n"
"import System.IO.Unsafe (unsafePerformIO)\n"
"\n"
"-- | An abstract unique object.  Objects of type 'Unique' may be\n"
"-- compared for equality and ordering and hashed into 'Int'.\n"
"newtype Unique = Unique Integer deriving (Eq,Ord)\n"
"\n"
"uniqSource :: MVar Integer\n"
"uniqSource = unsafePerformIO (newMVar 0)\n"
"{-# NOINLINE uniqSource #-}\n"
"\n"
"-- | Creates a new object of type 'Unique'.  The value returned will\n"
"-- not compare equal to any other value of type 'Unique' returned by\n"
"-- previous calls to 'newUnique'.  There is no limit on the number of\n"
"-- times 'newUnique' may be called.\n"
"newUnique :: IO Unique\n"
"newUnique = do\n"
"   val <- takeMVar uniqSource\n"
"   let next = val+1\n"
"   putMVar uniqSource next\n"
"   return (Unique next)\n"
"\n"
"-- | Hashes a 'Unique' into an 'Int'.  Two 'Unique's may hash to the\n"
"-- same value, although in practice this is unlikely.  The 'Int'\n"
"-- returned makes a good hash key.\n"
"hashUnique :: Unique -> Int\n"
"hashUnique (Unique u) = fromInteger (u `mod` (toInteger (maxBound :: Int) + 1))\n";
const char *Data_Bits = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Bits\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"--  This module defines bitwise operations for signed and unsigned\n"
"--  integers.  Instances of the class 'Bits' for the 'Int' and\n"
"--  'Integer' types are available from this module, and instances for\n"
"--  explicitly sized integral types are available from the\n"
"--  \"Data.Int\" and \"Data.Word\" modules.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Bits ( \n"
"  Bits(\n"
"    (.&.), (.|.), xor, -- :: a -> a -> a\n"
"    complement,        -- :: a -> a\n"
"    shift,             -- :: a -> Int -> a\n"
"    rotate,            -- :: a -> Int -> a\n"
"    bit,               -- :: Int -> a\n"
"    setBit,            -- :: a -> Int -> a\n"
"    clearBit,          -- :: a -> Int -> a\n"
"    complementBit,     -- :: a -> Int -> a\n"
"    testBit,           -- :: a -> Int -> Bool\n"
"    bitSize,           -- :: a -> Int\n"
"    isSigned,          -- :: a -> Bool\n"
"    shiftL, shiftR,    -- :: a -> Int -> a\n"
"    rotateL, rotateR   -- :: a -> Int -> a\n"
"  )\n"
"\n"
"  -- instance Bits Int\n"
"  -- instance Bits Integer\n"
" ) where\n"
"\n"
"-- Defines the @Bits@ class containing bit-based operations.\n"
"-- See library document for details on the semantics of the\n"
"-- individual operations.\n"
"\n"
"import Hugs.Bits\n"
"\n"
"infixl 8 `shift`, `rotate`, `shiftL`, `shiftR`, `rotateL`, `rotateR`\n"
"infixl 7 .&.\n"
"infixl 6 `xor`\n"
"infixl 5 .|.\n"
"\n"
"{-| \n"
"The 'Bits' class defines bitwise operations over integral types.\n"
"\n"
"* Bits are numbered from 0 with bit 0 being the least\n"
"  significant bit.\n"
"-}\n"
"class Num a => Bits a where\n"
"    -- | Bitwise \\\"and\\\"\n"
"    (.&.) :: a -> a -> a\n"
"\n"
"    -- | Bitwise \\\"or\\\"\n"
"    (.|.) :: a -> a -> a\n"
"\n"
"    -- | Bitwise \\\"xor\\\"\n"
"    xor :: a -> a -> a\n"
"\n"
"    {-| Reverse all the bits in the argument -}\n"
"    complement        :: a -> a\n"
"\n"
"    {-| Shift the argument left by the specified number of bits.\n"
"	Right shifts (signed) are specified by giving a negative value.\n"
"\n"
"	An instance can define either this unified 'shift' or 'shiftL' and\n"
"	'shiftR', depending on which is more convenient for the type in\n"
"	question. -}\n"
"    shift             :: a -> Int -> a\n"
"\n"
"    x `shift`   i | i<0  = x `shiftR` (-i)\n"
"                  | i==0 = x\n"
"                  | i>0  = x `shiftL` i\n"
"\n"
"    {-| Rotate the argument left by the specified number of bits.\n"
"	Right rotates are specified by giving a negative value.\n"
"\n"
"        For unbounded types like 'Integer', 'rotate' is equivalent to 'shift'.\n"
"\n"
"	An instance can define either this unified 'rotate' or 'rotateL' and\n"
"	'rotateR', depending on which is more convenient for the type in\n"
"	question. -}\n"
"    rotate            :: a -> Int -> a\n"
"\n"
"    x `rotate`  i | i<0  = x `rotateR` (-i)\n"
"                  | i==0 = x\n"
"                  | i>0  = x `rotateL` i\n"
"\n"
"    {-\n"
"    -- Rotation can be implemented in terms of two shifts, but care is\n"
"    -- needed for negative values.  This suggested implementation assumes\n"
"    -- 2's-complement arithmetic.  It is commented out because it would\n"
"    -- require an extra context (Ord a) on the signature of 'rotate'.\n"
"    x `rotate`  i | i<0 && isSigned x && x<0\n"
"                         = let left = i+bitSize x in\n"
"                           ((x `shift` i) .&. complement ((-1) `shift` left))\n"
"                           .|. (x `shift` left)\n"
"                  | i<0  = (x `shift` i) .|. (x `shift` (i+bitSize x))\n"
"                  | i==0 = x\n"
"                  | i>0  = (x `shift` i) .|. (x `shift` (i-bitSize x))\n"
"    -}\n"
"\n"
"    -- | @bit i@ is a value with the @i@th bit set\n"
"    bit               :: Int -> a\n"
"\n"
"    -- | @x \\`setBit\\` i@ is the same as @x .|. bit i@\n"
"    setBit            :: a -> Int -> a\n"
"\n"
"    -- | @x \\`clearBit\\` i@ is the same as @x .&. complement (bit i)@\n"
"    clearBit          :: a -> Int -> a\n"
"\n"
"    -- | @x \\`complementBit\\` i@ is the same as @x \\`xor\\` bit i@\n"
"    complementBit     :: a -> Int -> a\n"
"\n"
"    -- | Return 'True' if the @n@th bit of the argument is 1\n"
"    testBit           :: a -> Int -> Bool\n"
"\n"
"    {-| Return the number of bits in the type of the argument.  The actual\n"
"	value of the argument is ignored.  The function 'bitSize' is\n"
"	undefined for types that do not have a fixed bitsize, like 'Integer'.\n"
"	-}\n"
"    bitSize           :: a -> Int\n"
"\n"
"    {-| Return 'True' if the argument is a signed type.  The actual\n"
"        value of the argument is ignored -}\n"
"    isSigned          :: a -> Bool\n"
"\n"
"    bit i               = 1 `shiftL` i\n"
"    x `setBit` i        = x .|. bit i\n"
"    x `clearBit` i      = x .&. complement (bit i)\n"
"    x `complementBit` i = x `xor` bit i\n"
"    x `testBit` i       = (x .&. bit i) /= 0\n"
"\n"
"    {-| Shift the argument left by the specified number of bits\n"
"	(which must be non-negative).\n"
"\n"
"	An instance can define either this and 'shiftR' or the unified\n"
"	'shift', depending on which is more convenient for the type in\n"
"	question. -}\n"
"    shiftL            :: a -> Int -> a\n"
"    x `shiftL`  i = x `shift`  i\n"
"\n"
"    {-| Shift the argument right (signed) by the specified number of bits\n"
"	(which must be non-negative).\n"
"\n"
"	An instance can define either this and 'shiftL' or the unified\n"
"	'shift', depending on which is more convenient for the type in\n"
"	question. -}\n"
"    shiftR            :: a -> Int -> a\n"
"    x `shiftR`  i = x `shift`  (-i)\n"
"\n"
"    {-| Rotate the argument left by the specified number of bits\n"
"	(which must be non-negative).\n"
"\n"
"	An instance can define either this and 'rotateR' or the unified\n"
"	'rotate', depending on which is more convenient for the type in\n"
"	question. -}\n"
"    rotateL           :: a -> Int -> a\n"
"    x `rotateL` i = x `rotate` i\n"
"\n"
"    {-| Rotate the argument right by the specified number of bits\n"
"	(which must be non-negative).\n"
"\n"
"	An instance can define either this and 'rotateL' or the unified\n"
"	'rotate', depending on which is more convenient for the type in\n"
"	question. -}\n"
"    rotateR           :: a -> Int -> a\n"
"    x `rotateR` i = x `rotate` (-i)\n"
"\n"
"instance Bits Int where\n"
"\n"
"    (.&.)                  = primAndInt\n"
"    (.|.)                  = primOrInt\n"
"    xor                    = primXorInt\n"
"    complement             = primComplementInt\n"
"    shift                  = primShiftInt\n"
"    bit                    = primBitInt\n"
"    testBit                = primTestInt\n"
"    bitSize _              = 4*8\n"
"\n"
"    x `rotate`  i\n"
"	| i<0 && x<0       = let left = i+bitSize x in\n"
"                             ((x `shift` i) .&. complement ((-1) `shift` left))\n"
"                             .|. (x `shift` left)\n"
"	| i<0              = (x `shift` i) .|. (x `shift` (i+bitSize x))\n"
"	| i==0             = x\n"
"	| i>0              = (x `shift` i) .|. (x `shift` (i-bitSize x))\n"
"\n"
"    isSigned _             = True\n"
"\n"
"instance Bits Integer where\n"
"   -- reduce bitwise binary operations to special cases we can handle\n"
"\n"
"   x .&. y   | x<0 && y<0 = complement (complement x `posOr` complement y)\n"
"	     | otherwise  = x `posAnd` y\n"
"   \n"
"   x .|. y   | x<0 || y<0 = complement (complement x `posAnd` complement y)\n"
"	     | otherwise  = x `posOr` y\n"
"   \n"
"   x `xor` y | x<0 && y<0 = complement x `posXOr` complement y\n"
"	     | x<0        = complement (complement x `posXOr` y)\n"
"	     |        y<0 = complement (x `posXOr` complement y)\n"
"	     | otherwise  = x `posXOr` y\n"
"\n"
"   -- assuming infinite 2's-complement arithmetic\n"
"   complement a = -1 - a\n"
"\n"
"   shift x i | i >= 0    = x * 2^i\n"
"	     | otherwise = x `div` 2^(-i)\n"
"\n"
"   rotate x i = shift x i   -- since an Integer never wraps around\n"
"\n"
"   bitSize _  = error \"Data.Bits.bitSize(Integer)\"\n"
"   isSigned _ = True\n"
"\n"
"-- Crude implementation of bitwise operations on Integers: convert them\n"
"-- to finite lists of Ints (least significant first), zip and convert\n"
"-- back again.\n"
"\n"
"-- posAnd requires at least one argument non-negative\n"
"-- posOr and posXOr require both arguments non-negative\n"
"\n"
"posAnd, posOr, posXOr :: Integer -> Integer -> Integer\n"
"posAnd x y   = fromInts $ zipWith (.&.) (toInts x) (toInts y)\n"
"posOr x y    = fromInts $ longZipWith (.|.) (toInts x) (toInts y)\n"
"posXOr x y   = fromInts $ longZipWith xor (toInts x) (toInts y)\n"
"\n"
"longZipWith :: (a -> a -> a) -> [a] -> [a] -> [a]\n"
"longZipWith f xs [] = xs\n"
"longZipWith f [] ys = ys\n"
"longZipWith f (x:xs) (y:ys) = f x y:longZipWith f xs ys\n"
"\n"
"toInts :: Integer -> [Int]\n"
"toInts n\n"
"    | n == 0 = []\n"
"    | otherwise = mkInt (n `mod` numInts):toInts (n `div` numInts)\n"
"  where mkInt n | n > toInteger(maxBound::Int) = fromInteger (n-numInts)\n"
"		| otherwise = fromInteger n\n"
"\n"
"fromInts :: [Int] -> Integer\n"
"fromInts = foldr catInt 0\n"
"    where catInt d n = (if d<0 then n+1 else n)*numInts + toInteger d\n"
"\n"
"numInts = toInteger (maxBound::Int) - toInteger (minBound::Int) + 1\n";
const char *Data_Int = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Int\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- Signed integer types\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Int\n"
"  ( \n"
"	-- * Signed integer types\n"
"	Int,\n"
"	Int8, Int16, Int32, Int64,\n"
"\n"
"	-- * Notes\n"
"\n"
"	-- $notes\n"
"	) where\n"
"\n"
"import Hugs.Int ( Int8, Int16, Int32, Int64 )\n"
"\n"
"{- $notes\n"
"\n"
"* All arithmetic is performed modulo 2^n, where @n@ is the number of\n"
"  bits in the type.\n"
"\n"
"* For coercing between any two integer types, use 'fromIntegral',\n"
"  which is specialized for all the common cases so should be fast\n"
"  enough.  Coercing word types (see \"Data.Word\") to and from integer\n"
"  types preserves representation, not sign.\n"
"\n"
"* The rules that hold for 'Enum' instances over a\n"
"  bounded type such as 'Int' (see the section of the\n"
"  Haskell report dealing with arithmetic sequences) also hold for the\n"
"  'Enum' instances over the various\n"
"  'Int' types defined here.\n"
"\n"
"* Right and left shifts by amounts greater than or equal to the width\n"
"  of the type result in either zero or -1, depending on the sign of\n"
"  the value being shifted.  This is contrary to the behaviour in C,\n"
"  which is undefined; a common interpretation is to truncate the shift\n"
"  count to the width of the type, for example @1 \\<\\< 32\n"
"  == 1@ in some C implementations.\n"
"-}\n";
const char *Data_IORef = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.IORef\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- Mutable references in the IO monad.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.IORef\n"
"  ( \n"
"	-- * IORefs\n"
"	IORef,		      -- abstract, instance of: Eq, Typeable\n"
"	newIORef,	      -- :: a -> IO (IORef a)\n"
"        readIORef,	      -- :: IORef a -> IO a\n"
"        writeIORef,	      -- :: IORef a -> a -> IO ()\n"
"	modifyIORef,	      -- :: IORef a -> (a -> a) -> IO ()\n"
"	atomicModifyIORef,    -- :: IORef a -> (a -> (a,b)) -> IO b\n"
"\n"
"	) where\n"
"\n"
"import Prelude	-- Explicit dependency helps 'make depend' do the right thing\n"
"\n"
"import Hugs.IORef\n"
"\n"
"-- |Mutate the contents of an 'IORef'\n"
"modifyIORef :: IORef a -> (a -> a) -> IO ()\n"
"modifyIORef ref f = writeIORef ref . f =<< readIORef ref\n"
"\n"
"-- |Atomically modifies the contents of an 'IORef'.\n"
"--\n"
"-- This function is useful for using 'IORef' in a safe way in a multithreaded\n"
"-- program.  If you only have one 'IORef', then using 'atomicModifyIORef' to\n"
"-- access and modify it will prevent race conditions.\n"
"--\n"
"-- Extending the atomicity to multiple 'IORef's is problematic, so it\n"
"-- is recommended that if you need to do anything more complicated\n"
"-- then using 'MVar' instead is a good idea.\n"
"--\n"
"atomicModifyIORef :: IORef a -> (a -> (a,b)) -> IO b\n"
"atomicModifyIORef = plainModifyIORef	-- Hugs has no preemption\n"
"  where plainModifyIORef r f = do\n"
"		a <- readIORef r\n"
"		case f a of (a',b) -> writeIORef r a' >> return b\n";
const char *Data_Tuple = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Tuple\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- The tuple data types, and associated functions.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Tuple\n"
"  ( fst		-- :: (a,b) -> a\n"
"  , snd		-- :: (a,b) -> a\n"
"  , curry	-- :: ((a, b) -> c) -> a -> b -> c\n"
"  , uncurry	-- :: (a -> b -> c) -> ((a, b) -> c)\n"
"  )\n"
"    where\n"
"\n"
"default ()		-- Double isn't available yet\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Standard functions over tuples\n"
"\n";
const char *Data_Typeable = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Typeable\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- The Typeable class reifies types to some extent by associating type\n"
"-- representations to types. These type representations can be compared,\n"
"-- and one can in turn define a type-safe cast operation. To this end,\n"
"-- an unsafe cast is guarded by a test for type (representation)\n"
"-- equivalence. The module Data.Dynamic uses Typeable for an\n"
"-- implementation of dynamics. The module Data.Generics uses Typeable\n"
"-- and type-safe cast (but not dynamics) to support the \\\"Scrap your\n"
"-- boilerplate\\\" style of generic programming.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Typeable\n"
"  (\n"
"\n"
"	-- * The Typeable class\n"
"	Typeable( typeOf ),	-- :: a -> TypeRep\n"
"\n"
"	-- * Type-safe cast\n"
"	cast,			-- :: (Typeable a, Typeable b) => a -> Maybe b\n"
"	castss,			-- a cast for kind \"* -> *\"\n"
"	castarr,		-- another convenient variation\n"
"\n"
"	-- * Type representations\n"
"	TypeRep,	-- abstract, instance of: Eq, Show, Typeable\n"
"	TyCon,		-- abstract, instance of: Eq, Show, Typeable\n"
"\n"
"	-- * Construction of type representations\n"
"	mkTyCon,	-- :: String  -> TyCon\n"
"	mkAppTy,	-- :: TyCon   -> [TypeRep] -> TypeRep\n"
"	mkFunTy,	-- :: TypeRep -> TypeRep   -> TypeRep\n"
"	applyTy,	-- :: TypeRep -> TypeRep   -> Maybe TypeRep\n"
"\n"
"	-- * Observation of type representations\n"
"	typerepTyCon,	-- :: TypeRep -> TyCon\n"
"	typerepArgs,	-- :: TypeRep -> [TypeRep]\n"
"	tyconString	-- :: TyCon   -> String\n"
"\n"
"  ) where\n"
"\n"
"import qualified Data.HashTable as HT\n"
"import Data.Maybe\n"
"import Data.Either\n"
"import Data.Int\n"
"import Data.Word\n"
"import Data.List( foldl )\n"
"\n"
"import Hugs.Prelude\n"
"import Hugs.IO\n"
"import Hugs.IORef\n"
"import Hugs.IOExts\n"
"\n"
"	-- \n"
"	-- let fTy = mkTyCon \"Foo\" in show (mkAppTy (mkTyCon \",,\")\n"
"	--                                 [fTy,fTy,fTy])\n"
"	-- \n"
"	-- returns \"(Foo,Foo,Foo)\"\n"
"	--\n"
"	-- The TypeRep Show instance promises to print tuple types\n"
"	-- correctly. Tuple type constructors are specified by a \n"
"	-- sequence of commas, e.g., (mkTyCon \",,,,\") returns\n"
"	-- the 5-tuple tycon.\n"
"\n"
"----------------- Construction --------------------\n"
"\n"
"-- | Applies a type constructor to a sequence of types\n"
"mkAppTy  :: TyCon -> [TypeRep] -> TypeRep\n"
"mkAppTy tc@(TyCon tc_k _) args \n"
"  = TypeRep (appKeys tc_k arg_ks) tc args\n"
"  where\n"
"    arg_ks = [k | TypeRep k _ _ <- args]\n"
"\n"
"funTc :: TyCon\n"
"funTc = mkTyCon \"->\"\n"
"\n"
"-- | A special case of 'mkAppTy', which applies the function \n"
"-- type constructor to a pair of types.\n"
"mkFunTy  :: TypeRep -> TypeRep -> TypeRep\n"
"mkFunTy f a = mkAppTy funTc [f,a]\n"
"\n"
"-- | Applies a type to a function type.  Returns: @'Just' u@ if the\n"
"-- first argument represents a function of type @t -> u@ and the\n"
"-- second argument represents a function of type @t@.  Otherwise,\n"
"-- returns 'Nothing'.\n"
"applyTy :: TypeRep -> TypeRep -> Maybe TypeRep\n"
"applyTy (TypeRep _ tc [t1,t2]) t3\n"
"  | tc == funTc && t1 == t3	= Just t2\n"
"applyTy _ _     		= Nothing\n"
"\n"
"-- If we enforce the restriction that there is only one\n"
"-- @TyCon@ for a type & it is shared among all its uses,\n"
"-- we can map them onto Ints very simply. The benefit is,\n"
"-- of course, that @TyCon@s can then be compared efficiently.\n"
"\n"
"-- Provided the implementor of other @Typeable@ instances\n"
"-- takes care of making all the @TyCon@s CAFs (toplevel constants),\n"
"-- this will work. \n"
"\n"
"-- If this constraint does turn out to be a sore thumb, changing\n"
"-- the Eq instance for TyCons is trivial.\n"
"\n"
"-- | Builds a 'TyCon' object representing a type constructor.  An\n"
"-- implementation of \"Data.Typeable\" should ensure that the following holds:\n"
"--\n"
"-- >  mkTyCon \"a\" == mkTyCon \"a\"\n"
"--\n"
"\n"
"mkTyCon :: String	-- ^ the name of the type constructor (should be unique\n"
"			-- in the program, so it might be wise to use the\n"
"			-- fully qualified name).\n"
"	-> TyCon	-- ^ A unique 'TyCon' object\n"
"mkTyCon str = TyCon (mkTyConKey str) str\n"
"\n"
"----------------- Observation ---------------------\n"
"\n"
"-- | Observe the type constructor of a type representation\n"
"typerepTyCon :: TypeRep -> TyCon\n"
"typerepTyCon (TypeRep _ tc _) = tc\n"
"\n"
"-- | Observe the argument types of a type representation\n"
"typerepArgs :: TypeRep -> [TypeRep]\n"
"typerepArgs (TypeRep _ _ args) = args\n"
"\n"
"-- | Observe string encoding of a type representation\n"
"tyconString :: TyCon   -> String\n"
"tyconString  (TyCon _ str) = str\n"
"\n"
"----------------- Showing TypeReps --------------------\n"
"\n"
"instance Show TypeRep where\n"
"  showsPrec p (TypeRep _ tycon tys) =\n"
"    case tys of\n"
"      [] -> showsPrec p tycon\n"
"      [x]   | tycon == listTc -> showChar '[' . shows x . showChar ']'\n"
"      [a,r] | tycon == funTc  -> showParen (p > 8) $\n"
"			         showsPrec 9 a . showString \" -> \" . showsPrec 8 r\n"
"      xs | isTupleTyCon tycon -> showTuple tycon xs\n"
"	 | otherwise	     ->\n"
"	    showParen (p > 9) $\n"
"   	    showsPrec p tycon . \n"
"	    showChar ' '      . \n"
"	    showArgs tys\n"
"\n"
"instance Show TyCon where\n"
"  showsPrec _ (TyCon _ s) = showString s\n"
"\n"
"isTupleTyCon :: TyCon -> Bool\n"
"isTupleTyCon (TyCon _ (',':_)) = True\n"
"isTupleTyCon _		       = False\n"
"\n"
"-- Some (Show.TypeRep) helpers:\n"
"\n"
"showArgs :: Show a => [a] -> ShowS\n"
"showArgs [] = id\n"
"showArgs [a] = showsPrec 10 a\n"
"showArgs (a:as) = showsPrec 10 a . showString \" \" . showArgs as \n"
"\n"
"showTuple :: TyCon -> [TypeRep] -> ShowS\n"
"showTuple (TyCon _ str) args = showChar '(' . go str args\n"
" where\n"
"  go [] [a] = showsPrec 10 a . showChar ')'\n"
"  go _  []  = showChar ')' -- a failure condition, really.\n"
"  go (',':xs) (a:as) = showsPrec 10 a . showChar ',' . go xs as\n"
"  go _ _   = showChar ')'\n"
"\n"
"-------------------------------------------------------------\n"
"--\n"
"--	The Typeable class\n"
"--\n"
"-------------------------------------------------------------\n"
"\n"
"-- | The class 'Typeable' allows a concrete representation of a type to\n"
"-- be calculated.\n"
"class Typeable a where\n"
"  typeOf :: a -> TypeRep\n"
"  -- ^ Takes a value of type @a@ and returns a concrete representation\n"
"  -- of that type.  The /value/ of the argument should be ignored by\n"
"  -- any instance of 'Typeable', so that it is safe to pass 'undefined' as\n"
"  -- the argument.\n"
"\n"
"-------------------------------------------------------------\n"
"--\n"
"--		Type-safe cast\n"
"--\n"
"-------------------------------------------------------------\n"
"\n"
"-- | The type-safe cast operation\n"
"cast :: (Typeable a, Typeable b) => a -> Maybe b\n"
"cast x = r\n"
"       where\n"
"	 r = if typeOf x == typeOf (fromJust r)\n"
"               then Just $ unsafeCoerce x\n"
"	       else Nothing\n"
"\n"
"-- | A convenient variation for kind \\\"* -> *\\\"\n"
"castss :: (Typeable a, Typeable b) => t a -> Maybe (t b)\n"
"castss x = r\n"
"       where\n"
"	 r = if typeOf (get x) == typeOf (get (fromJust r))\n"
"               then Just $ unsafeCoerce x\n"
"	       else Nothing\n"
"         get :: t c -> c\n"
"	 get = undefined\n"
"\n"
"-- | Another variation\n"
"castarr :: (Typeable a, Typeable b, Typeable c, Typeable d)\n"
"        => (a -> t b) -> Maybe (c -> t d)\n"
"castarr x = r\n"
"       where\n"
"	 r = if typeOf (get x) == typeOf (get (fromJust r))\n"
"               then Just $ unsafeCoerce x\n"
"	       else Nothing\n"
"         get :: (e -> t f) -> (e, f)\n"
"	 get = undefined\n"
"\n"
"{-\n"
"\n"
"The variations castss and castarr are arguably not really needed.\n"
"Let's discuss castss in some detail. To get rid of castss, we can\n"
"require \"Typeable (t a)\" and \"Typeable (t b)\" rather than just\n"
"\"Typeable a\" and \"Typeable b\". In that case, the ordinary cast would\n"
"work. Eventually, all kinds of library instances should become\n"
"Typeable. (There is another potential use of variations as those given\n"
"above. It allows quantification on type constructors.\n"
"\n"
"-}\n"
"\n"
"-------------------------------------------------------------\n"
"--\n"
"--	Instances of the Typeable class for Prelude types\n"
"--\n"
"-------------------------------------------------------------\n"
"\n"
"listTc :: TyCon\n"
"listTc = mkTyCon \"[]\"\n"
"\n"
"instance Typeable a => Typeable [a] where\n"
"  typeOf ls = mkAppTy listTc [typeOf ((undefined :: [a] -> a) ls)]\n"
"	-- In GHC we can say\n"
"	--	typeOf (undefined :: a)\n"
"	-- using scoped type variables, but we use the \n"
"	-- more verbose form here, for compatibility with Hugs\n"
"\n"
"unitTc :: TyCon\n"
"unitTc = mkTyCon \"()\"\n"
"\n"
"instance Typeable () where\n"
"  typeOf _ = mkAppTy unitTc []\n"
"\n"
"tup2Tc :: TyCon\n"
"tup2Tc = mkTyCon \",\"\n"
"\n"
"instance (Typeable a, Typeable b) => Typeable (a,b) where\n"
"  typeOf tu = mkAppTy tup2Tc [typeOf ((undefined :: (a,b) -> a) tu),\n"
"			      typeOf ((undefined :: (a,b) -> b) tu)]\n"
"\n"
"tup3Tc :: TyCon\n"
"tup3Tc = mkTyCon \",,\"\n"
"\n"
"instance ( Typeable a , Typeable b , Typeable c) => Typeable (a,b,c) where\n"
"  typeOf tu = mkAppTy tup3Tc [typeOf ((undefined :: (a,b,c) -> a) tu),\n"
"			      typeOf ((undefined :: (a,b,c) -> b) tu),\n"
"			      typeOf ((undefined :: (a,b,c) -> c) tu)]\n"
"\n"
"tup4Tc :: TyCon\n"
"tup4Tc = mkTyCon \",,,\"\n"
"\n"
"instance ( Typeable a\n"
"	 , Typeable b\n"
"	 , Typeable c\n"
"	 , Typeable d) => Typeable (a,b,c,d) where\n"
"  typeOf tu = mkAppTy tup4Tc [typeOf ((undefined :: (a,b,c,d) -> a) tu),\n"
"			      typeOf ((undefined :: (a,b,c,d) -> b) tu),\n"
"			      typeOf ((undefined :: (a,b,c,d) -> c) tu),\n"
"			      typeOf ((undefined :: (a,b,c,d) -> d) tu)]\n"
"tup5Tc :: TyCon\n"
"tup5Tc = mkTyCon \",,,,\"\n"
"\n"
"instance ( Typeable a\n"
"	 , Typeable b\n"
"	 , Typeable c\n"
"	 , Typeable d\n"
"	 , Typeable e) => Typeable (a,b,c,d,e) where\n"
"  typeOf tu = mkAppTy tup5Tc [typeOf ((undefined :: (a,b,c,d,e) -> a) tu),\n"
"			      typeOf ((undefined :: (a,b,c,d,e) -> b) tu),\n"
"			      typeOf ((undefined :: (a,b,c,d,e) -> c) tu),\n"
"			      typeOf ((undefined :: (a,b,c,d,e) -> d) tu),\n"
"			      typeOf ((undefined :: (a,b,c,d,e) -> e) tu)]\n"
"\n"
"instance (Typeable a, Typeable b) => Typeable (a -> b) where\n"
"  typeOf f = mkFunTy (typeOf ((undefined :: (a -> b) -> a) f))\n"
"		     (typeOf ((undefined :: (a -> b) -> b) f))\n"
"\n"
"-------------------------------------------------------\n"
"--\n"
"-- Generate Typeable instances for standard datatypes\n"
"--\n"
"-------------------------------------------------------\n"
"\n"
"boolTc = mkTyCon \"Bool\"; instance Typeable Bool where { typeOf _ = mkAppTy boolTc [] }\n"
"charTc = mkTyCon \"Char\"; instance Typeable Char where { typeOf _ = mkAppTy charTc [] }\n"
"floatTc = mkTyCon \"Float\"; instance Typeable Float where { typeOf _ = mkAppTy floatTc [] }\n"
"doubleTc = mkTyCon \"Double\"; instance Typeable Double where { typeOf _ = mkAppTy doubleTc [] }\n"
"intTc = mkTyCon \"Int\"; instance Typeable Int where { typeOf _ = mkAppTy intTc [] }\n"
"integerTc = mkTyCon \"Integer\"; instance Typeable Integer where { typeOf _ = mkAppTy integerTc [] }\n"
"ratioTc = mkTyCon \"Ratio\"; instance Typeable a => Typeable (Ratio a) where {   typeOf x = mkAppTy ratioTc [typeOf ((undefined :: Ratio a -> a) x) ] }\n"
"eitherTc = mkTyCon \"Either\"; instance (Typeable a, Typeable b) => Typeable (Either a b) where {   typeOf x = mkAppTy eitherTc [typeOf ((undefined :: Either a b -> a) x), 			     typeOf ((undefined :: Either a b -> b) x)] }\n"
"ioTc = mkTyCon \"IO\"; instance Typeable a => Typeable (IO a) where {   typeOf x = mkAppTy ioTc [typeOf ((undefined :: IO a -> a) x) ] }\n"
"maybeTc = mkTyCon \"Maybe\"; instance Typeable a => Typeable (Maybe a) where {   typeOf x = mkAppTy maybeTc [typeOf ((undefined :: Maybe a -> a) x) ] }\n"
"orderingTc = mkTyCon \"Ordering\"; instance Typeable Ordering where { typeOf _ = mkAppTy orderingTc [] }\n"
"handleTc = mkTyCon \"Handle\"; instance Typeable Handle where { typeOf _ = mkAppTy handleTc [] }\n"
"ptrTc = mkTyCon \"Ptr\"; instance Typeable a => Typeable (Ptr a) where {   typeOf x = mkAppTy ptrTc [typeOf ((undefined :: Ptr a -> a) x) ] }\n"
"stablePtrTc = mkTyCon \"StablePtr\"; instance Typeable a => Typeable (StablePtr a) where {   typeOf x = mkAppTy stablePtrTc [typeOf ((undefined :: StablePtr a -> a) x) ] }\n"
"\n"
"int8Tc = mkTyCon \"Int8\"; instance Typeable Int8 where { typeOf _ = mkAppTy int8Tc [] }\n"
"int16Tc = mkTyCon \"Int16\"; instance Typeable Int16 where { typeOf _ = mkAppTy int16Tc [] }\n"
"int32Tc = mkTyCon \"Int32\"; instance Typeable Int32 where { typeOf _ = mkAppTy int32Tc [] }\n"
"int64Tc = mkTyCon \"Int64\"; instance Typeable Int64 where { typeOf _ = mkAppTy int64Tc [] }\n"
"\n"
"word8Tc = mkTyCon \"Word8\" ; instance Typeable Word8 where { typeOf _ = mkAppTy word8Tc [] }\n"
"word16Tc = mkTyCon \"Word16\"; instance Typeable Word16 where { typeOf _ = mkAppTy word16Tc [] }\n"
"word32Tc = mkTyCon \"Word32\"; instance Typeable Word32 where { typeOf _ = mkAppTy word32Tc [] }\n"
"word64Tc = mkTyCon \"Word64\"; instance Typeable Word64 where { typeOf _ = mkAppTy word64Tc [] }\n"
"\n"
"tyconTc = mkTyCon \"TyCon\"; instance Typeable TyCon where { typeOf _ = mkAppTy tyconTc [] }\n"
"typeRepTc = mkTyCon \"TypeRep\"; instance Typeable TypeRep where { typeOf _ = mkAppTy typeRepTc [] }\n"
"\n"
"ioRefTc = mkTyCon \"IORef\"; instance Typeable a => Typeable (IORef a) where {   typeOf x = mkAppTy ioRefTc [typeOf ((undefined :: IORef a -> a) x) ] }\n"
"\n"
"---------------------------------------------\n"
"--\n"
"--		Internals \n"
"--\n"
"---------------------------------------------\n"
"\n"
"data KeyPr = KeyPr !Key !Key deriving( Eq )\n"
"\n"
"hashKP :: KeyPr -> Int32\n"
"hashKP (KeyPr (Key k1) (Key k2)) = (HT.hashInt k1 + HT.hashInt k2) `rem` HT.prime\n"
"\n"
"data Cache = Cache { next_key :: !(IORef Key),\n"
"		     tc_tbl   :: !(HT.HashTable String Key),\n"
"		     ap_tbl   :: !(HT.HashTable KeyPr Key) }\n"
"\n"
"{-# NOINLINE cache #-}\n"
"cache :: Cache\n"
"cache = unsafePerformIO $ do\n"
"		empty_tc_tbl <- HT.new (==) HT.hashString\n"
"		empty_ap_tbl <- HT.new (==) hashKP\n"
"		key_loc      <- newIORef (Key 1) \n"
"		return (Cache { next_key = key_loc,\n"
"				tc_tbl = empty_tc_tbl, \n"
"				ap_tbl = empty_ap_tbl })\n"
"\n"
"newKey :: IORef Key -> IO Key\n"
"newKey kloc = do { k@(Key i) <- readIORef kloc ;\n"
"		   writeIORef kloc (Key (i+1)) ;\n"
"		   return k }\n"
"\n"
"mkTyConKey :: String -> Key\n"
"mkTyConKey str \n"
"  = unsafePerformIO $ do\n"
"	let Cache {next_key = kloc, tc_tbl = tbl} = cache\n"
"	mb_k <- HT.lookup tbl str\n"
"	case mb_k of\n"
"	  Just k  -> return k\n"
"	  Nothing -> do { k <- newKey kloc ;\n"
"			  HT.insert tbl str k ;\n"
"			  return k }\n"
"\n"
"appKey :: Key -> Key -> Key\n"
"appKey k1 k2\n"
"  = unsafePerformIO $ do\n"
"	let Cache {next_key = kloc, ap_tbl = tbl} = cache\n"
"	mb_k <- HT.lookup tbl kpr\n"
"	case mb_k of\n"
"	  Just k  -> return k\n"
"	  Nothing -> do { k <- newKey kloc ;\n"
"			  HT.insert tbl kpr k ;\n"
"			  return k }\n"
"  where\n"
"    kpr = KeyPr k1 k2\n"
"\n"
"appKeys :: Key -> [Key] -> Key\n"
"appKeys k ks = foldl appKey k ks\n";
const char *Data_Array_IArray = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Array.IArray\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- Immutable arrays, with an overloaded interface.  For array types\n"
"-- which can be used with this interface, see \"Data.Array\",\n"
"-- \"Data.Array.Unboxed\", and \"Data.Array.Diff\".\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Array.IArray ( \n"
"    -- * Class of immutable array types\n"
"    IArray,     -- :: (* -> * -> *) -> * -> class\n"
"\n"
"    -- * Class of array types with immutable bounds\n"
"    HasBounds,  -- :: (* -> * -> *) -> class\n"
"\n"
"    -- * Ordinary boxed\\/lazy arrays\n"
"    Array,    \n"
"\n"
"    -- * The @Ix@ class and operations\n"
"    module Data.Ix,\n"
"\n"
"    -- * Array construction\n"
"    array,      -- :: (IArray a e, Ix i) => (i,i) -> [(i, e)] -> a i e\n"
"    listArray,  -- :: (IArray a e, Ix i) => (i,i) -> [e] -> a i e\n"
"    accumArray, -- :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i,i) -> [(i, e')] -> a i e\n"
"\n"
"    -- * Indexing arrays\n"
"    (!),        -- :: (IArray a e, Ix i) => a i e -> i -> e\n"
"\n"
"    -- * Incremental updates\n"
"    (//),       -- :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e\n"
"    accum,      -- :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e\n"
"\n"
"    -- * Derived Arrays\n"
"    amap,       -- :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e\n"
"    ixmap,      -- :: (IArray a e, Ix i, Ix j) => (i,i) -> (i -> j) -> a j e -> a i e\n"
"\n"
"    -- * Deconstructing arrays\n"
"    bounds,     -- :: (HasBounds a, Ix i) => a i e -> (i,i)\n"
"    indices,    -- :: (HasBounds a, Ix i) => a i e -> [i]\n"
"    elems,      -- :: (IArray a e, Ix i) => a i e -> [e]\n"
"    assocs,     -- :: (IArray a e, Ix i) => a i e -> [(i, e)]\n"
" )  where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Ix\n"
"import Data.Array (Array)\n"
"import Data.Array.Base\n";
const char *Data_Array_Diff = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Array.Diff\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- Functional arrays with constant-time update.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Array.Diff (\n"
"\n"
"    -- * Diff array types\n"
"\n"
"    -- | Diff arrays have an immutable interface, but rely on internal\n"
"    -- updates in place to provide fast functional update operator\n"
"    -- '//'.\n"
"    --\n"
"    -- When the '//' operator is applied to a diff array, its contents\n"
"    -- are physically updated in place. The old array silently changes\n"
"    -- its representation without changing the visible behavior:\n"
"    -- it stores a link to the new current array along with the\n"
"    -- difference to be applied to get the old contents.\n"
"    --\n"
"    -- So if a diff array is used in a single-threaded style,\n"
"    -- i.e. after '//' application the old version is no longer used,\n"
"    -- @a'!'i@ takes O(1) time and @a '//' d@ takes O(@length d@).\n"
"    -- Accessing elements of older versions gradually becomes slower.\n"
"    --\n"
"    -- Updating an array which is not current makes a physical copy.\n"
"    -- The resulting array is unlinked from the old family. So you\n"
"    -- can obtain a version which is guaranteed to be current and\n"
"    -- thus have fast element access by @a '//' []@.\n"
"\n"
"    -- Possible improvement for the future (not implemented now):\n"
"    -- make it possible to say \"I will make an update now, but when\n"
"    -- I later return to the old version, I want it to mutate back\n"
"    -- instead of being copied\".\n"
"\n"
"    IOToDiffArray, -- data IOToDiffArray\n"
"                   --     (a :: * -> * -> *) -- internal mutable array\n"
"                   --     (i :: *)           -- indices\n"
"                   --     (e :: *)           -- elements\n"
"\n"
"    -- | Type synonyms for the two most important IO array types.\n"
"\n"
"    -- Two most important diff array types are fully polymorphic\n"
"    -- lazy boxed DiffArray:\n"
"    DiffArray,     -- = IOToDiffArray IOArray\n"
"    -- ...and strict unboxed DiffUArray, working only for elements\n"
"    -- of primitive types but more compact and usually faster:\n"
"    DiffUArray,    -- = IOToDiffArray IOUArray\n"
"\n"
"    -- * Overloaded immutable array interface\n"
"    \n"
"    -- | Module \"Data.Array.IArray\" provides the interface of diff arrays.\n"
"    -- They are instances of class 'IArray'.\n"
"    module Data.Array.IArray,\n"
"\n"
"    -- * Low-level interface\n"
"\n"
"    -- | These are really internal functions, but you will need them\n"
"    -- to make further 'IArray' instances of various diff array types\n"
"    -- (for either more 'MArray' types or more unboxed element types).\n"
"    newDiffArray, readDiffArray, replaceDiffArray\n"
"    )\n"
"    where\n"
"\n"
"------------------------------------------------------------------------\n"
"-- Imports.\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Ix\n"
"import Data.Array.Base\n"
"import Data.Array.IArray\n"
"import Data.Array.IO\n"
"\n"
"import Foreign.Ptr        ( Ptr, FunPtr )\n"
"import Foreign.StablePtr  ( StablePtr )\n"
"import Data.Int           ( Int8,  Int16,  Int32,  Int64 )\n"
"import Data.Word          ( Word8, Word16, Word32, Word64 )\n"
"\n"
"import System.IO.Unsafe	  ( unsafePerformIO )\n"
"import Control.Concurrent.MVar ( MVar, newMVar, takeMVar, putMVar, readMVar )\n"
"\n"
"------------------------------------------------------------------------\n"
"-- Diff array types.\n"
"\n"
"-- | An arbitrary 'MArray' type living in the 'IO' monad can be converted\n"
"-- to a diff array.\n"
"\n"
"newtype IOToDiffArray a i e =\n"
"    DiffArray {varDiffArray :: MVar (DiffArrayData a i e)}\n"
"\n"
"-- Internal representation: either a mutable array, or a link to\n"
"-- another diff array patched with a list of index+element pairs.\n"
"data DiffArrayData a i e = Current (a i e)\n"
"                         | Diff (IOToDiffArray a i e) [(Int, e)]\n"
"\n"
"-- | Fully polymorphic lazy boxed diff array.\n"
"type DiffArray  = IOToDiffArray IOArray\n"
"\n"
"-- | Strict unboxed diff array, working only for elements\n"
"-- of primitive types but more compact and usually faster than 'DiffArray'.\n"
"type DiffUArray = IOToDiffArray IOUArray\n"
"\n"
"-- Having 'MArray a e IO' in instance context would require\n"
"-- -fallow-undecidable-instances, so each instance is separate here.\n"
"\n"
"------------------------------------------------------------------------\n"
"-- Showing DiffArrays\n"
"\n"
"instance (Ix ix, Show ix, Show e) => Show (DiffArray ix e) where\n"
"  showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (DiffUArray ix Char) where\n"
"  showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (DiffUArray ix Int) where\n"
"  showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (DiffUArray ix Float) where\n"
"  showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (DiffUArray ix Double) where\n"
"  showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (DiffUArray ix Int8) where\n"
"  showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (DiffUArray ix Int16) where\n"
"  showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (DiffUArray ix Int32) where\n"
"  showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (DiffUArray ix Int64) where\n"
"  showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (DiffUArray ix Word8) where\n"
"  showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (DiffUArray ix Word16) where\n"
"  showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (DiffUArray ix Word32) where\n"
"  showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (DiffUArray ix Word64) where\n"
"  showsPrec = showsIArray\n"
"\n"
"------------------------------------------------------------------------\n"
"-- Boring instances.\n"
"\n"
"instance HasBounds a => HasBounds (IOToDiffArray a) where\n"
"    bounds a = unsafePerformIO $ boundsDiffArray a\n"
"\n"
"instance IArray (IOToDiffArray IOArray) e where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) Char where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) Int where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) (Ptr a) where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) (FunPtr a) where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) Float where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) Double where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) (StablePtr a) where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) Int8 where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) Int16 where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) Int32 where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) Int64 where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) Word8 where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) Word16 where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) Word32 where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"instance IArray (IOToDiffArray IOUArray) Word64 where\n"
"    unsafeArray   lu ies = unsafePerformIO $ newDiffArray lu ies\n"
"    unsafeAt      a i    = unsafePerformIO $ a `readDiffArray` i\n"
"    unsafeReplace a ies  = unsafePerformIO $ a `replaceDiffArray` ies\n"
"\n"
"------------------------------------------------------------------------\n"
"-- The important stuff.\n"
"\n"
"newDiffArray :: (MArray a e IO, Ix i)\n"
"             => (i,i)\n"
"             -> [(Int, e)]\n"
"             -> IO (IOToDiffArray a i e)\n"
"newDiffArray (l,u) ies = do\n"
"    a <- newArray_ (l,u)\n"
"    sequence_ [unsafeWrite a i e | (i, e) <- ies]\n"
"    var <- newMVar (Current a)\n"
"    return (DiffArray var)\n"
"\n"
"readDiffArray :: (MArray a e IO, Ix i)\n"
"              => IOToDiffArray a i e\n"
"              -> Int\n"
"              -> IO e\n"
"a `readDiffArray` i = do\n"
"    d <- readMVar (varDiffArray a)\n"
"    case d of\n"
"        Current a'  -> unsafeRead a' i\n"
"        Diff a' ies -> maybe (readDiffArray a' i) return (lookup i ies)\n"
"\n"
"replaceDiffArray :: (MArray a e IO, Ix i)\n"
"                => IOToDiffArray a i e\n"
"                -> [(Int, e)]\n"
"                -> IO (IOToDiffArray a i e)\n"
"a `replaceDiffArray` ies = do\n"
"    d <- takeMVar (varDiffArray a)\n"
"    case d of\n"
"        Current a' -> case ies of\n"
"            [] -> do\n"
"                -- We don't do the copy when there is nothing to change\n"
"                -- and this is the current version. But see below.\n"
"                putMVar (varDiffArray a) d\n"
"                return a\n"
"            _:_ -> do\n"
"                diff <- sequence [do e <- unsafeRead a' i; return (i, e)\n"
"                                  | (i, _) <- ies]\n"
"                sequence_ [unsafeWrite a' i e | (i, e) <- ies]\n"
"                var' <- newMVar (Current a')\n"
"                putMVar (varDiffArray a) (Diff (DiffArray var') diff)\n"
"                return (DiffArray var')\n"
"        Diff _ _ -> do\n"
"            -- We still do the copy when there is nothing to change\n"
"            -- but this is not the current version. So you can use\n"
"            -- 'a // []' to make sure that the resulting array has\n"
"            -- fast element access.\n"
"            putMVar (varDiffArray a) d\n"
"            a' <- thawDiffArray a\n"
"                -- thawDiffArray gives a fresh array which we can\n"
"                -- safely mutate.\n"
"            sequence_ [unsafeWrite a' i e | (i, e) <- ies]\n"
"            var' <- newMVar (Current a')\n"
"            return (DiffArray var')\n"
"\n"
"boundsDiffArray :: (HasBounds a, Ix ix)\n"
"                => IOToDiffArray a ix e\n"
"                -> IO (ix,ix)\n"
"boundsDiffArray a = do\n"
"    d <- readMVar (varDiffArray a)\n"
"    case d of\n"
"        Current a' -> return (bounds a')\n"
"        Diff a' _  -> boundsDiffArray a'\n"
"\n"
"freezeDiffArray :: (MArray a e IO, Ix ix)\n"
"                => a ix e\n"
"                -> IO (IOToDiffArray a ix e)\n"
"freezeDiffArray a = case bounds a of\n"
"  (l,u) -> do\n"
"    a' <- newArray_ (l,u)\n"
"    sequence_ [unsafeRead a i >>= unsafeWrite a' i | i <- [0 .. rangeSize (l,u) - 1]]\n"
"    var <- newMVar (Current a')\n"
"    return (DiffArray var)\n"
"\n"
"{-# RULES\n"
"\"freeze/DiffArray\" freeze = freezeDiffArray\n"
"    #-}\n"
"\n"
"-- unsafeFreezeDiffArray is really unsafe. Better don't use the old\n"
"-- array at all after freezing. The contents of the source array will\n"
"-- be changed when '//' is applied to the resulting array.\n"
"\n"
"unsafeFreezeDiffArray :: (MArray a e IO, Ix ix)\n"
"                      => a ix e\n"
"                      -> IO (IOToDiffArray a ix e)\n"
"unsafeFreezeDiffArray a = do\n"
"    var <- newMVar (Current a)\n"
"    return (DiffArray var)\n"
"\n"
"{-# RULES\n"
"\"unsafeFreeze/DiffArray\" unsafeFreeze = unsafeFreezeDiffArray\n"
"    #-}\n"
"\n"
"thawDiffArray :: (MArray a e IO, Ix ix)\n"
"              => IOToDiffArray a ix e\n"
"              -> IO (a ix e)\n"
"thawDiffArray a = do\n"
"    d <- readMVar (varDiffArray a)\n"
"    case d of\n"
"        Current a' -> case bounds a' of\n"
"	  (l,u) -> do\n"
"            a'' <- newArray_ (l,u)\n"
"            sequence_ [unsafeRead a' i >>= unsafeWrite a'' i | i <- [0 .. rangeSize (l,u) - 1]]\n"
"            return a''\n"
"        Diff a' ies -> do\n"
"            a'' <- thawDiffArray a'\n"
"            sequence_ [unsafeWrite a'' i e | (i, e) <- ies]\n"
"            return a''\n"
"\n"
"{-# RULES\n"
"\"thaw/DiffArray\" thaw = thawDiffArray\n"
"    #-}\n"
"\n"
"-- unsafeThawDiffArray is really unsafe. Better don't use the old\n"
"-- array at all after thawing. The contents of the resulting array\n"
"-- will be changed when '//' is applied to the source array.\n"
"\n"
"unsafeThawDiffArray :: (MArray a e IO, Ix ix)\n"
"                    => IOToDiffArray a ix e\n"
"                    -> IO (a ix e)\n"
"unsafeThawDiffArray a = do\n"
"    d <- readMVar (varDiffArray a)\n"
"    case d of\n"
"        Current a'  -> return a'\n"
"        Diff a' ies -> do\n"
"            a'' <- unsafeThawDiffArray a'\n"
"            sequence_ [unsafeWrite a'' i e | (i, e) <- ies]\n"
"            return a''\n"
"\n"
"{-# RULES\n"
"\"unsafeThaw/DiffArray\" unsafeThaw = unsafeThawDiffArray\n"
"    #-}\n";
const char *Data_Array_MArray = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Array.MArray\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- An overloaded interface to mutable arrays.  For array types which can be\n"
"-- used with this interface, see \"Data.Array.IO\", \"Data.Array.ST\", \n"
"-- and \"Data.Array.Storable\".\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Array.MArray ( \n"
"    -- * Class of mutable array types\n"
"    MArray,       -- :: (* -> * -> *) -> * -> (* -> *) -> class\n"
"\n"
"    -- * Class of array types with bounds\n"
"    HasBounds,    -- :: (* -> * -> *) -> class\n"
"\n"
"    -- * The @Ix@ class and operations\n"
"    module Data.Ix,\n"
"\n"
"    -- * Constructing mutable arrays\n"
"    newArray,     -- :: (MArray a e m, Ix i) => (i,i) -> e -> m (a i e)\n"
"    newArray_,    -- :: (MArray a e m, Ix i) => (i,i) -> m (a i e)\n"
"    newListArray, -- :: (MArray a e m, Ix i) => (i,i) -> [e] -> m (a i e)\n"
"\n"
"    -- * Reading and writing mutable arrays\n"
"    readArray,    -- :: (MArray a e m, Ix i) => a i e -> i -> m e\n"
"    writeArray,   -- :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()\n"
"\n"
"    -- * Derived arrays\n"
"    mapArray,     -- :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)\n"
"    mapIndices,   -- :: (MArray a e m, Ix i, Ix j) => (i,i) -> (i -> j) -> a j e -> m (a i e)\n"
"\n"
"    -- * Deconstructing mutable arrays\n"
"    bounds,       -- :: (HasBounds a, Ix i) => a i e -> (i,i)\n"
"    indices,      -- :: (HasBounds a, Ix i) => a i e -> [i]\n"
"    getElems,     -- :: (MArray a e m, Ix i) => a i e -> m [e]\n"
"    getAssocs,    -- :: (MArray a e m, Ix i) => a i e -> m [(i, e)]\n"
"\n"
"    -- * Conversions between mutable and immutable arrays\n"
"    freeze,       -- :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)\n"
"    unsafeFreeze, -- :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)\n"
"    thaw,         -- :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)\n"
"    unsafeThaw,   -- :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Ix\n"
"import Data.Array.Base\n";
const char *Data_Array_ST = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Array.ST\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- Mutable boxed and unboxed arrays in the 'Control.Monad.ST.ST' monad.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Array.ST (\n"
"\n"
"   -- * Boxed arrays\n"
"   STArray,		-- instance of: Eq, MArray\n"
"\n"
"   -- * Unboxed arrays\n"
"   STUArray,		-- instance of: Eq, MArray\n"
"   castSTUArray,	-- :: STUArray s i a -> ST s (STUArray s i b)\n"
"\n"
"   -- * Overloaded mutable array interface\n"
"   module Data.Array.MArray,\n"
" ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Array.MArray\n"
"import Data.Array.Base	( STUArray, castSTUArray )\n"
"\n"
"import Hugs.ST		( STArray )\n"
"\n";
const char *Data_Array_IO = "\n"
"{-# OPTIONS -#include \"HsBase.h\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Array.IO\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- Mutable boxed and unboxed arrays in the IO monad.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Array.IO (\n"
"   -- * @IO@ arrays with boxed elements\n"
"   IOArray,		-- instance of: Eq, Typeable\n"
"\n"
"   -- * @IO@ arrays with unboxed elements\n"
"   IOUArray,		-- instance of: Eq, Typeable\n"
"   castIOUArray,	-- :: IOUArray i a -> IO (IOUArray i b)\n"
"\n"
"   -- * Overloaded mutable array interface\n"
"   module Data.Array.MArray,\n"
"\n"
"   -- * Doing I\\/O with @IOUArray@s\n"
"   hGetArray,		-- :: Handle -> IOUArray Int Word8 -> Int -> IO Int\n"
"   hPutArray,		-- :: Handle -> IOUArray Int Word8 -> Int -> IO ()\n"
" ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Array.Base\n"
"import Data.Array.IO.Internals\n"
"import Data.Array		( Array )\n"
"import Data.Array.MArray\n"
"import Data.Int\n"
"import Data.Word\n"
"\n"
"import Data.Char\n"
"import System.IO\n"
"import System.IO.Error\n"
"\n"
"hGetArray :: Handle -> IOUArray Int Word8 -> Int -> IO Int\n"
"hGetArray handle arr count\n"
"  | count < 0 || count > rangeSize (bounds arr)\n"
"  = illegalBufferSize handle \"hGetArray\" count\n"
"  | otherwise = get 0\n"
" where\n"
"  get i | i == count = return i\n"
"	| otherwise = do\n"
"		error_or_c <- try (hGetChar handle)\n"
"		case error_or_c of\n"
"		    Left ex\n"
"			| isEOFError ex -> return i\n"
"			| otherwise -> ioError ex\n"
"		    Right c -> do\n"
"			unsafeWrite arr i (fromIntegral (ord c))\n"
"			get (i+1)\n"
"\n"
"hPutArray :: Handle -> IOUArray Int Word8 -> Int -> IO ()\n"
"hPutArray handle arr count\n"
"  | count < 0 || count > rangeSize (bounds arr)\n"
"  = illegalBufferSize handle \"hPutArray\" count\n"
"  | otherwise = put 0\n"
" where\n"
"  put i | i == count = return ()\n"
"	| otherwise = do\n"
"		w <- unsafeRead arr i\n"
"		hPutChar handle (chr (fromIntegral w))\n"
"		put (i+1)\n"
"\n"
"illegalBufferSize :: Handle -> String -> Int -> IO a\n"
"illegalBufferSize _ fn sz = ioError $\n"
"	userError (fn ++ \": illegal buffer size \" ++ showsPrec 9 (sz::Int) [])\n";
const char *Data_Array_Unboxed = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Array.Unboxed\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- Unboxed immutable arrays.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Array.Unboxed (\n"
"   -- * Arrays with unboxed elements\n"
"   UArray,\n"
"\n"
"   -- * The overloaded immutable array interface\n"
"   module Data.Array.IArray,\n"
" ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Array.IArray\n"
"import Data.Array.Base\n";
const char *Data_Array_Base = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Array.Base\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- Basis for IArray and MArray.  Not intended for external consumption;\n"
"-- use IArray or MArray instead.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- #hide\n"
"module Data.Array.Base where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Ix		( Ix, range, index, rangeSize )\n"
"import Data.Int\n"
"import Data.Word\n"
"import Foreign.Ptr\n"
"import Foreign.StablePtr\n"
"\n"
"import Data.Bits\n"
"import Foreign.Storable\n"
"import qualified Hugs.Array as Arr\n"
"import qualified Hugs.ST as ArrST\n"
"import Hugs.Array ( unsafeIndex )\n"
"import Hugs.ST ( STArray, ST(..), runST )\n"
"import Hugs.ByteArray\n"
"\n"
"import Data.Typeable\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Class of immutable arrays\n"
"\n"
"-- | Class of array types with bounds\n"
"class HasBounds a where\n"
"    -- | Extracts the bounds of an array\n"
"    bounds :: Ix i => a i e -> (i,i)\n"
"\n"
"{- | Class of immutable array types.\n"
"\n"
"An array type has the form @(a i e)@ where @a@ is the array type\n"
"constructor (kind @* -> * -> *@), @i@ is the index type (a member of\n"
"the class 'Ix'), and @e@ is the element type.  The @IArray@ class is\n"
"parameterised over both @a@ and @e@, so that instances specialised to\n"
"certain element types can be defined.\n"
"-}\n"
"class HasBounds a => IArray a e where\n"
"    unsafeArray      :: Ix i => (i,i) -> [(Int, e)] -> a i e\n"
"    unsafeAt         :: Ix i => a i e -> Int -> e\n"
"    unsafeReplace    :: Ix i => a i e -> [(Int, e)] -> a i e\n"
"    unsafeAccum      :: Ix i => (e -> e' -> e) -> a i e -> [(Int, e')] -> a i e\n"
"    unsafeAccumArray :: Ix i => (e -> e' -> e) -> e -> (i,i) -> [(Int, e')] -> a i e\n"
"\n"
"    unsafeReplace arr ies = runST (unsafeReplaceST arr ies >>= unsafeFreeze)\n"
"    unsafeAccum f arr ies = runST (unsafeAccumST f arr ies >>= unsafeFreeze)\n"
"    unsafeAccumArray f e lu ies = runST (unsafeAccumArrayST f e lu ies >>= unsafeFreeze)\n"
"\n"
"{-# INLINE unsafeReplaceST #-}\n"
"unsafeReplaceST :: (IArray a e, Ix i) => a i e -> [(Int, e)] -> ST s (STArray s i e)\n"
"unsafeReplaceST arr ies = do\n"
"    marr <- thaw arr\n"
"    sequence_ [unsafeWrite marr i e | (i, e) <- ies]\n"
"    return marr\n"
"\n"
"{-# INLINE unsafeAccumST #-}\n"
"unsafeAccumST :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(Int, e')] -> ST s (STArray s i e)\n"
"unsafeAccumST f arr ies = do\n"
"    marr <- thaw arr\n"
"    sequence_ [do\n"
"        old <- unsafeRead marr i\n"
"        unsafeWrite marr i (f old new)\n"
"        | (i, new) <- ies]\n"
"    return marr\n"
"\n"
"{-# INLINE unsafeAccumArrayST #-}\n"
"unsafeAccumArrayST :: Ix i => (e -> e' -> e) -> e -> (i,i) -> [(Int, e')] -> ST s (STArray s i e)\n"
"unsafeAccumArrayST f e (l,u) ies = do\n"
"    marr <- newArray (l,u) e\n"
"    sequence_ [do\n"
"        old <- unsafeRead marr i\n"
"        unsafeWrite marr i (f old new)\n"
"        | (i, new) <- ies]\n"
"    return marr\n"
"\n"
"{-# INLINE array #-} \n"
"\n"
"{-| Constructs an immutable array from a pair of bounds and a list of\n"
"initial associations.\n"
"\n"
"The bounds are specified as a pair of the lowest and highest bounds in\n"
"the array respectively.  For example, a one-origin vector of length 10\n"
"has bounds (1,10), and a one-origin 10 by 10 matrix has bounds\n"
"((1,1),(10,10)).\n"
"\n"
"An association is a pair of the form @(i,x)@, which defines the value\n"
"of the array at index @i@ to be @x@.  The array is undefined if any\n"
"index in the list is out of bounds.  If any two associations in the\n"
"list have the same index, the value at that index is undefined.\n"
"\n"
"Because the indices must be checked for these errors, 'array' is\n"
"strict in the bounds argument and in the indices of the association\n"
"list.  Whether @array@ is strict or non-strict in the elements depends\n"
"on the array type: 'Data.Array.Array' is a non-strict array type, but\n"
"all of the 'Data.Array.Unboxed.UArray' arrays are strict.  Thus in a\n"
"non-strict array, recurrences such as the following are possible:\n"
"\n"
"> a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i \\<- [2..100]])\n"
"\n"
"Not every index within the bounds of the array need appear in the\n"
"association list, but the values associated with indices that do not\n"
"appear will be undefined.\n"
"\n"
"If, in any dimension, the lower bound is greater than the upper bound,\n"
"then the array is legal, but empty. Indexing an empty array always\n"
"gives an array-bounds error, but 'bounds' still yields the bounds with\n"
"which the array was constructed.\n"
"-}\n"
"array 	:: (IArray a e, Ix i) \n"
"	=> (i,i)	-- ^ bounds of the array: (lowest,highest)\n"
"	-> [(i, e)]	-- ^ list of associations\n"
"	-> a i e\n"
"array (l,u) ies = unsafeArray (l,u) [(index (l,u) i, e) | (i, e) <- ies]\n"
"\n"
"-- Since unsafeFreeze is not guaranteed to be only a cast, we will\n"
"-- use unsafeArray and zip instead of a specialized loop to implement\n"
"-- listArray, unlike Array.listArray, even though it generates some\n"
"-- unnecessary heap allocation. Will use the loop only when we have\n"
"-- fast unsafeFreeze, namely for Array and UArray (well, they cover\n"
"-- almost all cases).\n"
"\n"
"{-# INLINE listArray #-}\n"
"\n"
"-- | Constructs an immutable array from a list of initial elements.\n"
"-- The list gives the elements of the array in ascending order\n"
"-- beginning with the lowest index.\n"
"listArray :: (IArray a e, Ix i) => (i,i) -> [e] -> a i e\n"
"listArray (l,u) es = unsafeArray (l,u) (zip [0 .. rangeSize (l,u) - 1] es)\n"
"\n"
"{-# INLINE listArrayST #-}\n"
"listArrayST :: Ix i => (i,i) -> [e] -> ST s (STArray s i e)\n"
"listArrayST (l,u) es = do\n"
"    marr <- newArray_ (l,u)\n"
"    let n = rangeSize (l,u)\n"
"    let fillFromList i xs | i == n    = return ()\n"
"                          | otherwise = case xs of\n"
"            []   -> return ()\n"
"            y:ys -> unsafeWrite marr i y >> fillFromList (i+1) ys\n"
"    fillFromList 0 es\n"
"    return marr\n"
"\n"
"{-# RULES\n"
"\"listArray/Array\" listArray =\n"
"    \\lu es -> runST (listArrayST lu es >>= ArrST.unsafeFreezeSTArray)\n"
"    #-}\n"
"\n"
"{-# INLINE listUArrayST #-}\n"
"listUArrayST :: (MArray (STUArray s) e (ST s), Ix i)\n"
"             => (i,i) -> [e] -> ST s (STUArray s i e)\n"
"listUArrayST (l,u) es = do\n"
"    marr <- newArray_ (l,u)\n"
"    let n = rangeSize (l,u)\n"
"    let fillFromList i xs | i == n    = return ()\n"
"                          | otherwise = case xs of\n"
"            []   -> return ()\n"
"            y:ys -> unsafeWrite marr i y >> fillFromList (i+1) ys\n"
"    fillFromList 0 es\n"
"    return marr\n"
"\n"
"-- I don't know how to write a single rule for listUArrayST, because\n"
"-- the type looks like constrained over 's', which runST doesn't\n"
"-- like. In fact all MArray (STUArray s) instances are polymorphic\n"
"-- wrt. 's', but runST can't know that.\n"
"\n"
"-- I would like to write a rule for listUArrayST (or listArray or\n"
"-- whatever) applied to unpackCString#. Unfortunately unpackCString#\n"
"-- calls seem to be floated out, then floated back into the middle\n"
"-- of listUArrayST, so I was not able to do this.\n"
"\n"
"{-# RULES\n"
"\"listArray/UArray/Bool\"      listArray = \\lu (es :: [Bool])        ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Char\"      listArray = \\lu (es :: [Char])        ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Int\"       listArray = \\lu (es :: [Int])         ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Word\"      listArray = \\lu (es :: [Word])        ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Ptr\"       listArray = \\lu (es :: [Ptr a])       ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/FunPtr\"    listArray = \\lu (es :: [FunPtr a])    ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Float\"     listArray = \\lu (es :: [Float])       ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Double\"    listArray = \\lu (es :: [Double])      ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/StablePtr\" listArray = \\lu (es :: [StablePtr a]) ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Int8\"      listArray = \\lu (es :: [Int8])        ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Int16\"     listArray = \\lu (es :: [Int16])       ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Int32\"     listArray = \\lu (es :: [Int32])       ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Int64\"     listArray = \\lu (es :: [Int64])       ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Word8\"     listArray = \\lu (es :: [Word8])       ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Word16\"    listArray = \\lu (es :: [Word16])      ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Word32\"    listArray = \\lu (es :: [Word32])      ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"\"listArray/UArray/Word64\"    listArray = \\lu (es :: [Word64])      ->\n"
"    runST (listUArrayST lu es >>= unsafeFreezeSTUArray)\n"
"    #-}\n"
"\n"
"{-# INLINE (!) #-}\n"
"-- | Returns the element of an immutable array at the specified index.\n"
"(!) :: (IArray a e, Ix i) => a i e -> i -> e\n"
"arr ! i = case bounds arr of (l,u) -> unsafeAt arr (index (l,u) i)\n"
"\n"
"{-# INLINE indices #-}\n"
"-- | Returns a list of all the valid indices in an array.\n"
"indices :: (HasBounds a, Ix i) => a i e -> [i]\n"
"indices arr = case bounds arr of (l,u) -> range (l,u)\n"
"\n"
"{-# INLINE elems #-}\n"
"-- | Returns a list of all the elements of an array, in the same order\n"
"-- as their indices.\n"
"elems :: (IArray a e, Ix i) => a i e -> [e]\n"
"elems arr = case bounds arr of\n"
"    (l,u) -> [unsafeAt arr i | i <- [0 .. rangeSize (l,u) - 1]]\n"
"\n"
"{-# INLINE assocs #-}\n"
"-- | Returns the contents of an array as a list of associations.\n"
"assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]\n"
"assocs arr = case bounds arr of\n"
"    (l,u) -> [(i, unsafeAt arr (unsafeIndex (l,u) i)) | i <- range (l,u)]\n"
"\n"
"{-# INLINE accumArray #-}\n"
"\n"
"{-| \n"
"Constructs an immutable array from a list of associations.  Unlike\n"
"'array', the same index is allowed to occur multiple times in the list\n"
"of associations; an /accumulating function/ is used to combine the\n"
"values of elements with the same index.\n"
"\n"
"For example, given a list of values of some index type, hist produces\n"
"a histogram of the number of occurrences of each index within a\n"
"specified range:\n"
"\n"
"> hist :: (Ix a, Num b) => (a,a) -> [a] -> Array a b\n"
"> hist bnds is = accumArray (+) 0 bnds [(i, 1) | i\\<-is, inRange bnds i]\n"
"-}\n"
"accumArray :: (IArray a e, Ix i) \n"
"	=> (e -> e' -> e) 	-- ^ An accumulating function\n"
"	-> e			-- ^ A default element\n"
"	-> (i,i)		-- ^ The bounds of the array\n"
"	-> [(i, e')]		-- ^ List of associations\n"
"	-> a i e		-- ^ Returns: the array\n"
"accumArray f init (l,u) ies =\n"
"    unsafeAccumArray f init (l,u) [(index (l,u) i, e) | (i, e) <- ies]\n"
"\n"
"{-# INLINE (//) #-}\n"
"{-|\n"
"Takes an array and a list of pairs and returns an array identical to\n"
"the left argument except that it has been updated by the associations\n"
"in the right argument. (As with the array function, the indices in the\n"
"association list must be unique for the updated elements to be\n"
"defined.) For example, if m is a 1-origin, n by n matrix, then\n"
"@m\\/\\/[((i,i), 0) | i \\<- [1..n]]@ is the same matrix, except with the\n"
"diagonal zeroed.\n"
"\n"
"For most array types, this operation is O(/n/) where /n/ is the size\n"
"of the array.  However, the 'Data.Array.Diff.DiffArray' type provides\n"
"this operation with complexity linear in the number of updates.\n"
"-}\n"
"(//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e\n"
"arr // ies = case bounds arr of\n"
"    (l,u) -> unsafeReplace arr [(index (l,u) i, e) | (i, e) <- ies]\n"
"\n"
"{-# INLINE accum #-}\n"
"{-|\n"
"@accum f@ takes an array and an association list and accumulates pairs\n"
"from the list into the array with the accumulating function @f@. Thus\n"
"'accumArray' can be defined using 'accum':\n"
"\n"
"> accumArray f z b = accum f (array b [(i, z) | i \\<- range b])\n"
"-}\n"
"accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e\n"
"accum f arr ies = case bounds arr of\n"
"    (l,u) -> unsafeAccum f arr [(index (l,u) i, e) | (i, e) <- ies]\n"
"\n"
"{-# INLINE amap #-}\n"
"-- | Returns a new array derived from the original array by applying a\n"
"-- function to each of the elements.\n"
"amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e\n"
"amap f arr = case bounds arr of\n"
"    (l,u) -> unsafeArray (l,u) [(i, f (unsafeAt arr i)) |\n"
"				i <- [0 .. rangeSize (l,u) - 1]]\n"
"{-# INLINE ixmap #-}\n"
"-- | Returns a new array derived from the original array by applying a\n"
"-- function to each of the indices.\n"
"ixmap :: (IArray a e, Ix i, Ix j) => (i,i) -> (i -> j) -> a j e -> a i e\n"
"ixmap (l,u) f arr =\n"
"    unsafeArray (l,u) [(unsafeIndex (l,u) i, arr ! f i) | i <- range (l,u)]\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Normal polymorphic arrays\n"
"\n"
"instance HasBounds Arr.Array where\n"
"    {-# INLINE bounds #-}\n"
"    bounds = Arr.bounds\n"
"\n"
"instance IArray Arr.Array e where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray      = Arr.unsafeArray\n"
"    {-# INLINE unsafeAt #-}\n"
"    unsafeAt         = Arr.unsafeAt\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace    = Arr.unsafeReplace\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum      = Arr.unsafeAccum\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray = Arr.unsafeAccumArray\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Flat unboxed arrays\n"
"\n"
"-- | Arrays with unboxed elements.  Instances of 'IArray' are provided\n"
"-- for 'UArray' with certain element types ('Int', 'Float', 'Char',\n"
"-- etc.; see the 'UArray' class for a full list).\n"
"--\n"
"-- A 'UArray' will generally be more efficient (in terms of both time\n"
"-- and space) than the equivalent 'Data.Array.Array' with the same\n"
"-- element type.  However, 'UArray' is strict in its elements - so\n"
"-- don\\'t use 'UArray' if you require the non-strictness that\n"
"-- 'Data.Array.Array' provides.\n"
"--\n"
"-- Because the @IArray@ interface provides operations overloaded on\n"
"-- the type of the array, it should be possible to just change the\n"
"-- array type being used by a program from say @Array@ to @UArray@ to\n"
"-- get the benefits of unboxed arrays (don\\'t forget to import\n"
"-- \"Data.Array.Unboxed\" instead of \"Data.Array\").\n"
"--\n"
"data UArray i e = UArray !i !i !ByteArray\n"
"\n"
"uArrayTc = mkTyCon \"UArray\"; instance (Typeable a, Typeable b) => Typeable (UArray a b) where {   typeOf x = mkAppTy uArrayTc [typeOf ((undefined :: UArray a b -> a) x), 			     typeOf ((undefined :: UArray a b -> b) x)] }\n"
"\n"
"instance HasBounds UArray where\n"
"    {-# INLINE bounds #-}\n"
"    bounds (UArray l u _) = (l,u)\n"
"\n"
"{-# INLINE unsafeArrayUArray #-}\n"
"unsafeArrayUArray :: (MArray (STUArray s) e (ST s), Ix i)\n"
"                  => (i,i) -> [(Int, e)] -> e -> ST s (UArray i e)\n"
"unsafeArrayUArray (l,u) ies default_elem = do\n"
"    marr <- newArray (l,u) default_elem\n"
"    sequence_ [unsafeWrite marr i e | (i, e) <- ies]\n"
"    unsafeFreezeSTUArray marr\n"
"\n"
"unsafeFreezeSTUArray :: STUArray s i e -> ST s (UArray i e)\n"
"unsafeFreezeSTUArray (STUArray l u marr) = do\n"
"    arr <- unsafeFreezeMutableByteArray marr\n"
"    return (UArray l u arr)\n"
"\n"
"{-# INLINE unsafeReplaceUArray #-}\n"
"unsafeReplaceUArray :: (MArray (STUArray s) e (ST s), Ix i)\n"
"                    => UArray i e -> [(Int, e)] -> ST s (UArray i e)\n"
"unsafeReplaceUArray arr ies = do\n"
"    marr <- thawSTUArray arr\n"
"    sequence_ [unsafeWrite marr i e | (i, e) <- ies]\n"
"    unsafeFreezeSTUArray marr\n"
"\n"
"{-# INLINE unsafeAccumUArray #-}\n"
"unsafeAccumUArray :: (MArray (STUArray s) e (ST s), Ix i)\n"
"                  => (e -> e' -> e) -> UArray i e -> [(Int, e')] -> ST s (UArray i e)\n"
"unsafeAccumUArray f arr ies = do\n"
"    marr <- thawSTUArray arr\n"
"    sequence_ [do\n"
"        old <- unsafeRead marr i\n"
"        unsafeWrite marr i (f old new)\n"
"        | (i, new) <- ies]\n"
"    unsafeFreezeSTUArray marr\n"
"\n"
"{-# INLINE unsafeAccumArrayUArray #-}\n"
"unsafeAccumArrayUArray :: (MArray (STUArray s) e (ST s), Ix i)\n"
"                       => (e -> e' -> e) -> e -> (i,i) -> [(Int, e')] -> ST s (UArray i e)\n"
"unsafeAccumArrayUArray f init (l,u) ies = do\n"
"    marr <- newArray (l,u) init\n"
"    sequence_ [do\n"
"        old <- unsafeRead marr i\n"
"        unsafeWrite marr i (f old new)\n"
"        | (i, new) <- ies]\n"
"    unsafeFreezeSTUArray marr\n"
"\n"
"{-# INLINE eqUArray #-}\n"
"eqUArray :: (IArray UArray e, Ix i, Eq e) => UArray i e -> UArray i e -> Bool\n"
"eqUArray arr1@(UArray l1 u1 _) arr2@(UArray l2 u2 _) =\n"
"    if rangeSize (l1,u1) == 0 then rangeSize (l2,u2) == 0 else\n"
"    l1 == l2 && u1 == u2 &&\n"
"    and [unsafeAt arr1 i == unsafeAt arr2 i | i <- [0 .. rangeSize (l1,u1) - 1]]\n"
"\n"
"{-# INLINE cmpUArray #-}\n"
"cmpUArray :: (IArray UArray e, Ix i, Ord e) => UArray i e -> UArray i e -> Ordering\n"
"cmpUArray arr1 arr2 = compare (assocs arr1) (assocs arr2)\n"
"\n"
"{-# INLINE cmpIntUArray #-}\n"
"cmpIntUArray :: (IArray UArray e, Ord e) => UArray Int e -> UArray Int e -> Ordering\n"
"cmpIntUArray arr1@(UArray l1 u1 _) arr2@(UArray l2 u2 _) =\n"
"    if rangeSize (l1,u1) == 0 then if rangeSize (l2,u2) == 0 then EQ else LT else\n"
"    if rangeSize (l2,u2) == 0 then GT else\n"
"    case compare l1 l2 of\n"
"        EQ    -> foldr cmp (compare u1 u2) [0 .. rangeSize (l1, min u1 u2) - 1]\n"
"        other -> other\n"
"    where\n"
"    cmp i rest = case compare (unsafeAt arr1 i) (unsafeAt arr2 i) of\n"
"        EQ    -> rest\n"
"        other -> other\n"
"\n"
"{-# RULES \"cmpUArray/Int\" cmpUArray = cmpIntUArray #-}\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Showing IArrays\n"
"\n"
"{-# SPECIALISE \n"
"    showsIArray :: (IArray UArray e, Ix i, Show i, Show e) => \n"
"		   Int -> UArray i e -> ShowS\n"
"  #-}\n"
"\n"
"showsIArray :: (IArray a e, Ix i, Show i, Show e) => Int -> a i e -> ShowS\n"
"showsIArray p a =\n"
"    showParen (p > 9) $\n"
"    showString \"array \" .\n"
"    shows (bounds a) .\n"
"    showChar ' ' .\n"
"    shows (assocs a)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Flat unboxed arrays: instances\n"
"\n"
"unsafeAtBArray :: Storable e => UArray i e -> Int -> e\n"
"unsafeAtBArray (UArray _ _ arr) = readByteArray arr\n"
"\n"
"instance IArray UArray Bool where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies False)\n"
"    unsafeAt (UArray _ _ arr) i =\n"
"	testBit (readByteArray arr (bOOL_INDEX i)::BitSet) (bOOL_SUBINDEX i)\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray Char where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies '\\0')\n"
"    {-# INLINE unsafeAt #-}\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray Int where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray (Ptr a) where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies nullPtr)\n"
"    {-# INLINE unsafeAt #-}\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray (FunPtr a) where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies nullFunPtr)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray Float where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray Double where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray (StablePtr a) where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies nullStablePtr)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"-- bogus StablePtr value for initialising a UArray of StablePtr.\n"
"nullStablePtr = castPtrToStablePtr nullPtr\n"
"\n"
"instance IArray UArray Int8 where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray Int16 where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray Int32 where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray Int64 where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray Word8 where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray Word16 where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray Word32 where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance IArray UArray Word64 where\n"
"    {-# INLINE unsafeArray #-}\n"
"    unsafeArray lu ies = runST (unsafeArrayUArray lu ies 0)\n"
"    unsafeAt = unsafeAtBArray\n"
"    {-# INLINE unsafeReplace #-}\n"
"    unsafeReplace arr ies = runST (unsafeReplaceUArray arr ies)\n"
"    {-# INLINE unsafeAccum #-}\n"
"    unsafeAccum f arr ies = runST (unsafeAccumUArray f arr ies)\n"
"    {-# INLINE unsafeAccumArray #-}\n"
"    unsafeAccumArray f init lu ies = runST (unsafeAccumArrayUArray f init lu ies)\n"
"\n"
"instance Ix ix => Eq (UArray ix Bool) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix Char) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix Int) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix (Ptr a)) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix (FunPtr a)) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix Float) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix Double) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix Int8) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix Int16) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix Int32) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix Int64) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix Word8) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix Word16) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix Word32) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Eq (UArray ix Word64) where\n"
"    (==) = eqUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Bool) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Char) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Int) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix (Ptr a)) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix (FunPtr a)) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Float) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Double) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Int8) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Int16) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Int32) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Int64) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Word8) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Word16) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Word32) where\n"
"    compare = cmpUArray\n"
"\n"
"instance Ix ix => Ord (UArray ix Word64) where\n"
"    compare = cmpUArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Bool) where\n"
"    showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Char) where\n"
"    showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Int) where\n"
"    showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Float) where\n"
"    showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Double) where\n"
"    showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Int8) where\n"
"    showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Int16) where\n"
"    showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Int32) where\n"
"    showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Int64) where\n"
"    showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Word8) where\n"
"    showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Word16) where\n"
"    showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Word32) where\n"
"    showsPrec = showsIArray\n"
"\n"
"instance (Ix ix, Show ix) => Show (UArray ix Word64) where\n"
"    showsPrec = showsIArray\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Mutable arrays\n"
"\n"
"{-# NOINLINE arrEleBottom #-}\n"
"arrEleBottom :: a\n"
"arrEleBottom = error \"MArray: undefined array element\"\n"
"\n"
"{-| Class of mutable array types.\n"
"\n"
"An array type has the form @(a i e)@ where @a@ is the array type\n"
"constructor (kind @* -> * -> *@), @i@ is the index type (a member of\n"
"the class 'Ix'), and @e@ is the element type.\n"
"\n"
"The @MArray@ class is parameterised over both @a@ and @e@ (so that\n"
"instances specialised to certain element types can be defined, in the\n"
"same way as for 'IArray'), and also over the type of the monad, @m@,\n"
"in which the mutable array will be manipulated.\n"
"-}\n"
"class (HasBounds a, Monad m) => MArray a e m where\n"
"\n"
"    -- | Builds a new array, with every element initialised to the supplied \n"
"    -- value.\n"
"    newArray    :: Ix i => (i,i) -> e -> m (a i e)\n"
"\n"
"    -- | Builds a new array, with every element initialised to undefined.\n"
"    newArray_   :: Ix i => (i,i) -> m (a i e)\n"
"\n"
"    unsafeRead  :: Ix i => a i e -> Int -> m e\n"
"    unsafeWrite :: Ix i => a i e -> Int -> e -> m ()\n"
"\n"
"    newArray (l,u) init = do\n"
"        marr <- newArray_ (l,u)\n"
"        sequence_ [unsafeWrite marr i init | i <- [0 .. rangeSize (l,u) - 1]]\n"
"        return marr\n"
"\n"
"    newArray_ (l,u) = newArray (l,u) arrEleBottom\n"
"\n"
"    -- newArray takes an initialiser which all elements of\n"
"    -- the newly created array are initialised to.  newArray_ takes\n"
"    -- no initialiser, it is assumed that the array is initialised with\n"
"    -- \"undefined\" values.\n"
"\n"
"    -- why not omit newArray_?  Because in the unboxed array case we would\n"
"    -- like to omit the initialisation altogether if possible.  We can't do\n"
"    -- this for boxed arrays, because the elements must all have valid values\n"
"    -- at all times in case of garbage collection.\n"
"\n"
"    -- why not omit newArray?  Because in the boxed case, we can omit the\n"
"    -- default initialisation with undefined values if we *do* know the\n"
"    -- initial value and it is constant for all elements.\n"
"\n"
"{-# INLINE newListArray #-}\n"
"-- | Constructs a mutable array from a list of initial elements.\n"
"-- The list gives the elements of the array in ascending order\n"
"-- beginning with the lowest index.\n"
"newListArray :: (MArray a e m, Ix i) => (i,i) -> [e] -> m (a i e)\n"
"newListArray (l,u) es = do\n"
"    marr <- newArray_ (l,u)\n"
"    let n = rangeSize (l,u)\n"
"    let fillFromList i xs | i == n    = return ()\n"
"                          | otherwise = case xs of\n"
"            []   -> return ()\n"
"            y:ys -> unsafeWrite marr i y >> fillFromList (i+1) ys\n"
"    fillFromList 0 es\n"
"    return marr\n"
"\n"
"{-# INLINE readArray #-}\n"
"-- | Read an element from a mutable array\n"
"readArray :: (MArray a e m, Ix i) => a i e -> i -> m e\n"
"readArray marr i = case bounds marr of\n"
"    (l,u) -> unsafeRead marr (index (l,u) i)\n"
"\n"
"{-# INLINE writeArray #-}\n"
"-- | Write an element in a mutable array\n"
"writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()\n"
"writeArray marr i e = case bounds marr of\n"
"    (l,u) -> unsafeWrite marr (index (l,u) i) e\n"
"\n"
"{-# INLINE getElems #-}\n"
"-- | Return a list of all the elements of a mutable array\n"
"getElems :: (MArray a e m, Ix i) => a i e -> m [e]\n"
"getElems marr = case bounds marr of\n"
"    (l,u) -> sequence [unsafeRead marr i | i <- [0 .. rangeSize (l,u) - 1]]\n"
"\n"
"{-# INLINE getAssocs #-}\n"
"-- | Return a list of all the associations of a mutable array, in\n"
"-- index order.\n"
"getAssocs :: (MArray a e m, Ix i) => a i e -> m [(i, e)]\n"
"getAssocs marr = case bounds marr of\n"
"    (l,u) -> sequence [do e <- unsafeRead marr (index (l,u) i); return (i,e)\n"
"              | i <- range (l,u)]\n"
"\n"
"{-# INLINE mapArray #-}\n"
"-- | Constructs a new array derived from the original array by applying a\n"
"-- function to each of the elements.\n"
"mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)\n"
"mapArray f marr = case bounds marr of\n"
"  (l,u) -> do\n"
"    marr' <- newArray_ (l,u)\n"
"    sequence_ [do\n"
"        e <- unsafeRead marr i\n"
"        unsafeWrite marr' i (f e)\n"
"        | i <- [0 .. rangeSize (l,u) - 1]]\n"
"    return marr'\n"
"\n"
"{-# INLINE mapIndices #-}\n"
"-- | Constructs a new array derived from the original array by applying a\n"
"-- function to each of the indices.\n"
"mapIndices :: (MArray a e m, Ix i, Ix j) => (i,i) -> (i -> j) -> a j e -> m (a i e)\n"
"mapIndices (l,u) f marr = do\n"
"    marr' <- newArray_ (l,u)\n"
"    sequence_ [do\n"
"        e <- readArray marr (f i)\n"
"        unsafeWrite marr' (unsafeIndex (l,u) i) e\n"
"        | i <- range (l,u)]\n"
"    return marr'\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Polymorphic non-strict mutable arrays (ST monad)\n"
"\n"
"instance HasBounds (STArray s) where\n"
"    {-# INLINE bounds #-}\n"
"    bounds = ArrST.boundsSTArray\n"
"\n"
"instance MArray (STArray s) e (ST s) where\n"
"    {-# INLINE newArray #-}\n"
"    newArray    = ArrST.newSTArray\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead  = ArrST.unsafeReadSTArray\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite = ArrST.unsafeWriteSTArray\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Typeable instance for STArray\n"
"\n"
"sTArrayTc :: TyCon\n"
"sTArrayTc = mkTyCon \"STArray\"\n"
"\n"
"instance (Typeable a, Typeable b, Typeable c) => Typeable (STArray a b c) where\n"
"  typeOf a = mkAppTy sTArrayTc [typeOf ((undefined :: STArray a b c -> a) a),\n"
"				typeOf ((undefined :: STArray a b c -> b) a),\n"
"				typeOf ((undefined :: STArray a b c -> c) a)]\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Flat unboxed mutable arrays (ST monad)\n"
"\n"
"-- | A mutable array with unboxed elements, that can be manipulated in\n"
"-- the 'ST' monad.  The type arguments are as follows:\n"
"--\n"
"--  * @s@: the state variable argument for the 'ST' type\n"
"--\n"
"--  * @i@: the index type of the array (should be an instance of @Ix@)\n"
"--\n"
"--  * @e@: the element type of the array.  Only certain element types\n"
"--    are supported.\n"
"--\n"
"-- An 'STUArray' will generally be more efficient (in terms of both time\n"
"-- and space) than the equivalent boxed version ('STArray') with the same\n"
"-- element type.  However, 'STUArray' is strict in its elements - so\n"
"-- don\\'t use 'STUArray' if you require the non-strictness that\n"
"-- 'STArray' provides.\n"
"data STUArray s i a = STUArray !i !i !(MutableByteArray s)\n"
"\n"
"stUArrayTc = mkTyCon \"STUArray\"; instance (Typeable a, Typeable b, Typeable c) => Typeable (STUArray a b c) where {  typeOf a = mkAppTy stUArrayTc [typeOf ((undefined :: STUArray a b c -> a) a), 			     typeOf ((undefined :: STUArray a b c -> b) a), 			     typeOf ((undefined :: STUArray a b c -> c) a)] }\n"
"\n"
"instance HasBounds (STUArray s) where\n"
"    {-# INLINE bounds #-}\n"
"    bounds (STUArray l u _) = (l,u)\n"
"\n"
"newMBArray_ :: (Ix i, Storable e) => (i,i) -> ST s (STUArray s i e)\n"
"newMBArray_ = makeArray undefined\n"
"  where\n"
"    makeArray :: (Ix i, Storable e) => e -> (i,i) -> ST s (STUArray s i e)\n"
"    makeArray dummy (l,u) = do\n"
"	marr <- newMutableByteArray (rangeSize (l,u) * sizeOf dummy)\n"
"	return (STUArray l u marr)\n"
"\n"
"unsafeReadMBArray :: Storable e => STUArray s i e -> Int -> ST s e\n"
"unsafeReadMBArray (STUArray _ _ marr) = readMutableByteArray marr\n"
"\n"
"unsafeWriteMBArray :: Storable e => STUArray s i e -> Int -> e -> ST s ()\n"
"unsafeWriteMBArray (STUArray _ _ marr) = writeMutableByteArray marr\n"
"\n"
"instance MArray (STUArray s) Bool (ST s) where\n"
"    newArray_ (l,u) = do\n"
"        marr <- newMutableByteArray (bOOL_SCALE (rangeSize (l,u)))\n"
"        return (STUArray l u marr)\n"
"    unsafeRead (STUArray _ _ marr) i = do\n"
"	let ix = bOOL_INDEX i\n"
"	    bit = bOOL_SUBINDEX i\n"
"	w <- readMutableByteArray marr ix\n"
"	return (testBit (w::BitSet) bit)\n"
"    unsafeWrite (STUArray _ _ marr) i e = do\n"
"	let ix = bOOL_INDEX i\n"
"	    bit = bOOL_SUBINDEX i\n"
"	w <- readMutableByteArray marr ix\n"
"	writeMutableByteArray marr ix\n"
"	    (if e then setBit (w::BitSet) bit else clearBit w bit)\n"
"\n"
"instance MArray (STUArray s) Char (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) Int (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) (Ptr a) (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) (FunPtr a) (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) Float (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) Double (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) (StablePtr a) (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) Int8 (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) Int16 (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) Int32 (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) Int64 (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) Word8 (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) Word16 (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) Word32 (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"instance MArray (STUArray s) Word64 (ST s) where\n"
"    newArray_ = newMBArray_\n"
"    unsafeRead = unsafeReadMBArray\n"
"    unsafeWrite = unsafeWriteMBArray\n"
"\n"
"type BitSet = Word8\n"
"\n"
"bitSetSize = bitSize (0::BitSet)\n"
"\n"
"bOOL_SCALE :: Int -> Int\n"
"bOOL_SCALE n = (n + bitSetSize - 1) `div` bitSetSize\n"
" \n"
"bOOL_INDEX :: Int -> Int\n"
"bOOL_INDEX i = i `div` bitSetSize\n"
"\n"
"bOOL_SUBINDEX :: Int -> Int\n"
"bOOL_SUBINDEX i = i `mod` bitSetSize\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Freezing\n"
"\n"
"-- | Converts a mutable array (any instance of 'MArray') to an\n"
"-- immutable array (any instance of 'IArray') by taking a complete\n"
"-- copy of it.\n"
"freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)\n"
"freeze marr = case bounds marr of\n"
"  (l,u) -> do\n"
"    ies <- sequence [do e <- unsafeRead marr i; return (i,e)\n"
"                     | i <- [0 .. rangeSize (l,u) - 1]]\n"
"    return (unsafeArray (l,u) ies)\n"
"\n"
"-- In-place conversion of mutable arrays to immutable ones places\n"
"-- a proof obligation on the user: no other parts of your code can\n"
"-- have a reference to the array at the point where you unsafely\n"
"-- freeze it (and, subsequently mutate it, I suspect).\n"
"\n"
"{- |\n"
"   Converts an mutable array into an immutable array.  The \n"
"   implementation may either simply cast the array from\n"
"   one type to the other without copying the array, or it\n"
"   may take a full copy of the array.\n"
"\n"
"   Note that because the array is possibly not copied, any subsequent\n"
"   modifications made to the mutable version of the array may be\n"
"   shared with the immutable version.  It is safe to use, therefore, if\n"
"   the mutable version is never modified after the freeze operation.\n"
"\n"
"   The non-copying implementation is supported between certain pairs\n"
"   of array types only; one constraint is that the array types must\n"
"   have identical representations.  In GHC, The following pairs of\n"
"   array types have a non-copying O(1) implementation of\n"
"   'unsafeFreeze'.  Because the optimised versions are enabled by\n"
"   specialisations, you will need to compile with optimisation (-O) to\n"
"   get them.\n"
"\n"
"     * 'Data.Array.IO.IOUArray' -> 'Data.Array.Unboxed.UArray'\n"
"\n"
"     * 'Data.Array.ST.STUArray' -> 'Data.Array.Unboxed.UArray'\n"
"\n"
"     * 'Data.Array.IO.IOArray' -> 'Data.Array.Array'\n"
"\n"
"     * 'Data.Array.ST.STArray' -> 'Data.Array.Array'\n"
"-}\n"
"{-# INLINE unsafeFreeze #-}\n"
"unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)\n"
"unsafeFreeze = freeze\n"
"\n"
"{-# RULES\n"
"\"unsafeFreeze/STArray\"  unsafeFreeze = ArrST.unsafeFreezeSTArray\n"
"\"unsafeFreeze/STUArray\" unsafeFreeze = unsafeFreezeSTUArray\n"
"    #-}\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Thawing\n"
"\n"
"-- | Converts an immutable array (any instance of 'IArray') into a\n"
"-- mutable array (any instance of 'MArray') by taking a complete copy\n"
"-- of it.\n"
"thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)\n"
"thaw arr = case bounds arr of\n"
"  (l,u) -> do\n"
"    marr <- newArray_ (l,u)\n"
"    sequence_ [unsafeWrite marr i (unsafeAt arr i)\n"
"               | i <- [0 .. rangeSize (l,u) - 1]]\n"
"    return marr\n"
"\n"
"thawSTUArray :: Ix i => UArray i e -> ST s (STUArray s i e)\n"
"thawSTUArray (UArray l u arr) = do\n"
"    marr <- thawByteArray arr\n"
"    return (STUArray l u marr)\n"
"\n"
"-- In-place conversion of immutable arrays to mutable ones places\n"
"-- a proof obligation on the user: no other parts of your code can\n"
"-- have a reference to the array at the point where you unsafely\n"
"-- thaw it (and, subsequently mutate it, I suspect).\n"
"\n"
"{- |\n"
"   Converts an immutable array into a mutable array.  The \n"
"   implementation may either simply cast the array from\n"
"   one type to the other without copying the array, or it\n"
"   may take a full copy of the array.  \n"
"\n"
"   Note that because the array is possibly not copied, any subsequent\n"
"   modifications made to the mutable version of the array may be\n"
"   shared with the immutable version.  It is safe to use, therefore, if\n"
"   the immutable version is never referenced again.\n"
"\n"
"   The non-copying implementation is supported between certain pairs\n"
"   of array types only; one constraint is that the array types must\n"
"   have identical representations.  In GHC, The following pairs of\n"
"   array types have a non-copying O(1) implementation of\n"
"   'unsafeFreeze'.  Because the optimised versions are enabled by\n"
"   specialisations, you will need to compile with optimisation (-O) to\n"
"   get them.\n"
"\n"
"     * 'Data.Array.Unboxed.UArray' -> 'Data.Array.IO.IOUArray'\n"
"\n"
"     * 'Data.Array.Unboxed.UArray' -> 'Data.Array.ST.STUArray'\n"
"\n"
"     * 'Data.Array.Array'  -> 'Data.Array.IO.IOArray'\n"
"\n"
"     * 'Data.Array.Array'  -> 'Data.Array.ST.STArray'\n"
"-}\n"
"{-# INLINE unsafeThaw #-}\n"
"unsafeThaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)\n"
"unsafeThaw = thaw\n"
"\n"
"-- | Casts an 'STUArray' with one element type into one with a\n"
"-- different element type.  All the elements of the resulting array\n"
"-- are undefined (unless you know what you\\'re doing...).\n"
"\n"
"castSTUArray :: STUArray s ix a -> ST s (STUArray s ix b)\n"
"castSTUArray (STUArray l u marr) = return (STUArray l u marr)\n";
const char *Data_Array_Storable = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Array.Storable\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- A storable array is an IO-mutable array which stores its\n"
"-- contents in a contiguous memory block living in the C\n"
"-- heap. Elements are stored according to the class Storable.\n"
"-- You can obtain the pointer to the array contents to manipulate\n"
"-- elements from languages like C.\n"
"--\n"
"-- It's similar to IOUArray but slower. Its advantage is that\n"
"-- it's compatible with C.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.Array.Storable (\n"
"    \n"
"    -- Array type:\n"
"    StorableArray, -- data StorableArray index element\n"
"                   --     -- index type must be in class Ix\n"
"                   --     -- element type must be in class Storable\n"
"    \n"
"    -- Module MArray provides the interface of storable arrays.\n"
"    -- They are instances of class MArray (with IO monad).\n"
"    module Data.Array.MArray,\n"
"    \n"
"    -- The pointer to the array contents is obtained by withStorableArray.\n"
"    -- The idea is similar to ForeignPtr (used internally here). The\n"
"    -- pointer should be used only during execution of the IO action\n"
"    -- retured by the function passed as argument to withStorableArray:\n"
"    withStorableArray, -- :: StorableArray i e -> (Ptr e -> IO a) -> IO a\n"
"    \n"
"    -- If you want to use it afterwards, ensure that you\n"
"    -- touchStorableArray after the last use of the pointer,\n"
"    -- so the array is not freed too early:\n"
"    touchStorableArray -- :: StorableArray i e -> IO ()\n"
"    )\n"
"    where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Array.Base\n"
"import Data.Array.MArray\n"
"import Foreign hiding (newArray)\n"
"\n"
"data StorableArray i e = StorableArray !i !i !(ForeignPtr e)\n"
"\n"
"instance HasBounds StorableArray where\n"
"    bounds (StorableArray l u _) = (l,u)\n"
"\n"
"instance Storable e => MArray StorableArray e IO where\n"
"\n"
"    newArray (l,u) init = do\n"
"        fp <- mallocForeignPtrArray size\n"
"        withForeignPtr fp $ \\a ->\n"
"            sequence_ [pokeElemOff a i init | i <- [0..size-1]]\n"
"        return (StorableArray l u fp)\n"
"        where\n"
"        size = rangeSize (l,u)\n"
"\n"
"    newArray_ (l,u) = do\n"
"        fp <- mallocForeignPtrArray (rangeSize (l,u))\n"
"        return (StorableArray l u fp)\n"
"\n"
"    unsafeRead (StorableArray _ _ fp) i =\n"
"        withForeignPtr fp $ \\a -> peekElemOff a i\n"
"\n"
"    unsafeWrite (StorableArray _ _ fp) i e =\n"
"        withForeignPtr fp $ \\a -> pokeElemOff a i e\n"
"\n"
"withStorableArray :: StorableArray i e -> (Ptr e -> IO a) -> IO a\n"
"withStorableArray (StorableArray _ _ fp) f = withForeignPtr fp f\n"
"\n"
"touchStorableArray :: StorableArray i e -> IO ()\n"
"touchStorableArray (StorableArray _ _ fp) = touchForeignPtr fp\n";
const char *Data_Array_IO_Internals = "\n"
"{-# OPTIONS -#include \"HsBase.h\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.Array.IO.Internal\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- Mutable boxed and unboxed arrays in the IO monad.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- #hide\n"
"module Data.Array.IO.Internals (\n"
"   IOArray(..),		-- instance of: Eq, Typeable\n"
"   IOUArray(..),	-- instance of: Eq, Typeable\n"
"   castIOUArray,	-- :: IOUArray ix a -> IO (IOUArray ix b)\n"
" ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Array.MArray\n"
"import Data.Int\n"
"import Data.Word\n"
"import Data.Typeable\n"
"\n"
"import Hugs.IOArray\n"
"\n"
"import Control.Monad.ST		( RealWorld, stToIO )\n"
"import Foreign.Ptr		( Ptr, FunPtr )\n"
"import Foreign.StablePtr	( StablePtr )\n"
"import Data.Array.Base\n"
"\n"
"iOArrayTc :: TyCon\n"
"iOArrayTc = mkTyCon \"IOArray\"\n"
"\n"
"instance (Typeable a, Typeable b) => Typeable (IOArray a b) where\n"
"  typeOf a = mkAppTy iOArrayTc [typeOf ((undefined :: IOArray a b -> a) a),\n"
"				typeOf ((undefined :: IOArray a b -> b) a)]\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- | Instance declarations for 'IOArray's\n"
"\n"
"instance HasBounds IOArray where\n"
"    bounds      = boundsIOArray\n"
"\n"
"instance MArray IOArray e IO where\n"
"    newArray    = newIOArray\n"
"    unsafeRead  = unsafeReadIOArray\n"
"    unsafeWrite = unsafeWriteIOArray\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Flat unboxed mutable arrays (IO monad)\n"
"\n"
"-- | Mutable, unboxed, strict arrays in the 'IO' monad.  The type\n"
"-- arguments are as follows:\n"
"--\n"
"--  * @i@: the index type of the array (should be an instance of 'Ix')\n"
"--\n"
"--  * @e@: the element type of the array.  Only certain element types\n"
"--    are supported: see \"Data.Array.MArray\" for a list of instances.\n"
"--\n"
"newtype IOUArray i e = IOUArray (STUArray RealWorld i e)\n"
"\n"
"iOUArrayTc :: TyCon\n"
"iOUArrayTc = mkTyCon \"IOUArray\"\n"
"\n"
"instance (Typeable a, Typeable b) => Typeable (IOUArray a b) where\n"
"  typeOf a = mkAppTy iOUArrayTc [typeOf ((undefined :: IOUArray a b -> a) a),\n"
"				 typeOf ((undefined :: IOUArray a b -> b) a)]\n"
"\n"
"instance HasBounds IOUArray where\n"
"    {-# INLINE bounds #-}\n"
"    bounds (IOUArray marr) = bounds marr\n"
"\n"
"instance MArray IOUArray Bool IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray Char IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray Int IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray (Ptr a) IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray (FunPtr a) IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray Float IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray Double IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray (StablePtr a) IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray Int8 IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray Int16 IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray Int32 IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray Int64 IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray Word8 IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray Word16 IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray Word32 IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"instance MArray IOUArray Word64 IO where\n"
"    {-# INLINE newArray #-}\n"
"    newArray lu init = stToIO $ do\n"
"        marr <- newArray lu init; return (IOUArray marr)\n"
"    {-# INLINE newArray_ #-}\n"
"    newArray_ lu = stToIO $ do\n"
"        marr <- newArray_ lu; return (IOUArray marr)\n"
"    {-# INLINE unsafeRead #-}\n"
"    unsafeRead (IOUArray marr) i = stToIO (unsafeRead marr i)\n"
"    {-# INLINE unsafeWrite #-}\n"
"    unsafeWrite (IOUArray marr) i e = stToIO (unsafeWrite marr i e)\n"
"\n"
"-- | Casts an 'IOUArray' with one element type into one with a\n"
"-- different element type.  All the elements of the resulting array\n"
"-- are undefined (unless you know what you\\'re doing...).\n"
"castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)\n"
"castIOUArray (IOUArray marr) = stToIO $ do\n"
"    marr' <- castSTUArray marr\n"
"    return (IOUArray marr')\n";
const char *Data_STRef_Strict = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.STRef.Strict\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires universal quantification for runST)\n"
"--\n"
"-- Mutable references in the (strict) ST monad (re-export of \"Data.STRef\")\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Data.STRef.Strict (\n"
" 	module Data.STRef\n"
"  ) where\n"
"\n"
"import Prelude\n"
"import Data.STRef\n";
const char *Data_STRef_Lazy = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Data.STRef.Lazy\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable (requires non-portable module ST)\n"
"--\n"
"-- Mutable references in the lazy ST monad.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"module Data.STRef.Lazy (\n"
"	-- * STRefs\n"
"	ST.STRef,	-- abstract, instance Eq\n"
"	newSTRef,	-- :: a -> ST s (STRef s a)\n"
"	readSTRef,	-- :: STRef s a -> ST s a\n"
"	writeSTRef,	-- :: STRef s a -> a -> ST s ()\n"
"	modifySTRef	-- :: STRef s a -> (a -> a) -> ST s ()\n"
" ) where\n"
"\n"
"import Control.Monad.ST.Lazy\n"
"import qualified Data.STRef as ST\n"
"\n"
"newSTRef    :: a -> ST s (ST.STRef s a)\n"
"readSTRef   :: ST.STRef s a -> ST s a\n"
"writeSTRef  :: ST.STRef s a -> a -> ST s ()\n"
"modifySTRef :: ST.STRef s a -> (a -> a) -> ST s ()\n"
"\n"
"newSTRef   = strictToLazyST . ST.newSTRef\n"
"readSTRef  = strictToLazyST . ST.readSTRef\n"
"writeSTRef r a = strictToLazyST (ST.writeSTRef r a)\n"
"modifySTRef r f = strictToLazyST (ST.modifySTRef r f)\n";
const char *System_Posix = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix (\n"
"  module System.Posix.Types,\n"
"  module System.Posix.Signals,\n"
"  module System.Posix.Directory,\n"
"  module System.Posix.Files,\n"
"  module System.Posix.Unistd,\n"
"  module System.Posix.IO,\n"
"  module System.Posix.Env,\n"
"  module System.Posix.Process,\n"
"  module System.Posix.Temp,\n"
"  module System.Posix.Terminal,\n"
"  module System.Posix.Time,\n"
"  module System.Posix.User,\n"
"  module System.Posix.Resource\n"
" ) where\n"
"\n"
"import System.Posix.Types\n"
"import System.Posix.Signals\n"
"import System.Posix.Directory\n"
"import System.Posix.Files\n"
"import System.Posix.Unistd\n"
"import System.Posix.Process\n"
"import System.Posix.IO\n"
"import System.Posix.Env\n"
"import System.Posix.Temp\n"
"import System.Posix.Terminal\n"
"import System.Posix.Time\n"
"import System.Posix.User\n"
"import System.Posix.Resource\n"
"\n"
"{- TODO\n"
"\n"
"Here we detail our support for the IEEE Std 1003.1-2001 standard.  For\n"
"each header file defined by the standard, we categorise its\n"
"functionality as\n"
"\n"
" - \"supported\" \n"
"\n"
"   Full equivalent functionality is provided by the specified Haskell\n"
"   module.\n"
"\n"
" - \"unsupported\" (functionality not provided by a Haskell module)\n"
"\n"
"   The functionality is not currently provided.\n"
"\n"
" - \"to be supported\" \n"
"\n"
"   Currently unsupported, but support is planned for the future.\n"
"\n"
"Exceptions are listed where appropriate.\n"
"\n"
"Interfaces supported\n"
"--------------------\n"
"\n"
"base package:\n"
"\n"
"regex.h		Text.Regex.Posix\n"
"signal.h	System.Posix.Signals\n"
"\n"
"1 package:\n"
"\n"
"dirent.h 	System.Posix.Directory\n"
"dlfcn.h 	System.Posix.DynamicLinker\n"
"errno.h 	Foreign.C.Error\n"
"fcntl.h 	System.Posix.IO\n"
"sys/stat.h	System.Posix.Files\n"
"sys/times.h	System.Posix.Process\n"
"sys/types.h	System.Posix.Types (with exceptions...)\n"
"sys/utsname.h	System.Posix.Unistd\n"
"sys/wait.h	System.Posix.Process\n"
"termios.h	System.Posix.Terminal (check exceptions)\n"
"unistd.h	System.Posix.*\n"
"utime.h		System.Posix.Files\n"
"pwd.h		System.Posix.User\n"
"grp.h		System.Posix.User\n"
"stdlib.h: 	System.Posix.Env (getenv()/setenv()/unsetenv())\n"
"		System.Posix.Temp (mkstemp())\n"
"sys/resource.h: System.Posix.Resource (get/setrlimit() only)\n"
"\n"
"network package:\n"
"\n"
"arpa/inet.h\n"
"net/if.h\n"
"netinet/in.h\n"
"netinet/tcp.h\n"
"sys/socket.h\n"
"sys/un.h\n"
"\n"
"To be supported\n"
"---------------\n"
"\n"
"limits.h	(pathconf()/fpathconf() already done)\n"
"poll.h\n"
"sys/resource.h  (getrusage(): use instead of times() for getProcessTimes?)\n"
"sys/select.h\n"
"sys/statvfs.h	 (?)\n"
"sys/time.h	(but maybe not the itimer?)\n"
"time.h		(System.Posix.Time)\n"
"stdio.h		(popen only: System.Posix.IO)\n"
"sys/mman.h\n"
"\n"
"Unsupported interfaces\n"
"----------------------\n"
"\n"
"aio.h\n"
"assert.h\n"
"complex.h\n"
"cpio.h \n"
"ctype.h \n"
"fenv.h\n"
"float.h\n"
"fmtmsg.h\n"
"fnmatch.h\n"
"ftw.h\n"
"glob.h\n"
"iconv.h \n"
"inttypes.h \n"
"iso646.h \n"
"langinfo.h\n"
"libgen.h\n"
"locale.h	(see System.Locale)\n"
"math.h\n"
"monetary.h\n"
"mqueue.h\n"
"ndbm.h\n"
"netdb.h\n"
"nl_types.h\n"
"pthread.h\n"
"sched.h\n"
"search.h\n"
"semaphore.h\n"
"setjmp.h\n"
"spawn.h\n"
"stdarg.h\n"
"stdbool.h\n"
"stddef.h\n"
"stdint.h\n"
"stdio.h		except: popen()\n"
"stdlib.h	except: exit(): System.Posix.Process\n"
"			free()/malloc(): Foreign.Marshal.Alloc\n"
"			getenv()/setenv(): ?? System.Environment\n"
"			rand() etc.: System.Random\n"
"string.h\n"
"strings.h\n"
"stropts.h\n"
"sys/ipc.h\n"
"sys/msg.h\n"
"sys/sem.h\n"
"sys/shm.h\n"
"sys/timeb.h\n"
"sys/uio.h\n"
"syslog.h\n"
"tar.h\n"
"tgmath.h\n"
"trace.h\n"
"ucontext.h\n"
"ulimit.h\n"
"utmpx.h\n"
"wchar.h\n"
"wctype.h\n"
"wordexp.h\n"
"\n"
"-}\n";
const char *System_CPUTime = "{-# LINE 1 \"CPUTime.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"{-# LINE 2 \"CPUTime.hsc\" #-}\n"
"-- |\n"
"-- Module      :  System.CPUTime\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/core/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- The standard CPUTime library.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.CPUTime \n"
"	(\n"
"         getCPUTime,       -- :: IO Integer\n"
"	 cpuTimePrecision  -- :: Integer\n"
"        ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Ratio\n"
"\n"
"\n"
"{-# LINE 26 \"CPUTime.hsc\" #-}\n"
"import Hugs.Time ( getCPUTime, clockTicks )\n"
"\n"
"{-# LINE 28 \"CPUTime.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 35 \"CPUTime.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 123 \"CPUTime.hsc\" #-}\n"
"\n"
"-- |The 'cpuTimePrecision' constant is the smallest measurable difference\n"
"-- in CPU time that the implementation can record, and is given as an\n"
"-- integral number of picoseconds.\n"
"\n"
"cpuTimePrecision :: Integer\n"
"cpuTimePrecision = round ((1000000000000::Integer) % fromIntegral (clockTicks))\n"
"\n"
"\n"
"{-# LINE 141 \"CPUTime.hsc\" #-}\n";
const char *System_Random = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Random\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Random numbers.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Random\n"
"	(\n"
"\n"
"	-- $intro\n"
"\n"
"	-- * The 'RandomGen' class, and the 'StdGen' generator\n"
"\n"
"	  RandomGen(next, split, genRange)\n"
"	, StdGen\n"
"	, mkStdGen\n"
"\n"
"	-- * The 'Random' class\n"
"	, Random ( random,   randomR,\n"
"		   randoms,  randomRs,\n"
"		   randomIO, randomRIO )\n"
"\n"
"	-- * The global random number generator\n"
"\n"
"	-- $globalrng\n"
"\n"
"	, getStdRandom\n"
"	, getStdGen\n"
"	, setStdGen\n"
"	, newStdGen\n"
"\n"
"	-- * References\n"
"	-- $references\n"
"\n"
"	) where\n"
"\n"
"import Prelude\n"
"\n"
"import System.CPUTime	( getCPUTime )\n"
"import System.Time	( getClockTime, ClockTime(..) )\n"
"import Data.Char	( isSpace, chr, ord )\n"
"import System.IO.Unsafe ( unsafePerformIO )\n"
"import Data.IORef\n"
"import Numeric		( readDec )\n"
"\n"
"-- The standard nhc98 implementation of Time.ClockTime does not match\n"
"-- the extended one expected in this module, so we lash-up a quick\n"
"-- replacement here.\n"
"\n"
"{- $intro\n"
"\n"
"This library deals with the common task of pseudo-random\n"
"number generation. The library makes it possible to generate\n"
"repeatable results, by starting with a specified initial random\n"
"number generator; or to get different results on each run by using the \n"
"system-initialised generator, or by supplying a seed from some other\n"
"source.\n"
"\n"
"The library is split into two layers: \n"
"\n"
"* A core /random number generator/ provides a supply of bits. The class\n"
"'RandomGen' provides a common interface to such generators.\n"
"\n"
"* The class 'Random' provides a way to extract particular values from\n"
"a random number generator. For example, the 'Float' instance of 'Random'\n"
"allows one to generate random values of type 'Float'.\n"
"\n"
"[Comment found in this file when merging with Library Report:]\n"
"\n"
"The June 1988 (v31 \\#6) issue of the Communications of the ACM has an\n"
"article by Pierre L'Ecuyer called, /Efficient and Portable Combined\n"
"Random Number Generators/.  Here is the Portable Combined Generator of\n"
"L'Ecuyer for 32-bit computers.  It has a period of roughly 2.30584e18.\n"
"\n"
"Transliterator: Lennart Augustsson\n"
"\n"
"-}\n"
"\n"
"-- |RandomGen\n"
"-- The class 'RandomGen' provides a common interface to random number generators.\n"
"\n"
"class RandomGen g where\n"
"\n"
"   -- |The 'next' operation allows one to extract at least 30 bits (one 'Int''s\n"
"   -- worth) from the generator, returning a new generator as well.  The\n"
"   -- integer returned may be positive or negative.\n"
"   next     :: g -> (Int, g)\n"
"\n"
"   -- |The 'split' operation allows one to obtain two distinct random number\n"
"   -- generators. This is very useful in functional programs (for example, when\n"
"   -- passing a random number generator down to recursive calls), but very\n"
"   -- little work has been done on statistically robust implementations of\n"
"   -- @split ([1,4]@ are the only examples we know of).\n"
"   split    :: g -> (g, g)\n"
"\n"
"   genRange :: g -> (Int,Int)\n"
"\n"
"   -- default mathod\n"
"   genRange g = (minBound,maxBound)\n"
"\n"
"{- |The \"System.Random\" library provides one instance of 'RandomGen', the\n"
"abstract data type 'StdGen'.\n"
"\n"
"The result of repeatedly using next should be at least as statistically robust\n"
"as the /Minimal Standard Random Number Generator/ described by\n"
"[\"System.Random\\#Park\", \"System.Random\\#Carta\"]. Until more\n"
"is known about implementations of 'split', all we require is that 'split' deliver\n"
"generators that are (a) not identical and (b) independently robust in the sense\n"
"just given.\n"
"\n"
"The 'show'\\/'Read' instances of 'StdGen' provide a primitive way to save the\n"
"state of a random number generator. It is required that @read (show g) == g@.\n"
"\n"
"In addition, 'read' may be used to map an arbitrary string (not necessarily one\n"
"produced by 'show') onto a value of type 'StdGen'. In general, the 'read'\n"
"instance of 'StdGen' has the following properties: \n"
"\n"
"* It guarantees to succeed on any string. \n"
"\n"
"*It guarantees to consume only a finite portion of the string. \n"
"\n"
"* Different argument strings are likely to result in different results.\n"
"\n"
"The function 'mkStdGen' provides an alternative way of producing an initial\n"
"generator, by mapping an 'Int' into a generator. Again, distinct arguments\n"
"should be likely to produce distinct generators.\n"
"\n"
"Programmers may, of course, supply their own instances of 'RandomGen'.\n"
"\n"
"-}\n"
"\n"
"data StdGen \n"
" = StdGen Int Int\n"
"\n"
"instance RandomGen StdGen where\n"
"  next  = stdNext\n"
"  split = stdSplit\n"
"\n"
"instance Show StdGen where\n"
"  showsPrec p (StdGen s1 s2) = \n"
"     showsPrec p s1 . \n"
"     showChar ' ' .\n"
"     showsPrec p s2\n"
"\n"
"instance Read StdGen where\n"
"  readsPrec _p = \\ r ->\n"
"     case try_read r of\n"
"       r@[_] -> r\n"
"       _   -> [stdFromString r] -- because it shouldn't ever fail.\n"
"    where \n"
"      try_read r = do\n"
"         (s1, r1) <- readDec (dropWhile isSpace r)\n"
"	 (s2, r2) <- readDec (dropWhile isSpace r1)\n"
"	 return (StdGen s1 s2, r2)\n"
"\n"
"{-\n"
" If we cannot unravel the StdGen from a string, create\n"
" one based on the string given.\n"
"-}\n"
"stdFromString         :: String -> (StdGen, String)\n"
"stdFromString s        = (mkStdGen num, rest)\n"
"	where (cs, rest) = splitAt 6 s\n"
"              num        = foldl (\\a x -> x + 3 * a) 1 (map ord cs)\n"
"\n"
"mkStdGen :: Int -> StdGen -- why not Integer ?\n"
"mkStdGen s\n"
" | s < 0     = mkStdGen (-s)\n"
" | otherwise = StdGen (s1+1) (s2+1)\n"
"      where\n"
"	(q, s1) = s `divMod` 2147483562\n"
"	s2      = q `mod` 2147483398\n"
"\n"
"createStdGen :: Integer -> StdGen\n"
"createStdGen s\n"
" | s < 0     = createStdGen (-s)\n"
" | otherwise = StdGen (fromInteger (s1+1)) (fromInteger (s2+1))\n"
"      where\n"
"	(q, s1) = s `divMod` 2147483562\n"
"	s2      = q `mod` 2147483398\n"
"\n"
"-- FIXME: 1/2/3 below should be ** (vs@30082002) XXX\n"
"\n"
"{- |The 'Random' class\n"
"With a source of random number supply in hand, the 'Random' class allows the\n"
"programmer to extract random values of a variety of types.\n"
"\n"
"* 'randomR' takes a range /(lo,hi)/ and a random number generator /g/, and returns\n"
"a random value uniformly distributed in the closed interval /[lo,hi]/, together\n"
"with a new generator. It is unspecified what happens if /lo>hi/. For continuous\n"
"types there is no requirement that the values /lo/ and /hi/ are ever produced,\n"
"but they may be, depending on the implementation and the interval.\n"
"\n"
"* 'random' does the same as 'randomR', but does not take a range.\n"
"\n"
"(1) For bounded types (instances of 'Bounded', such as 'Char'), the range is\n"
"normally the whole type.\n"
"\n"
"(2) For fractional types, the range is normally the semi-closed interval @[0,1)@.\n"
"\n"
"(3) For 'Integer', the range is (arbitrarily) the range of 'Int'.\n"
"\n"
"* The plural versions, 'randomRs' and 'randoms', produce an infinite list of\n"
"random values, and do not return a new generator.\n"
"\n"
"* The 'IO' versions, 'randomRIO' and 'randomIO', use the global random number\n"
"generator (see Section 17.3\n"
"<http://www.haskell.org/onlinelibrary/random.html#global-rng>).\n"
"-}\n"
"\n"
"class Random a where\n"
"  -- |Minimal complete definition: 'random' and 'randomR'\n"
"  random  :: RandomGen g => g -> (a, g)\n"
"  randomR :: RandomGen g => (a,a) -> g -> (a,g)\n"
"\n"
"  -- |Default methods  \n"
"  randoms  :: RandomGen g => g -> [a]\n"
"  randoms  g      = (\\(x,g') -> x : randoms g') (random g)\n"
"\n"
"  randomRs :: RandomGen g => (a,a) -> g -> [a]\n"
"  randomRs ival g = x : randomRs ival g' where (x,g') = randomR ival g\n"
"\n"
"  randomIO  :: IO a\n"
"  randomIO	   = getStdRandom random\n"
"\n"
"  randomRIO :: (a,a) -> IO a\n"
"  randomRIO range  = getStdRandom (randomR range)\n"
"\n"
"instance Random Int where\n"
"  randomR (a,b) g = randomIvalInteger (toInteger a, toInteger b) g\n"
"  random g        = randomR (minBound,maxBound) g\n"
"\n"
"instance Random Char where\n"
"  randomR (a,b) g = \n"
"      case (randomIvalInteger (toInteger (ord a), toInteger (ord b)) g) of\n"
"        (x,g) -> (chr x, g)\n"
"  random g	  = randomR (minBound,maxBound) g\n"
"\n"
"instance Random Bool where\n"
"  randomR (a,b) g = \n"
"      case (randomIvalInteger (toInteger (bool2Int a), toInteger (bool2Int b)) g) of\n"
"        (x, g) -> (int2Bool x, g)\n"
"       where\n"
"         bool2Int False = 0\n"
"         bool2Int True  = 1\n"
"\n"
"	 int2Bool 0	= False\n"
"	 int2Bool _	= True\n"
"\n"
"  random g	  = randomR (minBound,maxBound) g\n"
" \n"
"instance Random Integer where\n"
"  randomR ival g = randomIvalInteger ival g\n"
"  random g	 = randomR (toInteger (minBound::Int), toInteger (maxBound::Int)) g\n"
"\n"
"instance Random Double where\n"
"  randomR ival g = randomIvalDouble ival id g\n"
"  random g       = randomR (0::Double,1) g\n"
"  \n"
"-- hah, so you thought you were saving cycles by using Float?\n"
"instance Random Float where\n"
"  random g        = randomIvalDouble (0::Double,1) realToFrac g\n"
"  randomR (a,b) g = randomIvalDouble (realToFrac a, realToFrac b) realToFrac g\n"
"\n"
"mkStdRNG :: Integer -> IO StdGen\n"
"mkStdRNG o = do\n"
"    ct          <- getCPUTime\n"
"    (TOD sec _) <- getClockTime\n"
"    return (createStdGen (sec * 12345 + ct + o))\n"
"\n"
"randomIvalInteger :: (RandomGen g, Num a) => (Integer, Integer) -> g -> (a, g)\n"
"randomIvalInteger (l,h) rng\n"
" | l > h     = randomIvalInteger (h,l) rng\n"
" | otherwise = case (f n 1 rng) of (v, rng') -> (fromInteger (l + v `mod` k), rng')\n"
"     where\n"
"       k = h - l + 1\n"
"       b = 2147483561\n"
"       n = iLogBase b k\n"
"\n"
"       f 0 acc g = (acc, g)\n"
"       f n acc g = \n"
"          let\n"
"	   (x,g')   = next g\n"
"	  in\n"
"	  f (n-1) (fromIntegral x + acc * b) g'\n"
"\n"
"randomIvalDouble :: (RandomGen g, Fractional a) => (Double, Double) -> (Double -> a) -> g -> (a, g)\n"
"randomIvalDouble (l,h) fromDouble rng \n"
"  | l > h     = randomIvalDouble (h,l) fromDouble rng\n"
"  | otherwise = \n"
"       case (randomIvalInteger (toInteger (minBound::Int), toInteger (maxBound::Int)) rng) of\n"
"         (x, rng') -> \n"
"	    let\n"
"	     scaled_x = \n"
"		fromDouble ((l+h)/2) + \n"
"                fromDouble ((h-l) / realToFrac intRange) *\n"
"		fromIntegral (x::Int)\n"
"	    in\n"
"	    (scaled_x, rng')\n"
"\n"
"intRange :: Integer\n"
"intRange  = toInteger (maxBound::Int) - toInteger (minBound::Int)\n"
"\n"
"iLogBase :: Integer -> Integer -> Integer\n"
"iLogBase b i = if i < b then 1 else 1 + iLogBase b (i `div` b)\n"
"\n"
"stdNext :: StdGen -> (Int, StdGen)\n"
"stdNext (StdGen s1 s2) = (z', StdGen s1'' s2'')\n"
"	where	z'   = if z < 1 then z + 2147483562 else z\n"
"		z    = s1'' - s2''\n"
"\n"
"		k    = s1 `quot` 53668\n"
"		s1'  = 40014 * (s1 - k * 53668) - k * 12211\n"
"		s1'' = if s1' < 0 then s1' + 2147483563 else s1'\n"
"    \n"
"		k'   = s2 `quot` 52774\n"
"		s2'  = 40692 * (s2 - k' * 52774) - k' * 3791\n"
"		s2'' = if s2' < 0 then s2' + 2147483399 else s2'\n"
"\n"
"stdSplit            :: StdGen -> (StdGen, StdGen)\n"
"stdSplit std@(StdGen s1 s2)\n"
"                     = (left, right)\n"
"                       where\n"
"                        -- no statistical foundation for this!\n"
"                        left    = StdGen new_s1 t2\n"
"                        right   = StdGen t1 new_s2\n"
"\n"
"                        new_s1 | s1 == 2147483562 = 1\n"
"                               | otherwise        = s1 + 1\n"
"\n"
"                        new_s2 | s2 == 1          = 2147483398\n"
"                               | otherwise        = s2 - 1\n"
"\n"
"                        StdGen t1 t2 = snd (next std)\n"
"\n"
"-- The global random number generator\n"
"\n"
"{- $globalrng\n"
"\n"
"There is a single, implicit, global random number generator of type\n"
"'StdGen', held in some global variable maintained by the 'IO' monad. It is\n"
"initialised automatically in some system-dependent fashion, for example, by\n"
"using the time of day, or Linux's kernel random number generator. To get\n"
"deterministic behaviour, use 'setStdGen'.\n"
"-}\n"
"\n"
"-- |'setStdGen' sets the global random number generator.\n"
"setStdGen :: StdGen -> IO ()\n"
"setStdGen sgen = writeIORef theStdGen sgen\n"
"\n"
"-- |'getStdGen' gets the global random number generator.\n"
"getStdGen :: IO StdGen\n"
"getStdGen  = readIORef theStdGen\n"
"\n"
"-- |'newStdGen' applies 'split' to the current global random generator, updates it\n"
"-- with one of the results, and returns the other.\n"
"theStdGen :: IORef StdGen\n"
"theStdGen  = unsafePerformIO $ do\n"
"   rng <- mkStdRNG 0\n"
"   newIORef rng\n"
"\n"
"newStdGen :: IO StdGen\n"
"newStdGen = do\n"
"  rng <- getStdGen\n"
"  let (a,b) = split rng\n"
"  setStdGen a\n"
"  return b\n"
"\n"
"{- |'getStdRandom' uses the supplied function to get a value from the current\n"
"global random generator, and updates the global generator with the new generator\n"
"returned by the function. For example, @rollDice@ gets a random integer between 1 and 6: \n"
"\n"
">  rollDice :: IO Int\n"
">  rollDice = getStdRandom (randomR (1,6))\n"
"\n"
"-}\n"
"\n"
"getStdRandom :: (StdGen -> (a,StdGen)) -> IO a\n"
"getStdRandom f = do\n"
"   rng		<- getStdGen\n"
"   let (v, new_rng) = f rng\n"
"   setStdGen new_rng\n"
"   return v\n"
"\n"
"{- $references\n"
"\n"
"* [1] FW Burton and RL Page, /Distributed random number generation/,\n"
"Journal of Functional Programming, 2(2):203-212, April 1992.\n"
"\n"
"* [2] SK #Park# Park, and KW Miller, /Random number generators -\n"
"good ones are hard to find/, Comm ACM 31(10), Oct 1988, pp1192-1201.\n"
"\n"
"* [3] DG #Carta# Carta, /Two fast implementations of the minimal standard\n"
"random number generator/, Comm ACM, 33(1), Jan 1990, pp87-88.\n"
"\n"
"* [4] P Hellekalek, /Don\\'t trust parallel Monte Carlo/,\n"
"Department of Mathematics, University of Salzburg,\n"
"<http://random.mat.sbg.ac.at/~peter/pads98.ps>, 1998.\n"
"\n"
"The Web site <http://random.mat.sbg.ac.at/> is a great source of information.\n"
"\n"
"-}\n";
const char *System_Exit = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Exit\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Exiting the program.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Exit\n"
"    ( \n"
"      ExitCode(ExitSuccess,ExitFailure)\n"
"    , exitWith      -- :: ExitCode -> IO a\n"
"    , exitFailure   -- :: IO a\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Hugs.Prelude\n"
"import Hugs.Exception\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- exitWith\n"
"\n"
"-- | Computation 'exitWith' @code@ throws 'ExitException' @code@.\n"
"-- Normally this terminates the program, returning @code@ to the\n"
"-- program's caller.  Before the program terminates, any open or\n"
"-- semi-closed handles are first closed.\n"
"--\n"
"-- A program that fails in any other way is treated as if it had\n"
"-- called 'exitFailure'.\n"
"-- A program that terminates successfully without calling 'exitWith'\n"
"-- explicitly is treated as it it had called 'exitWith' 'ExitSuccess'.\n"
"--\n"
"-- As an 'ExitException' is not an 'IOError', 'exitWith' bypasses\n"
"-- the error handling in the 'IO' monad and cannot be intercepted by\n"
"-- 'catch' from the \"Prelude\".  However it is an 'Exception', and can\n"
"-- be caught using the functions of \"Control.Exception\".  This means\n"
"-- that cleanup computations added with 'Control.Exception.bracket'\n"
"-- (from \"Control.Exception\") are also executed properly on 'exitWith'.\n"
"\n"
"exitWith :: ExitCode -> IO a\n"
"exitWith ExitSuccess = throwIO (ExitException ExitSuccess)\n"
"exitWith code@(ExitFailure n)\n"
"  | n /= 0 = throwIO (ExitException code)\n"
"\n"
"-- | The computation 'exitFailure' is equivalent to\n"
"-- 'exitWith' @(@'ExitFailure' /exitfail/@)@,\n"
"-- where /exitfail/ is implementation-dependent.\n"
"exitFailure :: IO a\n"
"exitFailure = exitWith (ExitFailure 1)\n";
const char *System_Environment = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Environment\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Miscellaneous information about the system environment.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Environment\n"
"    ( \n"
"      getArgs,	     -- :: IO [String]\n"
"      getProgName,   -- :: IO String\n"
"      getEnv,        -- :: String -> IO String\n"
"      withArgs,\n"
"      withProgName,\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Hugs.System\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- getArgs, getProgName, getEnv\n"
"\n"
"-- | Computation 'getArgs' returns a list of the program's command\n"
"-- line arguments (not including the program name).\n"
"\n";
const char *System_Mem = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Mem\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Memory-related system things.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Mem (\n"
" 	performGC	-- :: IO ()\n"
"  ) where\n"
" \n"
"import Prelude\n"
"\n"
"import Hugs.IOExts\n"
"\n";
const char *System_Cmd = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Cmd\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Executing an external command.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Cmd\n"
"    ( system,        -- :: String -> IO ExitCode\n"
"    ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Hugs.System\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- system\n"
"\n"
"{-| \n"
"Computation @system cmd@ returns the exit code\n"
"produced when the operating system processes the command @cmd@.\n"
"\n"
"This computation may fail with\n"
"\n"
"   * @PermissionDenied@: The process has insufficient privileges to\n"
"     perform the operation.\n"
"\n"
"   * @ResourceExhausted@: Insufficient resources are available to\n"
"     perform the operation.\n"
"\n"
"   * @UnsupportedOperation@: The implementation does not support\n"
"     system calls.\n"
"\n"
"On Windows, 'system' is implemented using Windows's native system\n"
"call, which ignores the @SHELL@ environment variable, and always\n"
"passes the command to the Windows command interpreter (@CMD.EXE@ or\n"
"@COMMAND.COM@), hence Unixy shell tricks will not work.\n"
"-}\n";
const char *System_IO = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.IO\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- The standard IO library.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.IO (\n"
"    -- * The IO monad\n"
"\n"
"    IO,			       -- instance MonadFix\n"
"    fixIO,		       -- :: (a -> IO a) -> IO a\n"
"\n"
"    -- * Files and handles\n"
"\n"
"    FilePath,		       -- :: String\n"
"\n"
"    Handle,		-- abstract, instance of: Eq, Show.\n"
"\n"
"    -- ** Standard handles\n"
"\n"
"    -- | Three handles are allocated during program initialisation,\n"
"    -- and are initially open.\n"
"\n"
"    stdin, stdout, stderr,   -- :: Handle\n"
"\n"
"    -- * Opening and closing files\n"
"\n"
"    -- ** Opening files\n"
"\n"
"    openFile,		       -- :: FilePath -> IOMode -> IO Handle\n"
"    IOMode(ReadMode,WriteMode,AppendMode,ReadWriteMode),\n"
"\n"
"    -- ** Closing files\n"
"\n"
"    hClose,		       -- :: Handle -> IO ()\n"
"\n"
"    -- ** Special cases\n"
"\n"
"    -- | These functions are also exported by the \"Prelude\".\n"
"\n"
"    readFile,		       -- :: FilePath -> IO String\n"
"    writeFile,		       -- :: FilePath -> String -> IO ()\n"
"    appendFile,		       -- :: FilePath -> String -> IO ()\n"
"\n"
"    -- ** File locking\n"
"\n"
"    -- $locking\n"
"\n"
"    -- * Operations on handles\n"
"\n"
"    -- ** Determining the size of a file\n"
"\n"
"    hFileSize,		       -- :: Handle -> IO Integer\n"
"\n"
"    -- ** Detecting the end of input\n"
"\n"
"    hIsEOF,		       -- :: Handle -> IO Bool\n"
"    isEOF,		       -- :: IO Bool\n"
"\n"
"    -- ** Buffering operations\n"
"\n"
"    BufferMode(NoBuffering,LineBuffering,BlockBuffering),\n"
"    hSetBuffering,	       -- :: Handle -> BufferMode -> IO ()\n"
"    hGetBuffering,	       -- :: Handle -> IO BufferMode\n"
"    hFlush,		       -- :: Handle -> IO ()\n"
"\n"
"    -- ** Repositioning handles\n"
"\n"
"    hGetPosn,		       -- :: Handle -> IO HandlePosn\n"
"    hSetPosn,		       -- :: HandlePosn -> IO ()\n"
"    HandlePosn,                -- abstract, instance of: Eq, Show.\n"
"\n"
"    hSeek,		       -- :: Handle -> SeekMode -> Integer -> IO ()\n"
"    SeekMode(AbsoluteSeek,RelativeSeek,SeekFromEnd),\n"
"    hTell,		       -- :: Handle -> IO Integer\n"
"\n"
"    -- ** Handle properties\n"
"\n"
"    hIsOpen, hIsClosed,        -- :: Handle -> IO Bool\n"
"    hIsReadable, hIsWritable,  -- :: Handle -> IO Bool\n"
"    hIsSeekable,               -- :: Handle -> IO Bool\n"
"\n"
"    -- ** Terminal operations\n"
"\n"
"    -- ** Showing handle state\n"
"\n"
"    -- * Text input and output\n"
"\n"
"    -- ** Text input\n"
"\n"
"    hWaitForInput,	       -- :: Handle -> Int -> IO Bool\n"
"    hReady,		       -- :: Handle -> IO Bool\n"
"    hGetChar,		       -- :: Handle -> IO Char\n"
"    hGetLine,		       -- :: Handle -> IO [Char]\n"
"    hLookAhead,		       -- :: Handle -> IO Char\n"
"    hGetContents,	       -- :: Handle -> IO [Char]\n"
"\n"
"    -- ** Text output\n"
"\n"
"    hPutChar,		       -- :: Handle -> Char -> IO ()\n"
"    hPutStr,		       -- :: Handle -> [Char] -> IO ()\n"
"    hPutStrLn,		       -- :: Handle -> [Char] -> IO ()\n"
"    hPrint,		       -- :: Show a => Handle -> a -> IO ()\n"
"\n"
"    -- ** Special cases for standard input and output\n"
"\n"
"    -- | These functions are also exported by the \"Prelude\".\n"
"\n"
"    interact,		       -- :: (String -> String) -> IO ()\n"
"    putChar,		       -- :: Char   -> IO ()\n"
"    putStr,		       -- :: String -> IO () \n"
"    putStrLn,		       -- :: String -> IO ()\n"
"    print,		       -- :: Show a => a -> IO ()\n"
"    getChar,		       -- :: IO Char\n"
"    getLine,		       -- :: IO String\n"
"    getContents,	       -- :: IO String\n"
"    readIO,		       -- :: Read a => String -> IO a\n"
"    readLn,		       -- :: Read a => IO a\n"
"\n"
"    -- * Binary input and output\n"
"\n"
"    openBinaryFile,	       -- :: FilePath -> IOMode -> IO Handle\n"
"\n"
"    module System.IO.Error,\n"
"  ) where\n"
"\n"
"import Hugs.IO\n"
"import Hugs.IOExts\n"
"\n"
"import System.IO.Error (\n"
"    isAlreadyExistsError, isDoesNotExistError,  -- :: IOError -> Bool\n"
"    isAlreadyInUseError, isFullError, \n"
"    isEOFError, isIllegalOperation, \n"
"    isPermissionError, isUserError, \n"
" \n"
"    ioeGetErrorString,         -- :: IOError -> String\n"
"    ioeGetHandle,              -- :: IOError -> Maybe Handle\n"
"    ioeGetFileName,            -- :: IOError -> Maybe FilePath\n"
" \n"
"    try,                       -- :: IO a -> IO (Either IOError a)\n"
" \n"
"    -- re-exports of Prelude names\n"
"    IOError,\n"
"    ioError,                   -- :: IOError -> IO a\n"
"    userError,                 -- :: String  -> IOError\n"
"    catch                      -- :: IO a    -> (IOError -> IO a) -> IO a\n"
"  )\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Standard IO\n"
"\n"
"-- | Computation 'hReady' @hdl@ indicates whether at least one item is\n"
"-- available for input from handle @hdl@.\n"
"-- \n"
"-- This operation may fail with:\n"
"--\n"
"--  * 'isEOFError' if the end of file has been reached.\n"
"\n"
"hReady		:: Handle -> IO Bool\n"
"hReady h 	=  hWaitForInput h 0\n"
"\n"
"-- | The same as 'hPutStr', but adds a newline character.\n"
"\n"
"hPutStrLn	:: Handle -> String -> IO ()\n"
"hPutStrLn hndl str = do\n"
" hPutStr  hndl str\n"
" hPutChar hndl '\\n'\n"
"\n"
"-- | Computation 'hPrint' @hdl t@ writes the string representation of @t@\n"
"-- given by the 'shows' function to the file or channel managed by @hdl@\n"
"-- and appends a newline.\n"
"--\n"
"-- This operation may fail with:\n"
"--\n"
"--  * 'isFullError' if the device is full; or\n"
"--\n"
"--  * 'isPermissionError' if another system resource limit would be exceeded.\n"
"\n"
"hPrint		:: Show a => Handle -> a -> IO ()\n"
"hPrint hdl 	=  hPutStrLn hdl . show\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- fixIO\n"
"\n"
"-- $locking\n"
"-- Implementations should enforce as far as possible, at least locally to the\n"
"-- Haskell process, multiple-reader single-writer locking on files.\n"
"-- That is, /there may either be many handles on the same file which manage\n"
"-- input, or just one handle on the file which manages output/.  If any\n"
"-- open or semi-closed handle is managing a file for output, no new\n"
"-- handle can be allocated for that file.  If any open or semi-closed\n"
"-- handle is managing a file for input, new handles can only be allocated\n"
"-- if they do not manage output.  Whether two files are the same is\n"
"-- implementation-dependent, but they should normally be the same if they\n"
"-- have the same absolute path name and neither has been renamed, for\n"
"-- example.\n"
"--\n"
"-- /Warning/: the 'readFile' operation holds a semi-closed handle on\n"
"-- the file until the entire contents of the file have been consumed.\n"
"-- It follows that an attempt to write to a file (using 'writeFile', for\n"
"-- example) that was earlier opened by 'readFile' will usually result in\n"
"-- failure with 'isAlreadyInUseError'.\n";
const char *System_Directory = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Directory\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- System-independent interface to directory manipulation.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Directory \n"
"   ( \n"
"    -- $intro\n"
"\n"
"    -- * Actions on directories\n"
"      createDirectory		-- :: FilePath -> IO ()\n"
"    , removeDirectory		-- :: FilePath -> IO ()\n"
"    , renameDirectory		-- :: FilePath -> FilePath -> IO ()\n"
"\n"
"    , getDirectoryContents      -- :: FilePath -> IO [FilePath]\n"
"    , getCurrentDirectory       -- :: IO FilePath\n"
"    , setCurrentDirectory       -- :: FilePath -> IO ()\n"
"\n"
"    -- * Actions on files\n"
"    , removeFile		-- :: FilePath -> IO ()\n"
"    , renameFile                -- :: FilePath -> FilePath -> IO ()\n"
"\n"
"    -- * Existence tests\n"
"    , doesFileExist		-- :: FilePath -> IO Bool\n"
"    , doesDirectoryExist        -- :: FilePath -> IO Bool\n"
"\n"
"    -- * Permissions\n"
"\n"
"    -- $permissions\n"
"\n"
"    , Permissions(\n"
"	Permissions,\n"
"	readable,		-- :: Permissions -> Bool\n"
"	writable,		-- :: Permissions -> Bool\n"
"	executable,		-- :: Permissions -> Bool\n"
"	searchable		-- :: Permissions -> Bool\n"
"      )\n"
"\n"
"    , getPermissions            -- :: FilePath -> IO Permissions\n"
"    , setPermissions	        -- :: FilePath -> Permissions -> IO ()\n"
"\n"
"    -- * Timestamps\n"
"\n"
"    , getModificationTime       -- :: FilePath -> IO ClockTime\n"
"   ) where\n"
"\n"
"import Hugs.Directory\n";
const char *System_Info = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Info\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- Misc information about the characteristics of the host \n"
"-- architecture\\/machine lucky enough to run your program.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Info\n"
"   (\n"
"       os,		    -- :: String\n"
"       arch		    -- :: String\n"
"   ) where\n"
"\n"
"import Prelude\n"
"\n"
"arch :: String\n"
"arch = \"x86_64\"\n"
"\n"
"os :: String\n"
"os = \"linux\"\n"
"\n";
const char *System_Time = "{-# LINE 1 \"Time.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"{-# LINE 2 \"Time.hsc\" #-}\n"
"-- |\n"
"-- Module      :  System.Time\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/core/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- The standard Time library.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"{-\n"
"Haskell 98 Time of Day Library\n"
"------------------------------\n"
"\n"
"The Time library provides standard functionality for clock times,\n"
"including timezone information (i.e, the functionality of \"time.h\",\n"
"adapted to the Haskell environment), It follows RFC 1129 in its use of\n"
"Coordinated Universal Time (UTC).\n"
"\n"
"2000/06/17 <michael.weber@post.rwth-aachen.de>:\n"
"RESTRICTIONS:\n"
"  * min./max. time diff currently is restricted to\n"
"    [minBound::Int, maxBound::Int]\n"
"\n"
"  * surely other restrictions wrt. min/max bounds\n"
"\n"
"\n"
"NOTES:\n"
"  * printing times\n"
"\n"
"    `showTime' (used in `instance Show ClockTime') always prints time\n"
"    converted to the local timezone (even if it is taken from\n"
"    `(toClockTime . toUTCTime)'), whereas `calendarTimeToString'\n"
"    honors the tzone & tz fields and prints UTC or whatever timezone\n"
"    is stored inside CalendarTime.\n"
"\n"
"    Maybe `showTime' should be changed to use UTC, since it would\n"
"    better correspond to the actual representation of `ClockTime'\n"
"    (can be done by replacing localtime(3) by gmtime(3)).\n"
"\n"
"\n"
"BUGS:\n"
"  * add proper handling of microsecs, currently, they're mostly\n"
"    ignored\n"
"\n"
"  * `formatFOO' case of `%s' is currently broken...\n"
"\n"
"\n"
"TODO:\n"
"  * check for unusual date cases, like 1970/1/1 00:00h, and conversions\n"
"    between different timezone's etc.\n"
"\n"
"  * check, what needs to be in the IO monad, the current situation\n"
"    seems to be a bit inconsistent to me\n"
"\n"
"  * check whether `isDst = -1' works as expected on other arch's\n"
"    (Solaris anyone?)\n"
"\n"
"  * add functions to parse strings to `CalendarTime' (some day...)\n"
"\n"
"  * implement padding capabilities (\"%_\", \"%-\") in `formatFOO'\n"
"\n"
"  * add rfc822 timezone (+0200 is CEST) representation (\"%z\") in `formatFOO'\n"
"-}\n"
"\n"
"module System.Time\n"
"     (\n"
"        Month(..)\n"
"     ,  Day(..)\n"
"\n"
"     ,  ClockTime(..) -- non-standard, lib. report gives this as abstract\n"
"	-- instance Eq, Ord\n"
"	-- instance Show (non-standard)\n"
"\n"
"     ,	getClockTime\n"
"\n"
"     ,  TimeDiff(..)\n"
"     ,  noTimeDiff      -- non-standard (but useful when constructing TimeDiff vals.)\n"
"     ,  diffClockTimes\n"
"     ,  addToClockTime\n"
"\n"
"     ,  normalizeTimeDiff -- non-standard\n"
"     ,  timeDiffToString  -- non-standard\n"
"     ,  formatTimeDiff    -- non-standard\n"
"\n"
"     ,  CalendarTime(..)\n"
"     ,	toCalendarTime\n"
"     ,  toUTCTime\n"
"     ,  toClockTime\n"
"     ,  calendarTimeToString\n"
"     ,  formatCalendarTime\n"
"\n"
"     ) where\n"
"\n"
"\n"
"{-# LINE 102 \"Time.hsc\" #-}\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Ix\n"
"import System.Locale\n"
"import System.IO.Unsafe\n"
"\n"
"\n"
"{-# LINE 110 \"Time.hsc\" #-}\n"
"import Hugs.Time ( getClockTimePrim, toCalTimePrim, toClockTimePrim )\n"
"\n"
"{-# LINE 115 \"Time.hsc\" #-}\n"
"\n"
"-- One way to partition and give name to chunks of a year and a week:\n"
"\n"
"data Month\n"
" = January   | February | March    | April\n"
" | May       | June     | July     | August\n"
" | September | October  | November | December\n"
" deriving (Eq, Ord, Enum, Bounded, Ix, Read, Show)\n"
"\n"
"data Day \n"
" = Sunday   | Monday | Tuesday | Wednesday\n"
" | Thursday | Friday | Saturday\n"
" deriving (Eq, Ord, Enum, Bounded, Ix, Read, Show)\n"
"\n"
"-- @ClockTime@ is an abstract type, used for the internal clock time.\n"
"-- Clock times may be compared, converted to strings, or converted to an\n"
"-- external calendar time @CalendarTime@.\n"
"\n"
"data ClockTime = TOD Integer 		-- Seconds since 00:00:00 on 1 Jan 1970\n"
"		     Integer		-- Picoseconds with the specified second\n"
"	       deriving (Eq, Ord)\n"
"\n"
"-- When a ClockTime is shown, it is converted to a CalendarTime in the current\n"
"-- timezone and then printed.  FIXME: This is arguably wrong, since we can't\n"
"-- get the current timezone without being in the IO monad.\n"
"\n"
"instance Show ClockTime where\n"
"    showsPrec _ t = showString (calendarTimeToString \n"
"	  			 (unsafePerformIO (toCalendarTime t)))\n"
"\n"
"{-\n"
"@CalendarTime@ is a user-readable and manipulable\n"
"representation of the internal $ClockTime$ type.  The\n"
"numeric fields have the following ranges.\n"
"\n"
"\\begin{verbatim}\n"
"Value         Range             Comments\n"
"-----         -----             --------\n"
"\n"
"year    -maxInt .. maxInt       [Pre-Gregorian dates are inaccurate]\n"
"mon           0 .. 11           [Jan = 0, Dec = 11]\n"
"day           1 .. 31\n"
"hour          0 .. 23\n"
"min           0 .. 59\n"
"sec           0 .. 61           [Allows for two leap seconds]\n"
"picosec       0 .. (10^12)-1    [This could be over-precise?]\n"
"wday          0 .. 6            [Sunday = 0, Saturday = 6]\n"
"yday          0 .. 365          [364 in non-Leap years]\n"
"tz       -43200 .. 43200        [Variation from UTC in seconds]\n"
"\\end{verbatim}\n"
"\n"
"The {\\em tzname} field is the name of the time zone.  The {\\em isdst}\n"
"field indicates whether Daylight Savings Time would be in effect.\n"
"-}\n"
"\n"
"data CalendarTime \n"
" = CalendarTime  {\n"
"     ctYear    :: Int,\n"
"     ctMonth   :: Month,\n"
"     ctDay     :: Int,\n"
"     ctHour    :: Int,\n"
"     ctMin     :: Int,\n"
"     ctSec     :: Int,\n"
"     ctPicosec :: Integer,\n"
"     ctWDay    :: Day,\n"
"     ctYDay    :: Int,\n"
"     ctTZName  :: String,\n"
"     ctTZ      :: Int,\n"
"     ctIsDST   :: Bool\n"
" }\n"
" deriving (Eq,Ord,Read,Show)\n"
"\n"
"-- The @TimeDiff@ type records the difference between two clock times in\n"
"-- a user-readable way.\n"
"\n"
"data TimeDiff\n"
" = TimeDiff {\n"
"     tdYear    :: Int,\n"
"     tdMonth   :: Int,\n"
"     tdDay     :: Int,\n"
"     tdHour    :: Int,\n"
"     tdMin     :: Int,\n"
"     tdSec     :: Int,\n"
"     tdPicosec :: Integer -- not standard\n"
"   }\n"
"   deriving (Eq,Ord,Read,Show)\n"
"\n"
"noTimeDiff :: TimeDiff\n"
"noTimeDiff = TimeDiff 0 0 0 0 0 0 0\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- getClockTime returns the current time in its internal representation.\n"
"\n"
"getClockTime :: IO ClockTime\n"
"\n"
"{-# LINE 210 \"Time.hsc\" #-}\n"
"getClockTime = do\n"
"  (sec,usec) <- getClockTimePrim\n"
"  return (TOD (fromIntegral sec) ((fromIntegral usec) * 1000000))\n"
"\n"
"\n"
"{-# LINE 236 \"Time.hsc\" #-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- addToClockTime d t adds a time difference d and a\n"
"-- clock time t to yield a new clock time.  The difference d\n"
"-- may be either positive or negative.  diffClockTimes t1 t2 returns \n"
"-- the difference between two clock times t1 and t2 as a TimeDiff.\n"
"\n"
"addToClockTime  :: TimeDiff  -> ClockTime -> ClockTime\n"
"addToClockTime (TimeDiff year mon day hour min sec psec) \n"
"	       (TOD c_sec c_psec) = \n"
"	let\n"
"	  sec_diff = toInteger sec +\n"
"                     60 * toInteger min +\n"
"                     3600 * toInteger hour +\n"
"                     24 * 3600 * toInteger day\n"
"	  cal      = toUTCTime (TOD (c_sec + sec_diff) (c_psec + psec))\n"
"                                                       -- FIXME! ^^^^\n"
"          new_mon  = fromEnum (ctMonth cal) + r_mon \n"
"	  (month', yr_diff)\n"
"	    | new_mon < 0  = (toEnum (12 + new_mon), (-1))\n"
"	    | new_mon > 11 = (toEnum (new_mon `mod` 12), 1)\n"
"	    | otherwise    = (toEnum new_mon, 0)\n"
"	    \n"
"	  (r_yr, r_mon) = mon `quotRem` 12\n"
"\n"
"          year' = ctYear cal + year + r_yr + yr_diff\n"
"	in\n"
"	toClockTime cal{ctMonth=month', ctYear=year'}\n"
"\n"
"diffClockTimes  :: ClockTime -> ClockTime -> TimeDiff\n"
"-- diffClockTimes is meant to be the dual to `addToClockTime'.\n"
"-- If you want to have the TimeDiff properly splitted, use\n"
"-- `normalizeTimeDiff' on this function's result\n"
"--\n"
"-- CAVEAT: see comment of normalizeTimeDiff\n"
"diffClockTimes (TOD sa pa) (TOD sb pb) =\n"
"    noTimeDiff{ tdSec     = fromIntegral (sa - sb) \n"
"                -- FIXME: can handle just 68 years...\n"
"              , tdPicosec = pa - pb\n"
"              }\n"
"\n"
"\n"
"normalizeTimeDiff :: TimeDiff -> TimeDiff\n"
"-- FIXME: handle psecs properly\n"
"-- FIXME: ?should be called by formatTimeDiff automagically?\n"
"--\n"
"-- when applied to something coming out of `diffClockTimes', you loose\n"
"-- the duality to `addToClockTime', since a year does not always have\n"
"-- 365 days, etc.\n"
"--\n"
"-- apply this function as late as possible to prevent those \"rounding\"\n"
"-- errors\n"
"normalizeTimeDiff td =\n"
"  let\n"
"      rest0 = tdSec td \n"
"               + 60 * (tdMin td \n"
"                    + 60 * (tdHour td \n"
"                         + 24 * (tdDay td \n"
"                              + 30 * (tdMonth td \n"
"                                   + 365 * tdYear td))))\n"
"\n"
"      (diffYears,  rest1)    = rest0 `quotRem` (365 * 24 * 3600)\n"
"      (diffMonths, rest2)    = rest1 `quotRem` (30 * 24 * 3600)\n"
"      (diffDays,   rest3)    = rest2 `quotRem` (24 * 3600)\n"
"      (diffHours,  rest4)    = rest3 `quotRem` 3600\n"
"      (diffMins,   diffSecs) = rest4 `quotRem` 60\n"
"  in\n"
"      td{ tdYear = diffYears\n"
"        , tdMonth = diffMonths\n"
"        , tdDay   = diffDays\n"
"        , tdHour  = diffHours\n"
"        , tdMin   = diffMins\n"
"        , tdSec   = diffSecs\n"
"        }\n"
"\n"
"\n"
"{-# LINE 372 \"Time.hsc\" #-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- toCalendarTime t converts t to a local time, modified by\n"
"-- the current timezone and daylight savings time settings.  toUTCTime\n"
"-- t converts t into UTC time.  toClockTime l converts l into the \n"
"-- corresponding internal ClockTime.  The wday, yday, tzname, and isdst fields\n"
"-- are ignored.\n"
"\n"
"\n"
"toCalendarTime :: ClockTime -> IO CalendarTime\n"
"\n"
"{-# LINE 383 \"Time.hsc\" #-}\n"
"toCalendarTime =  toCalTime False\n"
"\n"
"{-# LINE 389 \"Time.hsc\" #-}\n"
"\n"
"toUTCTime :: ClockTime -> CalendarTime\n"
"\n"
"{-# LINE 392 \"Time.hsc\" #-}\n"
"toUTCTime      =  unsafePerformIO . toCalTime True\n"
"\n"
"{-# LINE 398 \"Time.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 400 \"Time.hsc\" #-}\n"
"toCalTime :: Bool -> ClockTime -> IO CalendarTime\n"
"toCalTime toUTC (TOD s psecs)\n"
"  | (s > fromIntegral (maxBound :: Int)) || \n"
"    (s < fromIntegral (minBound :: Int))\n"
"  = error ((if toUTC then \"toUTCTime: \" else \"toCalendarTime: \") ++\n"
"           \"clock secs out of range\")\n"
"  | otherwise = do\n"
"    (sec,min,hour,mday,mon,year,wday,yday,isdst,zone,off) <- \n"
"  		toCalTimePrim (if toUTC then 1 else 0) (fromIntegral s)\n"
"    return (CalendarTime{ ctYear=1900+year\n"
"  		        , ctMonth=toEnum mon\n"
"		        , ctDay=mday\n"
"		        , ctHour=hour\n"
"		        , ctMin=min\n"
"		        , ctSec=sec\n"
"		        , ctPicosec=psecs\n"
"		        , ctWDay=toEnum wday\n"
"		        , ctYDay=yday\n"
"		        , ctTZName=(if toUTC then \"UTC\" else zone)\n"
"		        , ctTZ=(if toUTC then 0 else off)\n"
"		        , ctIsDST=not toUTC && (isdst/=0)\n"
"		        })\n"
"\n"
"{-# LINE 475 \"Time.hsc\" #-}\n"
"\n"
"toClockTime :: CalendarTime -> ClockTime\n"
"\n"
"{-# LINE 478 \"Time.hsc\" #-}\n"
"toClockTime (CalendarTime yr mon mday hour min sec psec\n"
"			  _wday _yday _tzname tz _isdst) =\n"
"  unsafePerformIO $ do\n"
"    s <- toClockTimePrim (yr-1900) (fromEnum mon) mday hour min sec tz\n"
"    return (TOD (fromIntegral s) psec)\n"
"\n"
"{-# LINE 526 \"Time.hsc\" #-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Converting time values to strings.\n"
"\n"
"calendarTimeToString  :: CalendarTime -> String\n"
"calendarTimeToString  =  formatCalendarTime defaultTimeLocale \"%c\"\n"
"\n"
"formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String\n"
"formatCalendarTime l fmt (CalendarTime year mon day hour min sec _\n"
"                                       wday yday tzname _ _) =\n"
"        doFmt fmt\n"
"  where doFmt ('%':'-':cs) = doFmt ('%':cs) -- padding not implemented\n"
"        doFmt ('%':'_':cs) = doFmt ('%':cs) -- padding not implemented\n"
"        doFmt ('%':c:cs)   = decode c ++ doFmt cs\n"
"        doFmt (c:cs) = c : doFmt cs\n"
"        doFmt \"\" = \"\"\n"
"\n"
"        decode 'A' = fst (wDays l  !! fromEnum wday) -- day of the week, full name\n"
"        decode 'a' = snd (wDays l  !! fromEnum wday) -- day of the week, abbrev.\n"
"        decode 'B' = fst (months l !! fromEnum mon)  -- month, full name\n"
"        decode 'b' = snd (months l !! fromEnum mon)  -- month, abbrev\n"
"        decode 'h' = snd (months l !! fromEnum mon)  -- ditto\n"
"        decode 'C' = show2 (year `quot` 100)         -- century\n"
"        decode 'c' = doFmt (dateTimeFmt l)           -- locale's data and time format.\n"
"        decode 'D' = doFmt \"%m/%d/%y\"\n"
"        decode 'd' = show2 day                       -- day of the month\n"
"        decode 'e' = show2' day                      -- ditto, padded\n"
"        decode 'H' = show2 hour                      -- hours, 24-hour clock, padded\n"
"        decode 'I' = show2 (to12 hour)               -- hours, 12-hour clock\n"
"        decode 'j' = show3 yday                      -- day of the year\n"
"        decode 'k' = show2' hour                     -- hours, 24-hour clock, no padding\n"
"        decode 'l' = show2' (to12 hour)              -- hours, 12-hour clock, no padding\n"
"        decode 'M' = show2 min                       -- minutes\n"
"        decode 'm' = show2 (fromEnum mon+1)          -- numeric month\n"
"        decode 'n' = \"\\n\"\n"
"        decode 'p' = (if hour < 12 then fst else snd) (amPm l) -- am or pm\n"
"        decode 'R' = doFmt \"%H:%M\"\n"
"        decode 'r' = doFmt (time12Fmt l)\n"
"        decode 'T' = doFmt \"%H:%M:%S\"\n"
"        decode 't' = \"\\t\"\n"
"        decode 'S' = show2 sec			     -- seconds\n"
"        decode 's' = show2 sec			     -- number of secs since Epoch. (ToDo.)\n"
"        decode 'U' = show2 ((yday + 7 - fromEnum wday) `div` 7) -- week number, starting on Sunday.\n"
"        decode 'u' = show (let n = fromEnum wday in  -- numeric day of the week (1=Monday, 7=Sunday)\n"
"                           if n == 0 then 7 else n)\n"
"        decode 'V' =                                 -- week number (as per ISO-8601.)\n"
"            let (week, days) =                       -- [yep, I've always wanted to be able to display that too.]\n"
"                   (yday + 7 - if fromEnum wday > 0 then \n"
"                               fromEnum wday - 1 else 6) `divMod` 7\n"
"            in  show2 (if days >= 4 then\n"
"                          week+1 \n"
"                       else if week == 0 then 53 else week)\n"
"\n"
"        decode 'W' =				     -- week number, weeks starting on monday\n"
"            show2 ((yday + 7 - if fromEnum wday > 0 then \n"
"                               fromEnum wday - 1 else 6) `div` 7)\n"
"        decode 'w' = show (fromEnum wday)            -- numeric day of the week, weeks starting on Sunday.\n"
"        decode 'X' = doFmt (timeFmt l)               -- locale's preferred way of printing time.\n"
"        decode 'x' = doFmt (dateFmt l)               -- locale's preferred way of printing dates.\n"
"        decode 'Y' = show year                       -- year, including century.\n"
"        decode 'y' = show2 (year `rem` 100)          -- year, within century.\n"
"        decode 'Z' = tzname                          -- timezone name\n"
"        decode '%' = \"%\"\n"
"        decode c   = [c]\n"
"\n"
"\n"
"show2, show2', show3 :: Int -> String\n"
"show2 x\n"
" | x' < 10   = '0': show x'\n"
" | otherwise = show x'\n"
" where x' = x `rem` 100\n"
"\n"
"show2' x\n"
" | x' < 10   = ' ': show x'\n"
" | otherwise = show x'\n"
" where x' = x `rem` 100\n"
"\n"
"show3 x = show (x `quot` 100) ++ show2 (x `rem` 100)\n"
" where x' = x `rem` 1000\n"
"\n"
"to12 :: Int -> Int\n"
"to12 h = let h' = h `mod` 12 in if h' == 0 then 12 else h'\n"
"\n"
"-- Useful extensions for formatting TimeDiffs.\n"
"\n"
"timeDiffToString :: TimeDiff -> String\n"
"timeDiffToString = formatTimeDiff defaultTimeLocale \"%c\"\n"
"\n"
"formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String\n"
"formatTimeDiff l fmt td@(TimeDiff year month day hour min sec _)\n"
" = doFmt fmt\n"
"  where \n"
"   doFmt \"\"         = \"\"\n"
"   doFmt ('%':'-':cs) = doFmt ('%':cs) -- padding not implemented\n"
"   doFmt ('%':'_':cs) = doFmt ('%':cs) -- padding not implemented\n"
"   doFmt ('%':c:cs) = decode c ++ doFmt cs\n"
"   doFmt (c:cs)     = c : doFmt cs\n"
"\n"
"   decode spec =\n"
"    case spec of\n"
"      'B' -> fst (months l !! fromEnum month)\n"
"      'b' -> snd (months l !! fromEnum month)\n"
"      'h' -> snd (months l !! fromEnum month)\n"
"      'c' -> defaultTimeDiffFmt td\n"
"      'C' -> show2 (year `quot` 100)\n"
"      'D' -> doFmt \"%m/%d/%y\"\n"
"      'd' -> show2 day\n"
"      'e' -> show2' day\n"
"      'H' -> show2 hour\n"
"      'I' -> show2 (to12 hour)\n"
"      'k' -> show2' hour\n"
"      'l' -> show2' (to12 hour)\n"
"      'M' -> show2 min\n"
"      'm' -> show2 (fromEnum month + 1)\n"
"      'n' -> \"\\n\"\n"
"      'p' -> (if hour < 12 then fst else snd) (amPm l)\n"
"      'R' -> doFmt \"%H:%M\"\n"
"      'r' -> doFmt (time12Fmt l)\n"
"      'T' -> doFmt \"%H:%M:%S\"\n"
"      't' -> \"\\t\"\n"
"      'S' -> show2 sec\n"
"      's' -> show2 sec -- Implementation-dependent, sez the lib doc..\n"
"      'X' -> doFmt (timeFmt l)\n"
"      'x' -> doFmt (dateFmt l)\n"
"      'Y' -> show year\n"
"      'y' -> show2 (year `rem` 100)\n"
"      '%' -> \"%\"\n"
"      c   -> [c]\n"
"\n"
"   defaultTimeDiffFmt (TimeDiff year month day hour min sec _) =\n"
"       foldr (\\ (v,s) rest -> \n"
"                  (if v /= 0 \n"
"                     then show v ++ ' ':(addS v s)\n"
"                       ++ if null rest then \"\" else \", \"\n"
"                     else \"\") ++ rest\n"
"             )\n"
"             \"\"\n"
"             (zip [year, month, day, hour, min, sec] (intervals l))\n"
"\n"
"   addS v s = if abs v == 1 then fst s else snd s\n"
"\n"
"\n"
"{-# LINE 700 \"Time.hsc\" #-}\n";
const char *System_Locale = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Locale\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- This module provides the ability to adapt to local conventions.\n"
"-- At present, it supports only time and date information as used by\n"
"-- 'System.Time.calendarTimeToString' from the \"System.Time\" module.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Locale (\n"
"\n"
"    TimeLocale(..)\n"
"\n"
"    , defaultTimeLocale\n"
"    \n"
"    , iso8601DateFormat\n"
"    , rfc822DateFormat\n"
"    )\n"
"where\n"
"\n"
"import Prelude\n"
"\n"
"data TimeLocale = TimeLocale {\n"
"	-- |full and abbreviated week days\n"
"        wDays  :: [(String, String)],\n"
"	-- |full and abbreviated months\n"
"        months :: [(String, String)],\n"
"        intervals :: [(String, String)],\n"
"	-- |AM\\/PM symbols\n"
"        amPm   :: (String, String),\n"
"	-- |formatting strings\n"
"        dateTimeFmt, dateFmt,\n"
"        timeFmt, time12Fmt :: String     \n"
"        } deriving (Eq, Ord, Show)\n"
"\n"
"defaultTimeLocale :: TimeLocale \n"
"defaultTimeLocale =  TimeLocale { \n"
"        wDays  = [(\"Sunday\",   \"Sun\"),  (\"Monday\",    \"Mon\"),   \n"
"                  (\"Tuesday\",  \"Tue\"),  (\"Wednesday\", \"Wed\"), \n"
"                  (\"Thursday\", \"Thu\"),  (\"Friday\",    \"Fri\"), \n"
"                  (\"Saturday\", \"Sat\")],\n"
"\n"
"        months = [(\"January\",   \"Jan\"), (\"February\",  \"Feb\"),\n"
"                  (\"March\",     \"Mar\"), (\"April\",     \"Apr\"),\n"
"                  (\"May\",       \"May\"), (\"June\",      \"Jun\"),\n"
"                  (\"July\",      \"Jul\"), (\"August\",    \"Aug\"),\n"
"                  (\"September\", \"Sep\"), (\"October\",   \"Oct\"),\n"
"                  (\"November\",  \"Nov\"), (\"December\",  \"Dec\")],\n"
"\n"
"        intervals = [ (\"year\",\"years\")\n"
"                    , (\"month\", \"months\")\n"
"                    , (\"day\",\"days\")\n"
"                    , (\"hour\",\"hours\")\n"
"                    , (\"min\",\"mins\")\n"
"                    , (\"sec\",\"secs\")\n"
"                    , (\"usec\",\"usecs\")\n"
"                    ],\n"
"\n"
"        amPm = (\"AM\", \"PM\"),\n"
"        dateTimeFmt = \"%a %b %e %H:%M:%S %Z %Y\",\n"
"        dateFmt = \"%m/%d/%y\",\n"
"        timeFmt = \"%H:%M:%S\",\n"
"        time12Fmt = \"%I:%M:%S %p\"\n"
"        }\n"
"\n"
"-- |Normally, ISO-8601 just defines YYYY-MM-DD\n"
"-- but we can add a time spec.\n"
"\n"
"iso8601DateFormat :: Maybe String -> String\n"
"iso8601DateFormat timeFmt =\n"
"    \"%Y-%m-%d\" ++ case timeFmt of\n"
"             Nothing  -> \"\" \n"
"             Just fmt -> ' ' : fmt\n"
"\n"
"rfc822DateFormat :: String\n"
"rfc822DateFormat = \"%a, %_d %b %Y %H:%M:%S %Z\"\n";
const char *System_IO_Unsafe = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.IO.Unsafe\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- \\\"Unsafe\\\" IO operations.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.IO.Unsafe (\n"
"   -- * Unsafe 'IO' operations\n"
"   unsafePerformIO,	-- :: IO a -> a\n"
"   unsafeInterleaveIO,	-- :: IO a -> IO a\n"
"  ) where\n"
"\n"
"import Hugs.IOExts (unsafePerformIO)\n"
"\n"
"unsafeInterleaveIO :: IO a -> IO a\n"
"unsafeInterleaveIO f = return (unsafePerformIO f)\n";
const char *System_IO_Error = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.IO.Error\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Standard IO Errors.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.IO.Error (\n"
"\n"
"    -- * I\\/O errors\n"
"    IOError,			-- = IOException\n"
"\n"
"    userError,		       	-- :: String  -> IOError\n"
"\n"
"    mkIOError,			-- :: IOErrorType -> String -> Maybe Handle\n"
"				--    -> Maybe FilePath -> IOError\n"
"\n"
"    annotateIOError,		-- :: IOError -> String -> Maybe Handle\n"
"				--    -> Maybe FilePath -> IOError\n"
"\n"
"    -- ** Classifying I\\/O errors\n"
"    isAlreadyExistsError,	-- :: IOError -> Bool\n"
"    isDoesNotExistError,\n"
"    isAlreadyInUseError,\n"
"    isFullError, \n"
"    isEOFError,\n"
"    isIllegalOperation, \n"
"    isPermissionError,\n"
"    isUserError,\n"
"\n"
"    -- ** Attributes of I\\/O errors\n"
"    ioeGetErrorType,		-- :: IOError -> IOErrorType\n"
"    ioeGetErrorString,		-- :: IOError -> String\n"
"    ioeGetHandle,		-- :: IOError -> Maybe Handle\n"
"    ioeGetFileName,		-- :: IOError -> Maybe FilePath\n"
"\n"
"    ioeSetErrorType,		-- :: IOError -> IOErrorType -> IOError\n"
"    ioeSetErrorString,		-- :: IOError -> String -> IOError\n"
"    ioeSetHandle,		-- :: IOError -> Handle -> IOError\n"
"    ioeSetFileName,		-- :: IOError -> FilePath -> IOError\n"
"\n"
"    -- * Types of I\\/O error\n"
"    IOErrorType,		-- abstract\n"
"\n"
"    alreadyExistsErrorType,	-- :: IOErrorType\n"
"    doesNotExistErrorType,\n"
"    alreadyInUseErrorType,\n"
"    fullErrorType,\n"
"    eofErrorType,\n"
"    illegalOperationErrorType, \n"
"    permissionErrorType,\n"
"    userErrorType,\n"
"\n"
"    -- ** 'IOErrorType' predicates\n"
"    isAlreadyExistsErrorType,	-- :: IOErrorType -> Bool\n"
"    isDoesNotExistErrorType,\n"
"    isAlreadyInUseErrorType,\n"
"    isFullErrorType, \n"
"    isEOFErrorType,\n"
"    isIllegalOperationErrorType, \n"
"    isPermissionErrorType,\n"
"    isUserErrorType, \n"
"\n"
"    -- * Throwing and catching I\\/O errors\n"
"\n"
"    ioError,		       	-- :: IOError -> IO a\n"
"\n"
"    catch,			-- :: IO a -> (IOError -> IO a) -> IO a\n"
"    try,			-- :: IO a -> IO (Either IOError a)\n"
"\n"
"    modifyIOError,		-- :: (IOError -> IOError) -> IO a -> IO a\n"
"  ) where\n"
"\n"
"import Data.Either\n"
"import Data.Maybe\n"
"\n"
"import Hugs.Prelude(Handle, IOException(..), IOErrorType(..))\n"
"\n"
"-- | The construct 'try' @comp@ exposes IO errors which occur within a\n"
"-- computation, and which are not fully handled.\n"
"--\n"
"-- Non-I\\/O exceptions are not caught by this variant; to catch all\n"
"-- exceptions, use 'Control.Exception.try' from \"Control.Exception\".\n"
"\n"
"try            :: IO a -> IO (Either IOError a)\n"
"try f          =  catch (do r <- f\n"
"                            return (Right r))\n"
"                        (return . Left)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Constructing an IOError\n"
"\n"
"-- | Construct an 'IOError' of the given type where the second argument\n"
"-- describes the error location and the third and fourth argument\n"
"-- contain the file handle and file path of the file involved in the\n"
"-- error if applicable.\n"
"mkIOError :: IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError\n"
"mkIOError t location maybe_hdl maybe_filename =\n"
"               IOError{ ioe_type = t, \n"
"			ioe_location = location,\n"
"	   		ioe_description = \"\",\n"
"			ioe_handle = maybe_hdl, \n"
"			ioe_filename = maybe_filename\n"
" 			}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- IOErrorType\n"
"\n"
"-- | An error indicating that an 'IO' operation failed because\n"
"-- one of its arguments already exists.\n"
"isAlreadyExistsError :: IOError -> Bool\n"
"isAlreadyExistsError = isAlreadyExistsErrorType    . ioeGetErrorType\n"
"\n"
"-- | An error indicating that an 'IO' operation failed because\n"
"-- one of its arguments does not exist.\n"
"isDoesNotExistError :: IOError -> Bool\n"
"isDoesNotExistError  = isDoesNotExistErrorType     . ioeGetErrorType\n"
"\n"
"-- | An error indicating that an 'IO' operation failed because\n"
"-- one of its arguments is a single-use resource, which is already\n"
"-- being used (for example, opening the same file twice for writing\n"
"-- might give this error).\n"
"isAlreadyInUseError :: IOError -> Bool\n"
"isAlreadyInUseError  = isAlreadyInUseErrorType     . ioeGetErrorType\n"
"\n"
"-- | An error indicating that an 'IO' operation failed because\n"
"-- the device is full.\n"
"isFullError         :: IOError -> Bool\n"
"isFullError          = isFullErrorType             . ioeGetErrorType\n"
"\n"
"-- | An error indicating that an 'IO' operation failed because\n"
"-- the end of file has been reached.\n"
"isEOFError          :: IOError -> Bool\n"
"isEOFError           = isEOFErrorType              . ioeGetErrorType\n"
"\n"
"-- | An error indicating that an 'IO' operation failed because\n"
"-- the operation was not possible.\n"
"-- Any computation which returns an 'IO' result may fail with\n"
"-- 'isIllegalOperation'.  In some cases, an implementation will not be\n"
"-- able to distinguish between the possible error causes.  In this case\n"
"-- it should fail with 'isIllegalOperation'.\n"
"isIllegalOperation  :: IOError -> Bool\n"
"isIllegalOperation   = isIllegalOperationErrorType . ioeGetErrorType\n"
"\n"
"-- | An error indicating that an 'IO' operation failed because\n"
"-- the user does not have sufficient operating system privilege\n"
"-- to perform that operation.\n"
"isPermissionError   :: IOError -> Bool\n"
"isPermissionError    = isPermissionErrorType       . ioeGetErrorType\n"
"\n"
"-- | A programmer-defined error value constructed using 'userError'.\n"
"isUserError         :: IOError -> Bool\n"
"isUserError          = isUserErrorType             . ioeGetErrorType\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- IOErrorTypes\n"
"\n"
"-- | I\\/O error where the operation failed because one of its arguments\n"
"-- already exists.\n"
"alreadyExistsErrorType   :: IOErrorType\n"
"alreadyExistsErrorType    = AlreadyExists\n"
"\n"
"-- | I\\/O error where the operation failed because one of its arguments\n"
"-- does not exist.\n"
"doesNotExistErrorType    :: IOErrorType\n"
"doesNotExistErrorType     = NoSuchThing\n"
"\n"
"-- | I\\/O error where the operation failed because one of its arguments\n"
"-- is a single-use resource, which is already being used.\n"
"alreadyInUseErrorType    :: IOErrorType\n"
"alreadyInUseErrorType     = ResourceBusy\n"
"\n"
"-- | I\\/O error where the operation failed because the device is full.\n"
"fullErrorType            :: IOErrorType\n"
"fullErrorType             = ResourceExhausted\n"
"\n"
"-- | I\\/O error where the operation failed because the end of file has\n"
"-- been reached.\n"
"eofErrorType             :: IOErrorType\n"
"eofErrorType              = EOF\n"
"\n"
"-- | I\\/O error where the operation is not possible.\n"
"illegalOperationErrorType :: IOErrorType\n"
"illegalOperationErrorType = IllegalOperation\n"
"\n"
"-- | I\\/O error where the operation failed because the user does not\n"
"-- have sufficient operating system privilege to perform that operation.\n"
"permissionErrorType      :: IOErrorType\n"
"permissionErrorType       = PermissionDenied\n"
"\n"
"-- | I\\/O error that is programmer-defined.\n"
"userErrorType		 :: IOErrorType\n"
"userErrorType		  = UserError\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- IOErrorType predicates\n"
"\n"
"-- | I\\/O error where the operation failed because one of its arguments\n"
"-- already exists.\n"
"isAlreadyExistsErrorType :: IOErrorType -> Bool\n"
"isAlreadyExistsErrorType AlreadyExists = True\n"
"isAlreadyExistsErrorType _ = False\n"
"\n"
"-- | I\\/O error where the operation failed because one of its arguments\n"
"-- does not exist.\n"
"isDoesNotExistErrorType :: IOErrorType -> Bool\n"
"isDoesNotExistErrorType NoSuchThing = True\n"
"isDoesNotExistErrorType _ = False\n"
"\n"
"-- | I\\/O error where the operation failed because one of its arguments\n"
"-- is a single-use resource, which is already being used.\n"
"isAlreadyInUseErrorType :: IOErrorType -> Bool\n"
"isAlreadyInUseErrorType ResourceBusy = True\n"
"isAlreadyInUseErrorType _ = False\n"
"\n"
"-- | I\\/O error where the operation failed because the device is full.\n"
"isFullErrorType :: IOErrorType -> Bool\n"
"isFullErrorType ResourceExhausted = True\n"
"isFullErrorType _ = False\n"
"\n"
"-- | I\\/O error where the operation failed because the end of file has\n"
"-- been reached.\n"
"isEOFErrorType :: IOErrorType -> Bool\n"
"isEOFErrorType EOF = True\n"
"isEOFErrorType _ = False\n"
"\n"
"-- | I\\/O error where the operation is not possible.\n"
"isIllegalOperationErrorType :: IOErrorType -> Bool\n"
"isIllegalOperationErrorType IllegalOperation = True\n"
"isIllegalOperationErrorType _ = False\n"
"\n"
"-- | I\\/O error where the operation failed because the user does not\n"
"-- have sufficient operating system privilege to perform that operation.\n"
"isPermissionErrorType :: IOErrorType -> Bool\n"
"isPermissionErrorType PermissionDenied = True\n"
"isPermissionErrorType _ = False\n"
"\n"
"-- | I\\/O error that is programmer-defined.\n"
"isUserErrorType :: IOErrorType -> Bool\n"
"isUserErrorType UserError = True\n"
"isUserErrorType _ = False\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Miscellaneous\n"
"\n"
"ioeGetErrorType	      :: IOError -> IOErrorType\n"
"ioeGetErrorString     :: IOError -> String\n"
"ioeGetHandle          :: IOError -> Maybe Handle\n"
"ioeGetFileName        :: IOError -> Maybe FilePath\n"
"\n"
"ioeGetErrorType ioe = ioe_type ioe\n"
"\n"
"ioeGetErrorString ioe\n"
"   | isUserErrorType (ioe_type ioe) = ioe_description ioe\n"
"   | otherwise                      = show (ioe_type ioe)\n"
"\n"
"ioeGetHandle ioe = ioe_handle ioe\n"
"\n"
"ioeGetFileName ioe = ioe_filename ioe\n"
"\n"
"ioeSetErrorType		:: IOError -> IOErrorType -> IOError\n"
"ioeSetErrorString	:: IOError -> String      -> IOError\n"
"ioeSetHandle		:: IOError -> Handle      -> IOError\n"
"ioeSetFileName		:: IOError -> FilePath    -> IOError\n"
"\n"
"ioeSetErrorType   ioe errtype  = ioe{ ioe_type = errtype }\n"
"ioeSetErrorString ioe str      = ioe{ ioe_description = str }\n"
"ioeSetHandle      ioe hdl      = ioe{ ioe_handle = Just hdl }\n"
"ioeSetFileName    ioe filename = ioe{ ioe_filename = Just filename }\n"
"\n"
"-- | Catch any 'IOError' that occurs in the computation and throw a\n"
"-- modified version.\n"
"modifyIOError :: (IOError -> IOError) -> IO a -> IO a\n"
"modifyIOError f io = catch io (\\e -> ioError (f e))\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- annotating an IOError\n"
"\n"
"-- | Adds a location description and maybe a file path and file handle\n"
"-- to an 'IOError'.  If any of the file handle or file path is not given\n"
"-- the corresponding value in the 'IOError' remains unaltered.\n"
"annotateIOError :: IOError \n"
"              -> String \n"
"              -> Maybe Handle \n"
"              -> Maybe FilePath \n"
"              -> IOError \n"
"annotateIOError (IOError ohdl errTy _ str opath) loc hdl path = \n"
"  IOError (hdl `mplus` ohdl) errTy loc str (path `mplus` opath)\n"
"  where\n"
"    Nothing `mplus` ys = ys\n"
"    xs      `mplus` _  = xs\n"
"\n";
const char *System_Posix_Resource = "{-# LINE 1 \"Resource.hsc\" #-}\n"
"{-# LINE 2 \"Resource.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.Resource\n"
"-- Copyright   :  (c) The University of Glasgow 2003\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX resource support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.Resource (\n"
"    -- * Resource Limits\n"
"    ResourceLimit(..), ResourceLimits(..), Resource(..),\n"
"    getResourceLimit,\n"
"    setResourceLimit,\n"
"  ) where\n"
"\n"
"\n"
"{-# LINE 24 \"Resource.hsc\" #-}\n"
"\n"
"import System.Posix.Types\n"
"import Foreign\n"
"import Foreign.C\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Resource limits\n"
"\n"
"data Resource\n"
"  = ResourceCoreFileSize\n"
"  | ResourceCPUTime\n"
"  | ResourceDataSize\n"
"  | ResourceFileSize\n"
"  | ResourceOpenFiles\n"
"  | ResourceStackSize\n"
"\n"
"{-# LINE 40 \"Resource.hsc\" #-}\n"
"  | ResourceTotalMemory\n"
"\n"
"{-# LINE 42 \"Resource.hsc\" #-}\n"
"  deriving Eq\n"
"\n"
"data ResourceLimits\n"
"  = ResourceLimits { softLimit, hardLimit :: ResourceLimit }\n"
"  deriving Eq\n"
"\n"
"data ResourceLimit\n"
"  = ResourceLimitInfinity\n"
"  | ResourceLimitUnknown\n"
"  | ResourceLimit Integer\n"
"  deriving Eq\n"
"\n"
"type RLimit = ()\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h getrlimit\"\n"
"  c_getrlimit :: CInt -> Ptr RLimit -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h setrlimit\"\n"
"  c_setrlimit :: CInt -> Ptr RLimit -> IO CInt\n"
"\n"
"getResourceLimit :: Resource -> IO ResourceLimits\n"
"getResourceLimit res = do\n"
"  allocaBytes (16) $ \\p_rlimit -> do\n"
"{-# LINE 65 \"Resource.hsc\" #-}\n"
"    throwErrnoIfMinus1 \"getResourceLimit\" $\n"
"      c_getrlimit (packResource res) p_rlimit\n"
"    soft <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0)) p_rlimit\n"
"{-# LINE 68 \"Resource.hsc\" #-}\n"
"    hard <- ((\\hsc_ptr -> peekByteOff hsc_ptr 8)) p_rlimit\n"
"{-# LINE 69 \"Resource.hsc\" #-}\n"
"    return (ResourceLimits { \n"
"		softLimit = unpackRLimit soft,\n"
"		hardLimit = unpackRLimit hard\n"
"	   })\n"
"\n"
"setResourceLimit :: Resource -> ResourceLimits -> IO ()\n"
"setResourceLimit res ResourceLimits{softLimit=soft,hardLimit=hard} = do\n"
"  allocaBytes (16) $ \\p_rlimit -> do\n"
"{-# LINE 77 \"Resource.hsc\" #-}\n"
"    ((\\hsc_ptr -> pokeByteOff hsc_ptr 0)) p_rlimit (packRLimit soft True)\n"
"{-# LINE 78 \"Resource.hsc\" #-}\n"
"    ((\\hsc_ptr -> pokeByteOff hsc_ptr 8)) p_rlimit (packRLimit hard False)\n"
"{-# LINE 79 \"Resource.hsc\" #-}\n"
"    throwErrnoIfMinus1 \"setResourceLimit\" $\n"
"	c_setrlimit (packResource res) p_rlimit\n"
"    return ()\n"
"\n"
"packResource :: Resource -> CInt\n"
"packResource ResourceCoreFileSize  = (4)\n"
"{-# LINE 85 \"Resource.hsc\" #-}\n"
"packResource ResourceCPUTime       = (0)\n"
"{-# LINE 86 \"Resource.hsc\" #-}\n"
"packResource ResourceDataSize      = (2)\n"
"{-# LINE 87 \"Resource.hsc\" #-}\n"
"packResource ResourceFileSize      = (1)\n"
"{-# LINE 88 \"Resource.hsc\" #-}\n"
"packResource ResourceOpenFiles     = (7)\n"
"{-# LINE 89 \"Resource.hsc\" #-}\n"
"packResource ResourceStackSize     = (3)\n"
"{-# LINE 90 \"Resource.hsc\" #-}\n"
"\n"
"{-# LINE 91 \"Resource.hsc\" #-}\n"
"packResource ResourceTotalMemory   = (9)\n"
"{-# LINE 92 \"Resource.hsc\" #-}\n"
"\n"
"{-# LINE 93 \"Resource.hsc\" #-}\n"
"\n"
"unpackRLimit :: CRLim -> ResourceLimit\n"
"unpackRLimit (18446744073709551615)  = ResourceLimitInfinity\n"
"{-# LINE 96 \"Resource.hsc\" #-}\n"
"\n"
"{-# LINE 97 \"Resource.hsc\" #-}\n"
"unpackRLimit (18446744073709551615) = ResourceLimitUnknown\n"
"{-# LINE 98 \"Resource.hsc\" #-}\n"
"unpackRLimit (18446744073709551615) = ResourceLimitUnknown\n"
"{-# LINE 99 \"Resource.hsc\" #-}\n"
"\n"
"{-# LINE 100 \"Resource.hsc\" #-}\n"
"unpackRLimit other = ResourceLimit (fromIntegral other)\n"
"\n"
"packRLimit :: ResourceLimit -> Bool -> CRLim\n"
"packRLimit ResourceLimitInfinity _     = (18446744073709551615)\n"
"{-# LINE 104 \"Resource.hsc\" #-}\n"
"\n"
"{-# LINE 105 \"Resource.hsc\" #-}\n"
"packRLimit ResourceLimitUnknown  True  = (18446744073709551615)\n"
"{-# LINE 106 \"Resource.hsc\" #-}\n"
"packRLimit ResourceLimitUnknown  False = (18446744073709551615)\n"
"{-# LINE 107 \"Resource.hsc\" #-}\n"
"\n"
"{-# LINE 108 \"Resource.hsc\" #-}\n"
"packRLimit (ResourceLimit other) _     = fromIntegral other\n"
"\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Test code\n"
"\n"
"{-\n"
"import System.Posix\n"
"import Control.Monad\n"
"\n"
"main = do\n"
" zipWithM_ (\\r n -> setResourceLimit r ResourceLimits{\n"
"					hardLimit = ResourceLimit n,\n"
"					softLimit = ResourceLimit n })\n"
"	allResources [1..]	\n"
" showAll\n"
" mapM_ (\\r -> setResourceLimit r ResourceLimits{\n"
"					hardLimit = ResourceLimit 1,\n"
"					softLimit = ResourceLimitInfinity })\n"
"	allResources\n"
"   -- should fail\n"
"\n"
"\n"
"showAll = \n"
"  mapM_ (\\r -> getResourceLimit r >>= (putStrLn . showRLims)) allResources\n"
"\n"
"allResources =\n"
"    [ResourceCoreFileSize, ResourceCPUTime, ResourceDataSize,\n"
"	ResourceFileSize, ResourceOpenFiles, ResourceStackSize\n"
"#ifdef RLIMIT_AS\n"
"	, ResourceTotalMemory \n"
"#endif\n"
"	]\n"
"\n"
"showRLims ResourceLimits{hardLimit=h,softLimit=s}\n"
"  = \"hard: \" ++ showRLim h ++ \", soft: \" ++ showRLim s\n"
" \n"
"showRLim ResourceLimitInfinity = \"infinity\"\n"
"showRLim ResourceLimitUnknown  = \"unknown\"\n"
"showRLim (ResourceLimit other)  = show other\n"
"-}\n";
const char *System_Posix_Types = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.Types\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX data types: Haskell equivalents of the types defined by the\n"
"-- @\\<sys\\/types.h>@ C header on a POSIX system.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.Types (\n"
"\n"
"  -- * POSIX data types\n"
"  CDev,\n"
"  CIno,\n"
"  CMode,\n"
"  COff,\n"
"  CPid,\n"
"  CSsize,\n"
"\n"
"  CGid,\n"
"  CNlink,\n"
"  CUid,\n"
"  CCc,\n"
"  CSpeed,\n"
"  CTcflag,\n"
"  CRLim,\n"
"\n"
"  Fd(..),\n"
"\n"
"  LinkCount,\n"
"  UserID,\n"
"  GroupID,\n"
"\n"
"  ByteCount,\n"
"  ClockTick,\n"
"  EpochTime,\n"
"  FileOffset,\n"
"  ProcessID,\n"
"  ProcessGroupID,\n"
"  DeviceID,\n"
"  FileID,\n"
"  FileMode,\n"
"  Limit\n"
" ) where\n"
"\n"
"import Foreign\n"
"import Foreign.C\n"
"import Data.Typeable\n"
"import Data.Bits\n"
"\n"
"import Control.Monad\n"
"\n"
"newtype CDev = CDev Word64 deriving (Eq, Ord) ; instance Num CDev where {    (CDev i) + (CDev j) = CDev (i + j) ;    (CDev i) - (CDev j) = CDev (i - j) ;    (CDev i) * (CDev j) = CDev (i * j) ;    negate  (CDev i) = CDev (negate i) ;    abs     (CDev i) = CDev (abs    i) ;    signum  (CDev i) = CDev (signum i) ;    fromInteger x = CDev (fromInteger x) } ; instance Read CDev where {    readsPrec p s = map (\\(x, t) -> (CDev x, t)) (readsPrec p s) } ; instance Show CDev where {    showsPrec p (CDev x) = showsPrec p x } ; instance Enum CDev where {    succ           (CDev i)             = CDev (succ i) ;    pred           (CDev i)             = CDev (pred i) ;    toEnum               x           = CDev (toEnum x) ;    fromEnum       (CDev i)             = fromEnum i ;    enumFrom       (CDev i)             = map CDev (enumFrom i) ;    enumFromThen   (CDev i) (CDev j)       = map CDev (enumFromThen i j) ;    enumFromTo     (CDev i) (CDev j)       = map CDev (enumFromTo i j) ;    enumFromThenTo (CDev i) (CDev j) (CDev k) = map CDev (enumFromThenTo i j k) } ; instance Storable CDev where {    sizeOf    (CDev x)       = sizeOf x ;    alignment (CDev x)       = alignment x ;    peekElemOff a i       = liftM CDev (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CDev x) = pokeElemOff (castPtr a) i x } ; tyConCDev = mkTyCon \"CDev\"; instance Typeable CDev where { typeOf _ = mkAppTy tyConCDev [] } ;\n"
"newtype CIno = CIno Word64 deriving (Eq, Ord) ; instance Num CIno where {    (CIno i) + (CIno j) = CIno (i + j) ;    (CIno i) - (CIno j) = CIno (i - j) ;    (CIno i) * (CIno j) = CIno (i * j) ;    negate  (CIno i) = CIno (negate i) ;    abs     (CIno i) = CIno (abs    i) ;    signum  (CIno i) = CIno (signum i) ;    fromInteger x = CIno (fromInteger x) } ; instance Read CIno where {    readsPrec p s = map (\\(x, t) -> (CIno x, t)) (readsPrec p s) } ; instance Show CIno where {    showsPrec p (CIno x) = showsPrec p x } ; instance Enum CIno where {    succ           (CIno i)             = CIno (succ i) ;    pred           (CIno i)             = CIno (pred i) ;    toEnum               x           = CIno (toEnum x) ;    fromEnum       (CIno i)             = fromEnum i ;    enumFrom       (CIno i)             = map CIno (enumFrom i) ;    enumFromThen   (CIno i) (CIno j)       = map CIno (enumFromThen i j) ;    enumFromTo     (CIno i) (CIno j)       = map CIno (enumFromTo i j) ;    enumFromThenTo (CIno i) (CIno j) (CIno k) = map CIno (enumFromThenTo i j k) } ; instance Storable CIno where {    sizeOf    (CIno x)       = sizeOf x ;    alignment (CIno x)       = alignment x ;    peekElemOff a i       = liftM CIno (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CIno x) = pokeElemOff (castPtr a) i x } ; tyConCIno = mkTyCon \"CIno\"; instance Typeable CIno where { typeOf _ = mkAppTy tyConCIno [] } ; ; instance Bounded CIno where {    minBound = CIno minBound ;    maxBound = CIno maxBound } ; instance Real CIno where {    toRational (CIno i) = toRational i } ; instance Integral CIno where {    (CIno i) `quot`    (CIno j) = CIno (i `quot` j) ;    (CIno i) `rem`     (CIno j) = CIno (i `rem`  j) ;    (CIno i) `div`     (CIno j) = CIno (i `div`  j) ;    (CIno i) `mod`     (CIno j) = CIno (i `mod`  j) ;    (CIno i) `quotRem` (CIno j) = let (q,r) = i `quotRem` j in (CIno q, CIno r) ;    (CIno i) `divMod`  (CIno j) = let (d,m) = i `divMod`  j in (CIno d, CIno m) ;    toInteger (CIno i)       = toInteger i } ; instance Bits CIno where {   (CIno x) .&.     (CIno y)   = CIno (x .&.   y) ;   (CIno x) .|.     (CIno y)   = CIno (x .|.   y) ;   (CIno x) `xor`   (CIno y)   = CIno (x `xor` y) ;   complement    (CIno x)   = CIno (complement x) ;   shift         (CIno x) n = CIno (shift x n) ;   rotate        (CIno x) n = CIno (rotate x n) ;   bit                 n = CIno (bit n) ;   setBit        (CIno x) n = CIno (setBit x n) ;   clearBit      (CIno x) n = CIno (clearBit x n) ;   complementBit (CIno x) n = CIno (complementBit x n) ;   testBit       (CIno x) n = testBit x n ;   bitSize       (CIno x)   = bitSize x ;   isSigned      (CIno x)   = isSigned x }\n"
"newtype CMode = CMode Word32 deriving (Eq, Ord) ; instance Num CMode where {    (CMode i) + (CMode j) = CMode (i + j) ;    (CMode i) - (CMode j) = CMode (i - j) ;    (CMode i) * (CMode j) = CMode (i * j) ;    negate  (CMode i) = CMode (negate i) ;    abs     (CMode i) = CMode (abs    i) ;    signum  (CMode i) = CMode (signum i) ;    fromInteger x = CMode (fromInteger x) } ; instance Read CMode where {    readsPrec p s = map (\\(x, t) -> (CMode x, t)) (readsPrec p s) } ; instance Show CMode where {    showsPrec p (CMode x) = showsPrec p x } ; instance Enum CMode where {    succ           (CMode i)             = CMode (succ i) ;    pred           (CMode i)             = CMode (pred i) ;    toEnum               x           = CMode (toEnum x) ;    fromEnum       (CMode i)             = fromEnum i ;    enumFrom       (CMode i)             = map CMode (enumFrom i) ;    enumFromThen   (CMode i) (CMode j)       = map CMode (enumFromThen i j) ;    enumFromTo     (CMode i) (CMode j)       = map CMode (enumFromTo i j) ;    enumFromThenTo (CMode i) (CMode j) (CMode k) = map CMode (enumFromThenTo i j k) } ; instance Storable CMode where {    sizeOf    (CMode x)       = sizeOf x ;    alignment (CMode x)       = alignment x ;    peekElemOff a i       = liftM CMode (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CMode x) = pokeElemOff (castPtr a) i x } ; tyConCMode = mkTyCon \"CMode\"; instance Typeable CMode where { typeOf _ = mkAppTy tyConCMode [] } ; ; instance Bounded CMode where {    minBound = CMode minBound ;    maxBound = CMode maxBound } ; instance Real CMode where {    toRational (CMode i) = toRational i } ; instance Integral CMode where {    (CMode i) `quot`    (CMode j) = CMode (i `quot` j) ;    (CMode i) `rem`     (CMode j) = CMode (i `rem`  j) ;    (CMode i) `div`     (CMode j) = CMode (i `div`  j) ;    (CMode i) `mod`     (CMode j) = CMode (i `mod`  j) ;    (CMode i) `quotRem` (CMode j) = let (q,r) = i `quotRem` j in (CMode q, CMode r) ;    (CMode i) `divMod`  (CMode j) = let (d,m) = i `divMod`  j in (CMode d, CMode m) ;    toInteger (CMode i)       = toInteger i } ; instance Bits CMode where {   (CMode x) .&.     (CMode y)   = CMode (x .&.   y) ;   (CMode x) .|.     (CMode y)   = CMode (x .|.   y) ;   (CMode x) `xor`   (CMode y)   = CMode (x `xor` y) ;   complement    (CMode x)   = CMode (complement x) ;   shift         (CMode x) n = CMode (shift x n) ;   rotate        (CMode x) n = CMode (rotate x n) ;   bit                 n = CMode (bit n) ;   setBit        (CMode x) n = CMode (setBit x n) ;   clearBit      (CMode x) n = CMode (clearBit x n) ;   complementBit (CMode x) n = CMode (complementBit x n) ;   testBit       (CMode x) n = testBit x n ;   bitSize       (CMode x)   = bitSize x ;   isSigned      (CMode x)   = isSigned x }\n"
"newtype COff = COff Int64 deriving (Eq, Ord) ; instance Num COff where {    (COff i) + (COff j) = COff (i + j) ;    (COff i) - (COff j) = COff (i - j) ;    (COff i) * (COff j) = COff (i * j) ;    negate  (COff i) = COff (negate i) ;    abs     (COff i) = COff (abs    i) ;    signum  (COff i) = COff (signum i) ;    fromInteger x = COff (fromInteger x) } ; instance Read COff where {    readsPrec p s = map (\\(x, t) -> (COff x, t)) (readsPrec p s) } ; instance Show COff where {    showsPrec p (COff x) = showsPrec p x } ; instance Enum COff where {    succ           (COff i)             = COff (succ i) ;    pred           (COff i)             = COff (pred i) ;    toEnum               x           = COff (toEnum x) ;    fromEnum       (COff i)             = fromEnum i ;    enumFrom       (COff i)             = map COff (enumFrom i) ;    enumFromThen   (COff i) (COff j)       = map COff (enumFromThen i j) ;    enumFromTo     (COff i) (COff j)       = map COff (enumFromTo i j) ;    enumFromThenTo (COff i) (COff j) (COff k) = map COff (enumFromThenTo i j k) } ; instance Storable COff where {    sizeOf    (COff x)       = sizeOf x ;    alignment (COff x)       = alignment x ;    peekElemOff a i       = liftM COff (peekElemOff (castPtr a) i) ;    pokeElemOff a i (COff x) = pokeElemOff (castPtr a) i x } ; tyConCOff = mkTyCon \"COff\"; instance Typeable COff where { typeOf _ = mkAppTy tyConCOff [] } ; ; instance Bounded COff where {    minBound = COff minBound ;    maxBound = COff maxBound } ; instance Real COff where {    toRational (COff i) = toRational i } ; instance Integral COff where {    (COff i) `quot`    (COff j) = COff (i `quot` j) ;    (COff i) `rem`     (COff j) = COff (i `rem`  j) ;    (COff i) `div`     (COff j) = COff (i `div`  j) ;    (COff i) `mod`     (COff j) = COff (i `mod`  j) ;    (COff i) `quotRem` (COff j) = let (q,r) = i `quotRem` j in (COff q, COff r) ;    (COff i) `divMod`  (COff j) = let (d,m) = i `divMod`  j in (COff d, COff m) ;    toInteger (COff i)       = toInteger i } ; instance Bits COff where {   (COff x) .&.     (COff y)   = COff (x .&.   y) ;   (COff x) .|.     (COff y)   = COff (x .|.   y) ;   (COff x) `xor`   (COff y)   = COff (x `xor` y) ;   complement    (COff x)   = COff (complement x) ;   shift         (COff x) n = COff (shift x n) ;   rotate        (COff x) n = COff (rotate x n) ;   bit                 n = COff (bit n) ;   setBit        (COff x) n = COff (setBit x n) ;   clearBit      (COff x) n = COff (clearBit x n) ;   complementBit (COff x) n = COff (complementBit x n) ;   testBit       (COff x) n = testBit x n ;   bitSize       (COff x)   = bitSize x ;   isSigned      (COff x)   = isSigned x }\n"
"newtype CPid = CPid Int32 deriving (Eq, Ord) ; instance Num CPid where {    (CPid i) + (CPid j) = CPid (i + j) ;    (CPid i) - (CPid j) = CPid (i - j) ;    (CPid i) * (CPid j) = CPid (i * j) ;    negate  (CPid i) = CPid (negate i) ;    abs     (CPid i) = CPid (abs    i) ;    signum  (CPid i) = CPid (signum i) ;    fromInteger x = CPid (fromInteger x) } ; instance Read CPid where {    readsPrec p s = map (\\(x, t) -> (CPid x, t)) (readsPrec p s) } ; instance Show CPid where {    showsPrec p (CPid x) = showsPrec p x } ; instance Enum CPid where {    succ           (CPid i)             = CPid (succ i) ;    pred           (CPid i)             = CPid (pred i) ;    toEnum               x           = CPid (toEnum x) ;    fromEnum       (CPid i)             = fromEnum i ;    enumFrom       (CPid i)             = map CPid (enumFrom i) ;    enumFromThen   (CPid i) (CPid j)       = map CPid (enumFromThen i j) ;    enumFromTo     (CPid i) (CPid j)       = map CPid (enumFromTo i j) ;    enumFromThenTo (CPid i) (CPid j) (CPid k) = map CPid (enumFromThenTo i j k) } ; instance Storable CPid where {    sizeOf    (CPid x)       = sizeOf x ;    alignment (CPid x)       = alignment x ;    peekElemOff a i       = liftM CPid (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CPid x) = pokeElemOff (castPtr a) i x } ; tyConCPid = mkTyCon \"CPid\"; instance Typeable CPid where { typeOf _ = mkAppTy tyConCPid [] } ; ; instance Bounded CPid where {    minBound = CPid minBound ;    maxBound = CPid maxBound } ; instance Real CPid where {    toRational (CPid i) = toRational i } ; instance Integral CPid where {    (CPid i) `quot`    (CPid j) = CPid (i `quot` j) ;    (CPid i) `rem`     (CPid j) = CPid (i `rem`  j) ;    (CPid i) `div`     (CPid j) = CPid (i `div`  j) ;    (CPid i) `mod`     (CPid j) = CPid (i `mod`  j) ;    (CPid i) `quotRem` (CPid j) = let (q,r) = i `quotRem` j in (CPid q, CPid r) ;    (CPid i) `divMod`  (CPid j) = let (d,m) = i `divMod`  j in (CPid d, CPid m) ;    toInteger (CPid i)       = toInteger i } ; instance Bits CPid where {   (CPid x) .&.     (CPid y)   = CPid (x .&.   y) ;   (CPid x) .|.     (CPid y)   = CPid (x .|.   y) ;   (CPid x) `xor`   (CPid y)   = CPid (x `xor` y) ;   complement    (CPid x)   = CPid (complement x) ;   shift         (CPid x) n = CPid (shift x n) ;   rotate        (CPid x) n = CPid (rotate x n) ;   bit                 n = CPid (bit n) ;   setBit        (CPid x) n = CPid (setBit x n) ;   clearBit      (CPid x) n = CPid (clearBit x n) ;   complementBit (CPid x) n = CPid (complementBit x n) ;   testBit       (CPid x) n = testBit x n ;   bitSize       (CPid x)   = bitSize x ;   isSigned      (CPid x)   = isSigned x }\n"
"\n"
"newtype CSsize = CSsize Word64 deriving (Eq, Ord) ; instance Num CSsize where {    (CSsize i) + (CSsize j) = CSsize (i + j) ;    (CSsize i) - (CSsize j) = CSsize (i - j) ;    (CSsize i) * (CSsize j) = CSsize (i * j) ;    negate  (CSsize i) = CSsize (negate i) ;    abs     (CSsize i) = CSsize (abs    i) ;    signum  (CSsize i) = CSsize (signum i) ;    fromInteger x = CSsize (fromInteger x) } ; instance Read CSsize where {    readsPrec p s = map (\\(x, t) -> (CSsize x, t)) (readsPrec p s) } ; instance Show CSsize where {    showsPrec p (CSsize x) = showsPrec p x } ; instance Enum CSsize where {    succ           (CSsize i)             = CSsize (succ i) ;    pred           (CSsize i)             = CSsize (pred i) ;    toEnum               x           = CSsize (toEnum x) ;    fromEnum       (CSsize i)             = fromEnum i ;    enumFrom       (CSsize i)             = map CSsize (enumFrom i) ;    enumFromThen   (CSsize i) (CSsize j)       = map CSsize (enumFromThen i j) ;    enumFromTo     (CSsize i) (CSsize j)       = map CSsize (enumFromTo i j) ;    enumFromThenTo (CSsize i) (CSsize j) (CSsize k) = map CSsize (enumFromThenTo i j k) } ; instance Storable CSsize where {    sizeOf    (CSsize x)       = sizeOf x ;    alignment (CSsize x)       = alignment x ;    peekElemOff a i       = liftM CSsize (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CSsize x) = pokeElemOff (castPtr a) i x } ; tyConCSsize = mkTyCon \"CSsize\"; instance Typeable CSsize where { typeOf _ = mkAppTy tyConCSsize [] } ; ; instance Bounded CSsize where {    minBound = CSsize minBound ;    maxBound = CSsize maxBound } ; instance Real CSsize where {    toRational (CSsize i) = toRational i } ; instance Integral CSsize where {    (CSsize i) `quot`    (CSsize j) = CSsize (i `quot` j) ;    (CSsize i) `rem`     (CSsize j) = CSsize (i `rem`  j) ;    (CSsize i) `div`     (CSsize j) = CSsize (i `div`  j) ;    (CSsize i) `mod`     (CSsize j) = CSsize (i `mod`  j) ;    (CSsize i) `quotRem` (CSsize j) = let (q,r) = i `quotRem` j in (CSsize q, CSsize r) ;    (CSsize i) `divMod`  (CSsize j) = let (d,m) = i `divMod`  j in (CSsize d, CSsize m) ;    toInteger (CSsize i)       = toInteger i } ; instance Bits CSsize where {   (CSsize x) .&.     (CSsize y)   = CSsize (x .&.   y) ;   (CSsize x) .|.     (CSsize y)   = CSsize (x .|.   y) ;   (CSsize x) `xor`   (CSsize y)   = CSsize (x `xor` y) ;   complement    (CSsize x)   = CSsize (complement x) ;   shift         (CSsize x) n = CSsize (shift x n) ;   rotate        (CSsize x) n = CSsize (rotate x n) ;   bit                 n = CSsize (bit n) ;   setBit        (CSsize x) n = CSsize (setBit x n) ;   clearBit      (CSsize x) n = CSsize (clearBit x n) ;   complementBit (CSsize x) n = CSsize (complementBit x n) ;   testBit       (CSsize x) n = testBit x n ;   bitSize       (CSsize x)   = bitSize x ;   isSigned      (CSsize x)   = isSigned x }\n"
"\n"
"newtype CGid = CGid Word32 deriving (Eq, Ord) ; instance Num CGid where {    (CGid i) + (CGid j) = CGid (i + j) ;    (CGid i) - (CGid j) = CGid (i - j) ;    (CGid i) * (CGid j) = CGid (i * j) ;    negate  (CGid i) = CGid (negate i) ;    abs     (CGid i) = CGid (abs    i) ;    signum  (CGid i) = CGid (signum i) ;    fromInteger x = CGid (fromInteger x) } ; instance Read CGid where {    readsPrec p s = map (\\(x, t) -> (CGid x, t)) (readsPrec p s) } ; instance Show CGid where {    showsPrec p (CGid x) = showsPrec p x } ; instance Enum CGid where {    succ           (CGid i)             = CGid (succ i) ;    pred           (CGid i)             = CGid (pred i) ;    toEnum               x           = CGid (toEnum x) ;    fromEnum       (CGid i)             = fromEnum i ;    enumFrom       (CGid i)             = map CGid (enumFrom i) ;    enumFromThen   (CGid i) (CGid j)       = map CGid (enumFromThen i j) ;    enumFromTo     (CGid i) (CGid j)       = map CGid (enumFromTo i j) ;    enumFromThenTo (CGid i) (CGid j) (CGid k) = map CGid (enumFromThenTo i j k) } ; instance Storable CGid where {    sizeOf    (CGid x)       = sizeOf x ;    alignment (CGid x)       = alignment x ;    peekElemOff a i       = liftM CGid (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CGid x) = pokeElemOff (castPtr a) i x } ; tyConCGid = mkTyCon \"CGid\"; instance Typeable CGid where { typeOf _ = mkAppTy tyConCGid [] } ; ; instance Bounded CGid where {    minBound = CGid minBound ;    maxBound = CGid maxBound } ; instance Real CGid where {    toRational (CGid i) = toRational i } ; instance Integral CGid where {    (CGid i) `quot`    (CGid j) = CGid (i `quot` j) ;    (CGid i) `rem`     (CGid j) = CGid (i `rem`  j) ;    (CGid i) `div`     (CGid j) = CGid (i `div`  j) ;    (CGid i) `mod`     (CGid j) = CGid (i `mod`  j) ;    (CGid i) `quotRem` (CGid j) = let (q,r) = i `quotRem` j in (CGid q, CGid r) ;    (CGid i) `divMod`  (CGid j) = let (d,m) = i `divMod`  j in (CGid d, CGid m) ;    toInteger (CGid i)       = toInteger i } ; instance Bits CGid where {   (CGid x) .&.     (CGid y)   = CGid (x .&.   y) ;   (CGid x) .|.     (CGid y)   = CGid (x .|.   y) ;   (CGid x) `xor`   (CGid y)   = CGid (x `xor` y) ;   complement    (CGid x)   = CGid (complement x) ;   shift         (CGid x) n = CGid (shift x n) ;   rotate        (CGid x) n = CGid (rotate x n) ;   bit                 n = CGid (bit n) ;   setBit        (CGid x) n = CGid (setBit x n) ;   clearBit      (CGid x) n = CGid (clearBit x n) ;   complementBit (CGid x) n = CGid (complementBit x n) ;   testBit       (CGid x) n = testBit x n ;   bitSize       (CGid x)   = bitSize x ;   isSigned      (CGid x)   = isSigned x }\n"
"newtype CNlink = CNlink Word64 deriving (Eq, Ord) ; instance Num CNlink where {    (CNlink i) + (CNlink j) = CNlink (i + j) ;    (CNlink i) - (CNlink j) = CNlink (i - j) ;    (CNlink i) * (CNlink j) = CNlink (i * j) ;    negate  (CNlink i) = CNlink (negate i) ;    abs     (CNlink i) = CNlink (abs    i) ;    signum  (CNlink i) = CNlink (signum i) ;    fromInteger x = CNlink (fromInteger x) } ; instance Read CNlink where {    readsPrec p s = map (\\(x, t) -> (CNlink x, t)) (readsPrec p s) } ; instance Show CNlink where {    showsPrec p (CNlink x) = showsPrec p x } ; instance Enum CNlink where {    succ           (CNlink i)             = CNlink (succ i) ;    pred           (CNlink i)             = CNlink (pred i) ;    toEnum               x           = CNlink (toEnum x) ;    fromEnum       (CNlink i)             = fromEnum i ;    enumFrom       (CNlink i)             = map CNlink (enumFrom i) ;    enumFromThen   (CNlink i) (CNlink j)       = map CNlink (enumFromThen i j) ;    enumFromTo     (CNlink i) (CNlink j)       = map CNlink (enumFromTo i j) ;    enumFromThenTo (CNlink i) (CNlink j) (CNlink k) = map CNlink (enumFromThenTo i j k) } ; instance Storable CNlink where {    sizeOf    (CNlink x)       = sizeOf x ;    alignment (CNlink x)       = alignment x ;    peekElemOff a i       = liftM CNlink (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CNlink x) = pokeElemOff (castPtr a) i x } ; tyConCNlink = mkTyCon \"CNlink\"; instance Typeable CNlink where { typeOf _ = mkAppTy tyConCNlink [] } ; ; instance Bounded CNlink where {    minBound = CNlink minBound ;    maxBound = CNlink maxBound } ; instance Real CNlink where {    toRational (CNlink i) = toRational i } ; instance Integral CNlink where {    (CNlink i) `quot`    (CNlink j) = CNlink (i `quot` j) ;    (CNlink i) `rem`     (CNlink j) = CNlink (i `rem`  j) ;    (CNlink i) `div`     (CNlink j) = CNlink (i `div`  j) ;    (CNlink i) `mod`     (CNlink j) = CNlink (i `mod`  j) ;    (CNlink i) `quotRem` (CNlink j) = let (q,r) = i `quotRem` j in (CNlink q, CNlink r) ;    (CNlink i) `divMod`  (CNlink j) = let (d,m) = i `divMod`  j in (CNlink d, CNlink m) ;    toInteger (CNlink i)       = toInteger i } ; instance Bits CNlink where {   (CNlink x) .&.     (CNlink y)   = CNlink (x .&.   y) ;   (CNlink x) .|.     (CNlink y)   = CNlink (x .|.   y) ;   (CNlink x) `xor`   (CNlink y)   = CNlink (x `xor` y) ;   complement    (CNlink x)   = CNlink (complement x) ;   shift         (CNlink x) n = CNlink (shift x n) ;   rotate        (CNlink x) n = CNlink (rotate x n) ;   bit                 n = CNlink (bit n) ;   setBit        (CNlink x) n = CNlink (setBit x n) ;   clearBit      (CNlink x) n = CNlink (clearBit x n) ;   complementBit (CNlink x) n = CNlink (complementBit x n) ;   testBit       (CNlink x) n = testBit x n ;   bitSize       (CNlink x)   = bitSize x ;   isSigned      (CNlink x)   = isSigned x }\n"
"\n"
"newtype CUid = CUid Word32 deriving (Eq, Ord) ; instance Num CUid where {    (CUid i) + (CUid j) = CUid (i + j) ;    (CUid i) - (CUid j) = CUid (i - j) ;    (CUid i) * (CUid j) = CUid (i * j) ;    negate  (CUid i) = CUid (negate i) ;    abs     (CUid i) = CUid (abs    i) ;    signum  (CUid i) = CUid (signum i) ;    fromInteger x = CUid (fromInteger x) } ; instance Read CUid where {    readsPrec p s = map (\\(x, t) -> (CUid x, t)) (readsPrec p s) } ; instance Show CUid where {    showsPrec p (CUid x) = showsPrec p x } ; instance Enum CUid where {    succ           (CUid i)             = CUid (succ i) ;    pred           (CUid i)             = CUid (pred i) ;    toEnum               x           = CUid (toEnum x) ;    fromEnum       (CUid i)             = fromEnum i ;    enumFrom       (CUid i)             = map CUid (enumFrom i) ;    enumFromThen   (CUid i) (CUid j)       = map CUid (enumFromThen i j) ;    enumFromTo     (CUid i) (CUid j)       = map CUid (enumFromTo i j) ;    enumFromThenTo (CUid i) (CUid j) (CUid k) = map CUid (enumFromThenTo i j k) } ; instance Storable CUid where {    sizeOf    (CUid x)       = sizeOf x ;    alignment (CUid x)       = alignment x ;    peekElemOff a i       = liftM CUid (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CUid x) = pokeElemOff (castPtr a) i x } ; tyConCUid = mkTyCon \"CUid\"; instance Typeable CUid where { typeOf _ = mkAppTy tyConCUid [] } ; ; instance Bounded CUid where {    minBound = CUid minBound ;    maxBound = CUid maxBound } ; instance Real CUid where {    toRational (CUid i) = toRational i } ; instance Integral CUid where {    (CUid i) `quot`    (CUid j) = CUid (i `quot` j) ;    (CUid i) `rem`     (CUid j) = CUid (i `rem`  j) ;    (CUid i) `div`     (CUid j) = CUid (i `div`  j) ;    (CUid i) `mod`     (CUid j) = CUid (i `mod`  j) ;    (CUid i) `quotRem` (CUid j) = let (q,r) = i `quotRem` j in (CUid q, CUid r) ;    (CUid i) `divMod`  (CUid j) = let (d,m) = i `divMod`  j in (CUid d, CUid m) ;    toInteger (CUid i)       = toInteger i } ; instance Bits CUid where {   (CUid x) .&.     (CUid y)   = CUid (x .&.   y) ;   (CUid x) .|.     (CUid y)   = CUid (x .|.   y) ;   (CUid x) `xor`   (CUid y)   = CUid (x `xor` y) ;   complement    (CUid x)   = CUid (complement x) ;   shift         (CUid x) n = CUid (shift x n) ;   rotate        (CUid x) n = CUid (rotate x n) ;   bit                 n = CUid (bit n) ;   setBit        (CUid x) n = CUid (setBit x n) ;   clearBit      (CUid x) n = CUid (clearBit x n) ;   complementBit (CUid x) n = CUid (complementBit x n) ;   testBit       (CUid x) n = testBit x n ;   bitSize       (CUid x)   = bitSize x ;   isSigned      (CUid x)   = isSigned x }\n"
"newtype CCc = CCc Word8 deriving (Eq, Ord) ; instance Num CCc where {    (CCc i) + (CCc j) = CCc (i + j) ;    (CCc i) - (CCc j) = CCc (i - j) ;    (CCc i) * (CCc j) = CCc (i * j) ;    negate  (CCc i) = CCc (negate i) ;    abs     (CCc i) = CCc (abs    i) ;    signum  (CCc i) = CCc (signum i) ;    fromInteger x = CCc (fromInteger x) } ; instance Read CCc where {    readsPrec p s = map (\\(x, t) -> (CCc x, t)) (readsPrec p s) } ; instance Show CCc where {    showsPrec p (CCc x) = showsPrec p x } ; instance Enum CCc where {    succ           (CCc i)             = CCc (succ i) ;    pred           (CCc i)             = CCc (pred i) ;    toEnum               x           = CCc (toEnum x) ;    fromEnum       (CCc i)             = fromEnum i ;    enumFrom       (CCc i)             = map CCc (enumFrom i) ;    enumFromThen   (CCc i) (CCc j)       = map CCc (enumFromThen i j) ;    enumFromTo     (CCc i) (CCc j)       = map CCc (enumFromTo i j) ;    enumFromThenTo (CCc i) (CCc j) (CCc k) = map CCc (enumFromThenTo i j k) } ; instance Storable CCc where {    sizeOf    (CCc x)       = sizeOf x ;    alignment (CCc x)       = alignment x ;    peekElemOff a i       = liftM CCc (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CCc x) = pokeElemOff (castPtr a) i x } ; tyConCCc = mkTyCon \"CCc\"; instance Typeable CCc where { typeOf _ = mkAppTy tyConCCc [] } ;\n"
"newtype CSpeed = CSpeed Word32 deriving (Eq, Ord) ; instance Num CSpeed where {    (CSpeed i) + (CSpeed j) = CSpeed (i + j) ;    (CSpeed i) - (CSpeed j) = CSpeed (i - j) ;    (CSpeed i) * (CSpeed j) = CSpeed (i * j) ;    negate  (CSpeed i) = CSpeed (negate i) ;    abs     (CSpeed i) = CSpeed (abs    i) ;    signum  (CSpeed i) = CSpeed (signum i) ;    fromInteger x = CSpeed (fromInteger x) } ; instance Read CSpeed where {    readsPrec p s = map (\\(x, t) -> (CSpeed x, t)) (readsPrec p s) } ; instance Show CSpeed where {    showsPrec p (CSpeed x) = showsPrec p x } ; instance Enum CSpeed where {    succ           (CSpeed i)             = CSpeed (succ i) ;    pred           (CSpeed i)             = CSpeed (pred i) ;    toEnum               x           = CSpeed (toEnum x) ;    fromEnum       (CSpeed i)             = fromEnum i ;    enumFrom       (CSpeed i)             = map CSpeed (enumFrom i) ;    enumFromThen   (CSpeed i) (CSpeed j)       = map CSpeed (enumFromThen i j) ;    enumFromTo     (CSpeed i) (CSpeed j)       = map CSpeed (enumFromTo i j) ;    enumFromThenTo (CSpeed i) (CSpeed j) (CSpeed k) = map CSpeed (enumFromThenTo i j k) } ; instance Storable CSpeed where {    sizeOf    (CSpeed x)       = sizeOf x ;    alignment (CSpeed x)       = alignment x ;    peekElemOff a i       = liftM CSpeed (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CSpeed x) = pokeElemOff (castPtr a) i x } ; tyConCSpeed = mkTyCon \"CSpeed\"; instance Typeable CSpeed where { typeOf _ = mkAppTy tyConCSpeed [] } ;\n"
"newtype CTcflag = CTcflag Word32 deriving (Eq, Ord) ; instance Num CTcflag where {    (CTcflag i) + (CTcflag j) = CTcflag (i + j) ;    (CTcflag i) - (CTcflag j) = CTcflag (i - j) ;    (CTcflag i) * (CTcflag j) = CTcflag (i * j) ;    negate  (CTcflag i) = CTcflag (negate i) ;    abs     (CTcflag i) = CTcflag (abs    i) ;    signum  (CTcflag i) = CTcflag (signum i) ;    fromInteger x = CTcflag (fromInteger x) } ; instance Read CTcflag where {    readsPrec p s = map (\\(x, t) -> (CTcflag x, t)) (readsPrec p s) } ; instance Show CTcflag where {    showsPrec p (CTcflag x) = showsPrec p x } ; instance Enum CTcflag where {    succ           (CTcflag i)             = CTcflag (succ i) ;    pred           (CTcflag i)             = CTcflag (pred i) ;    toEnum               x           = CTcflag (toEnum x) ;    fromEnum       (CTcflag i)             = fromEnum i ;    enumFrom       (CTcflag i)             = map CTcflag (enumFrom i) ;    enumFromThen   (CTcflag i) (CTcflag j)       = map CTcflag (enumFromThen i j) ;    enumFromTo     (CTcflag i) (CTcflag j)       = map CTcflag (enumFromTo i j) ;    enumFromThenTo (CTcflag i) (CTcflag j) (CTcflag k) = map CTcflag (enumFromThenTo i j k) } ; instance Storable CTcflag where {    sizeOf    (CTcflag x)       = sizeOf x ;    alignment (CTcflag x)       = alignment x ;    peekElemOff a i       = liftM CTcflag (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CTcflag x) = pokeElemOff (castPtr a) i x } ; tyConCTcflag = mkTyCon \"CTcflag\"; instance Typeable CTcflag where { typeOf _ = mkAppTy tyConCTcflag [] } ; ; instance Bounded CTcflag where {    minBound = CTcflag minBound ;    maxBound = CTcflag maxBound } ; instance Real CTcflag where {    toRational (CTcflag i) = toRational i } ; instance Integral CTcflag where {    (CTcflag i) `quot`    (CTcflag j) = CTcflag (i `quot` j) ;    (CTcflag i) `rem`     (CTcflag j) = CTcflag (i `rem`  j) ;    (CTcflag i) `div`     (CTcflag j) = CTcflag (i `div`  j) ;    (CTcflag i) `mod`     (CTcflag j) = CTcflag (i `mod`  j) ;    (CTcflag i) `quotRem` (CTcflag j) = let (q,r) = i `quotRem` j in (CTcflag q, CTcflag r) ;    (CTcflag i) `divMod`  (CTcflag j) = let (d,m) = i `divMod`  j in (CTcflag d, CTcflag m) ;    toInteger (CTcflag i)       = toInteger i } ; instance Bits CTcflag where {   (CTcflag x) .&.     (CTcflag y)   = CTcflag (x .&.   y) ;   (CTcflag x) .|.     (CTcflag y)   = CTcflag (x .|.   y) ;   (CTcflag x) `xor`   (CTcflag y)   = CTcflag (x `xor` y) ;   complement    (CTcflag x)   = CTcflag (complement x) ;   shift         (CTcflag x) n = CTcflag (shift x n) ;   rotate        (CTcflag x) n = CTcflag (rotate x n) ;   bit                 n = CTcflag (bit n) ;   setBit        (CTcflag x) n = CTcflag (setBit x n) ;   clearBit      (CTcflag x) n = CTcflag (clearBit x n) ;   complementBit (CTcflag x) n = CTcflag (complementBit x n) ;   testBit       (CTcflag x) n = testBit x n ;   bitSize       (CTcflag x)   = bitSize x ;   isSigned      (CTcflag x)   = isSigned x }\n"
"newtype CRLim = CRLim Word64 deriving (Eq, Ord) ; instance Num CRLim where {    (CRLim i) + (CRLim j) = CRLim (i + j) ;    (CRLim i) - (CRLim j) = CRLim (i - j) ;    (CRLim i) * (CRLim j) = CRLim (i * j) ;    negate  (CRLim i) = CRLim (negate i) ;    abs     (CRLim i) = CRLim (abs    i) ;    signum  (CRLim i) = CRLim (signum i) ;    fromInteger x = CRLim (fromInteger x) } ; instance Read CRLim where {    readsPrec p s = map (\\(x, t) -> (CRLim x, t)) (readsPrec p s) } ; instance Show CRLim where {    showsPrec p (CRLim x) = showsPrec p x } ; instance Enum CRLim where {    succ           (CRLim i)             = CRLim (succ i) ;    pred           (CRLim i)             = CRLim (pred i) ;    toEnum               x           = CRLim (toEnum x) ;    fromEnum       (CRLim i)             = fromEnum i ;    enumFrom       (CRLim i)             = map CRLim (enumFrom i) ;    enumFromThen   (CRLim i) (CRLim j)       = map CRLim (enumFromThen i j) ;    enumFromTo     (CRLim i) (CRLim j)       = map CRLim (enumFromTo i j) ;    enumFromThenTo (CRLim i) (CRLim j) (CRLim k) = map CRLim (enumFromThenTo i j k) } ; instance Storable CRLim where {    sizeOf    (CRLim x)       = sizeOf x ;    alignment (CRLim x)       = alignment x ;    peekElemOff a i       = liftM CRLim (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CRLim x) = pokeElemOff (castPtr a) i x } ; tyConCRlim = mkTyCon \"CRLim\"; instance Typeable CRLim where { typeOf _ = mkAppTy tyConCRlim [] } ; ; instance Bounded CRLim where {    minBound = CRLim minBound ;    maxBound = CRLim maxBound } ; instance Real CRLim where {    toRational (CRLim i) = toRational i } ; instance Integral CRLim where {    (CRLim i) `quot`    (CRLim j) = CRLim (i `quot` j) ;    (CRLim i) `rem`     (CRLim j) = CRLim (i `rem`  j) ;    (CRLim i) `div`     (CRLim j) = CRLim (i `div`  j) ;    (CRLim i) `mod`     (CRLim j) = CRLim (i `mod`  j) ;    (CRLim i) `quotRem` (CRLim j) = let (q,r) = i `quotRem` j in (CRLim q, CRLim r) ;    (CRLim i) `divMod`  (CRLim j) = let (d,m) = i `divMod`  j in (CRLim d, CRLim m) ;    toInteger (CRLim i)       = toInteger i } ; instance Bits CRLim where {   (CRLim x) .&.     (CRLim y)   = CRLim (x .&.   y) ;   (CRLim x) .|.     (CRLim y)   = CRLim (x .|.   y) ;   (CRLim x) `xor`   (CRLim y)   = CRLim (x `xor` y) ;   complement    (CRLim x)   = CRLim (complement x) ;   shift         (CRLim x) n = CRLim (shift x n) ;   rotate        (CRLim x) n = CRLim (rotate x n) ;   bit                 n = CRLim (bit n) ;   setBit        (CRLim x) n = CRLim (setBit x n) ;   clearBit      (CRLim x) n = CRLim (clearBit x n) ;   complementBit (CRLim x) n = CRLim (complementBit x n) ;   testBit       (CRLim x) n = testBit x n ;   bitSize       (CRLim x)   = bitSize x ;   isSigned      (CRLim x)   = isSigned x }\n"
"\n"
"-- ToDo: blksize_t, clockid_t, blkcnt_t, fsblkcnt_t, fsfilcnt_t, id_t, key_t\n"
"-- suseconds_t, timer_t, useconds_t\n"
"\n"
"-- Make an Fd type rather than using CInt everywhere\n"
"newtype Fd = Fd CInt deriving (Eq, Ord) ; instance Num Fd where {    (Fd i) + (Fd j) = Fd (i + j) ;    (Fd i) - (Fd j) = Fd (i - j) ;    (Fd i) * (Fd j) = Fd (i * j) ;    negate  (Fd i) = Fd (negate i) ;    abs     (Fd i) = Fd (abs    i) ;    signum  (Fd i) = Fd (signum i) ;    fromInteger x = Fd (fromInteger x) } ; instance Read Fd where {    readsPrec p s = map (\\(x, t) -> (Fd x, t)) (readsPrec p s) } ; instance Show Fd where {    showsPrec p (Fd x) = showsPrec p x } ; instance Enum Fd where {    succ           (Fd i)             = Fd (succ i) ;    pred           (Fd i)             = Fd (pred i) ;    toEnum               x           = Fd (toEnum x) ;    fromEnum       (Fd i)             = fromEnum i ;    enumFrom       (Fd i)             = map Fd (enumFrom i) ;    enumFromThen   (Fd i) (Fd j)       = map Fd (enumFromThen i j) ;    enumFromTo     (Fd i) (Fd j)       = map Fd (enumFromTo i j) ;    enumFromThenTo (Fd i) (Fd j) (Fd k) = map Fd (enumFromThenTo i j k) } ; instance Storable Fd where {    sizeOf    (Fd x)       = sizeOf x ;    alignment (Fd x)       = alignment x ;    peekElemOff a i       = liftM Fd (peekElemOff (castPtr a) i) ;    pokeElemOff a i (Fd x) = pokeElemOff (castPtr a) i x } ; tyConFd = mkTyCon \"Fd\"; instance Typeable Fd where { typeOf _ = mkAppTy tyConFd [] } ; ; instance Bounded Fd where {    minBound = Fd minBound ;    maxBound = Fd maxBound } ; instance Real Fd where {    toRational (Fd i) = toRational i } ; instance Integral Fd where {    (Fd i) `quot`    (Fd j) = Fd (i `quot` j) ;    (Fd i) `rem`     (Fd j) = Fd (i `rem`  j) ;    (Fd i) `div`     (Fd j) = Fd (i `div`  j) ;    (Fd i) `mod`     (Fd j) = Fd (i `mod`  j) ;    (Fd i) `quotRem` (Fd j) = let (q,r) = i `quotRem` j in (Fd q, Fd r) ;    (Fd i) `divMod`  (Fd j) = let (d,m) = i `divMod`  j in (Fd d, Fd m) ;    toInteger (Fd i)       = toInteger i } ; instance Bits Fd where {   (Fd x) .&.     (Fd y)   = Fd (x .&.   y) ;   (Fd x) .|.     (Fd y)   = Fd (x .|.   y) ;   (Fd x) `xor`   (Fd y)   = Fd (x `xor` y) ;   complement    (Fd x)   = Fd (complement x) ;   shift         (Fd x) n = Fd (shift x n) ;   rotate        (Fd x) n = Fd (rotate x n) ;   bit                 n = Fd (bit n) ;   setBit        (Fd x) n = Fd (setBit x n) ;   clearBit      (Fd x) n = Fd (clearBit x n) ;   complementBit (Fd x) n = Fd (complementBit x n) ;   testBit       (Fd x) n = testBit x n ;   bitSize       (Fd x)   = bitSize x ;   isSigned      (Fd x)   = isSigned x }\n"
"\n"
"-- nicer names, and backwards compatibility with POSIX library:\n"
"type LinkCount      = CNlink\n"
"type UserID         = CUid\n"
"type GroupID        = CGid\n"
"\n"
"type ByteCount      = CSize\n"
"type ClockTick      = CClock\n"
"type EpochTime      = CTime\n"
"type DeviceID       = CDev\n"
"type FileID         = CIno\n"
"type FileMode       = CMode\n"
"type ProcessID      = CPid\n"
"type FileOffset     = COff\n"
"type ProcessGroupID = CPid\n"
"type Limit	    = CLong\n"
"\n";
const char *System_Posix_Signals = "{-# LINE 1 \"Signals.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"{-# LINE 2 \"Signals.hsc\" #-}\n"
"-- |\n"
"-- Module      :  System.Posix.Signals\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX signal support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"\n"
"{-# LINE 16 \"Signals.hsc\" #-}\n"
"\n"
"module System.Posix.Signals (\n"
"\n"
"{-# LINE 19 \"Signals.hsc\" #-}\n"
"  -- * The Signal type\n"
"  Signal,\n"
"\n"
"  -- * Specific signals\n"
"  nullSignal,\n"
"  internalAbort, sigABRT,\n"
"  realTimeAlarm, sigALRM,\n"
"  busError, sigBUS,\n"
"  processStatusChanged, sigCHLD,\n"
"  continueProcess, sigCONT,\n"
"  floatingPointException, sigFPE,\n"
"  lostConnection, sigHUP,\n"
"  illegalInstruction, sigILL,\n"
"  keyboardSignal, sigINT,\n"
"  killProcess, sigKILL,\n"
"  openEndedPipe, sigPIPE,\n"
"  keyboardTermination, sigQUIT,\n"
"  segmentationViolation, sigSEGV,\n"
"  softwareStop, sigSTOP,\n"
"  softwareTermination, sigTERM,\n"
"  keyboardStop, sigTSTP,\n"
"  backgroundRead, sigTTIN,\n"
"  backgroundWrite, sigTTOU,\n"
"  userDefinedSignal1, sigUSR1,\n"
"  userDefinedSignal2, sigUSR2,\n"
"\n"
"{-# LINE 45 \"Signals.hsc\" #-}\n"
"  pollableEvent, sigPOLL,\n"
"\n"
"{-# LINE 47 \"Signals.hsc\" #-}\n"
"  profilingTimerExpired, sigPROF,\n"
"  badSystemCall, sigSYS,\n"
"  breakpointTrap, sigTRAP,\n"
"  urgentDataAvailable, sigURG,\n"
"  virtualTimerExpired, sigVTALRM,\n"
"  cpuTimeLimitExceeded, sigXCPU,\n"
"  fileSizeLimitExceeded, sigXFSZ,\n"
"\n"
"  -- * Sending signals\n"
"  raiseSignal,\n"
"  signalProcess,\n"
"  signalProcessGroup,\n"
"\n"
"\n"
"{-# LINE 65 \"Signals.hsc\" #-}\n"
"\n"
"  -- * Signal sets\n"
"  SignalSet,\n"
"  emptySignalSet, fullSignalSet, \n"
"  addSignal, deleteSignal, inSignalSet,\n"
"\n"
"  -- * The process signal mask\n"
"  getSignalMask, setSignalMask, blockSignals, unblockSignals,\n"
"\n"
"  -- * The alarm timer\n"
"  scheduleAlarm,\n"
"\n"
"  -- * Waiting for signals\n"
"  getPendingSignals, awaitSignal,\n"
"\n"
"\n"
"{-# LINE 84 \"Signals.hsc\" #-}\n"
"\n"
"  -- MISSING FUNCTIONALITY:\n"
"  -- sigaction(), (inc. the sigaction structure + flags etc.)\n"
"  -- the siginfo structure\n"
"  -- sigaltstack()\n"
"  -- sighold, sigignore, sigpause, sigrelse, sigset\n"
"  -- siginterrupt\n"
"\n"
"{-# LINE 92 \"Signals.hsc\" #-}\n"
"  ) where\n"
"\n"
"\n"
"{-# LINE 97 \"Signals.hsc\" #-}\n"
"\n"
"{-# LINE 98 \"Signals.hsc\" #-}\n"
"\n"
"{-# LINE 99 \"Signals.hsc\" #-}\n"
"\n"
"import Foreign\n"
"import Foreign.C\n"
"import System.IO.Unsafe\n"
"import System.Posix.Types\n"
"import System.Posix.Internals\n"
"\n"
"\n"
"{-# LINE 107 \"Signals.hsc\" #-}\n"
"-- WHOLE FILE...\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Specific signals\n"
"\n"
"type Signal = CInt\n"
"\n"
"nullSignal :: Signal\n"
"nullSignal = 0\n"
"\n"
"\n"
"{-# LINE 118 \"Signals.hsc\" #-}\n"
"sigABRT   = (6)   :: CInt\n"
"{-# LINE 119 \"Signals.hsc\" #-}\n"
"sigALRM   = (14)   :: CInt\n"
"{-# LINE 120 \"Signals.hsc\" #-}\n"
"sigBUS    = (7)    :: CInt\n"
"{-# LINE 121 \"Signals.hsc\" #-}\n"
"sigCHLD   = (17)   :: CInt\n"
"{-# LINE 122 \"Signals.hsc\" #-}\n"
"sigCONT   = (18)   :: CInt\n"
"{-# LINE 123 \"Signals.hsc\" #-}\n"
"sigFPE    = (8)    :: CInt\n"
"{-# LINE 124 \"Signals.hsc\" #-}\n"
"sigHUP    = (1)    :: CInt\n"
"{-# LINE 125 \"Signals.hsc\" #-}\n"
"sigILL    = (4)    :: CInt\n"
"{-# LINE 126 \"Signals.hsc\" #-}\n"
"sigINT    = (2)    :: CInt\n"
"{-# LINE 127 \"Signals.hsc\" #-}\n"
"sigKILL   = (9)   :: CInt\n"
"{-# LINE 128 \"Signals.hsc\" #-}\n"
"sigPIPE   = (13)   :: CInt\n"
"{-# LINE 129 \"Signals.hsc\" #-}\n"
"sigQUIT   = (3)   :: CInt\n"
"{-# LINE 130 \"Signals.hsc\" #-}\n"
"sigSEGV   = (11)   :: CInt\n"
"{-# LINE 131 \"Signals.hsc\" #-}\n"
"sigSTOP   = (19)   :: CInt\n"
"{-# LINE 132 \"Signals.hsc\" #-}\n"
"sigTERM   = (15)   :: CInt\n"
"{-# LINE 133 \"Signals.hsc\" #-}\n"
"sigTSTP   = (20)   :: CInt\n"
"{-# LINE 134 \"Signals.hsc\" #-}\n"
"sigTTIN   = (21)   :: CInt\n"
"{-# LINE 135 \"Signals.hsc\" #-}\n"
"sigTTOU   = (22)   :: CInt\n"
"{-# LINE 136 \"Signals.hsc\" #-}\n"
"sigUSR1   = (10)   :: CInt\n"
"{-# LINE 137 \"Signals.hsc\" #-}\n"
"sigUSR2   = (12)   :: CInt\n"
"{-# LINE 138 \"Signals.hsc\" #-}\n"
"\n"
"{-# LINE 139 \"Signals.hsc\" #-}\n"
"sigPOLL   = (29)   :: CInt\n"
"{-# LINE 140 \"Signals.hsc\" #-}\n"
"\n"
"{-# LINE 141 \"Signals.hsc\" #-}\n"
"sigPROF   = (27)   :: CInt\n"
"{-# LINE 142 \"Signals.hsc\" #-}\n"
"sigSYS    = (31)    :: CInt\n"
"{-# LINE 143 \"Signals.hsc\" #-}\n"
"sigTRAP   = (5)   :: CInt\n"
"{-# LINE 144 \"Signals.hsc\" #-}\n"
"sigURG    = (23)    :: CInt\n"
"{-# LINE 145 \"Signals.hsc\" #-}\n"
"sigVTALRM = (26) :: CInt\n"
"{-# LINE 146 \"Signals.hsc\" #-}\n"
"sigXCPU   = (24)   :: CInt\n"
"{-# LINE 147 \"Signals.hsc\" #-}\n"
"sigXFSZ   = (25)   :: CInt\n"
"{-# LINE 148 \"Signals.hsc\" #-}\n"
"\n"
"{-# LINE 180 \"Signals.hsc\" #-}\n"
"\n"
"internalAbort ::Signal\n"
"internalAbort = sigABRT\n"
"\n"
"realTimeAlarm :: Signal\n"
"realTimeAlarm = sigALRM\n"
"\n"
"busError :: Signal\n"
"busError = sigBUS\n"
"\n"
"processStatusChanged :: Signal\n"
"processStatusChanged = sigCHLD\n"
"\n"
"\n"
"{-# LINE 194 \"Signals.hsc\" #-}\n"
"continueProcess :: Signal\n"
"continueProcess = sigCONT\n"
"\n"
"{-# LINE 197 \"Signals.hsc\" #-}\n"
"\n"
"floatingPointException :: Signal\n"
"floatingPointException = sigFPE\n"
"\n"
"lostConnection :: Signal\n"
"lostConnection = sigHUP\n"
"\n"
"illegalInstruction :: Signal\n"
"illegalInstruction = sigILL\n"
"\n"
"keyboardSignal :: Signal\n"
"keyboardSignal = sigINT\n"
"\n"
"killProcess :: Signal\n"
"killProcess = sigKILL\n"
"\n"
"openEndedPipe :: Signal\n"
"openEndedPipe = sigPIPE\n"
"\n"
"keyboardTermination :: Signal\n"
"keyboardTermination = sigQUIT\n"
"\n"
"segmentationViolation :: Signal\n"
"segmentationViolation = sigSEGV\n"
"\n"
"softwareStop :: Signal\n"
"softwareStop = sigSTOP\n"
"\n"
"softwareTermination :: Signal\n"
"softwareTermination = sigTERM\n"
"\n"
"keyboardStop :: Signal\n"
"keyboardStop = sigTSTP\n"
"\n"
"backgroundRead :: Signal\n"
"backgroundRead = sigTTIN\n"
"\n"
"backgroundWrite :: Signal\n"
"backgroundWrite = sigTTOU\n"
"\n"
"userDefinedSignal1 :: Signal\n"
"userDefinedSignal1 = sigUSR1\n"
"\n"
"userDefinedSignal2 :: Signal\n"
"userDefinedSignal2 = sigUSR2\n"
"\n"
"\n"
"{-# LINE 244 \"Signals.hsc\" #-}\n"
"pollableEvent :: Signal\n"
"pollableEvent = sigPOLL\n"
"\n"
"{-# LINE 247 \"Signals.hsc\" #-}\n"
"\n"
"profilingTimerExpired :: Signal\n"
"profilingTimerExpired = sigPROF\n"
"\n"
"badSystemCall :: Signal\n"
"badSystemCall = sigSYS\n"
"\n"
"breakpointTrap :: Signal\n"
"breakpointTrap = sigTRAP\n"
"\n"
"urgentDataAvailable :: Signal\n"
"urgentDataAvailable = sigURG\n"
"\n"
"virtualTimerExpired :: Signal\n"
"virtualTimerExpired = sigVTALRM\n"
"\n"
"cpuTimeLimitExceeded :: Signal\n"
"cpuTimeLimitExceeded = sigXCPU\n"
"\n"
"fileSizeLimitExceeded :: Signal\n"
"fileSizeLimitExceeded = sigXFSZ\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Signal-related functions\n"
"\n"
"signalProcess :: Signal -> ProcessID -> IO ()\n"
"signalProcess sig pid \n"
" = throwErrnoIfMinus1_ \"signalProcess\" (c_kill (fromIntegral pid) sig)\n"
"\n"
"foreign import ccall unsafe \"Signals_inc.h kill\"\n"
"  c_kill :: CPid -> CInt -> IO CInt\n"
"\n"
"signalProcessGroup :: Signal -> ProcessGroupID -> IO ()\n"
"signalProcessGroup sig pgid \n"
"  = throwErrnoIfMinus1_ \"signalProcessGroup\" (c_killpg (fromIntegral pgid) sig)\n"
"\n"
"foreign import ccall unsafe \"Signals_inc.h killpg\"\n"
"  c_killpg :: CPid -> CInt -> IO CInt\n"
"\n"
"raiseSignal :: Signal -> IO ()\n"
"raiseSignal sig = throwErrnoIfMinus1_ \"raiseSignal\" (c_raise sig)\n"
"\n"
"foreign import ccall unsafe \"Signals_inc.h raise\"\n"
"  c_raise :: CInt -> IO CInt\n"
"\n"
"\n"
"{-# LINE 349 \"Signals.hsc\" #-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Alarms\n"
"\n"
"scheduleAlarm :: Int -> IO Int\n"
"scheduleAlarm secs = do\n"
"   r <- c_alarm (fromIntegral secs)\n"
"   return (fromIntegral r)\n"
"\n"
"foreign import ccall unsafe \"Signals_inc.h alarm\"\n"
"  c_alarm :: CUInt -> IO CUInt\n"
"\n"
"\n"
"{-# LINE 383 \"Signals.hsc\" #-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Manipulating signal sets\n"
"\n"
"newtype SignalSet = SignalSet (ForeignPtr CSigset)\n"
"\n"
"emptySignalSet :: SignalSet\n"
"emptySignalSet = unsafePerformIO $ do\n"
"  fp <- mallocForeignPtrBytes sizeof_sigset_t\n"
"  throwErrnoIfMinus1_ \"emptySignalSet\" (withForeignPtr fp $ c_sigemptyset)\n"
"  return (SignalSet fp)\n"
"\n"
"fullSignalSet :: SignalSet\n"
"fullSignalSet = unsafePerformIO $ do\n"
"  fp <- mallocForeignPtrBytes sizeof_sigset_t\n"
"  throwErrnoIfMinus1_ \"fullSignalSet\" (withForeignPtr fp $ c_sigfillset)\n"
"  return (SignalSet fp)\n"
"\n"
"infixr `addSignal`, `deleteSignal`\n"
"addSignal :: Signal -> SignalSet -> SignalSet\n"
"addSignal sig (SignalSet fp1) = unsafePerformIO $ do\n"
"  fp2 <- mallocForeignPtrBytes sizeof_sigset_t\n"
"  withForeignPtr fp1 $ \\p1 ->\n"
"    withForeignPtr fp2 $ \\p2 -> do\n"
"      copyBytes p2 p1 sizeof_sigset_t\n"
"      throwErrnoIfMinus1_ \"addSignal\" (c_sigaddset p2 sig)\n"
"  return (SignalSet fp2)\n"
"\n"
"deleteSignal :: Signal -> SignalSet -> SignalSet\n"
"deleteSignal sig (SignalSet fp1) = unsafePerformIO $ do\n"
"  fp2 <- mallocForeignPtrBytes sizeof_sigset_t\n"
"  withForeignPtr fp1 $ \\p1 ->\n"
"    withForeignPtr fp2 $ \\p2 -> do\n"
"      copyBytes p2 p1 sizeof_sigset_t\n"
"      throwErrnoIfMinus1_ \"deleteSignal\" (c_sigdelset p2 sig)\n"
"  return (SignalSet fp2)\n"
"\n"
"inSignalSet :: Signal -> SignalSet -> Bool\n"
"inSignalSet sig (SignalSet fp) = unsafePerformIO $\n"
"  withForeignPtr fp $ \\p -> do\n"
"    r <- throwErrnoIfMinus1 \"inSignalSet\" (c_sigismember p sig)\n"
"    return (r /= 0)\n"
"\n"
"getSignalMask :: IO SignalSet\n"
"getSignalMask = do\n"
"  fp <- mallocForeignPtrBytes sizeof_sigset_t\n"
"  withForeignPtr fp $ \\p ->\n"
"    throwErrnoIfMinus1_ \"getSignalMask\" (c_sigprocmask 0 nullPtr p)\n"
"  return (SignalSet fp)\n"
"   \n"
"sigProcMask :: String -> CInt -> SignalSet -> IO ()\n"
"sigProcMask fn how (SignalSet set) =\n"
"  withForeignPtr set $ \\p_set ->\n"
"    throwErrnoIfMinus1_ fn (c_sigprocmask how p_set nullPtr)\n"
"  \n"
"setSignalMask :: SignalSet -> IO ()\n"
"setSignalMask set = sigProcMask \"setSignalMask\" c_SIG_SETMASK set\n"
"\n"
"blockSignals :: SignalSet -> IO ()\n"
"blockSignals set = sigProcMask \"blockSignals\" c_SIG_BLOCK set\n"
"\n"
"unblockSignals :: SignalSet -> IO ()\n"
"unblockSignals set = sigProcMask \"unblockSignals\" c_SIG_UNBLOCK set\n"
"\n"
"getPendingSignals :: IO SignalSet\n"
"getPendingSignals = do\n"
"  fp <- mallocForeignPtrBytes sizeof_sigset_t\n"
"  withForeignPtr fp $ \\p -> \n"
"   throwErrnoIfMinus1_ \"getPendingSignals\" (c_sigpending p)\n"
"  return (SignalSet fp)\n"
"\n"
"\n"
"{-# LINE 455 \"Signals.hsc\" #-}\n"
"awaitSignal :: Maybe SignalSet -> IO ()\n"
"awaitSignal maybe_sigset = do\n"
"  fp <- case maybe_sigset of\n"
"    	  Nothing -> do SignalSet fp <- getSignalMask; return fp\n"
"    	  Just (SignalSet fp) -> return fp\n"
"  withForeignPtr fp $ \\p -> do\n"
"  c_sigsuspend p\n"
"  return ()\n"
"  -- ignore the return value; according to the docs it can only ever be\n"
"  -- (-1) with errno set to EINTR.\n"
" \n"
"foreign import ccall unsafe \"Signals_inc.h sigsuspend\"\n"
"  c_sigsuspend :: Ptr CSigset -> IO CInt\n"
"\n"
"{-# LINE 469 \"Signals.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 471 \"Signals.hsc\" #-}\n"
"foreign import ccall unsafe \"Signals_inc.h sigdelset\"\n"
"  c_sigdelset   :: Ptr CSigset -> CInt -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"Signals_inc.h sigfillset\"\n"
"  c_sigfillset  :: Ptr CSigset -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"Signals_inc.h sigismember\"\n"
"  c_sigismember :: Ptr CSigset -> CInt -> IO CInt\n"
"\n"
"{-# LINE 489 \"Signals.hsc\" #-}\n"
"\n"
"foreign import ccall unsafe \"Signals_inc.h sigpending\"\n"
"  c_sigpending :: Ptr CSigset -> IO CInt\n"
"\n"
"\n"
"{-# LINE 494 \"Signals.hsc\" #-}\n"
"c_SIG_BLOCK   = (0)   :: CInt\n"
"{-# LINE 495 \"Signals.hsc\" #-}\n"
"c_SIG_SETMASK = (2) :: CInt\n"
"{-# LINE 496 \"Signals.hsc\" #-}\n"
"c_SIG_UNBLOCK = (1) :: CInt\n"
"{-# LINE 497 \"Signals.hsc\" #-}\n"
"\n"
"{-# LINE 502 \"Signals.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 504 \"Signals.hsc\" #-}\n"
"\n";
const char *System_Posix_User = "{-# LINE 1 \"User.hsc\" #-}\n"
"{-# LINE 2 \"User.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.User\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX user\\/group support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.User (\n"
"    -- * User environment\n"
"    -- ** Querying the user environment\n"
"    getRealUserID,\n"
"    getRealGroupID,\n"
"    getEffectiveUserID,\n"
"    getEffectiveGroupID,\n"
"    getGroups,\n"
"    getLoginName,\n"
"    getEffectiveUserName,\n"
"\n"
"    -- *** The group database\n"
"    GroupEntry(..),\n"
"    getGroupEntryForID,\n"
"    getGroupEntryForName,\n"
"\n"
"    -- *** The user database\n"
"    UserEntry(..),\n"
"    getUserEntryForID,\n"
"    getUserEntryForName,\n"
"\n"
"    -- ** Modifying the user environment\n"
"    setUserID,\n"
"    setGroupID,\n"
"\n"
"  ) where\n"
"\n"
"\n"
"{-# LINE 44 \"User.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 49 \"User.hsc\" #-}\n"
"\n"
"import System.Posix.Types\n"
"import Foreign\n"
"import Foreign.C\n"
"import System.Posix.Internals	( CGroup, CPasswd )\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- user environemnt\n"
"\n"
"getRealUserID :: IO UserID\n"
"getRealUserID = c_getuid\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h getuid\"\n"
"  c_getuid :: IO CUid\n"
"\n"
"getRealGroupID :: IO GroupID\n"
"getRealGroupID = c_getgid\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h getgid\"\n"
"  c_getgid :: IO CGid\n"
"\n"
"getEffectiveUserID :: IO UserID\n"
"getEffectiveUserID = c_geteuid\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h geteuid\"\n"
"  c_geteuid :: IO CUid\n"
"\n"
"getEffectiveGroupID :: IO GroupID\n"
"getEffectiveGroupID = c_getegid\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h getegid\"\n"
"  c_getegid :: IO CGid\n"
"\n"
"getGroups :: IO [GroupID]\n"
"getGroups = do\n"
"    ngroups <- c_getgroups 0 nullPtr\n"
"    allocaArray (fromIntegral ngroups) $ \\arr -> do\n"
"       throwErrnoIfMinus1_ \"getGroups\" (c_getgroups ngroups arr)\n"
"       groups <- peekArray (fromIntegral ngroups) arr\n"
"       return groups\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h getgroups\"\n"
"  c_getgroups :: CInt -> Ptr CGid -> IO CInt\n"
"\n"
"-- ToDo: use getlogin_r\n"
"getLoginName :: IO String\n"
"getLoginName =  do\n"
"    str <- throwErrnoIfNull \"getLoginName\" c_getlogin\n"
"    peekCString str\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h getlogin\"\n"
"  c_getlogin :: IO CString\n"
"\n"
"setUserID :: UserID -> IO ()\n"
"setUserID uid = throwErrnoIfMinus1_ \"setUserID\" (c_setuid uid)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h setuid\"\n"
"  c_setuid :: CUid -> IO CInt\n"
"\n"
"setGroupID :: GroupID -> IO ()\n"
"setGroupID gid = throwErrnoIfMinus1_ \"setGroupID\" (c_setgid gid)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h setgid\"\n"
"  c_setgid :: CGid -> IO CInt\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- User names\n"
"\n"
"getEffectiveUserName :: IO String\n"
"getEffectiveUserName = do\n"
"    euid <- getEffectiveUserID\n"
"    pw <- getUserEntryForID euid\n"
"    return (userName pw)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- The group database (grp.h)\n"
"\n"
"data GroupEntry =\n"
" GroupEntry {\n"
"  groupName    :: String,\n"
"  groupID      :: GroupID,\n"
"  groupMembers :: [String]\n"
" }\n"
"\n"
"getGroupEntryForID :: GroupID -> IO GroupEntry\n"
"\n"
"{-# LINE 148 \"User.hsc\" #-}\n"
"getGroupEntryForID = error \"System.Posix.User.getGroupEntryForID: not supported\"\n"
"\n"
"{-# LINE 150 \"User.hsc\" #-}\n"
"\n"
"\n"
"getGroupEntryForName :: String -> IO GroupEntry\n"
"\n"
"{-# LINE 167 \"User.hsc\" #-}\n"
"getGroupEntryForName = error \"System.Posix.User.getGroupEntryForName: not supported\"\n"
"\n"
"{-# LINE 169 \"User.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 179 \"User.hsc\" #-}\n"
"\n"
"unpackGroupEntry :: Ptr CGroup -> IO GroupEntry\n"
"unpackGroupEntry ptr = do\n"
"   name    <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0)) ptr >>= peekCString\n"
"{-# LINE 183 \"User.hsc\" #-}\n"
"   gid     <- ((\\hsc_ptr -> peekByteOff hsc_ptr 16)) ptr\n"
"{-# LINE 184 \"User.hsc\" #-}\n"
"   mem     <- ((\\hsc_ptr -> peekByteOff hsc_ptr 24)) ptr\n"
"{-# LINE 185 \"User.hsc\" #-}\n"
"   members <- peekArray0 nullPtr mem >>= mapM peekCString\n"
"   return (GroupEntry name gid members)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- The user database (pwd.h)\n"
"\n"
"data UserEntry =\n"
" UserEntry {\n"
"   userName      :: String,\n"
"   userID        :: UserID,\n"
"   userGroupID   :: GroupID,\n"
"   homeDirectory :: String,\n"
"   userShell     :: String\n"
" }\n"
"\n"
"getUserEntryForID :: UserID -> IO UserEntry\n"
"\n"
"{-# LINE 214 \"User.hsc\" #-}\n"
"getUserEntryForID = error \"System.Posix.User.getUserEntryForID: not supported\"\n"
"\n"
"{-# LINE 216 \"User.hsc\" #-}\n"
"\n"
"getUserEntryForName :: String -> IO UserEntry\n"
"\n"
"{-# LINE 232 \"User.hsc\" #-}\n"
"getUserEntryForName = error \"System.Posix.User.getUserEntryForName: not supported\"\n"
"\n"
"{-# LINE 234 \"User.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 244 \"User.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 249 \"User.hsc\" #-}\n"
"\n"
"unpackUserEntry :: Ptr CPasswd -> IO UserEntry\n"
"unpackUserEntry ptr = do\n"
"   name   <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0))  ptr >>= peekCString\n"
"{-# LINE 253 \"User.hsc\" #-}\n"
"   uid    <- ((\\hsc_ptr -> peekByteOff hsc_ptr 16))   ptr\n"
"{-# LINE 254 \"User.hsc\" #-}\n"
"   gid    <- ((\\hsc_ptr -> peekByteOff hsc_ptr 20))   ptr\n"
"{-# LINE 255 \"User.hsc\" #-}\n"
"   dir    <- ((\\hsc_ptr -> peekByteOff hsc_ptr 32))   ptr >>= peekCString\n"
"{-# LINE 256 \"User.hsc\" #-}\n"
"   shell  <- ((\\hsc_ptr -> peekByteOff hsc_ptr 40)) ptr >>= peekCString\n"
"{-# LINE 257 \"User.hsc\" #-}\n"
"   return (UserEntry name uid gid dir shell)\n"
"\n"
"-- Used when calling re-entrant system calls that signal their 'errno' \n"
"-- directly through the return value.\n"
"throwErrorIfNonZero_ :: String -> IO CInt -> IO ()\n"
"throwErrorIfNonZero_ loc act = do\n"
"    rc <- act\n"
"    if (rc == 0) \n"
"     then return ()\n"
"     else ioError (errnoToIOError loc (Errno (fromIntegral rc)) Nothing Nothing)\n"
"\n";
const char *System_Posix_Temp = "{-# LINE 1 \"Temp.hsc\" #-}\n"
"{-# LINE 2 \"Temp.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.Temp\n"
"-- Copyright   :  (c) Volker Stolz <vs@foldr.org>\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  vs@foldr.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX environment support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.Temp (\n"
"\n"
"	mkstemp\n"
"\n"
"{- Not ported (yet?):\n"
"	tmpfile: can we handle FILE*?\n"
"	tmpnam: ISO C, should go in base?\n"
"	tempname: dito\n"
"-}\n"
"\n"
") where\n"
"\n"
"\n"
"{-# LINE 29 \"Temp.hsc\" #-}\n"
"\n"
"import System.IO\n"
"import System.Posix.IO\n"
"import System.Posix.Types\n"
"import Foreign.C\n"
"\n"
"-- |'mkstemp' - make a unique filename and open it for\n"
"-- reading\\/writing (only safe on GHC & Hugs)\n"
"\n"
"mkstemp :: String -> IO (String, Handle)\n"
"mkstemp template = do\n"
"\n"
"{-# LINE 41 \"Temp.hsc\" #-}\n"
"  withCString template $ \\ ptr -> do\n"
"    fd <- throwErrnoIfMinus1 \"mkstemp\" (c_mkstemp ptr)\n"
"    name <- peekCString ptr\n"
"    h <- fdToHandle fd\n"
"    return (name, h)\n"
"\n"
"{-# LINE 63 \"Temp.hsc\" #-}\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h mkstemp\"\n"
"  c_mkstemp :: CString -> IO Fd\n"
"\n";
const char *System_Posix_Terminal = "{-# LINE 1 \"Terminal.hsc\" #-}\n"
"{-# LINE 2 \"Terminal.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.Terminal\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX Terminal support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.Terminal (\n"
"  -- * Terminal support\n"
"\n"
"  -- ** Terminal attributes\n"
"  TerminalAttributes,\n"
"  getTerminalAttributes,\n"
"  TerminalState(..),\n"
"  setTerminalAttributes,\n"
"\n"
"  TerminalMode(..),\n"
"  withoutMode,\n"
"  withMode,\n"
"  terminalMode,\n"
"  bitsPerByte,\n"
"  withBits,\n"
"\n"
"  ControlCharacter(..),\n"
"  controlChar,\n"
"  withCC,\n"
"  withoutCC,\n"
"\n"
"  inputTime,\n"
"  withTime,\n"
"  minInput,\n"
"  withMinInput,\n"
"\n"
"  BaudRate(..),\n"
"  inputSpeed,\n"
"  withInputSpeed,\n"
"  outputSpeed,\n"
"  withOutputSpeed,\n"
"\n"
"  -- ** Terminal operations\n"
"  sendBreak,\n"
"  drainOutput,\n"
"  QueueSelector(..),\n"
"  discardData,\n"
"  FlowAction(..),\n"
"  controlFlow,\n"
"\n"
"  -- ** Process groups\n"
"  getTerminalProcessGroupID,\n"
"  setTerminalProcessGroupID,\n"
"\n"
"  -- ** Testing a file descriptor\n"
"  queryTerminal,\n"
"  getTerminalName,\n"
"  getControllingTerminalName\n"
"\n"
"  ) where\n"
"\n"
"\n"
"{-# LINE 68 \"Terminal.hsc\" #-}\n"
"\n"
"import Data.Bits\n"
"import Data.Char\n"
"import Foreign.C.Error ( throwErrnoIfMinus1, throwErrnoIfMinus1_, throwErrnoIfNull )\n"
"import Foreign.C.String ( CString, peekCString )\n"
"import Foreign.C.Types ( CInt )\n"
"import Foreign.ForeignPtr ( ForeignPtr, withForeignPtr, mallocForeignPtrBytes )\n"
"import Foreign.Marshal.Utils ( copyBytes )\n"
"import Foreign.Ptr ( Ptr, nullPtr, plusPtr )\n"
"import Foreign.Storable ( Storable(..) )\n"
"import System.IO.Unsafe ( unsafePerformIO )\n"
"import System.Posix.Types\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Terminal attributes\n"
"\n"
"type CTermios = ()\n"
"newtype TerminalAttributes = TerminalAttributes (ForeignPtr CTermios)\n"
"\n"
"makeTerminalAttributes :: ForeignPtr CTermios -> TerminalAttributes\n"
"makeTerminalAttributes = TerminalAttributes\n"
"\n"
"withTerminalAttributes :: TerminalAttributes -> (Ptr CTermios -> IO a) -> IO a\n"
"withTerminalAttributes (TerminalAttributes termios) = withForeignPtr termios\n"
"\n"
"\n"
"data TerminalMode\n"
"	-- input flags\n"
"   = InterruptOnBreak		-- BRKINT\n"
"   | MapCRtoLF			-- ICRNL\n"
"   | IgnoreBreak		-- IGNBRK\n"
"   | IgnoreCR			-- IGNCR\n"
"   | IgnoreParityErrors		-- IGNPAR\n"
"   | MapLFtoCR			-- INLCR\n"
"   | CheckParity		-- INPCK\n"
"   | StripHighBit		-- ISTRIP\n"
"   | StartStopInput		-- IXOFF\n"
"   | StartStopOutput		-- IXON\n"
"   | MarkParityErrors		-- PARMRK\n"
"\n"
"	-- output flags\n"
"   | ProcessOutput		-- OPOST\n"
"	-- ToDo: ONLCR, OCRNL, ONOCR, ONLRET, OFILL,\n"
"	--       NLDLY(NL0,NL1), CRDLY(CR0,CR1,CR2,CR2)\n"
"	--	 TABDLY(TAB0,TAB1,TAB2,TAB3)\n"
"	--	 BSDLY(BS0,BS1), VTDLY(VT0,VT1), FFDLY(FF0,FF1)\n"
"\n"
"	-- control flags\n"
"   | LocalMode			-- CLOCAL\n"
"   | ReadEnable			-- CREAD\n"
"   | TwoStopBits		-- CSTOPB\n"
"   | HangupOnClose		-- HUPCL\n"
"   | EnableParity		-- PARENB\n"
"   | OddParity			-- PARODD\n"
"\n"
"	-- local modes\n"
"   | EnableEcho			-- ECHO\n"
"   | EchoErase			-- ECHOE\n"
"   | EchoKill			-- ECHOK\n"
"   | EchoLF			-- ECHONL\n"
"   | ProcessInput		-- ICANON\n"
"   | ExtendedFunctions		-- IEXTEN\n"
"   | KeyboardInterrupts		-- ISIG\n"
"   | NoFlushOnInterrupt		-- NOFLSH\n"
"   | BackgroundWriteInterrupt	-- TOSTOP\n"
"\n"
"withoutMode :: TerminalAttributes -> TerminalMode -> TerminalAttributes\n"
"withoutMode termios InterruptOnBreak = clearInputFlag (2) termios\n"
"{-# LINE 136 \"Terminal.hsc\" #-}\n"
"withoutMode termios MapCRtoLF = clearInputFlag (256) termios\n"
"{-# LINE 137 \"Terminal.hsc\" #-}\n"
"withoutMode termios IgnoreBreak = clearInputFlag (1) termios\n"
"{-# LINE 138 \"Terminal.hsc\" #-}\n"
"withoutMode termios IgnoreCR = clearInputFlag (128) termios\n"
"{-# LINE 139 \"Terminal.hsc\" #-}\n"
"withoutMode termios IgnoreParityErrors = clearInputFlag (4) termios\n"
"{-# LINE 140 \"Terminal.hsc\" #-}\n"
"withoutMode termios MapLFtoCR = clearInputFlag (64) termios\n"
"{-# LINE 141 \"Terminal.hsc\" #-}\n"
"withoutMode termios CheckParity = clearInputFlag (16) termios\n"
"{-# LINE 142 \"Terminal.hsc\" #-}\n"
"withoutMode termios StripHighBit = clearInputFlag (32) termios\n"
"{-# LINE 143 \"Terminal.hsc\" #-}\n"
"withoutMode termios StartStopInput = clearInputFlag (4096) termios\n"
"{-# LINE 144 \"Terminal.hsc\" #-}\n"
"withoutMode termios StartStopOutput = clearInputFlag (1024) termios\n"
"{-# LINE 145 \"Terminal.hsc\" #-}\n"
"withoutMode termios MarkParityErrors = clearInputFlag (8) termios\n"
"{-# LINE 146 \"Terminal.hsc\" #-}\n"
"withoutMode termios ProcessOutput = clearOutputFlag (1) termios\n"
"{-# LINE 147 \"Terminal.hsc\" #-}\n"
"withoutMode termios LocalMode = clearControlFlag (2048) termios\n"
"{-# LINE 148 \"Terminal.hsc\" #-}\n"
"withoutMode termios ReadEnable = clearControlFlag (128) termios\n"
"{-# LINE 149 \"Terminal.hsc\" #-}\n"
"withoutMode termios TwoStopBits = clearControlFlag (64) termios\n"
"{-# LINE 150 \"Terminal.hsc\" #-}\n"
"withoutMode termios HangupOnClose = clearControlFlag (1024) termios\n"
"{-# LINE 151 \"Terminal.hsc\" #-}\n"
"withoutMode termios EnableParity = clearControlFlag (256) termios\n"
"{-# LINE 152 \"Terminal.hsc\" #-}\n"
"withoutMode termios OddParity = clearControlFlag (512) termios\n"
"{-# LINE 153 \"Terminal.hsc\" #-}\n"
"withoutMode termios EnableEcho = clearLocalFlag (8) termios\n"
"{-# LINE 154 \"Terminal.hsc\" #-}\n"
"withoutMode termios EchoErase = clearLocalFlag (16) termios\n"
"{-# LINE 155 \"Terminal.hsc\" #-}\n"
"withoutMode termios EchoKill = clearLocalFlag (32) termios\n"
"{-# LINE 156 \"Terminal.hsc\" #-}\n"
"withoutMode termios EchoLF = clearLocalFlag (64) termios\n"
"{-# LINE 157 \"Terminal.hsc\" #-}\n"
"withoutMode termios ProcessInput = clearLocalFlag (2) termios\n"
"{-# LINE 158 \"Terminal.hsc\" #-}\n"
"withoutMode termios ExtendedFunctions = clearLocalFlag (32768) termios\n"
"{-# LINE 159 \"Terminal.hsc\" #-}\n"
"withoutMode termios KeyboardInterrupts = clearLocalFlag (1) termios\n"
"{-# LINE 160 \"Terminal.hsc\" #-}\n"
"withoutMode termios NoFlushOnInterrupt = setLocalFlag (128) termios\n"
"{-# LINE 161 \"Terminal.hsc\" #-}\n"
"withoutMode termios BackgroundWriteInterrupt = clearLocalFlag (256) termios\n"
"{-# LINE 162 \"Terminal.hsc\" #-}\n"
"\n"
"withMode :: TerminalAttributes -> TerminalMode -> TerminalAttributes\n"
"withMode termios InterruptOnBreak = setInputFlag (2) termios\n"
"{-# LINE 165 \"Terminal.hsc\" #-}\n"
"withMode termios MapCRtoLF = setInputFlag (256) termios\n"
"{-# LINE 166 \"Terminal.hsc\" #-}\n"
"withMode termios IgnoreBreak = setInputFlag (1) termios\n"
"{-# LINE 167 \"Terminal.hsc\" #-}\n"
"withMode termios IgnoreCR = setInputFlag (128) termios\n"
"{-# LINE 168 \"Terminal.hsc\" #-}\n"
"withMode termios IgnoreParityErrors = setInputFlag (4) termios\n"
"{-# LINE 169 \"Terminal.hsc\" #-}\n"
"withMode termios MapLFtoCR = setInputFlag (64) termios\n"
"{-# LINE 170 \"Terminal.hsc\" #-}\n"
"withMode termios CheckParity = setInputFlag (16) termios\n"
"{-# LINE 171 \"Terminal.hsc\" #-}\n"
"withMode termios StripHighBit = setInputFlag (32) termios\n"
"{-# LINE 172 \"Terminal.hsc\" #-}\n"
"withMode termios StartStopInput = setInputFlag (4096) termios\n"
"{-# LINE 173 \"Terminal.hsc\" #-}\n"
"withMode termios StartStopOutput = setInputFlag (1024) termios\n"
"{-# LINE 174 \"Terminal.hsc\" #-}\n"
"withMode termios MarkParityErrors = setInputFlag (8) termios\n"
"{-# LINE 175 \"Terminal.hsc\" #-}\n"
"withMode termios ProcessOutput = setOutputFlag (1) termios\n"
"{-# LINE 176 \"Terminal.hsc\" #-}\n"
"withMode termios LocalMode = setControlFlag (2048) termios\n"
"{-# LINE 177 \"Terminal.hsc\" #-}\n"
"withMode termios ReadEnable = setControlFlag (128) termios\n"
"{-# LINE 178 \"Terminal.hsc\" #-}\n"
"withMode termios TwoStopBits = setControlFlag (64) termios\n"
"{-# LINE 179 \"Terminal.hsc\" #-}\n"
"withMode termios HangupOnClose = setControlFlag (1024) termios\n"
"{-# LINE 180 \"Terminal.hsc\" #-}\n"
"withMode termios EnableParity = setControlFlag (256) termios\n"
"{-# LINE 181 \"Terminal.hsc\" #-}\n"
"withMode termios OddParity = setControlFlag (512) termios\n"
"{-# LINE 182 \"Terminal.hsc\" #-}\n"
"withMode termios EnableEcho = setLocalFlag (8) termios\n"
"{-# LINE 183 \"Terminal.hsc\" #-}\n"
"withMode termios EchoErase = setLocalFlag (16) termios\n"
"{-# LINE 184 \"Terminal.hsc\" #-}\n"
"withMode termios EchoKill = setLocalFlag (32) termios\n"
"{-# LINE 185 \"Terminal.hsc\" #-}\n"
"withMode termios EchoLF = setLocalFlag (64) termios\n"
"{-# LINE 186 \"Terminal.hsc\" #-}\n"
"withMode termios ProcessInput = setLocalFlag (2) termios\n"
"{-# LINE 187 \"Terminal.hsc\" #-}\n"
"withMode termios ExtendedFunctions = setLocalFlag (32768) termios\n"
"{-# LINE 188 \"Terminal.hsc\" #-}\n"
"withMode termios KeyboardInterrupts = setLocalFlag (1) termios\n"
"{-# LINE 189 \"Terminal.hsc\" #-}\n"
"withMode termios NoFlushOnInterrupt = clearLocalFlag (128) termios\n"
"{-# LINE 190 \"Terminal.hsc\" #-}\n"
"withMode termios BackgroundWriteInterrupt = setLocalFlag (256) termios\n"
"{-# LINE 191 \"Terminal.hsc\" #-}\n"
"\n"
"terminalMode :: TerminalMode -> TerminalAttributes -> Bool\n"
"terminalMode InterruptOnBreak = testInputFlag (2)\n"
"{-# LINE 194 \"Terminal.hsc\" #-}\n"
"terminalMode MapCRtoLF = testInputFlag (256)\n"
"{-# LINE 195 \"Terminal.hsc\" #-}\n"
"terminalMode IgnoreBreak = testInputFlag (1)\n"
"{-# LINE 196 \"Terminal.hsc\" #-}\n"
"terminalMode IgnoreCR = testInputFlag (128)\n"
"{-# LINE 197 \"Terminal.hsc\" #-}\n"
"terminalMode IgnoreParityErrors = testInputFlag (4)\n"
"{-# LINE 198 \"Terminal.hsc\" #-}\n"
"terminalMode MapLFtoCR = testInputFlag (64)\n"
"{-# LINE 199 \"Terminal.hsc\" #-}\n"
"terminalMode CheckParity = testInputFlag (16)\n"
"{-# LINE 200 \"Terminal.hsc\" #-}\n"
"terminalMode StripHighBit = testInputFlag (32)\n"
"{-# LINE 201 \"Terminal.hsc\" #-}\n"
"terminalMode StartStopInput = testInputFlag (4096)\n"
"{-# LINE 202 \"Terminal.hsc\" #-}\n"
"terminalMode StartStopOutput = testInputFlag (1024)\n"
"{-# LINE 203 \"Terminal.hsc\" #-}\n"
"terminalMode MarkParityErrors = testInputFlag (8)\n"
"{-# LINE 204 \"Terminal.hsc\" #-}\n"
"terminalMode ProcessOutput = testOutputFlag (1)\n"
"{-# LINE 205 \"Terminal.hsc\" #-}\n"
"terminalMode LocalMode = testControlFlag (2048)\n"
"{-# LINE 206 \"Terminal.hsc\" #-}\n"
"terminalMode ReadEnable = testControlFlag (128)\n"
"{-# LINE 207 \"Terminal.hsc\" #-}\n"
"terminalMode TwoStopBits = testControlFlag (64)\n"
"{-# LINE 208 \"Terminal.hsc\" #-}\n"
"terminalMode HangupOnClose = testControlFlag (1024)\n"
"{-# LINE 209 \"Terminal.hsc\" #-}\n"
"terminalMode EnableParity = testControlFlag (256)\n"
"{-# LINE 210 \"Terminal.hsc\" #-}\n"
"terminalMode OddParity = testControlFlag (512)\n"
"{-# LINE 211 \"Terminal.hsc\" #-}\n"
"terminalMode EnableEcho = testLocalFlag (8)\n"
"{-# LINE 212 \"Terminal.hsc\" #-}\n"
"terminalMode EchoErase = testLocalFlag (16)\n"
"{-# LINE 213 \"Terminal.hsc\" #-}\n"
"terminalMode EchoKill = testLocalFlag (32)\n"
"{-# LINE 214 \"Terminal.hsc\" #-}\n"
"terminalMode EchoLF = testLocalFlag (64)\n"
"{-# LINE 215 \"Terminal.hsc\" #-}\n"
"terminalMode ProcessInput = testLocalFlag (2)\n"
"{-# LINE 216 \"Terminal.hsc\" #-}\n"
"terminalMode ExtendedFunctions = testLocalFlag (32768)\n"
"{-# LINE 217 \"Terminal.hsc\" #-}\n"
"terminalMode KeyboardInterrupts = testLocalFlag (1)\n"
"{-# LINE 218 \"Terminal.hsc\" #-}\n"
"terminalMode NoFlushOnInterrupt = not . testLocalFlag (128)\n"
"{-# LINE 219 \"Terminal.hsc\" #-}\n"
"terminalMode BackgroundWriteInterrupt = testLocalFlag (256)\n"
"{-# LINE 220 \"Terminal.hsc\" #-}\n"
"\n"
"bitsPerByte :: TerminalAttributes -> Int\n"
"bitsPerByte termios = unsafePerformIO $ do\n"
"  withTerminalAttributes termios $ \\p -> do\n"
"    cflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 8)) p\n"
"{-# LINE 225 \"Terminal.hsc\" #-}\n"
"    return $! (word2Bits (cflag .&. (48)))\n"
"{-# LINE 226 \"Terminal.hsc\" #-}\n"
"  where\n"
"    word2Bits :: CTcflag -> Int\n"
"    word2Bits x =\n"
"	if x == (0) then 5\n"
"{-# LINE 230 \"Terminal.hsc\" #-}\n"
"	else if x == (16) then 6\n"
"{-# LINE 231 \"Terminal.hsc\" #-}\n"
"	else if x == (32) then 7\n"
"{-# LINE 232 \"Terminal.hsc\" #-}\n"
"	else if x == (48) then 8\n"
"{-# LINE 233 \"Terminal.hsc\" #-}\n"
"	else 0\n"
"\n"
"withBits :: TerminalAttributes -> Int -> TerminalAttributes\n"
"withBits termios bits = unsafePerformIO $ do\n"
"  withNewTermios termios $ \\p -> do\n"
"    cflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 8)) p\n"
"{-# LINE 239 \"Terminal.hsc\" #-}\n"
"    ((\\hsc_ptr -> pokeByteOff hsc_ptr 8)) p\n"
"{-# LINE 240 \"Terminal.hsc\" #-}\n"
"       ((cflag .&. complement (48)) .|. mask bits)\n"
"{-# LINE 241 \"Terminal.hsc\" #-}\n"
"  where\n"
"    mask :: Int -> CTcflag\n"
"    mask 5 = (0)\n"
"{-# LINE 244 \"Terminal.hsc\" #-}\n"
"    mask 6 = (16)\n"
"{-# LINE 245 \"Terminal.hsc\" #-}\n"
"    mask 7 = (32)\n"
"{-# LINE 246 \"Terminal.hsc\" #-}\n"
"    mask 8 = (48)\n"
"{-# LINE 247 \"Terminal.hsc\" #-}\n"
"    mask _ = error \"withBits bit value out of range [5..8]\"\n"
"\n"
"data ControlCharacter\n"
"  = EndOfFile		-- VEOF\n"
"  | EndOfLine		-- VEOL\n"
"  | Erase		-- VERASE\n"
"  | Interrupt		-- VINTR\n"
"  | Kill		-- VKILL\n"
"  | Quit		-- VQUIT\n"
"  | Start		-- VSTART\n"
"  | Stop		-- VSTOP\n"
"  | Suspend		-- VSUSP\n"
"\n"
"controlChar :: TerminalAttributes -> ControlCharacter -> Maybe Char\n"
"controlChar termios cc = unsafePerformIO $ do\n"
"  withTerminalAttributes termios $ \\p -> do\n"
"    let c_cc = ((\\hsc_ptr -> hsc_ptr `plusPtr` 17)) p\n"
"{-# LINE 264 \"Terminal.hsc\" #-}\n"
"    val <- peekElemOff c_cc (cc2Word cc)\n"
"    if val == ((0)::CCc)\n"
"{-# LINE 266 \"Terminal.hsc\" #-}\n"
"       then return Nothing\n"
"       else return (Just (chr (fromEnum val)))\n"
"  \n"
"withCC :: TerminalAttributes\n"
"       -> (ControlCharacter, Char)\n"
"       -> TerminalAttributes\n"
"withCC termios (cc, c) = unsafePerformIO $ do\n"
"  withNewTermios termios $ \\p -> do\n"
"    let c_cc = ((\\hsc_ptr -> hsc_ptr `plusPtr` 17)) p\n"
"{-# LINE 275 \"Terminal.hsc\" #-}\n"
"    pokeElemOff c_cc (cc2Word cc) (fromIntegral (ord c) :: CCc)\n"
"\n"
"withoutCC :: TerminalAttributes\n"
"          -> ControlCharacter\n"
"          -> TerminalAttributes\n"
"withoutCC termios cc = unsafePerformIO $ do\n"
"  withNewTermios termios $ \\p -> do\n"
"    let c_cc = ((\\hsc_ptr -> hsc_ptr `plusPtr` 17)) p\n"
"{-# LINE 283 \"Terminal.hsc\" #-}\n"
"    pokeElemOff c_cc (cc2Word cc) ((0) :: CCc)\n"
"{-# LINE 284 \"Terminal.hsc\" #-}\n"
"\n"
"inputTime :: TerminalAttributes -> Int\n"
"inputTime termios = unsafePerformIO $ do\n"
"  withTerminalAttributes termios $ \\p -> do\n"
"    c <- peekElemOff (((\\hsc_ptr -> hsc_ptr `plusPtr` 17)) p) (5)\n"
"{-# LINE 289 \"Terminal.hsc\" #-}\n"
"    return (fromEnum (c :: CCc))\n"
"\n"
"withTime :: TerminalAttributes -> Int -> TerminalAttributes\n"
"withTime termios time = unsafePerformIO $ do\n"
"  withNewTermios termios $ \\p -> do\n"
"    let c_cc = ((\\hsc_ptr -> hsc_ptr `plusPtr` 17)) p\n"
"{-# LINE 295 \"Terminal.hsc\" #-}\n"
"    pokeElemOff c_cc (5) (fromIntegral time :: CCc)\n"
"{-# LINE 296 \"Terminal.hsc\" #-}\n"
"\n"
"minInput :: TerminalAttributes -> Int\n"
"minInput termios = unsafePerformIO $ do\n"
"  withTerminalAttributes termios $ \\p -> do\n"
"    c <- peekElemOff (((\\hsc_ptr -> hsc_ptr `plusPtr` 17)) p) (6)\n"
"{-# LINE 301 \"Terminal.hsc\" #-}\n"
"    return (fromEnum (c :: CCc))\n"
"\n"
"withMinInput :: TerminalAttributes -> Int -> TerminalAttributes\n"
"withMinInput termios count = unsafePerformIO $ do\n"
"  withNewTermios termios $ \\p -> do\n"
"    let c_cc = ((\\hsc_ptr -> hsc_ptr `plusPtr` 17)) p\n"
"{-# LINE 307 \"Terminal.hsc\" #-}\n"
"    pokeElemOff c_cc (6) (fromIntegral count :: CCc)\n"
"{-# LINE 308 \"Terminal.hsc\" #-}\n"
"\n"
"data BaudRate\n"
"  = B0\n"
"  | B50\n"
"  | B75\n"
"  | B110\n"
"  | B134\n"
"  | B150\n"
"  | B200\n"
"  | B300\n"
"  | B600\n"
"  | B1200\n"
"  | B1800\n"
"  | B2400\n"
"  | B4800\n"
"  | B9600\n"
"  | B19200\n"
"  | B38400\n"
"\n"
"inputSpeed :: TerminalAttributes -> BaudRate\n"
"inputSpeed termios = unsafePerformIO $ do\n"
"  withTerminalAttributes termios $ \\p -> do\n"
"    w <- c_cfgetispeed p\n"
"    return (word2Baud w)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h cfgetispeed\"\n"
"  c_cfgetispeed :: Ptr CTermios -> IO CSpeed\n"
"\n"
"withInputSpeed :: TerminalAttributes -> BaudRate -> TerminalAttributes\n"
"withInputSpeed termios br = unsafePerformIO $ do\n"
"  withNewTermios termios $ \\p -> c_cfsetispeed p (baud2Word br)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h cfsetispeed\"\n"
"  c_cfsetispeed :: Ptr CTermios -> CSpeed -> IO CInt\n"
"\n"
"\n"
"outputSpeed :: TerminalAttributes -> BaudRate\n"
"outputSpeed termios = unsafePerformIO $ do\n"
"  withTerminalAttributes termios $ \\p ->  do\n"
"    w <- c_cfgetospeed p\n"
"    return (word2Baud w)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h cfgetospeed\"\n"
"  c_cfgetospeed :: Ptr CTermios -> IO CSpeed\n"
"\n"
"withOutputSpeed :: TerminalAttributes -> BaudRate -> TerminalAttributes\n"
"withOutputSpeed termios br = unsafePerformIO $ do\n"
"  withNewTermios termios $ \\p -> c_cfsetospeed p (baud2Word br)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h cfsetospeed\"\n"
"  c_cfsetospeed :: Ptr CTermios -> CSpeed -> IO CInt\n"
"\n"
"\n"
"getTerminalAttributes :: Fd -> IO TerminalAttributes\n"
"getTerminalAttributes fd = do\n"
"  fp <- mallocForeignPtrBytes (60)\n"
"{-# LINE 364 \"Terminal.hsc\" #-}\n"
"  withForeignPtr fp $ \\p ->\n"
"      throwErrnoIfMinus1_ \"getTerminalAttributes\" (c_tcgetattr fd p)\n"
"  return $ makeTerminalAttributes fp\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h tcgetattr\"\n"
"  c_tcgetattr :: Fd -> Ptr CTermios -> IO CInt\n"
"\n"
"data TerminalState\n"
"  = Immediately\n"
"  | WhenDrained\n"
"  | WhenFlushed\n"
"\n"
"setTerminalAttributes :: Fd\n"
"                      -> TerminalAttributes\n"
"                      -> TerminalState\n"
"                      -> IO ()\n"
"setTerminalAttributes fd termios state = do\n"
"  withTerminalAttributes termios $ \\p ->\n"
"    throwErrnoIfMinus1_ \"setTerminalAttributes\"\n"
"      (c_tcsetattr fd (state2Int state) p)\n"
"  where\n"
"    state2Int :: TerminalState -> CInt\n"
"    state2Int Immediately = (0)\n"
"{-# LINE 387 \"Terminal.hsc\" #-}\n"
"    state2Int WhenDrained = (1)\n"
"{-# LINE 388 \"Terminal.hsc\" #-}\n"
"    state2Int WhenFlushed = (2)\n"
"{-# LINE 389 \"Terminal.hsc\" #-}\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h tcsetattr\"\n"
"   c_tcsetattr :: Fd -> CInt -> Ptr CTermios -> IO CInt\n"
"\n"
"\n"
"sendBreak :: Fd -> Int -> IO ()\n"
"sendBreak fd duration\n"
"  = throwErrnoIfMinus1_ \"sendBreak\" (c_tcsendbreak fd (fromIntegral duration))\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h tcsendbreak\"\n"
"  c_tcsendbreak :: Fd -> CInt -> IO CInt\n"
"\n"
"drainOutput :: Fd -> IO ()\n"
"drainOutput fd = throwErrnoIfMinus1_ \"drainOutput\" (c_tcdrain fd)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h tcdrain\"\n"
"  c_tcdrain :: Fd -> IO CInt\n"
"\n"
"\n"
"data QueueSelector\n"
"  = InputQueue		-- TCIFLUSH\n"
"  | OutputQueue		-- TCOFLUSH\n"
"  | BothQueues		-- TCIOFLUSH\n"
"\n"
"discardData :: Fd -> QueueSelector -> IO ()\n"
"discardData fd queue =\n"
"  throwErrnoIfMinus1_ \"discardData\" (c_tcflush fd (queue2Int queue))\n"
"  where\n"
"    queue2Int :: QueueSelector -> CInt\n"
"    queue2Int InputQueue  = (0)\n"
"{-# LINE 419 \"Terminal.hsc\" #-}\n"
"    queue2Int OutputQueue = (1)\n"
"{-# LINE 420 \"Terminal.hsc\" #-}\n"
"    queue2Int BothQueues  = (2)\n"
"{-# LINE 421 \"Terminal.hsc\" #-}\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h tcflush\"\n"
"  c_tcflush :: Fd -> CInt -> IO CInt\n"
"\n"
"data FlowAction\n"
"  = SuspendOutput	-- TCOOFF\n"
"  | RestartOutput	-- TCOON\n"
"  | TransmitStop	-- TCIOFF\n"
"  | TransmitStart	-- TCION\n"
"\n"
"controlFlow :: Fd -> FlowAction -> IO ()\n"
"controlFlow fd action =\n"
"  throwErrnoIfMinus1_ \"controlFlow\" (c_tcflow fd (action2Int action))\n"
"  where\n"
"    action2Int :: FlowAction -> CInt\n"
"    action2Int SuspendOutput = (0)\n"
"{-# LINE 437 \"Terminal.hsc\" #-}\n"
"    action2Int RestartOutput = (1)\n"
"{-# LINE 438 \"Terminal.hsc\" #-}\n"
"    action2Int TransmitStop  = (2)\n"
"{-# LINE 439 \"Terminal.hsc\" #-}\n"
"    action2Int TransmitStart = (3)\n"
"{-# LINE 440 \"Terminal.hsc\" #-}\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h tcflow\"\n"
"  c_tcflow :: Fd -> CInt -> IO CInt\n"
"\n"
"getTerminalProcessGroupID :: Fd -> IO ProcessGroupID\n"
"getTerminalProcessGroupID fd = do\n"
"  throwErrnoIfMinus1 \"getTerminalProcessGroupID\" (c_tcgetpgrp fd)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h tcgetpgrp\"\n"
"  c_tcgetpgrp :: Fd -> IO CPid\n"
"\n"
"setTerminalProcessGroupID :: Fd -> ProcessGroupID -> IO ()\n"
"setTerminalProcessGroupID fd pgid =\n"
"  throwErrnoIfMinus1_ \"setTerminalProcessGroupID\" (c_tcsetpgrp fd pgid)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h tcsetpgrp\"\n"
"  c_tcsetpgrp :: Fd -> CPid -> IO CInt\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- file descriptor queries\n"
"\n"
"queryTerminal :: Fd -> IO Bool\n"
"queryTerminal fd = do\n"
"  r <- c_isatty fd\n"
"  return (r == 1)\n"
"  -- ToDo: the spec says that it can set errno to EBADF if the result is zero\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h isatty\"\n"
"  c_isatty :: Fd -> IO CInt\n"
"\n"
"\n"
"getTerminalName :: Fd -> IO FilePath\n"
"getTerminalName fd = do\n"
"  s <- throwErrnoIfNull \"getTerminalName\" (c_ttyname fd)\n"
"  peekCString s  \n"
"\n"
"foreign import ccall unsafe \"HsUnix.h ttyname\"\n"
"  c_ttyname :: Fd -> IO CString\n"
"\n"
"getControllingTerminalName :: IO FilePath\n"
"getControllingTerminalName = do\n"
"  s <- throwErrnoIfNull \"getControllingTerminalName\" (c_ctermid nullPtr)\n"
"  peekCString s\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h ctermid\"\n"
"  c_ctermid :: CString -> IO CString\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Local utility functions\n"
"\n"
"-- Convert Haskell ControlCharacter to Int\n"
"\n"
"cc2Word :: ControlCharacter -> Int\n"
"cc2Word EndOfFile = (4)\n"
"{-# LINE 494 \"Terminal.hsc\" #-}\n"
"cc2Word EndOfLine = (11)\n"
"{-# LINE 495 \"Terminal.hsc\" #-}\n"
"cc2Word Erase     = (2)\n"
"{-# LINE 496 \"Terminal.hsc\" #-}\n"
"cc2Word Interrupt = (0)\n"
"{-# LINE 497 \"Terminal.hsc\" #-}\n"
"cc2Word Kill      = (3)\n"
"{-# LINE 498 \"Terminal.hsc\" #-}\n"
"cc2Word Quit      = (1)\n"
"{-# LINE 499 \"Terminal.hsc\" #-}\n"
"cc2Word Suspend   = (10)\n"
"{-# LINE 500 \"Terminal.hsc\" #-}\n"
"cc2Word Start     = (8)\n"
"{-# LINE 501 \"Terminal.hsc\" #-}\n"
"cc2Word Stop      = (9)\n"
"{-# LINE 502 \"Terminal.hsc\" #-}\n"
"\n"
"-- Convert Haskell BaudRate to unsigned integral type (Word)\n"
"\n"
"baud2Word :: BaudRate -> CSpeed\n"
"baud2Word B0 = (0)\n"
"{-# LINE 507 \"Terminal.hsc\" #-}\n"
"baud2Word B50 = (1)\n"
"{-# LINE 508 \"Terminal.hsc\" #-}\n"
"baud2Word B75 = (2)\n"
"{-# LINE 509 \"Terminal.hsc\" #-}\n"
"baud2Word B110 = (3)\n"
"{-# LINE 510 \"Terminal.hsc\" #-}\n"
"baud2Word B134 = (4)\n"
"{-# LINE 511 \"Terminal.hsc\" #-}\n"
"baud2Word B150 = (5)\n"
"{-# LINE 512 \"Terminal.hsc\" #-}\n"
"baud2Word B200 = (6)\n"
"{-# LINE 513 \"Terminal.hsc\" #-}\n"
"baud2Word B300 = (7)\n"
"{-# LINE 514 \"Terminal.hsc\" #-}\n"
"baud2Word B600 = (8)\n"
"{-# LINE 515 \"Terminal.hsc\" #-}\n"
"baud2Word B1200 = (9)\n"
"{-# LINE 516 \"Terminal.hsc\" #-}\n"
"baud2Word B1800 = (10)\n"
"{-# LINE 517 \"Terminal.hsc\" #-}\n"
"baud2Word B2400 = (11)\n"
"{-# LINE 518 \"Terminal.hsc\" #-}\n"
"baud2Word B4800 = (12)\n"
"{-# LINE 519 \"Terminal.hsc\" #-}\n"
"baud2Word B9600 = (13)\n"
"{-# LINE 520 \"Terminal.hsc\" #-}\n"
"baud2Word B19200 = (14)\n"
"{-# LINE 521 \"Terminal.hsc\" #-}\n"
"baud2Word B38400 = (15)\n"
"{-# LINE 522 \"Terminal.hsc\" #-}\n"
"\n"
"-- And convert a word back to a baud rate\n"
"-- We really need some cpp macros here.\n"
"\n"
"word2Baud :: CSpeed -> BaudRate\n"
"word2Baud x =\n"
"    if x == (0) then B0\n"
"{-# LINE 529 \"Terminal.hsc\" #-}\n"
"    else if x == (1) then B50\n"
"{-# LINE 530 \"Terminal.hsc\" #-}\n"
"    else if x == (2) then B75\n"
"{-# LINE 531 \"Terminal.hsc\" #-}\n"
"    else if x == (3) then B110\n"
"{-# LINE 532 \"Terminal.hsc\" #-}\n"
"    else if x == (4) then B134\n"
"{-# LINE 533 \"Terminal.hsc\" #-}\n"
"    else if x == (5) then B150\n"
"{-# LINE 534 \"Terminal.hsc\" #-}\n"
"    else if x == (6) then B200\n"
"{-# LINE 535 \"Terminal.hsc\" #-}\n"
"    else if x == (7) then B300\n"
"{-# LINE 536 \"Terminal.hsc\" #-}\n"
"    else if x == (8) then B600\n"
"{-# LINE 537 \"Terminal.hsc\" #-}\n"
"    else if x == (9) then B1200\n"
"{-# LINE 538 \"Terminal.hsc\" #-}\n"
"    else if x == (10) then B1800\n"
"{-# LINE 539 \"Terminal.hsc\" #-}\n"
"    else if x == (11) then B2400\n"
"{-# LINE 540 \"Terminal.hsc\" #-}\n"
"    else if x == (12) then B4800\n"
"{-# LINE 541 \"Terminal.hsc\" #-}\n"
"    else if x == (13) then B9600\n"
"{-# LINE 542 \"Terminal.hsc\" #-}\n"
"    else if x == (14) then B19200\n"
"{-# LINE 543 \"Terminal.hsc\" #-}\n"
"    else if x == (15) then B38400\n"
"{-# LINE 544 \"Terminal.hsc\" #-}\n"
"    else error \"unknown baud rate\"\n"
"\n"
"-- Clear termios i_flag\n"
"\n"
"clearInputFlag :: CTcflag -> TerminalAttributes -> TerminalAttributes\n"
"clearInputFlag flag termios = unsafePerformIO $ do\n"
"  fp <- mallocForeignPtrBytes (60)\n"
"{-# LINE 551 \"Terminal.hsc\" #-}\n"
"  withForeignPtr fp $ \\p1 -> do\n"
"    withTerminalAttributes termios $ \\p2 -> do\n"
"      copyBytes p1 p2 (60) \n"
"{-# LINE 554 \"Terminal.hsc\" #-}\n"
"      iflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0)) p2\n"
"{-# LINE 555 \"Terminal.hsc\" #-}\n"
"      ((\\hsc_ptr -> pokeByteOff hsc_ptr 0)) p1 (iflag .&. complement flag)\n"
"{-# LINE 556 \"Terminal.hsc\" #-}\n"
"  return $ makeTerminalAttributes fp\n"
"\n"
"-- Set termios i_flag\n"
"\n"
"setInputFlag :: CTcflag -> TerminalAttributes -> TerminalAttributes\n"
"setInputFlag flag termios = unsafePerformIO $ do\n"
"  fp <- mallocForeignPtrBytes (60)\n"
"{-# LINE 563 \"Terminal.hsc\" #-}\n"
"  withForeignPtr fp $ \\p1 -> do\n"
"    withTerminalAttributes termios $ \\p2 -> do\n"
"      copyBytes p1 p2 (60) \n"
"{-# LINE 566 \"Terminal.hsc\" #-}\n"
"      iflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0)) p2\n"
"{-# LINE 567 \"Terminal.hsc\" #-}\n"
"      ((\\hsc_ptr -> pokeByteOff hsc_ptr 0)) p1 (iflag .|. flag)\n"
"{-# LINE 568 \"Terminal.hsc\" #-}\n"
"  return $ makeTerminalAttributes fp\n"
"\n"
"-- Examine termios i_flag\n"
"\n"
"testInputFlag :: CTcflag -> TerminalAttributes -> Bool\n"
"testInputFlag flag termios = unsafePerformIO $\n"
"  withTerminalAttributes termios $ \\p ->  do\n"
"    iflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0)) p\n"
"{-# LINE 576 \"Terminal.hsc\" #-}\n"
"    return $! ((iflag .&. flag) /= 0)\n"
"\n"
"-- Clear termios c_flag\n"
"\n"
"clearControlFlag :: CTcflag -> TerminalAttributes -> TerminalAttributes\n"
"clearControlFlag flag termios = unsafePerformIO $ do\n"
"  fp <- mallocForeignPtrBytes (60)\n"
"{-# LINE 583 \"Terminal.hsc\" #-}\n"
"  withForeignPtr fp $ \\p1 -> do\n"
"    withTerminalAttributes termios $ \\p2 -> do\n"
"      copyBytes p1 p2 (60) \n"
"{-# LINE 586 \"Terminal.hsc\" #-}\n"
"      cflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 8)) p2\n"
"{-# LINE 587 \"Terminal.hsc\" #-}\n"
"      ((\\hsc_ptr -> pokeByteOff hsc_ptr 8)) p1 (cflag .&. complement flag)\n"
"{-# LINE 588 \"Terminal.hsc\" #-}\n"
"  return $ makeTerminalAttributes fp\n"
"\n"
"-- Set termios c_flag\n"
"\n"
"setControlFlag :: CTcflag -> TerminalAttributes -> TerminalAttributes\n"
"setControlFlag flag termios = unsafePerformIO $ do\n"
"  fp <- mallocForeignPtrBytes (60)\n"
"{-# LINE 595 \"Terminal.hsc\" #-}\n"
"  withForeignPtr fp $ \\p1 -> do\n"
"    withTerminalAttributes termios $ \\p2 -> do\n"
"      copyBytes p1 p2 (60) \n"
"{-# LINE 598 \"Terminal.hsc\" #-}\n"
"      cflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 8)) p2\n"
"{-# LINE 599 \"Terminal.hsc\" #-}\n"
"      ((\\hsc_ptr -> pokeByteOff hsc_ptr 8)) p1 (cflag .|. flag)\n"
"{-# LINE 600 \"Terminal.hsc\" #-}\n"
"  return $ makeTerminalAttributes fp\n"
"\n"
"-- Examine termios c_flag\n"
"\n"
"testControlFlag :: CTcflag -> TerminalAttributes -> Bool\n"
"testControlFlag flag termios = unsafePerformIO $\n"
"  withTerminalAttributes termios $ \\p -> do\n"
"    cflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 8)) p\n"
"{-# LINE 608 \"Terminal.hsc\" #-}\n"
"    return $! ((cflag .&. flag) /= 0)\n"
"\n"
"-- Clear termios l_flag\n"
"\n"
"clearLocalFlag :: CTcflag -> TerminalAttributes -> TerminalAttributes\n"
"clearLocalFlag flag termios = unsafePerformIO $ do\n"
"  fp <- mallocForeignPtrBytes (60)\n"
"{-# LINE 615 \"Terminal.hsc\" #-}\n"
"  withForeignPtr fp $ \\p1 -> do\n"
"    withTerminalAttributes termios $ \\p2 -> do\n"
"      copyBytes p1 p2 (60) \n"
"{-# LINE 618 \"Terminal.hsc\" #-}\n"
"      lflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 12)) p2\n"
"{-# LINE 619 \"Terminal.hsc\" #-}\n"
"      ((\\hsc_ptr -> pokeByteOff hsc_ptr 12)) p1 (lflag .&. complement flag)\n"
"{-# LINE 620 \"Terminal.hsc\" #-}\n"
"  return $ makeTerminalAttributes fp\n"
"\n"
"-- Set termios l_flag\n"
"\n"
"setLocalFlag :: CTcflag -> TerminalAttributes -> TerminalAttributes\n"
"setLocalFlag flag termios = unsafePerformIO $ do\n"
"  fp <- mallocForeignPtrBytes (60)\n"
"{-# LINE 627 \"Terminal.hsc\" #-}\n"
"  withForeignPtr fp $ \\p1 -> do\n"
"    withTerminalAttributes termios $ \\p2 -> do\n"
"      copyBytes p1 p2 (60) \n"
"{-# LINE 630 \"Terminal.hsc\" #-}\n"
"      lflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 12)) p2\n"
"{-# LINE 631 \"Terminal.hsc\" #-}\n"
"      ((\\hsc_ptr -> pokeByteOff hsc_ptr 12)) p1 (lflag .|. flag)\n"
"{-# LINE 632 \"Terminal.hsc\" #-}\n"
"  return $ makeTerminalAttributes fp\n"
"\n"
"-- Examine termios l_flag\n"
"\n"
"testLocalFlag :: CTcflag -> TerminalAttributes -> Bool\n"
"testLocalFlag flag termios = unsafePerformIO $\n"
"  withTerminalAttributes termios $ \\p ->  do\n"
"    lflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 12)) p\n"
"{-# LINE 640 \"Terminal.hsc\" #-}\n"
"    return $! ((lflag .&. flag) /= 0)\n"
"\n"
"-- Clear termios o_flag\n"
"\n"
"clearOutputFlag :: CTcflag -> TerminalAttributes -> TerminalAttributes\n"
"clearOutputFlag flag termios = unsafePerformIO $ do\n"
"  fp <- mallocForeignPtrBytes (60)\n"
"{-# LINE 647 \"Terminal.hsc\" #-}\n"
"  withForeignPtr fp $ \\p1 -> do\n"
"    withTerminalAttributes termios $ \\p2 -> do\n"
"      copyBytes p1 p2 (60) \n"
"{-# LINE 650 \"Terminal.hsc\" #-}\n"
"      oflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 4)) p2\n"
"{-# LINE 651 \"Terminal.hsc\" #-}\n"
"      ((\\hsc_ptr -> pokeByteOff hsc_ptr 4)) p1 (oflag .&. complement flag)\n"
"{-# LINE 652 \"Terminal.hsc\" #-}\n"
"  return $ makeTerminalAttributes fp\n"
"\n"
"-- Set termios o_flag\n"
"\n"
"setOutputFlag :: CTcflag -> TerminalAttributes -> TerminalAttributes\n"
"setOutputFlag flag termios = unsafePerformIO $ do\n"
"  fp <- mallocForeignPtrBytes (60)\n"
"{-# LINE 659 \"Terminal.hsc\" #-}\n"
"  withForeignPtr fp $ \\p1 -> do\n"
"    withTerminalAttributes termios $ \\p2 -> do\n"
"      copyBytes p1 p2 (60) \n"
"{-# LINE 662 \"Terminal.hsc\" #-}\n"
"      oflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 4)) p2\n"
"{-# LINE 663 \"Terminal.hsc\" #-}\n"
"      ((\\hsc_ptr -> pokeByteOff hsc_ptr 4)) p1 (oflag .|. flag)\n"
"{-# LINE 664 \"Terminal.hsc\" #-}\n"
"  return $ makeTerminalAttributes fp\n"
"\n"
"-- Examine termios o_flag\n"
"\n"
"testOutputFlag :: CTcflag -> TerminalAttributes -> Bool\n"
"testOutputFlag flag termios = unsafePerformIO $\n"
"  withTerminalAttributes termios $ \\p -> do\n"
"    oflag <- ((\\hsc_ptr -> peekByteOff hsc_ptr 4)) p\n"
"{-# LINE 672 \"Terminal.hsc\" #-}\n"
"    return $! ((oflag .&. flag) /= 0)\n"
"\n"
"withNewTermios :: TerminalAttributes -> (Ptr CTermios -> IO a) \n"
"  -> IO TerminalAttributes\n"
"withNewTermios termios action = do\n"
"  fp1 <- mallocForeignPtrBytes (60)\n"
"{-# LINE 678 \"Terminal.hsc\" #-}\n"
"  withForeignPtr fp1 $ \\p1 -> do\n"
"   withTerminalAttributes termios $ \\p2 -> do\n"
"    copyBytes p1 p2 (60)\n"
"{-# LINE 681 \"Terminal.hsc\" #-}\n"
"    action p1\n"
"  return $ makeTerminalAttributes fp1\n";
const char *System_Posix_Files = "{-# LINE 1 \"Files.hsc\" #-}\n"
"{-# LINE 2 \"Files.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.Files\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX file support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.Files (\n"
"    -- * File modes\n"
"    -- FileMode exported by System.Posix.Types\n"
"    unionFileModes, intersectFileModes,\n"
"    nullFileMode,\n"
"    ownerReadMode, ownerWriteMode, ownerExecuteMode, ownerModes,\n"
"    groupReadMode, groupWriteMode, groupExecuteMode, groupModes,\n"
"    otherReadMode, otherWriteMode, otherExecuteMode, otherModes,\n"
"    setUserIDMode, setGroupIDMode,\n"
"    stdFileMode,   accessModes,\n"
"\n"
"    -- ** Setting file modes\n"
"    setFileMode, setFdMode, setFileCreationMask,\n"
"\n"
"    -- ** Checking file existence and permissions\n"
"    fileAccess, fileExist,\n"
"\n"
"    -- * File status\n"
"    FileStatus,\n"
"    -- ** Obtaining file status\n"
"    getFileStatus, getFdStatus, getSymbolicLinkStatus,\n"
"    -- ** Querying file status\n"
"    deviceID, fileID, fileMode, linkCount, fileOwner, fileGroup,\n"
"    specialDeviceID, fileSize, accessTime, modificationTime,\n"
"    statusChangeTime,\n"
"    isBlockDevice, isCharacterDevice, isNamedPipe, isRegularFile,\n"
"    isDirectory, isSymbolicLink, isSocket,\n"
"\n"
"    -- * Creation\n"
"    createNamedPipe, \n"
"    createDevice,\n"
"\n"
"    -- * Hard links\n"
"    createLink, removeLink,\n"
"\n"
"    -- * Symbolic links\n"
"    createSymbolicLink, readSymbolicLink,\n"
"\n"
"    -- * Renaming files\n"
"    rename,\n"
"\n"
"    -- * Changing file ownership\n"
"    setOwnerAndGroup,  setFdOwnerAndGroup,\n"
"\n"
"{-# LINE 62 \"Files.hsc\" #-}\n"
"\n"
"    -- * Changing file timestamps\n"
"    setFileTimes, touchFile,\n"
"\n"
"    -- * Setting file sizes\n"
"    setFileSize, setFdSize,\n"
"\n"
"    -- * Find system-specific limits for a file\n"
"    PathVar(..), getPathVar, getFdPathVar,\n"
"  ) where\n"
"\n"
"\n"
"{-# LINE 74 \"Files.hsc\" #-}\n"
"\n"
"import System.Posix.Types\n"
"import System.IO.Unsafe\n"
"import Data.Bits\n"
"import System.Posix.Internals\n"
"import Foreign\n"
"import Foreign.C\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- POSIX file modes\n"
"\n"
"-- The abstract type 'FileMode', constants and operators for\n"
"-- manipulating the file modes defined by POSIX.\n"
"\n"
"nullFileMode :: FileMode\n"
"nullFileMode = 0\n"
"\n"
"ownerReadMode :: FileMode\n"
"ownerReadMode = (256)\n"
"{-# LINE 93 \"Files.hsc\" #-}\n"
"\n"
"ownerWriteMode :: FileMode\n"
"ownerWriteMode = (128)\n"
"{-# LINE 96 \"Files.hsc\" #-}\n"
"\n"
"ownerExecuteMode :: FileMode\n"
"ownerExecuteMode = (64)\n"
"{-# LINE 99 \"Files.hsc\" #-}\n"
"\n"
"groupReadMode :: FileMode\n"
"groupReadMode = (32)\n"
"{-# LINE 102 \"Files.hsc\" #-}\n"
"\n"
"groupWriteMode :: FileMode\n"
"groupWriteMode = (16)\n"
"{-# LINE 105 \"Files.hsc\" #-}\n"
"\n"
"groupExecuteMode :: FileMode\n"
"groupExecuteMode = (8)\n"
"{-# LINE 108 \"Files.hsc\" #-}\n"
"\n"
"otherReadMode :: FileMode\n"
"otherReadMode = (4)\n"
"{-# LINE 111 \"Files.hsc\" #-}\n"
"\n"
"otherWriteMode :: FileMode\n"
"otherWriteMode = (2)\n"
"{-# LINE 114 \"Files.hsc\" #-}\n"
"\n"
"otherExecuteMode :: FileMode\n"
"otherExecuteMode = (1)\n"
"{-# LINE 117 \"Files.hsc\" #-}\n"
"\n"
"setUserIDMode :: FileMode\n"
"setUserIDMode = (2048)\n"
"{-# LINE 120 \"Files.hsc\" #-}\n"
"\n"
"setGroupIDMode :: FileMode\n"
"setGroupIDMode = (1024)\n"
"{-# LINE 123 \"Files.hsc\" #-}\n"
"\n"
"stdFileMode :: FileMode\n"
"stdFileMode = ownerReadMode  .|. ownerWriteMode .|. \n"
"	      groupReadMode  .|. groupWriteMode .|. \n"
"	      otherReadMode  .|. otherWriteMode\n"
"\n"
"ownerModes :: FileMode\n"
"ownerModes = (448)\n"
"{-# LINE 131 \"Files.hsc\" #-}\n"
"\n"
"groupModes :: FileMode\n"
"groupModes = (56)\n"
"{-# LINE 134 \"Files.hsc\" #-}\n"
"\n"
"otherModes :: FileMode\n"
"otherModes = (7)\n"
"{-# LINE 137 \"Files.hsc\" #-}\n"
"\n"
"accessModes :: FileMode\n"
"accessModes = ownerModes .|. groupModes .|. otherModes\n"
"\n"
"unionFileModes :: FileMode -> FileMode -> FileMode\n"
"unionFileModes m1 m2 = m1 .|. m2\n"
"\n"
"intersectFileModes :: FileMode -> FileMode -> FileMode\n"
"intersectFileModes m1 m2 = m1 .&. m2\n"
"\n"
"-- Not exported:\n"
"fileTypeModes :: FileMode\n"
"fileTypeModes = (61440)\n"
"{-# LINE 150 \"Files.hsc\" #-}\n"
"\n"
"blockSpecialMode :: FileMode\n"
"blockSpecialMode = (24576)\n"
"{-# LINE 153 \"Files.hsc\" #-}\n"
"\n"
"characterSpecialMode :: FileMode\n"
"characterSpecialMode = (8192)\n"
"{-# LINE 156 \"Files.hsc\" #-}\n"
"\n"
"namedPipeMode :: FileMode\n"
"namedPipeMode = (4096)\n"
"{-# LINE 159 \"Files.hsc\" #-}\n"
"\n"
"regularFileMode :: FileMode\n"
"regularFileMode = (32768)\n"
"{-# LINE 162 \"Files.hsc\" #-}\n"
"\n"
"directoryMode :: FileMode\n"
"directoryMode = (16384)\n"
"{-# LINE 165 \"Files.hsc\" #-}\n"
"\n"
"symbolicLinkMode :: FileMode\n"
"symbolicLinkMode = (40960)\n"
"{-# LINE 168 \"Files.hsc\" #-}\n"
"\n"
"socketMode :: FileMode\n"
"socketMode = (49152)\n"
"{-# LINE 171 \"Files.hsc\" #-}\n"
"\n"
"setFileMode :: FilePath -> FileMode -> IO ()\n"
"setFileMode name m =\n"
"  withCString name $ \\s -> do\n"
"    throwErrnoIfMinus1_ \"setFileMode\" (c_chmod s m)\n"
"\n"
"setFdMode :: Fd -> FileMode -> IO ()\n"
"setFdMode fd m =\n"
"  throwErrnoIfMinus1_ \"setFdMode\" (c_fchmod fd m)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h fchmod\" \n"
"  c_fchmod :: Fd -> CMode -> IO CInt\n"
"\n"
"setFileCreationMask :: FileMode -> IO FileMode\n"
"setFileCreationMask mask = c_umask mask\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- access()\n"
"\n"
"fileAccess :: FilePath -> Bool -> Bool -> Bool -> IO Bool\n"
"fileAccess name read write exec = access name flags\n"
"  where\n"
"   flags   = read_f .|. write_f .|. exec_f\n"
"   read_f  = if read  then (4) else 0\n"
"{-# LINE 195 \"Files.hsc\" #-}\n"
"   write_f = if write then (2) else 0\n"
"{-# LINE 196 \"Files.hsc\" #-}\n"
"   exec_f  = if exec  then (1) else 0\n"
"{-# LINE 197 \"Files.hsc\" #-}\n"
"\n"
"fileExist :: FilePath -> IO Bool\n"
"fileExist name = \n"
"  withCString name $ \\s -> do\n"
"    r <- c_access s (0)\n"
"{-# LINE 202 \"Files.hsc\" #-}\n"
"    if (r == 0)\n"
"	then return True\n"
"	else do err <- getErrno\n"
"	        if (err == eNOENT)\n"
"		   then return False\n"
"		   else throwErrno \"fileExist\"\n"
"\n"
"access :: FilePath -> CMode -> IO Bool\n"
"access name flags = \n"
"  withCString name $ \\s -> do\n"
"    r <- c_access s flags\n"
"    if (r == 0)\n"
"	then return True\n"
"	else do err <- getErrno\n"
"	        if (err == eACCES)\n"
"		   then return False\n"
"		   else throwErrno \"fileAccess\"\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- stat() support\n"
"\n"
"newtype FileStatus = FileStatus (ForeignPtr CStat)\n"
"\n"
"deviceID         :: FileStatus -> DeviceID\n"
"fileID           :: FileStatus -> FileID\n"
"fileMode         :: FileStatus -> FileMode\n"
"linkCount        :: FileStatus -> LinkCount\n"
"fileOwner        :: FileStatus -> UserID\n"
"fileGroup        :: FileStatus -> GroupID\n"
"specialDeviceID  :: FileStatus -> DeviceID\n"
"fileSize         :: FileStatus -> FileOffset\n"
"accessTime       :: FileStatus -> EpochTime\n"
"modificationTime :: FileStatus -> EpochTime\n"
"statusChangeTime :: FileStatus -> EpochTime\n"
"\n"
"deviceID (FileStatus stat) = \n"
"  unsafePerformIO $ withForeignPtr stat $ ((\\hsc_ptr -> peekByteOff hsc_ptr 0))\n"
"{-# LINE 239 \"Files.hsc\" #-}\n"
"fileID (FileStatus stat) = \n"
"  unsafePerformIO $ withForeignPtr stat $ ((\\hsc_ptr -> peekByteOff hsc_ptr 8))\n"
"{-# LINE 241 \"Files.hsc\" #-}\n"
"fileMode (FileStatus stat) =\n"
"  unsafePerformIO $ withForeignPtr stat $ ((\\hsc_ptr -> peekByteOff hsc_ptr 24))\n"
"{-# LINE 243 \"Files.hsc\" #-}\n"
"linkCount (FileStatus stat) =\n"
"  unsafePerformIO $ withForeignPtr stat $ ((\\hsc_ptr -> peekByteOff hsc_ptr 16))\n"
"{-# LINE 245 \"Files.hsc\" #-}\n"
"fileOwner (FileStatus stat) =\n"
"  unsafePerformIO $ withForeignPtr stat $ ((\\hsc_ptr -> peekByteOff hsc_ptr 28))\n"
"{-# LINE 247 \"Files.hsc\" #-}\n"
"fileGroup (FileStatus stat) =\n"
"  unsafePerformIO $ withForeignPtr stat $ ((\\hsc_ptr -> peekByteOff hsc_ptr 32))\n"
"{-# LINE 249 \"Files.hsc\" #-}\n"
"specialDeviceID (FileStatus stat) =\n"
"  unsafePerformIO $ withForeignPtr stat $ ((\\hsc_ptr -> peekByteOff hsc_ptr 40))\n"
"{-# LINE 251 \"Files.hsc\" #-}\n"
"fileSize (FileStatus stat) =\n"
"  unsafePerformIO $ withForeignPtr stat $ ((\\hsc_ptr -> peekByteOff hsc_ptr 48))\n"
"{-# LINE 253 \"Files.hsc\" #-}\n"
"accessTime (FileStatus stat) =\n"
"  unsafePerformIO $ withForeignPtr stat $ ((\\hsc_ptr -> peekByteOff hsc_ptr 72))\n"
"{-# LINE 255 \"Files.hsc\" #-}\n"
"modificationTime (FileStatus stat) =\n"
"  unsafePerformIO $ withForeignPtr stat $ ((\\hsc_ptr -> peekByteOff hsc_ptr 88))\n"
"{-# LINE 257 \"Files.hsc\" #-}\n"
"statusChangeTime (FileStatus stat) =\n"
"  unsafePerformIO $ withForeignPtr stat $ ((\\hsc_ptr -> peekByteOff hsc_ptr 104))\n"
"{-# LINE 259 \"Files.hsc\" #-}\n"
"\n"
"isBlockDevice     :: FileStatus -> Bool\n"
"isCharacterDevice :: FileStatus -> Bool\n"
"isNamedPipe       :: FileStatus -> Bool\n"
"isRegularFile     :: FileStatus -> Bool\n"
"isDirectory       :: FileStatus -> Bool\n"
"isSymbolicLink    :: FileStatus -> Bool\n"
"isSocket          :: FileStatus -> Bool\n"
"\n"
"isBlockDevice stat = \n"
"  (fileMode stat `intersectFileModes` fileTypeModes) == blockSpecialMode\n"
"isCharacterDevice stat = \n"
"  (fileMode stat `intersectFileModes` fileTypeModes) == characterSpecialMode\n"
"isNamedPipe stat = \n"
"  (fileMode stat `intersectFileModes` fileTypeModes) == namedPipeMode\n"
"isRegularFile stat = \n"
"  (fileMode stat `intersectFileModes` fileTypeModes) == regularFileMode\n"
"isDirectory stat = \n"
"  (fileMode stat `intersectFileModes` fileTypeModes) == directoryMode\n"
"isSymbolicLink stat = \n"
"  (fileMode stat `intersectFileModes` fileTypeModes) == symbolicLinkMode\n"
"isSocket stat = \n"
"  (fileMode stat `intersectFileModes` fileTypeModes) == socketMode\n"
"\n"
"getFileStatus :: FilePath -> IO FileStatus\n"
"getFileStatus path = do\n"
"  fp <- mallocForeignPtrBytes (144) \n"
"{-# LINE 286 \"Files.hsc\" #-}\n"
"  withForeignPtr fp $ \\p ->\n"
"    withCString path $ \\s -> \n"
"      throwErrnoIfMinus1_ \"getFileStatus\" (c_stat s p)\n"
"  return (FileStatus fp)\n"
"\n"
"getFdStatus :: Fd -> IO FileStatus\n"
"getFdStatus (Fd fd) = do\n"
"  fp <- mallocForeignPtrBytes (144) \n"
"{-# LINE 294 \"Files.hsc\" #-}\n"
"  withForeignPtr fp $ \\p ->\n"
"    throwErrnoIfMinus1_ \"getFdStatus\" (c_fstat fd p)\n"
"  return (FileStatus fp)\n"
"\n"
"getSymbolicLinkStatus :: FilePath -> IO FileStatus\n"
"getSymbolicLinkStatus path = do\n"
"  fp <- mallocForeignPtrBytes (144) \n"
"{-# LINE 301 \"Files.hsc\" #-}\n"
"  withForeignPtr fp $ \\p ->\n"
"    withCString path $ \\s -> \n"
"      throwErrnoIfMinus1_ \"getSymbolicLinkStatus\" (c_lstat s p)\n"
"  return (FileStatus fp)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h lstat\" \n"
"  c_lstat :: CString -> Ptr CStat -> IO CInt\n"
"\n"
"createNamedPipe :: FilePath -> FileMode -> IO ()\n"
"createNamedPipe name mode = do\n"
"  withCString name $ \\s -> \n"
"    throwErrnoIfMinus1_ \"createNamedPipe\" (c_mkfifo s mode)\n"
"\n"
"createDevice :: FilePath -> FileMode -> DeviceID -> IO ()\n"
"createDevice path mode dev =\n"
"  withCString path $ \\s ->\n"
"    throwErrnoIfMinus1_ \"createDevice\" (c_mknod s mode dev)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h mknod\" \n"
"  c_mknod :: CString -> CMode -> CDev -> IO CInt\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Hard links\n"
"\n"
"createLink :: FilePath -> FilePath -> IO ()\n"
"createLink name1 name2 =\n"
"  withCString name1 $ \\s1 ->\n"
"  withCString name2 $ \\s2 ->\n"
"  throwErrnoIfMinus1_ \"createLink\" (c_link s1 s2)\n"
"\n"
"removeLink :: FilePath -> IO ()\n"
"removeLink name =\n"
"  withCString name $ \\s ->\n"
"  throwErrnoIfMinus1_ \"removeLink\" (c_unlink s)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Symbolic Links\n"
"\n"
"createSymbolicLink :: FilePath -> FilePath -> IO ()\n"
"createSymbolicLink file1 file2 =\n"
"  withCString file1 $ \\s1 ->\n"
"  withCString file2 $ \\s2 ->\n"
"  throwErrnoIfMinus1_ \"createSymbolicLink\" (c_symlink s1 s2)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h symlink\"\n"
"  c_symlink :: CString -> CString -> IO CInt\n"
"\n"
"-- ToDo: should really use SYMLINK_MAX, but not everyone supports it yet,\n"
"-- and it seems that the intention is that SYMLINK_MAX is no larger than\n"
"-- PATH_MAX.\n"
"readSymbolicLink :: FilePath -> IO FilePath\n"
"readSymbolicLink file =\n"
"  allocaArray0 (4096) $ \\buf -> do\n"
"{-# LINE 354 \"Files.hsc\" #-}\n"
"    withCString file $ \\s -> do\n"
"      len <- throwErrnoIfMinus1 \"readSymbolicLink\" $ \n"
"	c_readlink s buf (4096)\n"
"{-# LINE 357 \"Files.hsc\" #-}\n"
"      peekCStringLen (buf,fromIntegral len)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h readlink\"\n"
"  c_readlink :: CString -> CString -> CInt -> IO CInt\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Renaming files\n"
"\n"
"rename :: FilePath -> FilePath -> IO ()\n"
"rename name1 name2 =\n"
"  withCString name1 $ \\s1 ->\n"
"  withCString name2 $ \\s2 ->\n"
"  throwErrnoIfMinus1_ \"rename\" (c_rename s1 s2)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- chmod()\n"
"\n"
"setOwnerAndGroup :: FilePath -> UserID -> GroupID -> IO ()\n"
"setOwnerAndGroup name uid gid = do\n"
"  withCString name $ \\s ->\n"
"    throwErrnoIfMinus1_ \"setOwnerAndGroup\" (c_chown s uid gid)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h chown\"\n"
"  c_chown :: CString -> CUid -> CGid -> IO CInt\n"
"\n"
"setFdOwnerAndGroup :: Fd -> UserID -> GroupID -> IO ()\n"
"setFdOwnerAndGroup (Fd fd) uid gid = \n"
"  throwErrnoIfMinus1_ \"setFdOwnerAndGroup\" (c_fchown fd uid gid)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h fchown\"\n"
"  c_fchown :: CInt -> CUid -> CGid -> IO CInt\n"
"\n"
"\n"
"{-# LINE 398 \"Files.hsc\" #-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- utime()\n"
"\n"
"setFileTimes :: FilePath -> EpochTime -> EpochTime -> IO ()\n"
"setFileTimes name atime mtime = do\n"
"  withCString name $ \\s ->\n"
"   allocaBytes (16) $ \\p -> do\n"
"{-# LINE 406 \"Files.hsc\" #-}\n"
"     ((\\hsc_ptr -> pokeByteOff hsc_ptr 0))  p atime\n"
"{-# LINE 407 \"Files.hsc\" #-}\n"
"     ((\\hsc_ptr -> pokeByteOff hsc_ptr 8)) p mtime\n"
"{-# LINE 408 \"Files.hsc\" #-}\n"
"     throwErrnoIfMinus1_ \"setFileTimes\" (c_utime s p)\n"
"\n"
"touchFile :: FilePath -> IO ()\n"
"touchFile name = do\n"
"  withCString name $ \\s ->\n"
"   throwErrnoIfMinus1_ \"touchFile\" (c_utime s nullPtr)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Setting file sizes\n"
"\n"
"setFileSize :: FilePath -> FileOffset -> IO ()\n"
"setFileSize file off = \n"
"  withCString file $ \\s ->\n"
"    throwErrnoIfMinus1_ \"setFileSize\" (c_truncate s off)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h truncate\"\n"
"  c_truncate :: CString -> COff -> IO CInt\n"
"\n"
"setFdSize :: Fd -> FileOffset -> IO ()\n"
"setFdSize fd off =\n"
"  throwErrnoIfMinus1_ \"setFdSize\" (c_ftruncate fd off)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h ftruncate\"\n"
"  c_ftruncate :: Fd -> COff -> IO CInt\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- pathconf()/fpathconf() support\n"
"\n"
"data PathVar\n"
"  = FileSizeBits		  {- _PC_FILESIZEBITS     -}\n"
"  | LinkLimit                     {- _PC_LINK_MAX         -}\n"
"  | InputLineLimit                {- _PC_MAX_CANON        -}\n"
"  | InputQueueLimit               {- _PC_MAX_INPUT        -}\n"
"  | FileNameLimit                 {- _PC_NAME_MAX         -}\n"
"  | PathNameLimit                 {- _PC_PATH_MAX         -}\n"
"  | PipeBufferLimit               {- _PC_PIPE_BUF         -}\n"
"				  -- These are described as optional in POSIX:\n"
"  				  {- _PC_ALLOC_SIZE_MIN     -}\n"
"  				  {- _PC_REC_INCR_XFER_SIZE -}\n"
"  				  {- _PC_REC_MAX_XFER_SIZE  -}\n"
"  				  {- _PC_REC_MIN_XFER_SIZE  -}\n"
" 				  {- _PC_REC_XFER_ALIGN     -}\n"
"  | SymbolicLinkLimit		  {- _PC_SYMLINK_MAX      -}\n"
"  | SetOwnerAndGroupIsRestricted  {- _PC_CHOWN_RESTRICTED -}\n"
"  | FileNamesAreNotTruncated      {- _PC_NO_TRUNC         -}\n"
"  | VDisableChar		  {- _PC_VDISABLE         -}\n"
"  | AsyncIOAvailable		  {- _PC_ASYNC_IO         -}\n"
"  | PrioIOAvailable		  {- _PC_PRIO_IO          -}\n"
"  | SyncIOAvailable		  {- _PC_SYNC_IO          -}\n"
"\n"
"pathVarConst :: PathVar -> CInt\n"
"pathVarConst v = case v of\n"
"	LinkLimit     			-> (0)\n"
"{-# LINE 461 \"Files.hsc\" #-}\n"
"	InputLineLimit			-> (1)\n"
"{-# LINE 462 \"Files.hsc\" #-}\n"
"	InputQueueLimit			-> (2)\n"
"{-# LINE 463 \"Files.hsc\" #-}\n"
"	FileNameLimit			-> (3)\n"
"{-# LINE 464 \"Files.hsc\" #-}\n"
"	PathNameLimit			-> (4)\n"
"{-# LINE 465 \"Files.hsc\" #-}\n"
"	PipeBufferLimit			-> (5)\n"
"{-# LINE 466 \"Files.hsc\" #-}\n"
"	SetOwnerAndGroupIsRestricted	-> (6)\n"
"{-# LINE 467 \"Files.hsc\" #-}\n"
"	FileNamesAreNotTruncated	-> (7)\n"
"{-# LINE 468 \"Files.hsc\" #-}\n"
"	VDisableChar			-> (8)\n"
"{-# LINE 469 \"Files.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 471 \"Files.hsc\" #-}\n"
"	SyncIOAvailable		-> (9)\n"
"{-# LINE 472 \"Files.hsc\" #-}\n"
"\n"
"{-# LINE 475 \"Files.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 477 \"Files.hsc\" #-}\n"
"	AsyncIOAvailable	-> (10)\n"
"{-# LINE 478 \"Files.hsc\" #-}\n"
"\n"
"{-# LINE 481 \"Files.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 483 \"Files.hsc\" #-}\n"
"	PrioIOAvailable		-> (11)\n"
"{-# LINE 484 \"Files.hsc\" #-}\n"
"\n"
"{-# LINE 487 \"Files.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 491 \"Files.hsc\" #-}\n"
"	FileSizeBits		-> error \"_PC_FILESIZEBITS not available\"\n"
"\n"
"{-# LINE 493 \"Files.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 497 \"Files.hsc\" #-}\n"
"	SymbolicLinkLimit	-> error \"_PC_SYMLINK_MAX not available\"\n"
"\n"
"{-# LINE 499 \"Files.hsc\" #-}\n"
"\n"
"getPathVar :: FilePath -> PathVar -> IO Limit\n"
"getPathVar name v = do\n"
"  withCString name $ \\ nameP -> \n"
"    throwErrnoIfMinus1 \"getPathVar\" $ \n"
"      c_pathconf nameP (pathVarConst v)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h pathconf\" \n"
"  c_pathconf :: CString -> CInt -> IO CLong\n"
"\n"
"getFdPathVar :: Fd -> PathVar -> IO Limit\n"
"getFdPathVar fd v =\n"
"    throwErrnoIfMinus1 \"getFdPathVar\" $ \n"
"      c_fpathconf fd (pathVarConst v)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h fpathconf\" \n"
"  c_fpathconf :: Fd -> CInt -> IO CLong\n";
const char *System_Posix_Process = "{-# LINE 1 \"Process.hsc\" #-}\n"
"{-# LINE 2 \"Process.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.Process\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX process support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.Process (\n"
"    -- * Processes\n"
"\n"
"    -- ** Forking and executing\n"
"\n"
"{-# LINE 23 \"Process.hsc\" #-}\n"
"    executeFile,\n"
"    \n"
"    -- ** Exiting\n"
"    exitImmediately,\n"
"\n"
"    -- ** Process environment\n"
"    getProcessID,\n"
"    getParentProcessID,\n"
"    getProcessGroupID,\n"
"\n"
"    -- ** Process groups\n"
"    createProcessGroup,\n"
"    joinProcessGroup,\n"
"    setProcessGroupID,\n"
"\n"
"    -- ** Sessions\n"
"    createSession,\n"
"\n"
"    -- ** Process times\n"
"    ProcessTimes(..),\n"
"    getProcessTimes,\n"
"\n"
"    -- ** Scheduling priority\n"
"    nice,\n"
"    getProcessPriority,\n"
"    getProcessGroupPriority,\n"
"    getUserPriority,\n"
"    setProcessPriority,\n"
"    setProcessGroupPriority,\n"
"    setUserPriority,\n"
"\n"
"    -- ** Process status\n"
"    ProcessStatus(..),\n"
"    getProcessStatus,\n"
"    getAnyProcessStatus,\n"
"    getGroupProcessStatus,\n"
"\n"
" ) where\n"
"\n"
"\n"
"{-# LINE 63 \"Process.hsc\" #-}\n"
"\n"
"import Foreign.C.Error\n"
"import Foreign.C.String ( CString, withCString )\n"
"import Foreign.C.Types ( CInt, CClock )\n"
"import Foreign.Marshal.Alloc ( alloca, allocaBytes )\n"
"import Foreign.Marshal.Array ( withArray0 )\n"
"import Foreign.Marshal.Utils ( withMany )\n"
"import Foreign.Ptr ( Ptr, nullPtr )\n"
"import Foreign.StablePtr ( StablePtr, newStablePtr, freeStablePtr )\n"
"import Foreign.Storable ( Storable(..) )\n"
"import System.IO\n"
"import System.IO.Error\n"
"import System.Exit\n"
"import System.Posix.Types\n"
"import System.Posix.Signals\n"
"import Control.Monad\n"
"\n"
"\n"
"{-# LINE 81 \"Process.hsc\" #-}\n"
"{-# CBITS HsUnix.c execvpe.c #-}\n"
"\n"
"{-# LINE 83 \"Process.hsc\" #-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Process environment\n"
"\n"
"getProcessID :: IO ProcessID\n"
"getProcessID = c_getpid\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h getpid\"\n"
"   c_getpid :: IO CPid\n"
"\n"
"getParentProcessID :: IO ProcessID\n"
"getParentProcessID = c_getppid\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h getppid\"\n"
"  c_getppid :: IO CPid\n"
"\n"
"getProcessGroupID :: IO ProcessGroupID\n"
"getProcessGroupID = c_getpgrp\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h getpgrp\"\n"
"  c_getpgrp :: IO CPid\n"
"\n"
"createProcessGroup :: ProcessID -> IO ProcessGroupID\n"
"createProcessGroup pid = do\n"
"  throwErrnoIfMinus1_ \"createProcessGroup\" (c_setpgid pid 0)\n"
"  return pid\n"
"\n"
"joinProcessGroup :: ProcessGroupID -> IO ()\n"
"joinProcessGroup pgid =\n"
"  throwErrnoIfMinus1_ \"joinProcessGroup\" (c_setpgid 0 pgid)\n"
"\n"
"setProcessGroupID :: ProcessID -> ProcessGroupID -> IO ()\n"
"setProcessGroupID pid pgid =\n"
"  throwErrnoIfMinus1_ \"setProcessGroupID\" (c_setpgid pid pgid)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h setpgid\"\n"
"  c_setpgid :: CPid -> CPid -> IO CInt\n"
"\n"
"createSession :: IO ProcessGroupID\n"
"createSession = throwErrnoIfMinus1 \"createSession\" c_setsid\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h setsid\"\n"
"  c_setsid :: IO CPid\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Process times\n"
"\n"
"-- All times in clock ticks (see getClockTick)\n"
"\n"
"data ProcessTimes\n"
"  = ProcessTimes { elapsedTime     :: ClockTick\n"
"  		 , userTime        :: ClockTick\n"
"		 , systemTime      :: ClockTick\n"
"		 , childUserTime   :: ClockTick\n"
"		 , childSystemTime :: ClockTick\n"
"		 }\n"
"\n"
"getProcessTimes :: IO ProcessTimes\n"
"getProcessTimes = do\n"
"   allocaBytes (32) $ \\p_tms -> do\n"
"{-# LINE 143 \"Process.hsc\" #-}\n"
"     elapsed <- throwErrnoIfMinus1 \"getProcessTimes\" (c_times p_tms)\n"
"     ut  <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0))  p_tms\n"
"{-# LINE 145 \"Process.hsc\" #-}\n"
"     st  <- ((\\hsc_ptr -> peekByteOff hsc_ptr 8))  p_tms\n"
"{-# LINE 146 \"Process.hsc\" #-}\n"
"     cut <- ((\\hsc_ptr -> peekByteOff hsc_ptr 16)) p_tms\n"
"{-# LINE 147 \"Process.hsc\" #-}\n"
"     cst <- ((\\hsc_ptr -> peekByteOff hsc_ptr 24)) p_tms\n"
"{-# LINE 148 \"Process.hsc\" #-}\n"
"     return (ProcessTimes{ elapsedTime     = elapsed,\n"
"	 		   userTime        = ut,\n"
"	 		   systemTime      = st,\n"
"	 		   childUserTime   = cut,\n"
"	 		   childSystemTime = cst\n"
"			  })\n"
"\n"
"type CTms = ()\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h times\"\n"
"  c_times :: Ptr CTms -> IO CClock\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Process scheduling priority\n"
"\n"
"nice :: Int -> IO ()\n"
"nice prio = do\n"
"  resetErrno\n"
"  res <- c_nice (fromIntegral prio)\n"
"  when (res == -1) $ do\n"
"    err <- getErrno\n"
"    when (err /= eOK) (throwErrno \"nice\")\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h nice\"\n"
"  c_nice :: CInt -> IO CInt\n"
"\n"
"getProcessPriority      :: ProcessID      -> IO Int\n"
"getProcessGroupPriority :: ProcessGroupID -> IO Int\n"
"getUserPriority         :: UserID         -> IO Int\n"
"\n"
"getProcessPriority pid = do\n"
"  r <- throwErrnoIfMinus1 \"getProcessPriority\" $\n"
"         c_getpriority (0) (fromIntegral pid)\n"
"{-# LINE 181 \"Process.hsc\" #-}\n"
"  return (fromIntegral r)\n"
"\n"
"getProcessGroupPriority pid = do\n"
"  r <- throwErrnoIfMinus1 \"getProcessPriority\" $\n"
"         c_getpriority (1) (fromIntegral pid)\n"
"{-# LINE 186 \"Process.hsc\" #-}\n"
"  return (fromIntegral r)\n"
"\n"
"getUserPriority uid = do\n"
"  r <- throwErrnoIfMinus1 \"getUserPriority\" $\n"
"         c_getpriority (2) (fromIntegral uid)\n"
"{-# LINE 191 \"Process.hsc\" #-}\n"
"  return (fromIntegral r)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h getpriority\"\n"
"  c_getpriority :: CInt -> CInt -> IO CInt\n"
"\n"
"setProcessPriority      :: ProcessID      -> Int -> IO ()\n"
"setProcessGroupPriority :: ProcessGroupID -> Int -> IO ()\n"
"setUserPriority         :: UserID         -> Int -> IO ()\n"
"\n"
"setProcessPriority pid val = \n"
"  throwErrnoIfMinus1_ \"setProcessPriority\" $\n"
"    c_setpriority (0) (fromIntegral pid) (fromIntegral val)\n"
"{-# LINE 203 \"Process.hsc\" #-}\n"
"\n"
"setProcessGroupPriority pid val =\n"
"  throwErrnoIfMinus1_ \"setProcessPriority\" $\n"
"    c_setpriority (1) (fromIntegral pid) (fromIntegral val)\n"
"{-# LINE 207 \"Process.hsc\" #-}\n"
"\n"
"setUserPriority uid val =\n"
"  throwErrnoIfMinus1_ \"setUserPriority\" $\n"
"    c_setpriority (2) (fromIntegral uid) (fromIntegral val)\n"
"{-# LINE 211 \"Process.hsc\" #-}\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h setpriority\"\n"
"  c_setpriority :: CInt -> CInt -> CInt -> IO CInt\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Forking, execution\n"
"\n"
"\n"
"{-# LINE 235 \"Process.hsc\" #-}\n"
"\n"
"executeFile :: FilePath			    -- Command\n"
"            -> Bool			    -- Search PATH?\n"
"            -> [String]			    -- Arguments\n"
"            -> Maybe [(String, String)]	    -- Environment\n"
"            -> IO ()\n"
"executeFile path search args Nothing = do\n"
"  withCString path $ \\s ->\n"
"    withMany withCString (path:args) $ \\cstrs ->\n"
"      withArray0 nullPtr cstrs $ \\arr -> do\n"
"	pPrPr_disableITimers\n"
"	if search \n"
"	   then throwErrnoIfMinus1_ \"executeFile\" (c_execvp s arr)\n"
"	   else throwErrnoIfMinus1_ \"executeFile\" (c_execv s arr)\n"
"\n"
"executeFile path search args (Just env) = do\n"
"  withCString path $ \\s ->\n"
"    withMany withCString (path:args) $ \\cstrs ->\n"
"      withArray0 nullPtr cstrs $ \\arg_arr ->\n"
"    let env' = map (\\ (name, val) -> name ++ ('=' : val)) env in\n"
"    withMany withCString env' $ \\cenv ->\n"
"      withArray0 nullPtr cenv $ \\env_arr -> do\n"
"	pPrPr_disableITimers\n"
"	if search \n"
"	   then throwErrnoIfMinus1_ \"executeFile\" (c_execvpe s arg_arr env_arr)\n"
"	   else throwErrnoIfMinus1_ \"executeFile\" (c_execve s arg_arr env_arr)\n"
"\n"
"-- this function disables the itimer, which would otherwise cause confusing\n"
"-- signals to be sent to the new process.\n"
"foreign import ccall unsafe \"HsUnix.h pPrPr_disableITimers\"\n"
"  pPrPr_disableITimers :: IO ()\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h execvp\"\n"
"  c_execvp :: CString -> Ptr CString -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h execv\"\n"
"  c_execv :: CString -> Ptr CString -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h execvpe\"\n"
"  c_execvpe :: CString -> Ptr CString -> Ptr CString -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h execve\"\n"
"  c_execve :: CString -> Ptr CString -> Ptr CString -> IO CInt\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Waiting for process termination\n"
"\n"
"data ProcessStatus = Exited ExitCode\n"
"                   | Terminated Signal\n"
"                   | Stopped Signal\n"
"		   deriving (Eq, Ord, Show)\n"
"\n"
"getProcessStatus :: Bool -> Bool -> ProcessID -> IO (Maybe ProcessStatus)\n"
"getProcessStatus block stopped pid =\n"
"  alloca $ \\wstatp -> do\n"
"    pid <- throwErrnoIfMinus1Retry \"getProcessStatus\"\n"
"		(c_waitpid pid wstatp (waitOptions block stopped))\n"
"    case pid of\n"
"      0  -> return Nothing\n"
"      _  -> do ps <- decipherWaitStatus wstatp\n"
"	       return (Just ps)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h waitpid\"\n"
"  c_waitpid :: CPid -> Ptr CInt -> CInt -> IO CPid\n"
"\n"
"getGroupProcessStatus :: Bool\n"
"                      -> Bool\n"
"                      -> ProcessGroupID\n"
"                      -> IO (Maybe (ProcessID, ProcessStatus))\n"
"getGroupProcessStatus block stopped pgid =\n"
"  alloca $ \\wstatp -> do\n"
"    pid <- throwErrnoIfMinus1Retry \"getGroupProcessStatus\"\n"
"		(c_waitpid (-pgid) wstatp (waitOptions block stopped))\n"
"    case pid of\n"
"      0  -> return Nothing\n"
"      _  -> do ps <- decipherWaitStatus wstatp\n"
"	       return (Just (pid, ps))\n"
"\n"
"getAnyProcessStatus :: Bool -> Bool -> IO (Maybe (ProcessID, ProcessStatus))\n"
"getAnyProcessStatus block stopped = getGroupProcessStatus block stopped 1\n"
"\n"
"waitOptions :: Bool -> Bool -> CInt\n"
"--             block   stopped\n"
"waitOptions False False = (1)\n"
"{-# LINE 319 \"Process.hsc\" #-}\n"
"waitOptions False True  = (3)\n"
"{-# LINE 320 \"Process.hsc\" #-}\n"
"waitOptions True  False = 0\n"
"waitOptions True  True  = (2)\n"
"{-# LINE 322 \"Process.hsc\" #-}\n"
"\n"
"-- Turn a (ptr to a) wait status into a ProcessStatus\n"
"\n"
"decipherWaitStatus :: Ptr CInt -> IO ProcessStatus\n"
"decipherWaitStatus wstatp = do\n"
"  wstat <- peek wstatp\n"
"  if c_WIFEXITED wstat /= 0\n"
"      then do\n"
"        let exitstatus = c_WEXITSTATUS wstat\n"
"        if exitstatus == 0\n"
"	   then return (Exited ExitSuccess)\n"
"	   else return (Exited (ExitFailure (fromIntegral exitstatus)))\n"
"      else do\n"
"        if c_WIFSIGNALED wstat /= 0\n"
"	   then do\n"
"		let termsig = c_WTERMSIG wstat\n"
"		return (Terminated (fromIntegral termsig))\n"
"	   else do\n"
"		if c_WIFSTOPPED wstat /= 0\n"
"		   then do\n"
"			let stopsig = c_WSTOPSIG wstat\n"
"			return (Stopped (fromIntegral stopsig))\n"
"		   else do\n"
"			ioError (mkIOError illegalOperationErrorType\n"
"				   \"waitStatus\" Nothing Nothing)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h __hsunix_wifexited\"\n"
"  c_WIFEXITED :: CInt -> CInt \n"
"\n"
"foreign import ccall unsafe \"HsUnix.h __hsunix_wexitstatus\"\n"
"  c_WEXITSTATUS :: CInt -> CInt\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h __hsunix_wifsignaled\"\n"
"  c_WIFSIGNALED :: CInt -> CInt\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h __hsunix_wtermsig\"\n"
"  c_WTERMSIG :: CInt -> CInt \n"
"\n"
"foreign import ccall unsafe \"HsUnix.h __hsunix_wifstopped\"\n"
"  c_WIFSTOPPED :: CInt -> CInt\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h __hsunix_wstopsig\"\n"
"  c_WSTOPSIG :: CInt -> CInt\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Exiting\n"
"\n"
"exitImmediately :: ExitCode -> IO ()\n"
"exitImmediately exitcode = c_exit (exitcode2Int exitcode)\n"
"  where\n"
"    exitcode2Int ExitSuccess = 0\n"
"    exitcode2Int (ExitFailure n) = fromIntegral n\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h exit\"\n"
"  c_exit :: CInt -> IO ()\n"
"\n"
"-- -----------------------------------------------------------------------------\n";
const char *System_Posix_Internals = "\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.Internals\n"
"-- Copyright   :  (c) The University of Glasgow, 1992-2002\n"
"-- License     :  see libraries/base/LICENSE\n"
"-- \n"
"-- Maintainer  :  cvs-ghc@haskell.org\n"
"-- Stability   :  internal\n"
"-- Portability :  non-portable\n"
"--\n"
"-- POSIX support layer for the standard libraries.\n"
"-- This library is built on *every* platform, including Win32.\n"
"--\n"
"-- Non-posix compliant in order to support the following features:\n"
"--	* S_ISSOCK (no sockets in POSIX)\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- #hide\n"
"module System.Posix.Internals where\n"
"\n"
"import Control.Monad\n"
"import System.Posix.Types\n"
"\n"
"import Foreign\n"
"import Foreign.C\n"
"\n"
"import Data.Bits\n"
"import Data.Maybe\n"
"\n"
"import System.IO\n"
"\n"
"import Hugs.Prelude (IOException(..), IOErrorType(..))\n"
"\n"
"{-# CBITS PrelIOUtils.c dirUtils.c consUtils.c #-}\n"
"ioException = ioError\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Types\n"
"\n"
"type CDir       = ()\n"
"type CDirent    = ()\n"
"type CFLock     = ()\n"
"type CGroup     = ()\n"
"type CLconv     = ()\n"
"type CPasswd    = ()\n"
"type CSigaction = ()\n"
"type CSigset    = ()\n"
"type CStat      = ()\n"
"type CTermios   = ()\n"
"type CTm	= ()\n"
"type CTms	= ()\n"
"type CUtimbuf   = ()\n"
"type CUtsname   = ()\n"
"\n"
"type FD = Int\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- stat()-related stuff\n"
"\n"
"fdFileSize :: Int -> IO Integer\n"
"fdFileSize fd = \n"
"  allocaBytes sizeof_stat $ \\ p_stat -> do\n"
"    throwErrnoIfMinus1Retry \"fileSize\" $\n"
"	c_fstat (fromIntegral fd) p_stat\n"
"    c_mode <- st_mode p_stat :: IO CMode \n"
"    if not (s_isreg c_mode)\n"
"	then return (-1)\n"
"	else do\n"
"    c_size <- st_size p_stat :: IO COff\n"
"    return (fromIntegral c_size)\n"
"\n"
"data FDType  = Directory | Stream | RegularFile\n"
"	       deriving (Eq)\n"
"\n"
"fileType :: FilePath -> IO FDType\n"
"fileType file =\n"
"  allocaBytes sizeof_stat $ \\ p_stat -> do\n"
"  withCString file $ \\p_file -> do\n"
"    throwErrnoIfMinus1Retry \"fileType\" $\n"
"      c_stat p_file p_stat\n"
"    statGetType p_stat\n"
"\n"
"-- NOTE: On Win32 platforms, this will only work with file descriptors\n"
"-- referring to file handles. i.e., it'll fail for socket FDs.\n"
"fdType :: Int -> IO FDType\n"
"fdType fd = \n"
"  allocaBytes sizeof_stat $ \\ p_stat -> do\n"
"    throwErrnoIfMinus1Retry \"fdType\" $\n"
"	c_fstat (fromIntegral fd) p_stat\n"
"    statGetType p_stat\n"
"\n"
"statGetType p_stat = do\n"
"  c_mode <- st_mode p_stat :: IO CMode\n"
"  case () of\n"
"      _ | s_isdir c_mode    	-> return Directory\n"
"        | s_isfifo c_mode || s_issock c_mode || s_ischr  c_mode\n"
"			  	-> return Stream\n"
"	| s_isreg c_mode	-> return RegularFile\n"
"	| otherwise		-> ioError ioe_unknownfiletype\n"
"    \n"
"\n"
"ioe_unknownfiletype = IOError Nothing UnsupportedOperation \"fdType\"\n"
"			\"unknown file type\" Nothing\n"
"\n"
"-- It isn't clear whether ftruncate is POSIX or not (I've read several\n"
"-- manpages and they seem to conflict), so we truncate using open/2.\n"
"fileTruncate :: FilePath -> IO ()\n"
"fileTruncate file = do\n"
"  let flags = o_WRONLY .|. o_TRUNC\n"
"  withCString file $ \\file_cstr -> do\n"
"    fd <- fromIntegral `liftM`\n"
"	    throwErrnoIfMinus1Retry \"fileTruncate\"\n"
" 	        (c_open file_cstr (fromIntegral flags) 0o666)\n"
"    c_close fd\n"
"  return ()\n"
"\n"
"fdGetMode :: Int -> IO IOMode\n"
"fdGetMode fd = do\n"
"    flags <- throwErrnoIfMinus1Retry \"fdGetMode\" \n"
"		(c_fcntl_read (fromIntegral fd) const_f_getfl)\n"
"    let\n"
"       wH  = (flags .&. o_WRONLY) /= 0\n"
"       aH  = (flags .&. o_APPEND) /= 0\n"
"       rwH = (flags .&. o_RDWR) /= 0\n"
"\n"
"       mode\n"
"	 | wH && aH  = AppendMode\n"
"	 | wH        = WriteMode\n"
"	 | rwH       = ReadWriteMode\n"
"	 | otherwise = ReadMode\n"
"	  \n"
"    return mode\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Terminal-related stuff\n"
"\n"
"fdIsTTY :: Int -> IO Bool\n"
"fdIsTTY fd = c_isatty (fromIntegral fd) >>= return.toBool\n"
"\n"
"setEcho :: Int -> Bool -> IO ()\n"
"setEcho fd on = do\n"
"  tcSetAttr fd $ \\ p_tios -> do\n"
"    c_lflag <- c_lflag p_tios :: IO CTcflag\n"
"    let new_c_lflag\n"
"	 | on        = c_lflag .|. fromIntegral const_echo\n"
"	 | otherwise = c_lflag .&. complement (fromIntegral const_echo)\n"
"    poke_c_lflag p_tios (new_c_lflag :: CTcflag)\n"
"\n"
"getEcho :: Int -> IO Bool\n"
"getEcho fd = do\n"
"  tcSetAttr fd $ \\ p_tios -> do\n"
"    c_lflag <- c_lflag p_tios :: IO CTcflag\n"
"    return ((c_lflag .&. fromIntegral const_echo) /= 0)\n"
"\n"
"setCooked :: Int -> Bool -> IO ()\n"
"setCooked fd cooked = \n"
"  tcSetAttr fd $ \\ p_tios -> do\n"
"\n"
"    -- turn on/off ICANON\n"
"    c_lflag <- c_lflag p_tios :: IO CTcflag\n"
"    let new_c_lflag | cooked    = c_lflag .|. (fromIntegral const_icanon)\n"
"	            | otherwise = c_lflag .&. complement (fromIntegral const_icanon)\n"
"    poke_c_lflag p_tios (new_c_lflag :: CTcflag)\n"
"\n"
"    -- set VMIN & VTIME to 1/0 respectively\n"
"    when (not cooked) $ do\n"
"            c_cc <- ptr_c_cc p_tios\n"
"	    let vmin  = (c_cc `plusPtr` (fromIntegral const_vmin))  :: Ptr Word8\n"
"		vtime = (c_cc `plusPtr` (fromIntegral const_vtime)) :: Ptr Word8\n"
"	    poke vmin  1\n"
"	    poke vtime 0\n"
"\n"
"tcSetAttr :: FD -> (Ptr CTermios -> IO a) -> IO a\n"
"tcSetAttr fd fun = do\n"
"     allocaBytes sizeof_termios  $ \\p_tios -> do\n"
"	throwErrnoIfMinus1Retry \"tcSetAttr\"\n"
"	   (c_tcgetattr (fromIntegral fd) p_tios)\n"
"\n"
"	-- tcsetattr() when invoked by a background process causes the process\n"
"	-- to be sent SIGTTOU regardless of whether the process has TOSTOP set\n"
"	-- in its terminal flags (try it...).  This function provides a\n"
"	-- wrapper which temporarily blocks SIGTTOU around the call, making it\n"
"	-- transparent.\n"
"	allocaBytes sizeof_sigset_t $ \\ p_sigset -> do\n"
"	allocaBytes sizeof_sigset_t $ \\ p_old_sigset -> do\n"
"	     c_sigemptyset p_sigset\n"
"	     c_sigaddset   p_sigset const_sigttou\n"
"	     c_sigprocmask const_sig_block p_sigset p_old_sigset\n"
"	     r <- fun p_tios  -- do the business\n"
"	     throwErrnoIfMinus1Retry_ \"tcSetAttr\" $\n"
"		 c_tcsetattr (fromIntegral fd) const_tcsanow p_tios\n"
"	     c_sigprocmask const_sig_setmask p_old_sigset nullPtr\n"
"	     return r\n"
"\n"
"-- ---------------------------------------------------------------------------\n"
"-- Turning on non-blocking for a file descriptor\n"
"\n"
"setNonBlockingFD fd = do\n"
"  flags <- throwErrnoIfMinus1Retry \"setNonBlockingFD\"\n"
"		 (c_fcntl_read (fromIntegral fd) const_f_getfl)\n"
"  -- An error when setting O_NONBLOCK isn't fatal: on some systems \n"
"  -- there are certain file handles on which this will fail (eg. /dev/null\n"
"  -- on FreeBSD) so we throw away the return code from fcntl_write.\n"
"  unless (testBit flags (fromIntegral o_NONBLOCK)) $ do\n"
"    c_fcntl_write (fromIntegral fd) const_f_setfl (flags .|. o_NONBLOCK)\n"
"    return ()\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- foreign imports\n"
"\n"
"foreign import ccall unsafe \"HsBase.h access\"\n"
"   c_access :: CString -> CMode -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h chmod\"\n"
"   c_chmod :: CString -> CMode -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h chdir\"\n"
"   c_chdir :: CString -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h close\"\n"
"   c_close :: CInt -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h closedir\" \n"
"   c_closedir :: Ptr CDir -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h creat\"\n"
"   c_creat :: CString -> CMode -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h dup\"\n"
"   c_dup :: CInt -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h dup2\"\n"
"   c_dup2 :: CInt -> CInt -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h fstat\"\n"
"   c_fstat :: CInt -> Ptr CStat -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h getcwd\"\n"
"   c_getcwd   :: Ptr CChar -> CInt -> IO (Ptr CChar)\n"
"\n"
"foreign import ccall unsafe \"HsBase.h isatty\"\n"
"   c_isatty :: CInt -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h lseek\"\n"
"   c_lseek :: CInt -> COff -> CInt -> IO COff\n"
"\n"
"foreign import ccall unsafe \"HsBase.h __hscore_lstat\"\n"
"   lstat :: CString -> Ptr CStat -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h open\"\n"
"   c_open :: CString -> CInt -> CMode -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h opendir\" \n"
"   c_opendir :: CString  -> IO (Ptr CDir)\n"
"\n"
"foreign import ccall unsafe \"HsBase.h __hscore_mkdir\"\n"
"   mkdir :: CString -> CInt -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h read\" \n"
"   c_read :: CInt -> Ptr CChar -> CSize -> IO CSsize\n"
"\n"
"foreign import ccall unsafe \"HsBase.h readdir\" \n"
"   c_readdir :: Ptr CDir -> IO (Ptr CDirent)\n"
"\n"
"foreign import ccall unsafe \"dirUtils.h __hscore_renameFile\"\n"
"   c_rename :: CString -> CString -> IO CInt\n"
"		     \n"
"foreign import ccall unsafe \"HsBase.h rewinddir\"\n"
"   c_rewinddir :: Ptr CDir -> IO ()\n"
"\n"
"foreign import ccall unsafe \"HsBase.h rmdir\"\n"
"   c_rmdir :: CString -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h stat\"\n"
"   c_stat :: CString -> Ptr CStat -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h umask\"\n"
"   c_umask :: CMode -> IO CMode\n"
"\n"
"foreign import ccall unsafe \"HsBase.h write\" \n"
"   c_write :: CInt -> Ptr CChar -> CSize -> IO CSsize\n"
"\n"
"foreign import ccall unsafe \"HsBase.h unlink\"\n"
"   c_unlink :: CString -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h fcntl\"\n"
"   c_fcntl_read  :: CInt -> CInt -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h fcntl\"\n"
"   c_fcntl_write :: CInt -> CInt -> CInt -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h fcntl\"\n"
"   c_fcntl_lock  :: CInt -> CInt -> Ptr CFLock -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h fork\"\n"
"   c_fork :: IO CPid \n"
"\n"
"foreign import ccall unsafe \"HsBase.h getpid\"\n"
"   c_getpid :: IO CPid\n"
"\n"
"foreign import ccall unsafe \"HsBase.h link\"\n"
"   c_link :: CString -> CString -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h mkfifo\"\n"
"   c_mkfifo :: CString -> CMode -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h pipe\"\n"
"   c_pipe :: Ptr CInt -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h __hscore_sigemptyset\"\n"
"   c_sigemptyset :: Ptr CSigset -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h __hscore_sigaddset\"\n"
"   c_sigaddset :: Ptr CSigset -> CInt -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h sigprocmask\"\n"
"   c_sigprocmask :: CInt -> Ptr CSigset -> Ptr CSigset -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h tcgetattr\"\n"
"   c_tcgetattr :: CInt -> Ptr CTermios -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h tcsetattr\"\n"
"   c_tcsetattr :: CInt -> CInt -> Ptr CTermios -> IO CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h utime\"\n"
"   c_utime :: CString -> Ptr CUtimbuf -> IO CMode\n"
"\n"
"foreign import ccall unsafe \"HsBase.h waitpid\"\n"
"   c_waitpid :: CPid -> Ptr CInt -> CInt -> IO CPid\n"
"\n"
"-- traversing directories\n"
"foreign import ccall unsafe \"dirUtils.h __hscore_readdir\"\n"
"  readdir  :: Ptr CDir -> Ptr (Ptr CDirent) -> IO CInt\n"
" \n"
"foreign import ccall unsafe \"HsBase.h __hscore_free_dirent\"\n"
"  freeDirEnt  :: Ptr CDirent -> IO ()\n"
" \n"
"foreign import ccall unsafe \"HsBase.h __hscore_end_of_dir\"\n"
"  end_of_dir :: CInt\n"
" \n"
"foreign import ccall unsafe \"HsBase.h __hscore_d_name\"\n"
"  d_name :: Ptr CDirent -> IO CString\n"
"\n"
"-- POSIX flags only:\n"
"foreign import ccall unsafe \"HsBase.h __hscore_o_rdonly\" o_RDONLY :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_o_wronly\" o_WRONLY :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_o_rdwr\"   o_RDWR   :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_o_append\" o_APPEND :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_o_creat\"  o_CREAT  :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_o_excl\"   o_EXCL   :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_o_trunc\"  o_TRUNC  :: CInt\n"
"\n"
"-- non-POSIX flags.\n"
"foreign import ccall unsafe \"HsBase.h __hscore_o_noctty\"   o_NOCTTY   :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_o_nonblock\" o_NONBLOCK :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_o_binary\"   o_BINARY   :: CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h __hscore_s_isreg\"  s_isreg  :: CMode -> Bool\n"
"foreign import ccall unsafe \"HsBase.h __hscore_s_ischr\"  s_ischr  :: CMode -> Bool\n"
"foreign import ccall unsafe \"HsBase.h __hscore_s_isblk\"  s_isblk  :: CMode -> Bool\n"
"foreign import ccall unsafe \"HsBase.h __hscore_s_isdir\"  s_isdir  :: CMode -> Bool\n"
"foreign import ccall unsafe \"HsBase.h __hscore_s_isfifo\" s_isfifo :: CMode -> Bool\n"
"\n"
"foreign import ccall unsafe \"HsBase.h __hscore_sizeof_stat\" sizeof_stat :: Int\n"
"foreign import ccall unsafe \"HsBase.h __hscore_st_mtime\" st_mtime :: Ptr CStat -> IO CTime\n"
"foreign import ccall unsafe \"HsBase.h __hscore_st_size\" st_size :: Ptr CStat -> IO COff\n"
"foreign import ccall unsafe \"HsBase.h __hscore_st_mode\" st_mode :: Ptr CStat -> IO CMode\n"
"\n"
"foreign import ccall unsafe \"HsBase.h __hscore_echo\"         const_echo :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_tcsanow\"      const_tcsanow :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_icanon\"       const_icanon :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_vmin\"         const_vmin   :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_vtime\"        const_vtime  :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_sigttou\"      const_sigttou :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_sig_block\"    const_sig_block :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_sig_setmask\"  const_sig_setmask :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_f_getfl\"      const_f_getfl :: CInt\n"
"foreign import ccall unsafe \"HsBase.h __hscore_f_setfl\"      const_f_setfl :: CInt\n"
"\n"
"foreign import ccall unsafe \"HsBase.h __hscore_sizeof_termios\"  sizeof_termios :: Int\n"
"foreign import ccall unsafe \"HsBase.h __hscore_sizeof_sigset_t\" sizeof_sigset_t :: Int\n"
"\n"
"foreign import ccall unsafe \"HsBase.h __hscore_lflag\" c_lflag :: Ptr CTermios -> IO CTcflag\n"
"foreign import ccall unsafe \"HsBase.h __hscore_poke_lflag\" poke_c_lflag :: Ptr CTermios -> CTcflag -> IO ()\n"
"foreign import ccall unsafe \"HsBase.h __hscore_ptr_c_cc\" ptr_c_cc  :: Ptr CTermios -> IO (Ptr Word8)\n"
"\n"
"foreign import ccall unsafe \"HsBase.h __hscore_s_issock\" s_issock :: CMode -> Bool\n";
const char *System_Posix_IO = "{-# OPTIONS -#include \"HsUnix.h\" #-}\n"
"{-# LINE 1 \"IO.hsc\" #-}\n"
"{-# OPTIONS -fffi #-}\n"
"{-# LINE 2 \"IO.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.IO\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX IO support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.IO (\n"
"    -- * Input \\/ Output\n"
"\n"
"    -- ** Standard file descriptors\n"
"    stdInput, stdOutput, stdError,\n"
"\n"
"    -- ** Opening and closing files\n"
"    OpenMode(..),\n"
"    OpenFileFlags(..), defaultFileFlags,\n"
"    openFd, createFile,\n"
"    closeFd,\n"
"\n"
"    -- ** Reading\\/writing data\n"
"    -- |Programmers using the 'fdRead' and 'fdWrite' API should be aware that\n"
"    -- EAGAIN exceptions may occur for non-blocking IO!\n"
"\n"
"    fdRead, fdWrite,\n"
"\n"
"    -- ** Seeking\n"
"    fdSeek,\n"
"\n"
"    -- ** File options\n"
"    FdOption(..),\n"
"    queryFdOption,\n"
"    setFdOption,\n"
"\n"
"    -- ** Locking\n"
"    FileLock,\n"
"    LockRequest(..),\n"
"    getLock,  setLock,\n"
"    waitToSetLock,\n"
"\n"
"    -- ** Pipes\n"
"    createPipe,\n"
"\n"
"    -- ** Duplicating file descriptors\n"
"    dup, dupTo,\n"
"\n"
"    -- ** Converting file descriptors to\\/from Handles\n"
"    handleToFd,\n"
"    fdToHandle,  \n"
"\n"
"  ) where\n"
"\n"
"import System.IO\n"
"import System.IO.Error\n"
"import System.Posix.Types\n"
"import System.Posix.Internals\n"
"\n"
"import Foreign\n"
"import Foreign.C\n"
"import Data.Bits\n"
"\n"
"\n"
"{-# LINE 74 \"IO.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 76 \"IO.hsc\" #-}\n"
"import Hugs.Prelude (IOException(..), IOErrorType(..))\n"
"import qualified Hugs.IO (handleToFd, openFd)\n"
"\n"
"{-# LINE 79 \"IO.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 81 \"IO.hsc\" #-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Pipes\n"
"-- |The 'createPipe' function creates a pair of connected file descriptors. The first\n"
"-- component is the fd to read from, the second is the write end.\n"
"-- Although pipes may be bidirectional, this behaviour is not portable and\n"
"-- programmers should use two separate pipes for this purpose.\n"
"\n"
"createPipe :: IO (Fd, Fd)\n"
"createPipe =\n"
"  allocaArray 2 $ \\p_fd -> do\n"
"    throwErrnoIfMinus1_ \"createPipe\" (c_pipe p_fd)\n"
"    rfd <- peekElemOff p_fd 0\n"
"    wfd <- peekElemOff p_fd 1\n"
"    return (Fd rfd, Fd wfd)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Duplicating file descriptors\n"
"\n"
"dup :: Fd -> IO Fd\n"
"dup (Fd fd) = do r <- throwErrnoIfMinus1 \"dup\" (c_dup fd); return (Fd r)\n"
"\n"
"dupTo :: Fd -> Fd -> IO Fd\n"
"dupTo (Fd fd1) (Fd fd2) = do\n"
"  r <- throwErrnoIfMinus1 \"dupTo\" (c_dup2 fd1 fd2)\n"
"  return (Fd r)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Opening and closing files\n"
"\n"
"stdInput, stdOutput, stdError :: Fd\n"
"stdInput   = Fd (0)\n"
"{-# LINE 113 \"IO.hsc\" #-}\n"
"stdOutput  = Fd (1)\n"
"{-# LINE 114 \"IO.hsc\" #-}\n"
"stdError   = Fd (2)\n"
"{-# LINE 115 \"IO.hsc\" #-}\n"
"\n"
"data OpenMode = ReadOnly | WriteOnly | ReadWrite\n"
"\n"
"data OpenFileFlags =\n"
" OpenFileFlags {\n"
"    append    :: Bool,\n"
"    exclusive :: Bool,\n"
"    noctty    :: Bool,\n"
"    nonBlock  :: Bool,\n"
"    trunc     :: Bool\n"
" }\n"
"\n"
"defaultFileFlags :: OpenFileFlags\n"
"defaultFileFlags =\n"
" OpenFileFlags {\n"
"    append    = False,\n"
"    exclusive = False,\n"
"    noctty    = False,\n"
"    nonBlock  = False,\n"
"    trunc     = False\n"
"  }\n"
"\n"
"openFd :: FilePath\n"
"       -> OpenMode\n"
"       -> Maybe FileMode -- Just x => O_CREAT, Nothing => must exist\n"
"       -> OpenFileFlags\n"
"       -> IO Fd\n"
"openFd name how maybe_mode (OpenFileFlags append exclusive noctty\n"
"				nonBlock truncate) = do\n"
"   withCString name $ \\s -> do\n"
"    fd <- throwErrnoIfMinus1 \"openFd\" (c_open s all_flags mode_w)\n"
"    return (Fd fd)\n"
"  where\n"
"    all_flags  = creat .|. flags .|. open_mode\n"
"\n"
"    flags =\n"
"       (if append    then (1024)   else 0) .|.\n"
"{-# LINE 152 \"IO.hsc\" #-}\n"
"       (if exclusive then (128)     else 0) .|.\n"
"{-# LINE 153 \"IO.hsc\" #-}\n"
"       (if noctty    then (256)   else 0) .|.\n"
"{-# LINE 154 \"IO.hsc\" #-}\n"
"       (if nonBlock  then (2048) else 0) .|.\n"
"{-# LINE 155 \"IO.hsc\" #-}\n"
"       (if truncate  then (512)    else 0)\n"
"{-# LINE 156 \"IO.hsc\" #-}\n"
"\n"
"    (creat, mode_w) = case maybe_mode of \n"
"			Nothing -> (0,0)\n"
"			Just x  -> ((64), x)\n"
"{-# LINE 160 \"IO.hsc\" #-}\n"
"\n"
"    open_mode = case how of\n"
"		   ReadOnly  -> (0)\n"
"{-# LINE 163 \"IO.hsc\" #-}\n"
"		   WriteOnly -> (1)\n"
"{-# LINE 164 \"IO.hsc\" #-}\n"
"		   ReadWrite -> (2)\n"
"{-# LINE 165 \"IO.hsc\" #-}\n"
"\n"
"createFile :: FilePath -> FileMode -> IO Fd\n"
"createFile name mode\n"
"  = openFd name WriteOnly (Just mode) defaultFileFlags{ trunc=True } \n"
"\n"
"closeFd :: Fd -> IO ()\n"
"closeFd (Fd fd) = throwErrnoIfMinus1_ \"closeFd\" (c_close fd)\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Converting file descriptors to/from Handles\n"
"\n"
"\n"
"{-# LINE 193 \"IO.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 195 \"IO.hsc\" #-}\n"
"handleToFd :: Handle -> IO Fd\n"
"handleToFd h = do\n"
"  fd <- Hugs.IO.handleToFd h\n"
"  return (fromIntegral fd)\n"
"\n"
"fdToHandle :: Fd -> IO Handle\n"
"fdToHandle fd = do\n"
"  mode <- fdGetMode (fromIntegral fd)\n"
"  Hugs.IO.openFd (fromIntegral fd) False mode True\n"
"\n"
"{-# LINE 205 \"IO.hsc\" #-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Fd options\n"
"\n"
"data FdOption = AppendOnWrite\n"
"	      | CloseOnExec\n"
"	      | NonBlockingRead\n"
"	      | SynchronousWrites\n"
"\n"
"fdOption2Int :: FdOption -> CInt\n"
"fdOption2Int CloseOnExec       = (1)\n"
"{-# LINE 216 \"IO.hsc\" #-}\n"
"fdOption2Int AppendOnWrite     = (1024)\n"
"{-# LINE 217 \"IO.hsc\" #-}\n"
"fdOption2Int NonBlockingRead   = (2048)\n"
"{-# LINE 218 \"IO.hsc\" #-}\n"
"fdOption2Int SynchronousWrites = (1052672)\n"
"{-# LINE 219 \"IO.hsc\" #-}\n"
"\n"
"queryFdOption :: Fd -> FdOption -> IO Bool\n"
"queryFdOption (Fd fd) opt = do\n"
"  r <- throwErrnoIfMinus1 \"queryFdOption\" (c_fcntl_read fd flag)\n"
"  return (testBit r (fromIntegral (fdOption2Int opt)))\n"
" where\n"
"  flag    = case opt of\n"
"	      CloseOnExec       -> (1)\n"
"{-# LINE 227 \"IO.hsc\" #-}\n"
"	      other		-> (3)\n"
"{-# LINE 228 \"IO.hsc\" #-}\n"
"\n"
"setFdOption :: Fd -> FdOption -> Bool -> IO ()\n"
"setFdOption (Fd fd) opt val = do\n"
"  r <- throwErrnoIfMinus1 \"setFdOption\" (c_fcntl_read fd getflag)\n"
"  let r' | val       = r .|. opt_val\n"
"	 | otherwise = r .&. (complement opt_val)\n"
"  throwErrnoIfMinus1_ \"setFdOption\" (c_fcntl_write fd setflag r')\n"
" where\n"
"  (getflag,setflag)= case opt of\n"
"	      CloseOnExec       -> ((1),(2)) \n"
"{-# LINE 238 \"IO.hsc\" #-}\n"
"	      other		-> ((3),(4))\n"
"{-# LINE 239 \"IO.hsc\" #-}\n"
"  opt_val = fdOption2Int opt\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Seeking \n"
"\n"
"mode2Int :: SeekMode -> CInt\n"
"mode2Int AbsoluteSeek = (0)\n"
"{-# LINE 246 \"IO.hsc\" #-}\n"
"mode2Int RelativeSeek = (1)\n"
"{-# LINE 247 \"IO.hsc\" #-}\n"
"mode2Int SeekFromEnd  = (2)\n"
"{-# LINE 248 \"IO.hsc\" #-}\n"
"\n"
"fdSeek :: Fd -> SeekMode -> FileOffset -> IO FileOffset\n"
"fdSeek (Fd fd) mode off =\n"
"  throwErrnoIfMinus1 \"fdSeek\" (c_lseek fd off (mode2Int mode))\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- Locking\n"
"\n"
"data LockRequest = ReadLock\n"
"                 | WriteLock\n"
"                 | Unlock\n"
"\n"
"type FileLock = (LockRequest, SeekMode, FileOffset, FileOffset)\n"
"\n"
"getLock :: Fd -> FileLock -> IO (Maybe (ProcessID, FileLock))\n"
"getLock (Fd fd) lock =\n"
"  allocaLock lock $ \\p_flock -> do\n"
"    throwErrnoIfMinus1_ \"getLock\" (c_fcntl_lock fd (5) p_flock)\n"
"{-# LINE 266 \"IO.hsc\" #-}\n"
"    result <- bytes2ProcessIDAndLock p_flock\n"
"    return (maybeResult result)\n"
"  where\n"
"    maybeResult (_, (Unlock, _, _, _)) = Nothing\n"
"    maybeResult x = Just x\n"
"\n"
"allocaLock :: FileLock -> (Ptr CFLock -> IO a) -> IO a\n"
"allocaLock (lockreq, mode, start, len) io = \n"
"  allocaBytes (32) $ \\p -> do\n"
"{-# LINE 275 \"IO.hsc\" #-}\n"
"    ((\\hsc_ptr -> pokeByteOff hsc_ptr 0))   p (lockReq2Int lockreq :: CShort)\n"
"{-# LINE 276 \"IO.hsc\" #-}\n"
"    ((\\hsc_ptr -> pokeByteOff hsc_ptr 2)) p (fromIntegral (mode2Int mode) :: CShort)\n"
"{-# LINE 277 \"IO.hsc\" #-}\n"
"    ((\\hsc_ptr -> pokeByteOff hsc_ptr 8))  p start\n"
"{-# LINE 278 \"IO.hsc\" #-}\n"
"    ((\\hsc_ptr -> pokeByteOff hsc_ptr 16))    p len\n"
"{-# LINE 279 \"IO.hsc\" #-}\n"
"    io p\n"
"\n"
"lockReq2Int :: LockRequest -> CShort\n"
"lockReq2Int ReadLock  = (0)\n"
"{-# LINE 283 \"IO.hsc\" #-}\n"
"lockReq2Int WriteLock = (1)\n"
"{-# LINE 284 \"IO.hsc\" #-}\n"
"lockReq2Int Unlock    = (2)\n"
"{-# LINE 285 \"IO.hsc\" #-}\n"
"\n"
"bytes2ProcessIDAndLock :: Ptr CFLock -> IO (ProcessID, FileLock)\n"
"bytes2ProcessIDAndLock p = do\n"
"  req   <- ((\\hsc_ptr -> peekByteOff hsc_ptr 0))   p\n"
"{-# LINE 289 \"IO.hsc\" #-}\n"
"  mode  <- ((\\hsc_ptr -> peekByteOff hsc_ptr 2)) p\n"
"{-# LINE 290 \"IO.hsc\" #-}\n"
"  start <- ((\\hsc_ptr -> peekByteOff hsc_ptr 8))  p\n"
"{-# LINE 291 \"IO.hsc\" #-}\n"
"  len   <- ((\\hsc_ptr -> peekByteOff hsc_ptr 16))    p\n"
"{-# LINE 292 \"IO.hsc\" #-}\n"
"  pid   <- ((\\hsc_ptr -> peekByteOff hsc_ptr 24))    p\n"
"{-# LINE 293 \"IO.hsc\" #-}\n"
"  return (pid, (int2req req, int2mode mode, start, len))\n"
" where\n"
"  int2req :: CShort -> LockRequest\n"
"  int2req (0) = ReadLock\n"
"{-# LINE 297 \"IO.hsc\" #-}\n"
"  int2req (1) = WriteLock\n"
"{-# LINE 298 \"IO.hsc\" #-}\n"
"  int2req (2) = Unlock\n"
"{-# LINE 299 \"IO.hsc\" #-}\n"
"  int2req _ = error $ \"int2req: bad argument\"\n"
"\n"
"  int2mode :: CShort -> SeekMode\n"
"  int2mode (0) = AbsoluteSeek\n"
"{-# LINE 303 \"IO.hsc\" #-}\n"
"  int2mode (1) = RelativeSeek\n"
"{-# LINE 304 \"IO.hsc\" #-}\n"
"  int2mode (2) = SeekFromEnd\n"
"{-# LINE 305 \"IO.hsc\" #-}\n"
"  int2mode _ = error $ \"int2mode: bad argument\"\n"
"\n"
"setLock :: Fd -> FileLock -> IO ()\n"
"setLock (Fd fd) lock = do\n"
"  allocaLock lock $ \\p_flock ->\n"
"    throwErrnoIfMinus1_ \"setLock\" (c_fcntl_lock fd (6) p_flock)\n"
"{-# LINE 311 \"IO.hsc\" #-}\n"
"\n"
"waitToSetLock :: Fd -> FileLock -> IO ()\n"
"waitToSetLock (Fd fd) lock = do\n"
"  allocaLock lock $ \\p_flock ->\n"
"    throwErrnoIfMinus1_ \"waitToSetLock\" \n"
"	(c_fcntl_lock fd (7) p_flock)\n"
"{-# LINE 317 \"IO.hsc\" #-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- fd{Read,Write}\n"
"\n"
"fdRead :: Fd -> ByteCount -> IO (String, ByteCount)\n"
"fdRead _fd 0 = return (\"\", 0)\n"
"fdRead (Fd fd) nbytes = do\n"
"    allocaBytes (fromIntegral nbytes) $ \\ bytes -> do\n"
"    rc    <-  throwErrnoIfMinus1Retry \"fdRead\" (c_read fd bytes nbytes)\n"
"    case fromIntegral rc of\n"
"      0 -> ioError (IOError Nothing EOF \"fdRead\" \"EOF\" Nothing)\n"
"      n -> do\n"
"       s <- peekCStringLen (bytes, fromIntegral n)\n"
"       return (s, n)\n"
"\n"
"fdWrite :: Fd -> String -> IO ByteCount\n"
"fdWrite (Fd fd) str = withCStringLen str $ \\ (strPtr,len) -> do\n"
"    rc <- throwErrnoIfMinus1Retry \"fdWrite\" (c_write fd strPtr (fromIntegral len))\n"
"    return (fromIntegral rc)\n";
const char *System_Posix_Env = "{-# LINE 1 \"Env.hsc\" #-}\n"
"{-# LINE 2 \"Env.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.Env\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX environment support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.Env (\n"
"	getEnv\n"
"	, getEnvDefault\n"
"	, getEnvironmentPrim\n"
"	, getEnvironment\n"
"	, putEnv\n"
"	, setEnv\n"
"	, unsetEnv\n"
") where\n"
"\n"
"\n"
"{-# LINE 27 \"Env.hsc\" #-}\n"
"\n"
"import Foreign.C.Error	( throwErrnoIfMinus1_ )\n"
"import Foreign.C.Types	( CInt )\n"
"import Foreign.C.String\n"
"import Foreign.Marshal.Array\n"
"import Foreign.Ptr\n"
"import Foreign.Storable\n"
"import Control.Monad	( liftM )\n"
"import Data.Maybe	( fromMaybe )\n"
"\n"
"-- |'getEnv' looks up a variable in the environment.\n"
"\n"
"getEnv :: String -> IO (Maybe String)\n"
"getEnv name = do\n"
"  litstring <- withCString name c_getenv\n"
"  if litstring /= nullPtr\n"
"     then liftM Just $ peekCString litstring\n"
"     else return Nothing\n"
"\n"
"-- |'getEnvDefault' is a wrapper around 'getEnvVar' where the\n"
"-- programmer can specify a fallback if the variable is not found\n"
"-- in the environment.\n"
"\n"
"getEnvDefault :: String -> String -> IO String\n"
"getEnvDefault name fallback = liftM (fromMaybe fallback) (getEnv name)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h getenv\"\n"
"   c_getenv :: CString -> IO CString\n"
"\n"
"getEnvironmentPrim :: IO [String]\n"
"getEnvironmentPrim = do\n"
"  c_environ <- peek c_environ_p\n"
"  arr <- peekArray0 nullPtr c_environ\n"
"  mapM peekCString arr\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h &environ\"\n"
"   c_environ_p :: Ptr (Ptr CString)\n"
"\n"
"-- |'getEnvironment' retrieves the entire environment as a\n"
"-- list of @(key,value)@ pairs.\n"
"\n"
"getEnvironment :: IO [(String,String)]\n"
"getEnvironment = do\n"
"  env <- getEnvironmentPrim\n"
"  return $ map (dropEq.(break ((==) '='))) env\n"
" where\n"
"   dropEq (x,'=':ys) = (x,ys)\n"
"   dropEq (x,_)      = error $ \"getEnvironment: insane variable \" ++ x\n"
"\n"
"-- |The 'unsetenv' function deletes all instances of the variable name\n"
"-- from the environment.\n"
"\n"
"unsetEnv :: String -> IO ()\n"
"\n"
"{-# LINE 81 \"Env.hsc\" #-}\n"
"\n"
"unsetEnv name = withCString name c_unsetenv\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h unsetenv\"\n"
"   c_unsetenv :: CString -> IO ()\n"
"\n"
"{-# LINE 89 \"Env.hsc\" #-}\n"
"\n"
"-- |'putEnv' function takes an argument of the form @name=value@\n"
"-- and is equivalent to @setEnv(key,value,True{-overwrite-})@.\n"
"\n"
"putEnv :: String -> IO ()\n"
"putEnv keyvalue = withCString keyvalue $ \\s ->\n"
"  throwErrnoIfMinus1_ \"putenv\" (c_putenv s)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h putenv\"\n"
"   c_putenv :: CString -> IO CInt\n"
"\n"
"{- |The 'setenv' function inserts or resets the environment variable name in\n"
"     the current environment list.  If the variable @name@ does not exist in the\n"
"     list, it is inserted with the given value.  If the variable does exist,\n"
"     the argument @overwrite@ is tested; if @overwrite@ is @False@, the variable is\n"
"     not reset, otherwise it is reset to the given value.\n"
"-}\n"
"\n"
"setEnv :: String -> String -> Bool {-overwrite-} -> IO ()\n"
"\n"
"{-# LINE 109 \"Env.hsc\" #-}\n"
"setEnv key value ovrwrt = do\n"
"  withCString key $ \\ keyP ->\n"
"    withCString value $ \\ valueP ->\n"
"      throwErrnoIfMinus1_ \"putenv\" $\n"
"	c_setenv keyP valueP (fromIntegral (fromEnum ovrwrt))\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h setenv\"\n"
"   c_setenv :: CString -> CString -> CInt -> IO CInt\n"
"\n"
"{-# LINE 125 \"Env.hsc\" #-}\n";
const char *System_Posix_Directory = "{-# LINE 1 \"Directory.hsc\" #-}\n"
"{-# LINE 2 \"Directory.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.Files\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX directory support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.Directory (\n"
"   -- * Creating and removing directories\n"
"   createDirectory, removeDirectory,\n"
"\n"
"   -- * Reading directories\n"
"   DirStream,\n"
"   openDirStream,\n"
"   readDirStream,\n"
"   rewindDirStream,   \n"
"   closeDirStream,\n"
"   DirStreamOffset,\n"
"   tellDirStream,\n"
"   seekDirStream,\n"
"\n"
"   -- * The working dirctory\n"
"   getWorkingDirectory,\n"
"   changeWorkingDirectory,\n"
"   changeWorkingDirectoryFd,\n"
"  ) where\n"
"\n"
"import System.Posix.Types\n"
"import System.Posix.Internals\n"
"import System.Directory hiding (createDirectory)\n"
"import Foreign\n"
"import Foreign.C\n"
"\n"
"createDirectory :: FilePath -> FileMode -> IO ()\n"
"createDirectory name mode =\n"
"  withCString name $ \\s -> \n"
"    throwErrnoIfMinus1_ \"createDirectory\" (c_mkdir s mode)  \n"
"\n"
"foreign import ccall unsafe \"HsUnix.h mkdir\"\n"
"  c_mkdir :: CString -> CMode -> IO CInt\n"
"\n"
"newtype DirStream = DirStream (Ptr CDir)\n"
"\n"
"openDirStream :: FilePath -> IO DirStream\n"
"openDirStream name =\n"
"  withCString name $ \\s -> do\n"
"    dirp <- throwErrnoIfNull \"openDirStream\" $ c_opendir s\n"
"    return (DirStream dirp)\n"
"\n"
"readDirStream :: DirStream -> IO FilePath\n"
"readDirStream (DirStream dirp) =\n"
"  alloca $ \\ptr_dEnt  -> loop ptr_dEnt\n"
" where\n"
"  loop ptr_dEnt = do\n"
"    resetErrno\n"
"    r <- readdir dirp ptr_dEnt\n"
"    if (r == 0)\n"
"	 then do dEnt <- peek ptr_dEnt\n"
"		 if (dEnt == nullPtr)\n"
"		    then return []\n"
"		    else do\n"
"	 	     entry <- (d_name dEnt >>= peekCString)\n"
"		     freeDirEnt dEnt\n"
"		     return entry\n"
"	 else do errno <- getErrno\n"
"		 if (errno == eINTR) then loop ptr_dEnt else do\n"
"		 let (Errno eo) = errno\n"
"		 if (eo == end_of_dir)\n"
"		    then return []\n"
"		    else throwErrno \"readDirStream\"\n"
"\n"
"rewindDirStream :: DirStream -> IO ()\n"
"rewindDirStream (DirStream dirp) = c_rewinddir dirp\n"
"\n"
"closeDirStream :: DirStream -> IO ()\n"
"closeDirStream (DirStream dirp) = do\n"
"  throwErrnoIfMinus1_ \"closeDirStream\" (c_closedir dirp)\n"
"\n"
"newtype DirStreamOffset = DirStreamOffset CLong\n"
"\n"
"seekDirStream :: DirStream -> DirStreamOffset -> IO ()\n"
"seekDirStream (DirStream dirp) (DirStreamOffset off) =\n"
"  c_seekdir dirp off\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h seekdir\"\n"
"  c_seekdir :: Ptr CDir -> CLong -> IO ()\n"
"\n"
"tellDirStream :: DirStream -> IO DirStreamOffset\n"
"tellDirStream (DirStream dirp) = do\n"
"  off <- c_telldir dirp\n"
"  return (DirStreamOffset off)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h telldir\"\n"
"  c_telldir :: Ptr CDir -> IO CLong\n"
"\n"
"{-\n"
" Renamings of functionality provided via Directory interface,\n"
" kept around for b.wards compatibility and for having more POSIXy\n"
" names\n"
"-}\n"
"getWorkingDirectory :: IO FilePath\n"
"getWorkingDirectory = getCurrentDirectory\n"
"\n"
"changeWorkingDirectory :: FilePath -> IO ()\n"
"changeWorkingDirectory name = setCurrentDirectory name\n"
"\n"
"changeWorkingDirectoryFd :: Fd -> IO ()\n"
"changeWorkingDirectoryFd (Fd fd) = \n"
"  throwErrnoIfMinus1_ \"changeWorkingDirectoryFd\" (c_fchdir fd)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h fchdir\"\n"
"  c_fchdir :: CInt -> IO CInt\n";
const char *System_Posix_DynamicLinker = "{-# OPTIONS -#include \"HsUnix.h\" #-}\n"
"{-# LINE 1 \"DynamicLinker.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"{-# LINE 2 \"DynamicLinker.hsc\" #-}\n"
"-- |\n"
"-- Module      :  System.Posix.DynamicLinker\n"
"-- Copyright   :  (c) Volker Stolz <vs@foldr.org> 2003\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  vs@foldr.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- Dynamic linker support through dlopen()\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.DynamicLinker (\n"
"\n"
"    module System.Posix.DynamicLinker.Prim,\n"
"    dlopen,\n"
"    dlsym,\n"
"    dlerror,\n"
"    dlclose,\n"
"    withDL, withDL_,\n"
"    undl,\n"
"    )\n"
"\n"
"--  Usage:\n"
"--  ******\n"
"--  \n"
"--  Let's assume you want to open a local shared library \\'foo\\' (.\\/libfoo.so)\n"
"--  offering a function\n"
"--    @char \\* mogrify (char\\*,int)@\n"
"--  and invoke @str = mogrify(\"test\",1)@:\n"
"-- \n"
"--  \n"
"--  type Fun = CString -> Int -> IO CString\n"
"--  foreign import dynamic unsafe fun__ :: FunPtr Fun -> Fun\n"
"-- \n"
"--  withDL \"libfoo.so\" [RTLD_NOW] \\$ \\\\ mod -> do\n"
"--     funptr <- dlsym mod \"mogrify\"\n"
"--     let fun = fun__ funptr\n"
"--     withCString \"test\" \\$ \\\\ str -> do\n"
"--       strptr <- fun str 1\n"
"--       strstr <- peekCString strptr\n"
"--       ...\n"
"--  \n"
"\n"
"where\n"
"\n"
"\n"
"{-# LINE 49 \"DynamicLinker.hsc\" #-}\n"
"\n"
"import System.Posix.DynamicLinker.Prim\n"
"import Control.Exception	( bracket )\n"
"import Control.Monad	( liftM )\n"
"import Foreign.Ptr	( Ptr, nullPtr, FunPtr, nullFunPtr )\n"
"import Foreign.C.String	( withCString, peekCString )\n"
"\n"
"dlopen :: String -> [RTLDFlags] -> IO DL\n"
"dlopen path flags = do\n"
"  withCString path $ \\ p -> do\n"
"    liftM DLHandle $ throwDLErrorIf \"dlopen\" (== nullPtr) $ c_dlopen p (packRTLDFlags flags)\n"
"\n"
"dlclose :: DL -> IO ()\n"
"dlclose (DLHandle h) = throwDLErrorIf_ \"dlclose\" (== 0) $ c_dlclose h\n"
"dlclose h = error $ \"dlclose: invalid argument\" ++ (show h)\n"
"\n"
"dlerror :: IO String\n"
"dlerror = c_dlerror >>= peekCString \n"
"\n"
"-- |'dlsym' returns the address binding of the symbol described in @symbol@,\n"
"-- as it occurs in the shared object identified by @source@.\n"
"\n"
"dlsym :: DL -> String -> IO (FunPtr a)\n"
"dlsym source symbol = do\n"
"  withCString symbol $ \\ s -> do\n"
"    throwDLErrorIf \"dlsym\" (== nullFunPtr) $ c_dlsym (packDL source) s\n"
"\n"
"withDL :: String -> [RTLDFlags] -> (DL -> IO a) -> IO a\n"
"withDL mod flags f = bracket (dlopen mod flags) (dlclose) f\n"
"\n"
"withDL_ :: String -> [RTLDFlags] -> (DL -> IO a) -> IO ()\n"
"withDL_ mod flags f = withDL mod flags f >> return ()\n"
"\n"
"-- |'undl' obtains the raw handle. You mustn't do something like\n"
"-- @withDL mod flags $ liftM undl >>= \\ p -> use p@\n"
"\n"
"undl :: DL -> Ptr ()\n"
"undl = packDL\n"
"\n"
"throwDLErrorIf :: String -> (a -> Bool) -> IO a -> IO a\n"
"throwDLErrorIf s p f = do\n"
"  r <- f\n"
"  if (p r)\n"
"    then dlerror >>= \\ err -> ioError (userError ( s ++ \": \" ++ err))\n"
"    else return r\n"
"\n"
"throwDLErrorIf_ s p f = throwDLErrorIf s p f >> return ()\n";
const char *System_Posix_Time = "{-# LINE 1 \"Time.hsc\" #-}\n"
"{-# LINE 2 \"Time.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.Time\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX Time support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.Time (\n"
"	epochTime,\n"
"	-- ToDo: lots more from sys/time.h\n"
"	-- how much already supported by System.Time?\n"
"  ) where\n"
"\n"
"\n"
"{-# LINE 23 \"Time.hsc\" #-}\n"
"\n"
"import System.Posix.Types\n"
"import Foreign\n"
"import Foreign.C\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- epochTime\n"
"\n"
"epochTime :: IO EpochTime\n"
"epochTime = throwErrnoIfMinus1 \"epochTime\" (c_time nullPtr)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h time\"\n"
"  c_time :: Ptr CTime -> IO CTime\n";
const char *System_Posix_Unistd = "{-# LINE 1 \"Unistd.hsc\" #-}\n"
"{-# LINE 2 \"Unistd.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.Unistd\n"
"-- Copyright   :  (c) The University of Glasgow 2002\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- POSIX miscellaneous stuff, mostly from unistd.h\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.Unistd (\n"
"    -- * System environment\n"
"    SystemID(..),\n"
"    getSystemID,\n"
"\n"
"    SysVar(..),\n"
"    getSysVar,\n"
"\n"
"    -- * Sleeping\n"
"    sleep, usleep,\n"
"\n"
"  {-\n"
"    ToDo from unistd.h:\n"
"      confstr, \n"
"      lots of sysconf variables\n"
"\n"
"    -- use Network.BSD\n"
"    gethostid, gethostname\n"
"\n"
"    -- should be in System.Posix.Files?\n"
"    pathconf, fpathconf,\n"
"\n"
"    -- System.Posix.Signals\n"
"    ualarm,\n"
"\n"
"    -- System.Posix.IO\n"
"    read, write,\n"
"\n"
"    -- should be in System.Posix.User?\n"
"    getEffectiveUserName,\n"
"-}\n"
"  ) where\n"
"\n"
"\n"
"{-# LINE 50 \"Unistd.hsc\" #-}\n"
"\n"
"import Foreign.C.Error ( throwErrnoIfMinus1, throwErrnoIfMinus1_ )\n"
"import Foreign.C.String ( peekCString )\n"
"import Foreign.C.Types ( CInt, CUInt, CLong )\n"
"import Foreign.Marshal.Alloc ( allocaBytes )\n"
"import Foreign.Ptr ( Ptr, plusPtr )\n"
"import System.Posix.Types\n"
"import System.Posix.Internals\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- System environment (uname())\n"
"\n"
"data SystemID =\n"
"  SystemID { systemName :: String\n"
"  	   , nodeName   :: String\n"
"	   , release    :: String\n"
"	   , version    :: String\n"
"	   , machine    :: String\n"
"	   }\n"
"\n"
"getSystemID :: IO SystemID\n"
"getSystemID = do\n"
"  allocaBytes (390) $ \\p_sid -> do\n"
"{-# LINE 73 \"Unistd.hsc\" #-}\n"
"    throwErrnoIfMinus1_ \"getSystemID\" (c_uname p_sid)\n"
"    sysN <- peekCString (((\\hsc_ptr -> hsc_ptr `plusPtr` 0)) p_sid)\n"
"{-# LINE 75 \"Unistd.hsc\" #-}\n"
"    node <- peekCString (((\\hsc_ptr -> hsc_ptr `plusPtr` 65)) p_sid)\n"
"{-# LINE 76 \"Unistd.hsc\" #-}\n"
"    rel  <- peekCString (((\\hsc_ptr -> hsc_ptr `plusPtr` 130)) p_sid)\n"
"{-# LINE 77 \"Unistd.hsc\" #-}\n"
"    ver  <- peekCString (((\\hsc_ptr -> hsc_ptr `plusPtr` 195)) p_sid)\n"
"{-# LINE 78 \"Unistd.hsc\" #-}\n"
"    mach <- peekCString (((\\hsc_ptr -> hsc_ptr `plusPtr` 260)) p_sid)\n"
"{-# LINE 79 \"Unistd.hsc\" #-}\n"
"    return (SystemID { systemName = sysN,\n"
"		       nodeName   = node,\n"
"		       release    = rel,\n"
"		       version    = ver,\n"
"		       machine    = mach\n"
"		     })\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h uname\"\n"
"   c_uname :: Ptr CUtsname -> IO CInt\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- sleeping\n"
"\n"
"sleep :: Int -> IO Int\n"
"sleep 0 = return 0\n"
"sleep secs = do r <- c_sleep (fromIntegral secs); return (fromIntegral r)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h sleep\"\n"
"  c_sleep :: CUInt -> IO CUInt\n"
"\n"
"usleep :: Int -> IO ()\n"
"usleep 0 = return ()\n"
"\n"
"{-# LINE 104 \"Unistd.hsc\" #-}\n"
"usleep usecs = throwErrnoIfMinus1_ \"usleep\" (c_usleep (fromIntegral usecs))\n"
"\n"
"{-# LINE 106 \"Unistd.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 111 \"Unistd.hsc\" #-}\n"
"foreign import ccall unsafe \"HsUnix.h usleep\"\n"
"  c_usleep :: CUInt -> IO CInt\n"
"\n"
"{-# LINE 114 \"Unistd.hsc\" #-}\n"
"\n"
"-- -----------------------------------------------------------------------------\n"
"-- System variables\n"
"\n"
"data SysVar = ArgumentLimit\n"
"            | ChildLimit\n"
"            | ClockTick\n"
"            | GroupLimit\n"
"            | OpenFileLimit\n"
"            | PosixVersion\n"
"            | HasSavedIDs\n"
"            | HasJobControl\n"
"	-- ToDo: lots more\n"
"\n"
"getSysVar :: SysVar -> IO Integer\n"
"getSysVar v =\n"
"    case v of\n"
"      ArgumentLimit -> sysconf (0)\n"
"{-# LINE 132 \"Unistd.hsc\" #-}\n"
"      ChildLimit    -> sysconf (1)\n"
"{-# LINE 133 \"Unistd.hsc\" #-}\n"
"      ClockTick	    -> sysconf (2)\n"
"{-# LINE 134 \"Unistd.hsc\" #-}\n"
"      GroupLimit    -> sysconf (3)\n"
"{-# LINE 135 \"Unistd.hsc\" #-}\n"
"      OpenFileLimit -> sysconf (4)\n"
"{-# LINE 136 \"Unistd.hsc\" #-}\n"
"      PosixVersion  -> sysconf (29)\n"
"{-# LINE 137 \"Unistd.hsc\" #-}\n"
"      HasSavedIDs   -> sysconf (8)\n"
"{-# LINE 138 \"Unistd.hsc\" #-}\n"
"      HasJobControl -> sysconf (7)\n"
"{-# LINE 139 \"Unistd.hsc\" #-}\n"
"\n"
"sysconf :: CInt -> IO Integer\n"
"sysconf n = do \n"
"  r <- throwErrnoIfMinus1 \"getSysVar\" (c_sysconf n)\n"
"  return (fromIntegral r)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h sysconf\"\n"
"  c_sysconf :: CInt -> IO CLong\n";
const char *System_Posix_DynamicLinker_Module = "{-# OPTIONS -#include \"HsUnix.h\" #-}\n"
"{-# LINE 1 \"Module.hsc\" #-}\n"
"{-# OPTIONS -fffi #-}\n"
"{-# LINE 2 \"Module.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.DynamicLinker.Module\n"
"-- Copyright   :  (c) Volker Stolz <vs@foldr.org> 2003\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  vs@foldr.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- DLOpen support, old API\n"
"--  Derived from GModule.chs by M.Weber & M.Chakravarty which is part of c2hs\n"
"--  I left the API more or less the same, mostly the flags are different.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.DynamicLinker.Module (\n"
"\n"
"--  Usage:\n"
"--  ******\n"
"--  \n"
"--  Let's assume you want to open a local shared library 'foo' (./libfoo.so)\n"
"--  offering a function\n"
"--    char * mogrify (char*,int)\n"
"--  and invoke str = mogrify(\"test\",1):\n"
"-- \n"
"--  type Fun = CString -> Int -> IO CString\n"
"--  foreign import dynamic unsafe fun__ :: FunPtr Fun -> Fun\n"
"-- \n"
"--  withModule (Just \".\") (\"libfoo.so\") [RTLD_NOW] $ \\ mod -> do\n"
"--     funptr <- moduleSymbol mod \"mogrify\"\n"
"--     let fun = fun__ funptr\n"
"--     withCString \"test\" $ \\ str -> do\n"
"--       strptr <- fun str 1\n"
"--       strstr <- peekCString strptr\n"
"--       ...\n"
"\n"
"      Module\n"
"    , moduleOpen             -- :: String -> ModuleFlags -> IO Module\n"
"    , moduleSymbol           -- :: Source -> String -> IO (FunPtr a)\n"
"    , moduleClose            -- :: Module -> IO Bool\n"
"    , moduleError            -- :: IO String\n"
"    , withModule             -- :: Maybe String \n"
"                             -- -> String \n"
"	                     -- -> [ModuleFlags ]\n"
"			     -- -> (Module -> IO a) \n"
"			     -- -> IO a\n"
"    , withModule_            -- :: Maybe String \n"
" 			     -- -> String \n"
" 			     -- -> [ModuleFlags] \n"
" 			     -- -> (Module -> IO a) \n"
" 			     -- -> IO ()\n"
"    )\n"
"where\n"
"\n"
"\n"
"{-# LINE 58 \"Module.hsc\" #-}\n"
"\n"
"import System.Posix.DynamicLinker\n"
"import Foreign.Ptr	( Ptr, nullPtr, FunPtr )\n"
"import Foreign.C.String	( withCString )\n"
"\n"
"-- abstract handle for dynamically loaded module (EXPORTED)\n"
"--\n"
"newtype Module = Module (Ptr ())\n"
"\n"
"unModule              :: Module -> (Ptr ())\n"
"unModule (Module adr)  = adr\n"
"\n"
"-- Opens a module (EXPORTED)\n"
"--\n"
"\n"
"moduleOpen :: String -> [RTLDFlags] -> IO Module\n"
"moduleOpen mod flags = do\n"
"  modPtr <- withCString mod $ \\ modAddr -> c_dlopen modAddr (packRTLDFlags flags)\n"
"  if (modPtr == nullPtr)\n"
"      then moduleError >>= \\ err -> ioError (userError (\"dlopen: \" ++ err))\n"
"      else return $ Module modPtr\n"
"\n"
"-- Gets a symbol pointer from a module (EXPORTED)\n"
"--\n"
"moduleSymbol :: Module -> String -> IO (FunPtr a)\n"
"moduleSymbol mod sym = dlsym (DLHandle (unModule mod)) sym\n"
"\n"
"-- Closes a module (EXPORTED)\n"
"-- \n"
"moduleClose     :: Module -> IO ()\n"
"moduleClose mod  = dlclose (DLHandle (unModule mod))\n"
"\n"
"-- Gets a string describing the last module error (EXPORTED)\n"
"-- \n"
"moduleError :: IO String\n"
"moduleError  = dlerror\n"
"\n"
"\n"
"-- Convenience function, cares for module open- & closing\n"
"-- additionally returns status of `moduleClose' (EXPORTED)\n"
"-- \n"
"withModule :: Maybe String \n"
"           -> String \n"
"	   -> [RTLDFlags]\n"
"           -> (Module -> IO a) \n"
"	   -> IO a\n"
"withModule dir mod flags p = do\n"
"  let modPath = case dir of\n"
"                  Nothing -> mod\n"
"	          Just p  -> p ++ if ((head (reverse p)) == '/')\n"
"                                       then mod\n"
"				       else ('/':mod)\n"
"  mod <- moduleOpen modPath flags\n"
"  result <- p mod\n"
"  moduleClose mod\n"
"  return result\n"
"\n"
"withModule_ :: Maybe String \n"
"            -> String \n"
"	    -> [RTLDFlags]\n"
"            -> (Module -> IO a) \n"
"	    -> IO ()\n"
"withModule_ dir mod flags p = withModule dir mod flags p >>= \\ _ -> return ()\n";
const char *System_Posix_DynamicLinker_Prim = "{-# LINE 1 \"Prim.hsc\" #-}\n"
"{-# LINE 2 \"Prim.hsc\" #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Posix.DynamicLinker.Prim\n"
"-- Copyright   :  (c) Volker Stolz <vs@foldr.org> 2003\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  vs@foldr.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  non-portable (requires POSIX)\n"
"--\n"
"-- DLOpen and friend\n"
"--  Derived from GModule.chs by M.Weber & M.Chakravarty which is part of c2hs\n"
"--  I left the API more or less the same, mostly the flags are different.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Posix.DynamicLinker.Prim (\n"
"  -- * low level API\n"
"  c_dlopen,\n"
"  c_dlsym,\n"
"  c_dlerror,\n"
"  c_dlclose,\n"
"  -- dlAddr, -- XXX NYI\n"
"  haveRtldNext,\n"
"  haveRtldLocal,\n"
"  packRTLDFlags,\n"
"  RTLDFlags(..),\n"
"  packDL,\n"
"  DL(..)\n"
" )\n"
"\n"
"where\n"
"\n"
"\n"
"{-# LINE 36 \"Prim.hsc\" #-}\n"
"\n"
"import Data.Bits	( (.|.) )\n"
"import Foreign.Ptr	( Ptr, FunPtr, nullPtr )\n"
"import Foreign.C.Types	( CInt )\n"
"import Foreign.C.String	( CString )\n"
"\n"
"-- RTLD_NEXT madness\n"
"-- On some host (e.g. SuSe Linux 7.2) RTLD_NEXT is not visible\n"
"-- without setting _GNU_SOURCE. Since we don't want to set this\n"
"-- flag, here's a different solution: You can use the Haskell\n"
"-- function 'haveRtldNext' to check wether the flag is available\n"
"-- to you. Ideally, this will be optimized by the compiler so\n"
"-- that it should be as efficient as an #ifdef.\n"
"--    If you fail to test the flag and use it although it is\n"
"-- undefined, 'packOneModuleFlag' will bomb.\n"
"--    The same applies to RTLD_LOCAL which isn't available on\n"
"-- cygwin.\n"
"\n"
"haveRtldNext :: Bool\n"
"\n"
"\n"
"{-# LINE 62 \"Prim.hsc\" #-}\n"
"haveRtldNext = False\n"
"\n"
"{-# LINE 64 \"Prim.hsc\" #-}\n"
"\n"
"haveRtldLocal :: Bool\n"
"\n"
"\n"
"{-# LINE 70 \"Prim.hsc\" #-}\n"
"haveRtldLocal = False\n"
"\n"
"{-# LINE 72 \"Prim.hsc\" #-}\n"
"\n"
"data RTLDFlags \n"
"  = RTLD_LAZY\n"
"  | RTLD_NOW\n"
"  | RTLD_GLOBAL \n"
"  | RTLD_LOCAL\n"
"    deriving (Show, Read)\n"
"\n"
"foreign import ccall unsafe \"HsUnix.h dlopen\" c_dlopen :: CString -> CInt -> IO (Ptr ())\n"
"foreign import ccall unsafe \"HsUnix.h dlsym\"  c_dlsym  :: Ptr () -> CString -> IO (FunPtr a)\n"
"foreign import ccall unsafe \"HsUnix.h dlerror\" c_dlerror :: IO CString\n"
"foreign import ccall unsafe \"HsUnix.h dlclose\" c_dlclose :: (Ptr ()) -> IO CInt\n"
"\n"
"packRTLDFlags :: [RTLDFlags] -> CInt\n"
"packRTLDFlags flags = foldl (\\ s f -> (packRTLDFlag f) .|. s) 0 flags\n"
"\n"
"packRTLDFlag :: RTLDFlags -> CInt\n"
"packRTLDFlag RTLD_LAZY = 1\n"
"{-# LINE 90 \"Prim.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 94 \"Prim.hsc\" #-}\n"
"packRTLDFlag RTLD_NOW =  error \"RTLD_NOW not available\"\n"
"\n"
"{-# LINE 96 \"Prim.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 100 \"Prim.hsc\" #-}\n"
"packRTLDFlag RTLD_GLOBAL = error \"RTLD_GLOBAL not available\"\n"
"\n"
"{-# LINE 102 \"Prim.hsc\" #-}\n"
"\n"
"\n"
"{-# LINE 106 \"Prim.hsc\" #-}\n"
"packRTLDFlag RTLD_LOCAL = error \"RTLD_LOCAL not available\"\n"
"\n"
"{-# LINE 108 \"Prim.hsc\" #-}\n"
"\n"
"-- |Flags for 'dlsym'. Notice that @Next@ might not be available on\n"
"-- your particular platform!\n"
"\n"
"data DL = Null | Next | Default | DLHandle (Ptr ()) deriving (Show)\n"
"\n"
"packDL :: DL -> Ptr ()\n"
"packDL Null = nullPtr\n"
"\n"
"{-# LINE 119 \"Prim.hsc\" #-}\n"
"packDL Next = error \"RTLD_NEXT not available\"\n"
"\n"
"{-# LINE 121 \"Prim.hsc\" #-}\n"
"packDL Default = nullPtr\n"
"packDL (DLHandle h) = h\n";
const char *System_Mem_StableName = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Mem.StableName\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- Stable names are a way of performing fast (O(1)), not-quite-exact\n"
"-- comparison between objects.\n"
"-- \n"
"-- Stable names solve the following problem: suppose you want to build\n"
"-- a hash table with Haskell objects as keys, but you want to use\n"
"-- pointer equality for comparison; maybe because the keys are large\n"
"-- and hashing would be slow, or perhaps because the keys are infinite\n"
"-- in size.  We can\\'t build a hash table using the address of the\n"
"-- object as the key, because objects get moved around by the garbage\n"
"-- collector, meaning a re-hash would be necessary after every garbage\n"
"-- collection.\n"
"--\n"
"-------------------------------------------------------------------------------\n"
"\n"
"module System.Mem.StableName (\n"
"  -- * Stable Names\n"
"  StableName,\n"
"  makeStableName,\n"
"  hashStableName,\n"
"  ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Typeable\n"
"\n"
"import Hugs.Stable\n"
"\n"
"stableNameTc = mkTyCon \"StableName\"; instance Typeable a => Typeable (StableName a) where {   typeOf x = mkAppTy stableNameTc [typeOf ((undefined :: StableName a -> a) x) ] }\n";
const char *System_Mem_Weak = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Mem.Weak\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  non-portable\n"
"--\n"
"-- In general terms, a weak pointer is a reference to an object that is\n"
"-- not followed by the garbage collector - that is, the existence of a\n"
"-- weak pointer to an object has no effect on the lifetime of that\n"
"-- object.  A weak pointer can be de-referenced to find out\n"
"-- whether the object it refers to is still alive or not, and if so\n"
"-- to return the object itself.\n"
"-- \n"
"-- Weak pointers are particularly useful for caches and memo tables.\n"
"-- To build a memo table, you build a data structure \n"
"-- mapping from the function argument (the key) to its result (the\n"
"-- value).  When you apply the function to a new argument you first\n"
"-- check whether the key\\/value pair is already in the memo table.\n"
"-- The key point is that the memo table itself should not keep the\n"
"-- key and value alive.  So the table should contain a weak pointer\n"
"-- to the key, not an ordinary pointer.  The pointer to the value must\n"
"-- not be weak, because the only reference to the value might indeed be\n"
"-- from the memo table.   \n"
"-- \n"
"-- So it looks as if the memo table will keep all its values\n"
"-- alive for ever.  One way to solve this is to purge the table\n"
"-- occasionally, by deleting entries whose keys have died.\n"
"-- \n"
"-- The weak pointers in this library\n"
"-- support another approach, called /finalization/.\n"
"-- When the key referred to by a weak pointer dies, the storage manager\n"
"-- arranges to run a programmer-specified finalizer.  In the case of memo\n"
"-- tables, for example, the finalizer could remove the key\\/value pair\n"
"-- from the memo table.  \n"
"-- \n"
"-- Another difficulty with the memo table is that the value of a\n"
"-- key\\/value pair might itself contain a pointer to the key.\n"
"-- So the memo table keeps the value alive, which keeps the key alive,\n"
"-- even though there may be no other references to the key so both should\n"
"-- die.  The weak pointers in this library provide a slight \n"
"-- generalisation of the basic weak-pointer idea, in which each\n"
"-- weak pointer actually contains both a key and a value.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module System.Mem.Weak (\n"
"	-- * The @Weak@ type\n"
"	Weak,	    		-- abstract\n"
"\n"
"	-- * The general interface\n"
"	mkWeak,      		-- :: k -> v -> Maybe (IO ()) -> IO (Weak v)\n"
"	deRefWeak, 		-- :: Weak v -> IO (Maybe v)\n"
"	finalize,		-- :: Weak v -> IO ()\n"
"\n"
"	-- * Specialised versions\n"
"	mkWeakPtr, 		-- :: k -> Maybe (IO ()) -> IO (Weak k)\n"
"	addFinalizer, 		-- :: key -> IO () -> IO ()\n"
"	mkWeakPair, 		-- :: k -> v -> Maybe (IO ()) -> IO (Weak (k,v))\n"
"	-- replaceFinaliser	-- :: Weak v -> IO () -> IO ()\n"
"\n"
"	-- * A precise semantics\n"
"	\n"
"	-- $precise\n"
"   ) where\n"
"\n"
"import Prelude\n"
"\n"
"import Data.Typeable\n"
"\n"
"import Hugs.Weak\n"
"\n"
"-- | A specialised version of 'mkWeak', where the key and the value are\n"
"-- the same object:\n"
"--\n"
"-- > mkWeakPtr key finalizer = mkWeak key key finalizer\n"
"--\n"
"mkWeakPtr :: k -> Maybe (IO ()) -> IO (Weak k)\n"
"mkWeakPtr key finalizer = mkWeak key key finalizer\n"
"\n"
"{-|\n"
"  A specialised version of 'mkWeakPtr', where the 'Weak' object\n"
"  returned is simply thrown away (however the finalizer will be\n"
"  remembered by the garbage collector, and will still be run\n"
"  when the key becomes unreachable).\n"
"\n"
"  Note: adding a finalizer to a 'Foreign.ForeignPtr.ForeignPtr' using\n"
"  'addFinalizer' won't work as well as using the specialised version\n"
"  'Foreign.ForeignPtr.addForeignPtrFinalizer' because the latter\n"
"  version adds the finalizer to the primitive 'ForeignPtr#' object\n"
"  inside, whereas the generic 'addFinalizer' will add the finalizer to\n"
"  the box.  Optimisations tend to remove the box, which may cause the\n"
"  finalizer to run earlier than you intended.  The same motivation\n"
"  justifies the existence of\n"
"  'Control.Concurrent.MVar.addMVarFinalizer' and\n"
"  'Data.IORef.mkWeakIORef' (the non-unformity is accidental).\n"
"-}\n"
"addFinalizer :: key -> IO () -> IO ()\n"
"addFinalizer key finalizer = do\n"
"   mkWeakPtr key (Just finalizer)	-- throw it away\n"
"   return ()\n"
"\n"
"-- | A specialised version of 'mkWeak' where the value is actually a pair\n"
"-- of the key and value passed to 'mkWeakPair':\n"
"--\n"
"-- > mkWeakPair key val finalizer = mkWeak key (key,val) finalizer\n"
"--\n"
"-- The advantage of this is that the key can be retrieved by 'deRefWeak'\n"
"-- in addition to the value.\n"
"mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k,v))\n"
"mkWeakPair key val finalizer = mkWeak key (key,val) finalizer\n"
"\n"
"weakTc = mkTyCon \"Weak\"; instance Typeable a => Typeable (Weak a) where {   typeOf x = mkAppTy weakTc [typeOf ((undefined :: Weak a -> a) x) ] }\n"
"\n"
"{- $precise\n"
"\n"
"The above informal specification is fine for simple situations, but\n"
"matters can get complicated.  In particular, it needs to be clear\n"
"exactly when a key dies, so that any weak pointers that refer to it\n"
"can be finalized.  Suppose, for example, the value of one weak pointer\n"
"refers to the key of another...does that keep the key alive?\n"
"\n"
"The behaviour is simply this:\n"
"\n"
" *  If a weak pointer (object) refers to an /unreachable/\n"
"    key, it may be finalized.\n"
"\n"
" *  Finalization means (a) arrange that subsequent calls\n"
"    to 'deRefWeak' return 'Nothing'; and (b) run the finalizer.\n"
"\n"
"This behaviour depends on what it means for a key to be reachable.\n"
"Informally, something is reachable if it can be reached by following\n"
"ordinary pointers from the root set, but not following weak pointers.\n"
"We define reachability more precisely as follows A heap object is\n"
"reachable if:\n"
"\n"
" * It is a member of the /root set/.\n"
"\n"
" * It is directly pointed to by a reachable object, other than\n"
"   a weak pointer object.\n"
"\n"
" * It is a weak pointer object whose key is reachable.\n"
"\n"
" * It is the value or finalizer of an object whose key is reachable.\n"
"-}\n";
const char *System_Console_GetOpt = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  System.Console.GetOpt\n"
"-- Copyright   :  (c) Sven Panne Oct. 1996 (small changes Feb. 2003)\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  libraries@haskell.org\n"
"-- Stability   :  experimental\n"
"-- Portability :  portable\n"
"--\n"
"-- This library provides facilities for parsing the command-line options\n"
"-- in a standalone program.  It is essentially a Haskell port of the GNU \n"
"-- @getopt@ library.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"{-\n"
"Sven Panne <Sven.Panne@informatik.uni-muenchen.de> Oct. 1996 (small\n"
"changes Dec. 1997)\n"
"\n"
"Two rather obscure features are missing: The Bash 2.0 non-option hack\n"
"(if you don't already know it, you probably don't want to hear about\n"
"it...) and the recognition of long options with a single dash\n"
"(e.g. '-help' is recognised as '--help', as long as there is no short\n"
"option 'h').\n"
"\n"
"Other differences between GNU's getopt and this implementation:\n"
"\n"
"* To enforce a coherent description of options and arguments, there\n"
"  are explanation fields in the option/argument descriptor.\n"
"\n"
"* Error messages are now more informative, but no longer POSIX\n"
"  compliant... :-(\n"
"\n"
"And a final Haskell advertisement: The GNU C implementation uses well\n"
"over 1100 lines, we need only 195 here, including a 46 line example! \n"
":-)\n"
"-}\n"
"\n"
"module System.Console.GetOpt (\n"
"	-- * GetOpt\n"
"	getOpt,\n"
"	usageInfo,\n"
"	ArgOrder(..),\n"
"	OptDescr(..),\n"
"	ArgDescr(..),\n"
"\n"
"	-- * Example\n"
"		\n"
"	-- $example\n"
"  ) where\n"
"\n"
"import Prelude\n"
"import Data.List 	( isPrefixOf )\n"
"\n"
"-- |What to do with options following non-options\n"
"data ArgOrder a\n"
"  = RequireOrder                -- ^ no option processing after first non-option\n"
"  | Permute                     -- ^ freely intersperse options and non-options\n"
"  | ReturnInOrder (String -> a) -- ^ wrap non-options into options\n"
"\n"
"{-|\n"
"Each 'OptDescr' describes a single option.\n"
"\n"
"The arguments to 'Option' are:\n"
"\n"
"* list of short option characters\n"
"\n"
"* list of long option strings (without \\\"--\\\")\n"
"\n"
"* argument descriptor\n"
"\n"
"* explanation of option for user\n"
"-}\n"
"data OptDescr a =              -- description of a single options:\n"
"   Option [Char]                --    list of short option characters\n"
"          [String]              --    list of long option strings (without \"--\")\n"
"          (ArgDescr a)          --    argument descriptor\n"
"          String                --    explanation of option for user\n"
"\n"
"-- |Describes whether an option takes an argument or not, and if so\n"
"-- how the argument is injected into a value of type @a@.\n"
"data ArgDescr a\n"
"   = NoArg                   a         -- ^   no argument expected\n"
"   | ReqArg (String       -> a) String -- ^   option requires argument\n"
"   | OptArg (Maybe String -> a) String -- ^   optional argument\n"
"\n"
"data OptKind a                -- kind of cmd line arg (internal use only):\n"
"   = Opt       a                --    an option\n"
"   | NonOpt    String           --    a non-option\n"
"   | EndOfOpts                  --    end-of-options marker (i.e. \"--\")\n"
"   | OptErr    String           --    something went wrong...\n"
"\n"
"-- | Return a string describing the usage of a command, derived from\n"
"-- the header (first argument) and the options described by the \n"
"-- second argument.\n"
"usageInfo :: String                    -- header\n"
"          -> [OptDescr a]              -- option descriptors\n"
"          -> String                    -- nicely formatted decription of options\n"
"usageInfo header optDescr = unlines (header:table)\n"
"   where (ss,ls,ds)     = (unzip3 . map fmtOpt) optDescr\n"
"         table          = zipWith3 paste (sameLen ss) (sameLen ls) ds\n"
"         paste x y z    = \"  \" ++ x ++ \"  \" ++ y ++ \"  \" ++ z\n"
"         sameLen xs     = flushLeft ((maximum . map length) xs) xs\n"
"         flushLeft n xs = [ take n (x ++ repeat ' ') | x <- xs ]\n"
"\n"
"fmtOpt :: OptDescr a -> (String,String,String)\n"
"fmtOpt (Option sos los ad descr) = (sepBy ',' (map (fmtShort ad) sos),\n"
"                                    sepBy ',' (map (fmtLong  ad) los),\n"
"                                    descr)\n"
"   where sepBy _  []     = \"\"\n"
"         sepBy _  [x]    = x\n"
"         sepBy ch (x:xs) = x ++ ch:' ':sepBy ch xs\n"
"\n"
"fmtShort :: ArgDescr a -> Char -> String\n"
"fmtShort (NoArg  _   ) so = \"-\" ++ [so]\n"
"fmtShort (ReqArg _ ad) so = \"-\" ++ [so] ++ \" \" ++ ad\n"
"fmtShort (OptArg _ ad) so = \"-\" ++ [so] ++ \"[\" ++ ad ++ \"]\"\n"
"\n"
"fmtLong :: ArgDescr a -> String -> String\n"
"fmtLong (NoArg  _   ) lo = \"--\" ++ lo\n"
"fmtLong (ReqArg _ ad) lo = \"--\" ++ lo ++ \"=\" ++ ad\n"
"fmtLong (OptArg _ ad) lo = \"--\" ++ lo ++ \"[=\" ++ ad ++ \"]\"\n"
"\n"
"{-|\n"
"Process the command-line, and return the list of values that matched\n"
"(and those that didn\\'t). The arguments are:\n"
"\n"
"* The order requirements (see 'ArgOrder')\n"
"\n"
"* The option descriptions (see 'OptDescr')\n"
"\n"
"* The actual command line arguments (presumably got from \n"
"  'System.Environment.getArgs').\n"
"\n"
"'getOpt' returns a triple, consisting of the argument values, a list\n"
"of options that didn\\'t match, and a list of error messages.\n"
"-}\n"
"getOpt :: ArgOrder a                   -- non-option handling\n"
"       -> [OptDescr a]                 -- option descriptors\n"
"       -> [String]                     -- the commandline arguments\n"
"       -> ([a],[String],[String])      -- (options,non-options,error messages)\n"
"getOpt _        _        []         =  ([],[],[])\n"
"getOpt ordering optDescr (arg:args) = procNextOpt opt ordering\n"
"   where procNextOpt (Opt o)    _                 = (o:os,xs,es)\n"
"         procNextOpt (NonOpt x) RequireOrder      = ([],x:rest,[])\n"
"         procNextOpt (NonOpt x) Permute           = (os,x:xs,es)\n"
"         procNextOpt (NonOpt x) (ReturnInOrder f) = (f x :os, xs,es)\n"
"         procNextOpt EndOfOpts  RequireOrder      = ([],rest,[])\n"
"         procNextOpt EndOfOpts  Permute           = ([],rest,[])\n"
"         procNextOpt EndOfOpts  (ReturnInOrder f) = (map f rest,[],[])\n"
"         procNextOpt (OptErr e) _                 = (os,xs,e:es)\n"
"\n"
"         (opt,rest) = getNext arg args optDescr\n"
"         (os,xs,es) = getOpt ordering optDescr rest\n"
"\n"
"-- take a look at the next cmd line arg and decide what to do with it\n"
"getNext :: String -> [String] -> [OptDescr a] -> (OptKind a,[String])\n"
"getNext ('-':'-':[]) rest _        = (EndOfOpts,rest)\n"
"getNext ('-':'-':xs) rest optDescr = longOpt xs rest optDescr\n"
"getNext ('-': x :xs) rest optDescr = shortOpt x xs rest optDescr\n"
"getNext a            rest _        = (NonOpt a,rest)\n"
"\n"
"-- handle long option\n"
"longOpt :: String -> [String] -> [OptDescr a] -> (OptKind a,[String])\n"
"longOpt ls rs optDescr = long ads arg rs\n"
"   where (opt,arg) = break (=='=') ls\n"
"         getWith p = [ o  | o@(Option _ ls _ _) <- optDescr, l <- ls, opt `p` l ]\n"
"         exact     = getWith (==)\n"
"         options   = if null exact then getWith isPrefixOf else exact\n"
"         ads       = [ ad | Option _ _ ad _ <- options ]\n"
"         optStr    = (\"--\"++opt)\n"
"\n"
"         long (_:_:_)      _        rest     = (errAmbig options optStr,rest)\n"
"         long [NoArg  a  ] []       rest     = (Opt a,rest)\n"
"         long [NoArg  _  ] ('=':_)  rest     = (errNoArg optStr,rest)\n"
"         long [ReqArg _ d] []       []       = (errReq d optStr,[])\n"
"         long [ReqArg f _] []       (r:rest) = (Opt (f r),rest)\n"
"         long [ReqArg f _] ('=':xs) rest     = (Opt (f xs),rest)\n"
"         long [OptArg f _] []       rest     = (Opt (f Nothing),rest)\n"
"         long [OptArg f _] ('=':xs) rest     = (Opt (f (Just xs)),rest)\n"
"         long _            _        rest     = (errUnrec optStr,rest)\n"
"\n"
"-- handle short option\n"
"shortOpt :: Char -> String -> [String] -> [OptDescr a] -> (OptKind a,[String])\n"
"shortOpt x xs rest optDescr = short ads xs rest\n"
"  where options = [ o  | o@(Option ss _ _ _) <- optDescr, s <- ss, x == s ]\n"
"        ads     = [ ad | Option _ _ ad _ <- options ]\n"
"        optStr  = '-':[x]\n"
"\n"
"        short (_:_:_)        _  rest     = (errAmbig options optStr,rest)\n"
"        short (NoArg  a  :_) [] rest     = (Opt a,rest)\n"
"        short (NoArg  a  :_) xs rest     = (Opt a,('-':xs):rest)\n"
"        short (ReqArg _ d:_) [] []       = (errReq d optStr,[])\n"
"        short (ReqArg f _:_) [] (r:rest) = (Opt (f r),rest)\n"
"        short (ReqArg f _:_) xs rest     = (Opt (f xs),rest)\n"
"        short (OptArg f _:_) [] rest     = (Opt (f Nothing),rest)\n"
"        short (OptArg f _:_) xs rest     = (Opt (f (Just xs)),rest)\n"
"        short []             [] rest     = (errUnrec optStr,rest)\n"
"        short []             xs rest     = (errUnrec optStr,('-':xs):rest)\n"
"\n"
"-- miscellaneous error formatting\n"
"\n"
"errAmbig :: [OptDescr a] -> String -> OptKind a\n"
"errAmbig ods optStr = OptErr (usageInfo header ods)\n"
"   where header = \"option `\" ++ optStr ++ \"' is ambiguous; could be one of:\"\n"
"\n"
"errReq :: String -> String -> OptKind a\n"
"errReq d optStr = OptErr (\"option `\" ++ optStr ++ \"' requires an argument \" ++ d ++ \"\\n\")\n"
"\n"
"errUnrec :: String -> OptKind a\n"
"errUnrec optStr = OptErr (\"unrecognized option `\" ++ optStr ++ \"'\\n\")\n"
"\n"
"errNoArg :: String -> OptKind a\n"
"errNoArg optStr = OptErr (\"option `\" ++ optStr ++ \"' doesn't allow an argument\\n\")\n"
"\n"
"{-\n"
"-----------------------------------------------------------------------------------------\n"
"-- and here a small and hopefully enlightening example:\n"
"\n"
"data Flag = Verbose | Version | Name String | Output String | Arg String   deriving Show\n"
"\n"
"options :: [OptDescr Flag]\n"
"options =\n"
"   [Option ['v']     [\"verbose\"]           (NoArg Verbose)      \"verbosely list files\",\n"
"    Option ['V','?'] [\"version\",\"release\"] (NoArg Version)      \"show version info\",\n"
"    Option ['o']     [\"output\"]            (OptArg out \"FILE\")  \"use FILE for dump\",\n"
"    Option ['n']     [\"name\"]              (ReqArg Name \"USER\") \"only dump USER's files\"]\n"
"\n"
"out :: Maybe String -> Flag\n"
"out Nothing  = Output \"stdout\"\n"
"out (Just o) = Output o\n"
"\n"
"test :: ArgOrder Flag -> [String] -> String\n"
"test order cmdline = case getOpt order options cmdline of\n"
"                        (o,n,[]  ) -> \"options=\" ++ show o ++ \"  args=\" ++ show n ++ \"\\n\"\n"
"                        (_,_,errs) -> concat errs ++ usageInfo header options\n"
"   where header = \"Usage: foobar [OPTION...] files...\"\n"
"\n"
"-- example runs:\n"
"-- putStr (test RequireOrder [\"foo\",\"-v\"])\n"
"--    ==> options=[]  args=[\"foo\", \"-v\"]\n"
"-- putStr (test Permute [\"foo\",\"-v\"])\n"
"--    ==> options=[Verbose]  args=[\"foo\"]\n"
"-- putStr (test (ReturnInOrder Arg) [\"foo\",\"-v\"])\n"
"--    ==> options=[Arg \"foo\", Verbose]  args=[]\n"
"-- putStr (test Permute [\"foo\",\"--\",\"-v\"])\n"
"--    ==> options=[]  args=[\"foo\", \"-v\"]\n"
"-- putStr (test Permute [\"-?o\",\"--name\",\"bar\",\"--na=baz\"])\n"
"--    ==> options=[Version, Output \"stdout\", Name \"bar\", Name \"baz\"]  args=[]\n"
"-- putStr (test Permute [\"--ver\",\"foo\"])\n"
"--    ==> option `--ver' is ambiguous; could be one of:\n"
"--          -v      --verbose             verbosely list files\n"
"--          -V, -?  --version, --release  show version info   \n"
"--        Usage: foobar [OPTION...] files...\n"
"--          -v        --verbose             verbosely list files  \n"
"--          -V, -?    --version, --release  show version info     \n"
"--          -o[FILE]  --output[=FILE]       use FILE for dump     \n"
"--          -n USER   --name=USER           only dump USER's files\n"
"-----------------------------------------------------------------------------------------\n"
"-}\n"
"\n"
"{- $example\n"
"\n"
"To hopefully illuminate the role of the different data\n"
"structures, here\\'s the command-line options for a (very simple)\n"
"compiler:\n"
"\n"
">    module Opts where\n"
">    \n"
">    import System.Console.GetOpt\n"
">    import Data.Maybe ( fromMaybe )\n"
">    \n"
">    data Flag \n"
">     = Verbose  | Version \n"
">     | Input String | Output String | LibDir String\n"
">    	deriving Show\n"
">    \n"
">    options :: [OptDescr Flag]\n"
">    options =\n"
">     [ Option ['v']     [\"verbose\"] (NoArg Verbose)       \"chatty output on stderr\"\n"
">     , Option ['V','?'] [\"version\"] (NoArg Version)       \"show version number\"\n"
">     , Option ['o']     [\"output\"]  (OptArg outp \"FILE\")  \"output FILE\"\n"
">     , Option ['c']     []          (OptArg inp  \"FILE\")  \"input FILE\"\n"
">     , Option ['L']     [\"libdir\"]  (ReqArg LibDir \"DIR\") \"library directory\"\n"
">     ]\n"
">    \n"
">    inp,outp :: Maybe String -> Flag\n"
">    outp = Output . fromMaybe \"stdout\"\n"
">    inp  = Input  . fromMaybe \"stdout\"\n"
">    \n"
">    compilerOpts :: [String] -> IO ([Flag], [String])\n"
">    compilerOpts argv = \n"
">    	case (getOpt Permute options argv) of\n"
">    	   (o,n,[]  ) -> return (o,n)\n"
">    	   (_,_,errs) -> ioError (userError (concat errs ++ usageInfo header options))\n"
">      where header = \"Usage: ic [OPTION...] files...\"\n"
"\n"
"-}\n";
const char *Foreign_C = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.C\n"
"-- Copyright   :  (c) The FFI task force 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Bundles the C specific FFI library functionality\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.C\n"
"        ( module Foreign.C.Types\n"
"	, module Foreign.C.String\n"
"	, module Foreign.C.Error\n"
"        ) where\n"
"\n"
"import Foreign.C.Types\n"
"import Foreign.C.String\n"
"import Foreign.C.Error\n";
const char *Foreign_ForeignPtr = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.ForeignPtr\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- The 'ForeignPtr' type and operations.  This module is part of the\n"
"-- Foreign Function Interface (FFI) and will usually be imported via\n"
"-- the \"Foreign\" module.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.ForeignPtr\n"
"        ( \n"
"	-- * Finalised data pointers\n"
"	  ForeignPtr\n"
"	, FinalizerPtr\n"
"	, FinalizerEnvPtr\n"
"	-- ** Basic operations\n"
"        , newForeignPtr\n"
"        , newForeignPtr_\n"
"        , addForeignPtrFinalizer\n"
"	, newForeignPtrEnv\n"
"	, addForeignPtrFinalizerEnv\n"
"	, withForeignPtr\n"
"\n"
"	-- ** Low-level operations\n"
"	, unsafeForeignPtrToPtr\n"
"	, touchForeignPtr\n"
"	, castForeignPtr\n"
"\n"
"	-- ** Allocating managed memory\n"
"	, mallocForeignPtr\n"
"	, mallocForeignPtrBytes\n"
"	, mallocForeignPtrArray\n"
"	, mallocForeignPtrArray0\n"
"        ) \n"
"	where\n"
"\n"
"import Foreign.Ptr\n"
"\n"
"import Hugs.ForeignPtr\n"
"\n"
"import Foreign.Storable	( Storable(sizeOf) )\n"
"\n"
"import Foreign.Marshal.Alloc	( malloc, mallocBytes, finalizerFree )\n"
"import Data.Typeable\n"
"\n"
"foreignPtrTc = mkTyCon \"ForeignPtr\"; instance Typeable a => Typeable (ForeignPtr a) where {   typeOf x = mkAppTy foreignPtrTc [typeOf ((undefined :: ForeignPtr a -> a) x) ] }\n"
"\n"
"instance Eq (ForeignPtr a) where \n"
"    p == q  =  unsafeForeignPtrToPtr p == unsafeForeignPtrToPtr q\n"
"\n"
"instance Ord (ForeignPtr a) where \n"
"    compare p q  =  compare (unsafeForeignPtrToPtr p) (unsafeForeignPtrToPtr q)\n"
"\n"
"instance Show (ForeignPtr a) where\n"
"    showsPrec p f = showsPrec p (unsafeForeignPtrToPtr f)\n"
"\n"
"newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)\n"
"-- ^Turns a plain memory reference into a foreign pointer, and\n"
"-- associates a finaliser with the reference.  The finaliser will be executed\n"
"-- after the last reference to the foreign object is dropped.  Note that there\n"
"-- is no guarantee on how soon the finaliser is executed after the last\n"
"-- reference was dropped; this depends on the details of the Haskell storage\n"
"-- manager. The only guarantee is that the finaliser runs before the program\n"
"-- terminates.\n"
"newForeignPtr finalizer p\n"
"  = do fObj <- newForeignPtr_ p\n"
"       addForeignPtrFinalizer finalizer fObj\n"
"       return fObj\n"
"\n"
"withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b\n"
"-- ^This is a way to look at the pointer living inside a\n"
"-- foreign object.  This function takes a function which is\n"
"-- applied to that pointer. The resulting 'IO' action is then\n"
"-- executed. The foreign object is kept alive at least during\n"
"-- the whole action, even if it is not used directly\n"
"-- inside. Note that it is not safe to return the pointer from\n"
"-- the action and use it after the action completes. All uses\n"
"-- of the pointer should be inside the\n"
"-- 'withForeignPtr' bracket.  The reason for\n"
"-- this unsafety is the same as for\n"
"-- 'unsafeForeignPtrToPtr' below: the finalizer\n"
"-- may run earlier than expected, because the compiler can only\n"
"-- track usage of the 'ForeignPtr' object, not\n"
"-- a 'Ptr' object made from it.\n"
"--\n"
"-- This function is normally used for marshalling data to\n"
"-- or from the object pointed to by the\n"
"-- 'ForeignPtr', using the operations from the\n"
"-- 'Storable' class.\n"
"withForeignPtr fo io\n"
"  = do r <- io (unsafeForeignPtrToPtr fo)\n"
"       touchForeignPtr fo\n"
"       return r\n"
"\n"
"-- | This variant of 'newForeignPtr' adds a finalizer that expects an\n"
"-- environment in addition to the finalized pointer.  The environment\n"
"-- that will be passed to the finalizer is fixed by the second argument to\n"
"-- 'newForeignPtrEnv'.\n"
"newForeignPtrEnv ::\n"
"    FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)\n"
"newForeignPtrEnv finalizer env p\n"
"  = do fObj <- newForeignPtr_ p\n"
"       addForeignPtrFinalizerEnv finalizer env fObj\n"
"       return fObj\n"
"\n"
"mallocForeignPtr :: Storable a => IO (ForeignPtr a)\n"
"mallocForeignPtr = do\n"
"  r <- malloc\n"
"  newForeignPtr finalizerFree r\n"
"\n"
"mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)\n"
"mallocForeignPtrBytes n = do\n"
"  r <- mallocBytes n\n"
"  newForeignPtr finalizerFree r\n"
"\n"
"-- | This function is similar to 'Foreign.Marshal.Array.mallocArray',\n"
"-- but yields a memory area that has a finalizer attached that releases\n"
"-- the memory area.  As with 'mallocForeignPtr', it is not guaranteed that\n"
"-- the block of memory was allocated by 'Foreign.Marshal.Alloc.malloc'.\n"
"mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)\n"
"mallocForeignPtrArray  = doMalloc undefined\n"
"  where\n"
"    doMalloc            :: Storable a => a -> Int -> IO (ForeignPtr a)\n"
"    doMalloc dummy size  = mallocForeignPtrBytes (size * sizeOf dummy)\n"
"\n"
"-- | This function is similar to 'Foreign.Marshal.Array.mallocArray0',\n"
"-- but yields a memory area that has a finalizer attached that releases\n"
"-- the memory area.  As with 'mallocForeignPtr', it is not guaranteed that\n"
"-- the block of memory was allocated by 'Foreign.Marshal.Alloc.malloc'.\n"
"mallocForeignPtrArray0      :: Storable a => Int -> IO (ForeignPtr a)\n"
"mallocForeignPtrArray0 size  = mallocForeignPtrArray (size + 1)\n";
const char *Foreign_Marshal = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.Marshal\n"
"-- Copyright   :  (c) The FFI task force 2003\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Marshalling support\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.Marshal\n"
"        ( module Foreign.Marshal.Alloc\n"
"        , module Foreign.Marshal.Array\n"
"        , module Foreign.Marshal.Error\n"
"        , module Foreign.Marshal.Pool\n"
"        , module Foreign.Marshal.Utils\n"
"        ) where\n"
"\n"
"import Foreign.Marshal.Alloc\n"
"import Foreign.Marshal.Array\n"
"import Foreign.Marshal.Error\n"
"import Foreign.Marshal.Pool\n"
"import Foreign.Marshal.Utils\n";
const char *Foreign_Ptr = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.Ptr\n"
"-- Copyright   :  (c) The FFI task force 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- This module provides typed pointers to foreign data.  It is part\n"
"-- of the Foreign Function Interface (FFI) and will normally be\n"
"-- imported via the \"Foreign\" module.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.Ptr (\n"
"\n"
"    -- * Data pointers\n"
"    \n"
"    Ptr,      -- data Ptr a\n"
"    nullPtr,      -- :: Ptr a\n"
"    castPtr,      -- :: Ptr a -> Ptr b\n"
"    plusPtr,      -- :: Ptr a -> Int -> Ptr b\n"
"    alignPtr,     -- :: Ptr a -> Int -> Ptr a\n"
"    minusPtr,     -- :: Ptr a -> Ptr b -> Int\n"
"    \n"
"    -- * Function pointers\n"
"    \n"
"    FunPtr,      -- data FunPtr a\n"
"    nullFunPtr,      -- :: FunPtr a\n"
"    castFunPtr,      -- :: FunPtr a -> FunPtr b\n"
"    castFunPtrToPtr, -- :: FunPtr a -> Ptr b\n"
"    castPtrToFunPtr, -- :: Ptr a -> FunPtr b\n"
"    \n"
"    freeHaskellFunPtr, -- :: FunPtr a -> IO ()\n"
"    -- Free the function pointer created by foreign export dynamic.\n"
"\n"
" ) where\n"
"\n"
"import Hugs.Ptr\n"
"\n";
const char *Foreign_Storable = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.Storable\n"
"-- Copyright   :  (c) The FFI task force 2001\n"
"-- License     :  see libraries/base/LICENSE\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- The module \"Foreign.Storable\" provides most elementary support for\n"
"-- marshalling and is part of the language-independent portion of the\n"
"-- Foreign Function Interface (FFI), and will normally be imported via\n"
"-- the \"Foreign\" module.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.Storable\n"
"	( Storable(\n"
"	     sizeOf,         -- :: a -> Int\n"
"	     alignment,      -- :: a -> Int\n"
"	     peekElemOff,    -- :: Ptr a -> Int      -> IO a\n"
"	     pokeElemOff,    -- :: Ptr a -> Int -> a -> IO ()\n"
"	     peekByteOff,    -- :: Ptr b -> Int      -> IO a\n"
"	     pokeByteOff,    -- :: Ptr b -> Int -> a -> IO ()\n"
"	     peek,           -- :: Ptr a             -> IO a\n"
"	     poke)           -- :: Ptr a        -> a -> IO ()\n"
"        ) where\n"
"\n"
"import Control.Monad		( liftM )\n"
"\n"
"import Data.Int\n"
"import Data.Word\n"
"import Foreign.Ptr\n"
"import Foreign.StablePtr\n"
"\n"
"import Hugs.Prelude\n"
"import Hugs.Storable\n"
"\n"
"{- |\n"
"The member functions of this class facilitate writing values of\n"
"primitive types to raw memory (which may have been allocated with the\n"
"above mentioned routines) and reading values from blocks of raw\n"
"memory.  The class, furthermore, includes support for computing the\n"
"storage requirements and alignment restrictions of storable types.\n"
"\n"
"Memory addresses are represented as values of type @'Ptr' a@, for some\n"
"@a@ which is an instance of class 'Storable'.  The type argument to\n"
"'Ptr' helps provide some valuable type safety in FFI code (you can\\'t\n"
"mix pointers of different types without an explicit cast), while\n"
"helping the Haskell type system figure out which marshalling method is\n"
"needed for a given pointer.\n"
"\n"
"All marshalling between Haskell and a foreign language ultimately\n"
"boils down to translating Haskell data structures into the binary\n"
"representation of a corresponding data structure of the foreign\n"
"language and vice versa.  To code this marshalling in Haskell, it is\n"
"necessary to manipulate primtive data types stored in unstructured\n"
"memory blocks.  The class 'Storable' facilitates this manipulation on\n"
"all types for which it is instantiated, which are the standard basic\n"
"types of Haskell, the fixed size @Int@ types ('Int8', 'Int16',\n"
"'Int32', 'Int64'), the fixed size @Word@ types ('Word8', 'Word16',\n"
"'Word32', 'Word64'), 'StablePtr', all types from \"Foreign.C.Types\",\n"
"as well as 'Ptr'.\n"
"\n"
"Minimal complete definition: 'sizeOf', 'alignment', one of 'peek',\n"
"'peekElemOff' and 'peekByteOff', and one of 'poke', 'pokeElemOff' and\n"
"'pokeByteOff'.\n"
"-}\n"
"\n"
"class Storable a where\n"
"\n"
"   sizeOf      :: a -> Int\n"
"   -- ^ Computes the storage requirements (in bytes) of the argument.\n"
"   -- The value of the argument is not used.\n"
"\n"
"   alignment   :: a -> Int\n"
"   -- ^ Computes the alignment constraint of the argument.  An\n"
"   -- alignment constraint @x@ is fulfilled by any address divisible\n"
"   -- by @x@.  The value of the argument is not used.\n"
"\n"
"   peekElemOff :: Ptr a -> Int      -> IO a\n"
"   -- ^       Read a value from a memory area regarded as an array\n"
"   --         of values of the same kind.  The first argument specifies\n"
"   --         the start address of the array and the second the index into\n"
"   --         the array (the first element of the array has index\n"
"   --         @0@).  The following equality holds,\n"
"   -- \n"
"   -- > peekElemOff addr idx = IOExts.fixIO $ \\result ->\n"
"   -- >   peek (addr `plusPtr` (idx * sizeOf result))\n"
"   --\n"
"   --         Note that this is only a specification, not\n"
"   --         necessarily the concrete implementation of the\n"
"   --         function.\n"
"\n"
"   pokeElemOff :: Ptr a -> Int -> a -> IO ()\n"
"   -- ^       Write a value to a memory area regarded as an array of\n"
"   --         values of the same kind.  The following equality holds:\n"
"   -- \n"
"   -- > pokeElemOff addr idx x = \n"
"   -- >   poke (addr `plusPtr` (idx * sizeOf x)) x\n"
"\n"
"   peekByteOff :: Ptr b -> Int      -> IO a\n"
"   -- ^       Read a value from a memory location given by a base\n"
"   --         address and offset.  The following equality holds:\n"
"   --\n"
"   -- > peekByteOff addr off = peek (addr `plusPtr` off)\n"
"\n"
"   pokeByteOff :: Ptr b -> Int -> a -> IO ()\n"
"   -- ^       Write a value to a memory location given by a base\n"
"   --         address and offset.  The following equality holds:\n"
"   --\n"
"   -- > pokeByteOff addr off x = poke (addr `plusPtr` off) x\n"
"  \n"
"   peek        :: Ptr a      -> IO a\n"
"   -- ^ Read a value from the given memory location.\n"
"   --\n"
"   --  Note that the peek and poke functions might require properly\n"
"   --  aligned addresses to function correctly.  This is architecture\n"
"   --  dependent; thus, portable code should ensure that when peeking or\n"
"   --  poking values of some type @a@, the alignment\n"
"   --  constraint for @a@, as given by the function\n"
"   --  'alignment' is fulfilled.\n"
"\n"
"   poke        :: Ptr a -> a -> IO ()\n"
"   -- ^ Write the given value to the given memory location.  Alignment\n"
"   -- restrictions might apply; see 'peek'.\n"
" \n"
"   -- circular default instances\n"
"   peekElemOff ptr off = peekByteOff ptr (off * sizeOfPtr ptr undefined)\n"
"   pokeElemOff ptr off val = pokeByteOff ptr (off * sizeOf val) val\n"
"\n"
"   peekByteOff ptr off = peek (ptr `plusPtr` off)\n"
"   pokeByteOff ptr off = poke (ptr `plusPtr` off)\n"
"\n"
"   peek ptr = peekElemOff ptr 0\n"
"   poke ptr = pokeElemOff ptr 0\n"
"\n"
"sizeOfPtr :: Storable a => Ptr a -> a -> Int\n"
"sizeOfPtr px x = sizeOf x\n"
"\n"
"-- System-dependent, but rather obvious instances\n"
"\n"
"instance Storable Bool where\n"
"   sizeOf _          = sizeOf (undefined::Int32)\n"
"   alignment _       = alignment (undefined::Int32)\n"
"   peekElemOff p i   = liftM (/= (0::Int32)) $ peekElemOff (castPtr p) i\n"
"   pokeElemOff p i x = pokeElemOff (castPtr p) i (if x then 1 else 0::Int32)\n"
"\n"
"instance Storable (Char) where {			    sizeOf    _ = 4;				    alignment _ = 4;			    peekElemOff =  	 readCharOffPtr;				    pokeElemOff = writeCharOffPtr }\n"
"\n"
"instance Storable (Int) where {			    sizeOf    _ = 4;				    alignment _ = 4;			    peekElemOff =  	 readIntOffPtr;				    pokeElemOff = writeIntOffPtr }\n"
"\n"
"instance Storable ((Ptr a)) where {			    sizeOf    _ = 8;				    alignment _ = 8;			    peekElemOff =  	 readPtrOffPtr;				    pokeElemOff = writePtrOffPtr }\n"
"\n"
"instance Storable ((FunPtr a)) where {			    sizeOf    _ = 8;				    alignment _ = 8;			    peekElemOff =  	 readFunPtrOffPtr;				    pokeElemOff = writeFunPtrOffPtr }\n"
"\n"
"instance Storable ((StablePtr a)) where {			    sizeOf    _ = 8;				    alignment _ = 8;			    peekElemOff =  	 readStablePtrOffPtr;				    pokeElemOff = writeStablePtrOffPtr }\n"
"\n"
"instance Storable (Float) where {			    sizeOf    _ = 4;				    alignment _ = 4;			    peekElemOff =  	 readFloatOffPtr;				    pokeElemOff = writeFloatOffPtr }\n"
"\n"
"instance Storable (Double) where {			    sizeOf    _ = 8;				    alignment _ = 8;			    peekElemOff =  	 readDoubleOffPtr;				    pokeElemOff = writeDoubleOffPtr }\n"
"\n"
"instance Storable (Word8) where {			    sizeOf    _ = 1;				    alignment _ = 1;			    peekElemOff =  	 readWord8OffPtr;				    pokeElemOff = writeWord8OffPtr }\n"
"\n"
"instance Storable (Word16) where {			    sizeOf    _ = 2;				    alignment _ = 2;			    peekElemOff =  	 readWord16OffPtr;				    pokeElemOff = writeWord16OffPtr }\n"
"\n"
"instance Storable (Word32) where {			    sizeOf    _ = 4;				    alignment _ = 4;			    peekElemOff =  	 readWord32OffPtr;				    pokeElemOff = writeWord32OffPtr }\n"
"\n"
"instance Storable (Word64) where {			    sizeOf    _ = 8;				    alignment _ = 8;			    peekElemOff =  	 readWord64OffPtr;				    pokeElemOff = writeWord64OffPtr }\n"
"\n"
"instance Storable (Int8) where {			    sizeOf    _ = 1;				    alignment _ = 1;			    peekElemOff =  	 readInt8OffPtr;				    pokeElemOff = writeInt8OffPtr }\n"
"\n"
"instance Storable (Int16) where {			    sizeOf    _ = 2;				    alignment _ = 2;			    peekElemOff =  	 readInt16OffPtr;				    pokeElemOff = writeInt16OffPtr }\n"
"\n"
"instance Storable (Int32) where {			    sizeOf    _ = 4;				    alignment _ = 4;			    peekElemOff =  	 readInt32OffPtr;				    pokeElemOff = writeInt32OffPtr }\n"
"\n"
"instance Storable (Int64) where {			    sizeOf    _ = 8;				    alignment _ = 8;			    peekElemOff =  	 readInt64OffPtr;				    pokeElemOff = writeInt64OffPtr }\n"
"\n";
const char *Foreign_StablePtr = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.StablePtr\n"
"-- Copyright   :  (c) The University of Glasgow 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- This module is part of the Foreign Function Interface (FFI) and will usually\n"
"-- be imported via the module \"Foreign\".\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.StablePtr\n"
"        ( -- * Stable references to Haskell values\n"
"	  StablePtr          -- abstract\n"
"        , newStablePtr       -- :: a -> IO (StablePtr a)\n"
"        , deRefStablePtr     -- :: StablePtr a -> IO a\n"
"        , freeStablePtr      -- :: StablePtr a -> IO ()\n"
"        , castStablePtrToPtr -- :: StablePtr a -> Ptr ()\n"
"        , castPtrToStablePtr -- :: Ptr () -> StablePtr a\n"
"	, -- ** The C-side interface\n"
"\n"
"	  -- $cinterface\n"
"        ) where\n"
"\n"
"import Hugs.StablePtr\n"
"\n"
"-- $cinterface\n"
"--\n"
"-- The following definition is available to C programs inter-operating with\n"
"-- Haskell code when including the header @HsFFI.h@.\n"
"--\n"
"-- > typedef void *HsStablePtr;  \n"
"--\n"
"-- Note that no assumptions may be made about the values representing stable\n"
"-- pointers.  In fact, they need not even be valid memory addresses.  The only\n"
"-- guarantee provided is that if they are passed back to Haskell land, the\n"
"-- function 'deRefStablePtr' will be able to reconstruct the\n"
"-- Haskell value refereed to by the stable pointer.\n";
const char *Foreign_Marshal_Alloc = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.Marshal.Alloc\n"
"-- Copyright   :  (c) The FFI task force 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Marshalling support: basic routines for memory allocation\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.Marshal.Alloc (\n"
"  -- * Allocation\n"
"  malloc,       -- :: Storable a =>        IO (Ptr a)\n"
"  mallocBytes,  -- ::               Int -> IO (Ptr a)\n"
"\n"
"  alloca,       -- :: Storable a =>        (Ptr a -> IO b) -> IO b\n"
"  allocaBytes,  -- ::               Int -> (Ptr a -> IO b) -> IO b\n"
"\n"
"  realloc,      -- :: Storable b => Ptr a        -> IO (Ptr b)\n"
"  reallocBytes, -- ::		    Ptr a -> Int -> IO (Ptr a)\n"
"\n"
"  free,         -- :: Ptr a -> IO ()\n"
"  finalizerFree -- :: FinalizerPtr a\n"
") where\n"
"\n"
"import Data.Maybe\n"
"import Foreign.Ptr	 	( Ptr, nullPtr, FunPtr )\n"
"import Foreign.C.Types	 	( CSize )\n"
"import Foreign.Storable  	( Storable(sizeOf) )\n"
"\n"
"import Control.Exception	( bracket )\n"
"\n"
"import Hugs.ForeignPtr		( FinalizerPtr )\n"
"\n"
"-- exported functions\n"
"-- ------------------\n"
"\n"
"-- |Allocate space for storable type.  The size of the area allocated\n"
"-- is determined by the 'sizeOf' method from the instance of\n"
"-- 'Storable' for the appropriate type.\n"
"--\n"
"malloc :: Storable a => IO (Ptr a)\n"
"malloc  = doMalloc undefined\n"
"  where\n"
"    doMalloc       :: Storable a => a -> IO (Ptr a)\n"
"    doMalloc dummy  = mallocBytes (sizeOf dummy)\n"
"\n"
"-- |Allocate given number of bytes of storage, equivalent to C\\'s @malloc()@.\n"
"--\n"
"mallocBytes      :: Int -> IO (Ptr a)\n"
"mallocBytes size  = failWhenNULL \"malloc\" (_malloc (fromIntegral size))\n"
"\n"
"-- |Temporarily allocate space for a storable type.\n"
"--\n"
"-- * the pointer passed as an argument to the function must /not/ escape from\n"
"--   this function; in other words, in @alloca f@ the allocated storage must\n"
"--   not be used after @f@ returns\n"
"--\n"
"alloca :: Storable a => (Ptr a -> IO b) -> IO b\n"
"alloca  = doAlloca undefined\n"
"  where\n"
"    doAlloca       :: Storable a => a -> (Ptr a -> IO b) -> IO b\n"
"    doAlloca dummy  = allocaBytes (sizeOf dummy)\n"
"\n"
"-- |Temporarily allocate the given number of bytes of storage.\n"
"--\n"
"-- * the pointer passed as an argument to the function must /not/ escape from\n"
"--   this function; in other words, in @allocaBytes n f@ the allocated storage\n"
"--   must not be used after @f@ returns\n"
"--\n"
"allocaBytes      :: Int -> (Ptr a -> IO b) -> IO b\n"
"allocaBytes size  = bracket (mallocBytes size) free\n"
"\n"
"-- |Adjust a malloc\\'ed storage area to the given size of the required type\n"
"-- (corresponds to C\\'s @realloc()@).\n"
"--\n"
"realloc :: Storable b => Ptr a -> IO (Ptr b)\n"
"realloc  = doRealloc undefined\n"
"  where\n"
"    doRealloc           :: Storable b => b -> Ptr a -> IO (Ptr b)\n"
"    doRealloc dummy ptr  = let\n"
"			     size = fromIntegral (sizeOf dummy)\n"
"			   in\n"
"			   failWhenNULL \"realloc\" (_realloc ptr size)\n"
"\n"
"-- |Adjust a malloc\\'ed storage area to the given size (equivalent to\n"
"-- C\\'s @realloc()@).\n"
"--\n"
"reallocBytes          :: Ptr a -> Int -> IO (Ptr a)\n"
"reallocBytes ptr 0     = do free ptr; return nullPtr\n"
"reallocBytes ptr size  = \n"
"  failWhenNULL \"realloc\" (_realloc ptr (fromIntegral size))\n"
"\n"
"-- |Free malloc\\'ed storage (equivalent to\n"
"-- C\\'s @free()@)\n"
"--\n"
"free :: Ptr a -> IO ()\n"
"free  = _free\n"
"\n"
"-- auxilliary routines\n"
"-- -------------------\n"
"\n"
"-- asserts that the pointer returned from the action in the second argument is\n"
"-- non-null\n"
"--\n"
"failWhenNULL :: String -> IO (Ptr a) -> IO (Ptr a)\n"
"failWhenNULL name f = do\n"
"   addr <- f\n"
"   if addr == nullPtr\n"
"      then ioError (userError (name++\": out of memory\"))\n"
"      else return addr\n"
"\n"
"-- basic C routines needed for memory allocation\n"
"--\n"
"foreign import ccall unsafe \"stdlib.h malloc\"  _malloc  ::          CSize -> IO (Ptr a)\n"
"foreign import ccall unsafe \"stdlib.h realloc\" _realloc :: Ptr a -> CSize -> IO (Ptr b)\n"
"foreign import ccall unsafe \"stdlib.h free\"    _free    :: Ptr a -> IO ()\n"
"\n"
"-- | A pointer to a foreign function equivalent to 'free', which may be used\n"
"-- as a finalizer for storage allocated with 'malloc' or 'mallocBytes'.\n"
"foreign import ccall unsafe \"stdlib.h &free\" finalizerFree :: FinalizerPtr a\n";
const char *Foreign_Marshal_Pool = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"--------------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.Marshal.Pool\n"
"-- Copyright   :  (c) Sven Panne 2003\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  sven_panne@yahoo.com\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- This module contains support for pooled memory management. Under this scheme,\n"
"-- (re-)allocations belong to a given pool, and everything in a pool is\n"
"-- deallocated when the pool itself is deallocated. This is useful when\n"
"-- 'Foreign.Marshal.Alloc.alloca' with its implicit allocation and deallocation\n"
"-- is not flexible enough, but explicit uses of 'Foreign.Marshal.Alloc.malloc'\n"
"-- and 'free' are too awkward.\n"
"--\n"
"--------------------------------------------------------------------------------\n"
"\n"
"module Foreign.Marshal.Pool (\n"
"   -- * Pool management\n"
"   Pool,\n"
"   newPool,             -- :: IO Pool\n"
"   freePool,            -- :: Pool -> IO ()\n"
"   withPool,            -- :: (Pool -> IO b) -> IO b\n"
"\n"
"   -- * (Re-)Allocation within a pool\n"
"   pooledMalloc,        -- :: Storable a => Pool                 -> IO (Ptr a)\n"
"   pooledMallocBytes,   -- ::               Pool          -> Int -> IO (Ptr a)\n"
"\n"
"   pooledRealloc,       -- :: Storable a => Pool -> Ptr a        -> IO (Ptr a)\n"
"   pooledReallocBytes,  -- ::               Pool -> Ptr a -> Int -> IO (Ptr a)\n"
"\n"
"   pooledMallocArray,   -- :: Storable a => Pool ->          Int -> IO (Ptr a)\n"
"   pooledMallocArray0,  -- :: Storable a => Pool ->          Int -> IO (Ptr a)\n"
"\n"
"   pooledReallocArray,  -- :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)\n"
"   pooledReallocArray0, -- :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)\n"
"\n"
"   -- * Combined allocation and marshalling\n"
"   pooledNew,           -- :: Storable a => Pool -> a            -> IO (Ptr a)\n"
"   pooledNewArray,      -- :: Storable a => Pool ->      [a]     -> IO (Ptr a)\n"
"   pooledNewArray0      -- :: Storable a => Pool -> a -> [a]     -> IO (Ptr a)\n"
") where\n"
"\n"
"import Data.IORef            ( IORef, newIORef, readIORef, writeIORef )\n"
"import Control.Exception     ( bracket )\n"
"\n"
"import Control.Monad         ( liftM )\n"
"import Data.List             ( delete )\n"
"import Foreign.Marshal.Alloc ( mallocBytes, reallocBytes, free )\n"
"import Foreign.Marshal.Array ( pokeArray, pokeArray0 )\n"
"import Foreign.Marshal.Error ( throwIf )\n"
"import Foreign.Ptr           ( Ptr, castPtr )\n"
"import Foreign.Storable      ( Storable(sizeOf, poke) )\n"
"\n"
"--------------------------------------------------------------------------------\n"
"\n"
"-- To avoid non-H98 stuff like existentially quantified data constructors, we\n"
"-- simply use pointers to () below. Not very nice, but...\n"
"\n"
"-- | A memory pool.\n"
"\n"
"newtype Pool = Pool (IORef [Ptr ()])\n"
"\n"
"-- | Allocate a fresh memory pool.\n"
"\n"
"newPool :: IO Pool\n"
"newPool = liftM Pool (newIORef [])\n"
"\n"
"-- | Deallocate a memory pool and everything which has been allocated in the\n"
"-- pool itself.\n"
"\n"
"freePool :: Pool -> IO ()\n"
"freePool (Pool pool) = readIORef pool >>= freeAll\n"
"   where freeAll []     = return ()\n"
"         freeAll (p:ps) = free p >> freeAll ps\n"
"\n"
"-- | Execute an action with a fresh memory pool, which gets automatically\n"
"-- deallocated (including its contents) after the action has finished.\n"
"\n"
"withPool :: (Pool -> IO b) -> IO b\n"
"withPool = bracket newPool freePool\n"
"\n"
"--------------------------------------------------------------------------------\n"
"\n"
"-- | Allocate space for storable type in the given pool. The size of the area\n"
"-- allocated is determined by the 'sizeOf' method from the instance of\n"
"-- 'Storable' for the appropriate type.\n"
"\n"
"pooledMalloc :: Storable a => Pool -> IO (Ptr a)\n"
"pooledMalloc = pm undefined\n"
"  where\n"
"    pm           :: Storable a => a -> Pool -> IO (Ptr a)\n"
"    pm dummy pool = pooledMallocBytes pool (sizeOf dummy)\n"
"\n"
"-- | Allocate the given number of bytes of storage in the pool.\n"
"\n"
"pooledMallocBytes :: Pool -> Int -> IO (Ptr a)\n"
"pooledMallocBytes (Pool pool) size = do\n"
"   ptr <- mallocBytes size\n"
"   ptrs <- readIORef pool\n"
"   writeIORef pool (ptr:ptrs)\n"
"   return (castPtr ptr)\n"
"\n"
"-- | Adjust the storage area for an element in the pool to the given size of\n"
"-- the required type.\n"
"\n"
"pooledRealloc :: Storable a => Pool -> Ptr a -> IO (Ptr a)\n"
"pooledRealloc = pr undefined\n"
"  where\n"
"    pr               :: Storable a => a -> Pool -> Ptr a -> IO (Ptr a)\n"
"    pr dummy pool ptr = pooledReallocBytes pool ptr (sizeOf dummy)\n"
"\n"
"-- | Adjust the storage area for an element in the pool to the given size.\n"
"\n"
"pooledReallocBytes :: Pool -> Ptr a -> Int -> IO (Ptr a)\n"
"pooledReallocBytes (Pool pool) ptr size = do\n"
"   let cPtr = castPtr ptr\n"
"   throwIf (not . (cPtr `elem`)) (\\_ -> \"pointer not in pool\") (readIORef pool)\n"
"   newPtr <- reallocBytes cPtr size\n"
"   ptrs <- readIORef pool\n"
"   writeIORef pool (newPtr : delete cPtr ptrs)\n"
"   return (castPtr newPtr)\n"
"\n"
"-- | Allocate storage for the given number of elements of a storable type in the\n"
"-- pool.\n"
"\n"
"pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)\n"
"pooledMallocArray = pma undefined\n"
"  where\n"
"    pma                :: Storable a => a -> Pool -> Int -> IO (Ptr a)\n"
"    pma dummy pool size = pooledMallocBytes pool (size * sizeOf dummy)\n"
"\n"
"-- | Allocate storage for the given number of elements of a storable type in the\n"
"-- pool, but leave room for an extra element to signal the end of the array.\n"
"\n"
"pooledMallocArray0 :: Storable a => Pool -> Int -> IO (Ptr a)\n"
"pooledMallocArray0 pool size =\n"
"   pooledMallocArray pool (size + 1)\n"
"\n"
"-- | Adjust the size of an array in the given pool.\n"
"\n"
"pooledReallocArray :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)\n"
"pooledReallocArray = pra undefined\n"
"  where\n"
"    pra                ::  Storable a => a -> Pool -> Ptr a -> Int -> IO (Ptr a)\n"
"    pra dummy pool ptr size  = pooledReallocBytes pool ptr (size * sizeOf dummy)\n"
"\n"
"-- | Adjust the size of an array with an end marker in the given pool.\n"
"\n"
"pooledReallocArray0 :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)\n"
"pooledReallocArray0 pool ptr size =\n"
"   pooledReallocArray pool ptr (size + 1)\n"
"\n"
"--------------------------------------------------------------------------------\n"
"\n"
"-- | Allocate storage for a value in the given pool and marshal the value into\n"
"-- this storage.\n"
"\n"
"pooledNew :: Storable a => Pool -> a -> IO (Ptr a)\n"
"pooledNew pool val = do\n"
"   ptr <- pooledMalloc pool\n"
"   poke ptr val\n"
"   return ptr\n"
"\n"
"-- | Allocate consecutive storage for a list of values in the given pool and\n"
"-- marshal these values into it.\n"
"\n"
"pooledNewArray :: Storable a => Pool -> [a] -> IO (Ptr a)\n"
"pooledNewArray pool vals = do\n"
"   ptr <- pooledMallocArray pool (length vals)\n"
"   pokeArray ptr vals\n"
"   return ptr\n"
"\n"
"-- | Allocate consecutive storage for a list of values in the given pool and\n"
"-- marshal these values into it, terminating the end with the given marker.\n"
"\n"
"pooledNewArray0 :: Storable a => Pool -> a -> [a] -> IO (Ptr a)\n"
"pooledNewArray0 pool marker vals = do\n"
"   ptr <- pooledMallocArray0 pool (length vals)\n"
"   pokeArray0 marker ptr vals\n"
"   return ptr\n";
const char *Foreign_Marshal_Utils = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.Marshal.Utils\n"
"-- Copyright   :  (c) The FFI task force 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Utilities for primitive marshaling\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.Marshal.Utils (\n"
"  -- * General marshalling utilities\n"
"\n"
"  -- ** Combined allocation and marshalling\n"
"  --\n"
"  with,          -- :: Storable a => a -> (Ptr a -> IO b) -> IO b\n"
"  new,           -- :: Storable a => a -> IO (Ptr a)\n"
"\n"
"  -- ** Marshalling of Boolean values (non-zero corresponds to 'True')\n"
"  --\n"
"  fromBool,      -- :: Num a => Bool -> a\n"
"  toBool,	 -- :: Num a => a -> Bool\n"
"\n"
"  -- ** Marshalling of Maybe values\n"
"  --\n"
"  maybeNew,      -- :: (      a -> IO (Ptr a))\n"
"		 -- -> (Maybe a -> IO (Ptr a))\n"
"  maybeWith,     -- :: (      a -> (Ptr b -> IO c) -> IO c)\n"
"		 -- -> (Maybe a -> (Ptr b -> IO c) -> IO c)\n"
"  maybePeek,     -- :: (Ptr a -> IO        b )\n"
"		 -- -> (Ptr a -> IO (Maybe b))\n"
"\n"
"  -- ** Marshalling lists of storable objects\n"
"  --\n"
"  withMany,      -- :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res\n"
"\n"
"  -- ** Haskellish interface to memcpy and memmove\n"
"  -- | (argument order: destination, source)\n"
"  --\n"
"  copyBytes,     -- :: Ptr a -> Ptr a -> Int -> IO ()\n"
"  moveBytes,     -- :: Ptr a -> Ptr a -> Int -> IO ()\n"
"\n"
"  -- ** DEPRECATED FUNCTIONS (don\\'t use; they may disappear at any time)\n"
"  --\n"
"  withObject     -- :: Storable a => a -> (Ptr a -> IO b) -> IO b\n"
") where\n"
"\n"
"import Data.Maybe\n"
"import Foreign.Ptr	        ( Ptr, nullPtr )\n"
"import Foreign.Storable		( Storable(poke) )\n"
"import Foreign.C.Types    	( CSize )\n"
"import Foreign.Marshal.Alloc 	( malloc, alloca )\n"
"\n"
"-- combined allocation and marshalling\n"
"-- -----------------------------------\n"
"\n"
"-- |Allocate storage for a value and marshal it into this storage\n"
"--\n"
"new     :: Storable a => a -> IO (Ptr a)\n"
"new val  = \n"
"  do \n"
"    ptr <- malloc\n"
"    poke ptr val\n"
"    return ptr\n"
"\n"
"-- |Allocate temporary storage for a value and marshal it into this storage\n"
"--\n"
"-- * see the life time constraints imposed by 'alloca'\n"
"--\n"
"with       :: Storable a => a -> (Ptr a -> IO b) -> IO b\n"
"with val f  =\n"
"  alloca $ \\ptr -> do\n"
"    poke ptr val\n"
"    res <- f ptr\n"
"    return res\n"
"\n"
"-- old DEPRECATED name (don't use; may disappear at any time)\n"
"--\n"
"withObject :: Storable a => a -> (Ptr a -> IO b) -> IO b\n"
"{-# DEPRECATED withObject \"use `with' instead\" #-}\n"
"withObject  = with\n"
"\n"
"-- marshalling of Boolean values (non-zero corresponds to 'True')\n"
"-- -----------------------------\n"
"\n"
"-- |Convert a Haskell 'Bool' to its numeric representation\n"
"--\n"
"fromBool       :: Num a => Bool -> a\n"
"fromBool False  = 0\n"
"fromBool True   = 1\n"
"\n"
"-- |Convert a Boolean in numeric representation to a Haskell value\n"
"--\n"
"toBool :: Num a => a -> Bool\n"
"toBool  = (/= 0)\n"
"\n"
"-- marshalling of Maybe values\n"
"-- ---------------------------\n"
"\n"
"-- |Allocate storage and marshall a storable value wrapped into a 'Maybe'\n"
"--\n"
"-- * the 'nullPtr' is used to represent 'Nothing'\n"
"--\n"
"maybeNew :: (      a -> IO (Ptr a))\n"
"	 -> (Maybe a -> IO (Ptr a))\n"
"maybeNew  = maybe (return nullPtr)\n"
"\n"
"-- |Converts a @withXXX@ combinator into one marshalling a value wrapped into a\n"
"-- 'Maybe'\n"
"--\n"
"maybeWith :: (      a -> (Ptr b -> IO c) -> IO c) \n"
"	  -> (Maybe a -> (Ptr b -> IO c) -> IO c)\n"
"maybeWith  = maybe ($ nullPtr)\n"
"\n"
"-- |Convert a peek combinator into a one returning 'Nothing' if applied to a\n"
"-- 'nullPtr' \n"
"--\n"
"maybePeek                           :: (Ptr a -> IO b) -> Ptr a -> IO (Maybe b)\n"
"maybePeek peek ptr | ptr == nullPtr  = return Nothing\n"
"		   | otherwise       = do a <- peek ptr; return (Just a)\n"
"\n"
"-- marshalling lists of storable objects\n"
"-- -------------------------------------\n"
"\n"
"-- |Replicates a @withXXX@ combinator over a list of objects, yielding a list of\n"
"-- marshalled objects\n"
"--\n"
"withMany :: (a -> (b -> res) -> res)  -- withXXX combinator for one object\n"
"	 -> [a]			      -- storable objects\n"
"	 -> ([b] -> res)	      -- action on list of marshalled obj.s\n"
"	 -> res\n"
"withMany _       []     f = f []\n"
"withMany withFoo (x:xs) f = withFoo x $ \\x' ->\n"
"			      withMany withFoo xs (\\xs' -> f (x':xs'))\n"
"\n"
"-- Haskellish interface to memcpy and memmove\n"
"-- ------------------------------------------\n"
"\n"
"-- |Copies the given number of bytes from the second area (source) into the\n"
"-- first (destination); the copied areas may /not/ overlap\n"
"--\n"
"copyBytes               :: Ptr a -> Ptr a -> Int -> IO ()\n"
"copyBytes dest src size  = memcpy dest src (fromIntegral size)\n"
"\n"
"-- |Copies the given number of elements from the second area (source) into the\n"
"-- first (destination); the copied areas /may/ overlap\n"
"--\n"
"moveBytes               :: Ptr a -> Ptr a -> Int -> IO ()\n"
"moveBytes dest src size  = memmove dest src (fromIntegral size)\n"
"\n"
"-- auxilliary routines\n"
"-- -------------------\n"
"\n"
"-- |Basic C routines needed for memory copying\n"
"--\n"
"foreign import ccall unsafe \"string.h\" memcpy  :: Ptr a -> Ptr a -> CSize -> IO ()\n"
"foreign import ccall unsafe \"string.h\" memmove :: Ptr a -> Ptr a -> CSize -> IO ()\n";
const char *Foreign_Marshal_Array = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.Marshal.Array\n"
"-- Copyright   :  (c) The FFI task force 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Marshalling support: routines allocating, storing, and retrieving Haskell\n"
"-- lists that are represented as arrays in the foreign language\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.Marshal.Array (\n"
"  -- * Marshalling arrays\n"
"\n"
"  -- ** Allocation\n"
"  --\n"
"  mallocArray,    -- :: Storable a => Int -> IO (Ptr a)\n"
"  mallocArray0,   -- :: Storable a => Int -> IO (Ptr a)\n"
"\n"
"  allocaArray,    -- :: Storable a => Int -> (Ptr a -> IO b) -> IO b\n"
"  allocaArray0,   -- :: Storable a => Int -> (Ptr a -> IO b) -> IO b\n"
"\n"
"  reallocArray,   -- :: Storable a => Ptr a -> Int -> IO (Ptr a)\n"
"  reallocArray0,  -- :: Storable a => Ptr a -> Int -> IO (Ptr a)\n"
"\n"
"  -- ** Marshalling\n"
"  --\n"
"  peekArray,      -- :: Storable a =>         Int -> Ptr a -> IO [a]\n"
"  peekArray0,     -- :: (Storable a, Eq a) => a   -> Ptr a -> IO [a]\n"
"\n"
"  pokeArray,      -- :: Storable a =>      Ptr a -> [a] -> IO ()\n"
"  pokeArray0,     -- :: Storable a => a -> Ptr a -> [a] -> IO ()\n"
"\n"
"  -- ** Combined allocation and marshalling\n"
"  --\n"
"  newArray,       -- :: Storable a =>      [a] -> IO (Ptr a)\n"
"  newArray0,      -- :: Storable a => a -> [a] -> IO (Ptr a)\n"
"\n"
"  withArray,      -- :: Storable a =>      [a] -> (Ptr a -> IO b) -> IO b\n"
"  withArray0,     -- :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b\n"
"\n"
"  -- ** Copying\n"
"\n"
"  -- | (argument order: destination, source)\n"
"  copyArray,      -- :: Storable a => Ptr a -> Ptr a -> Int -> IO ()\n"
"  moveArray,      -- :: Storable a => Ptr a -> Ptr a -> Int -> IO ()\n"
"\n"
"  -- ** Finding the length\n"
"  --\n"
"  lengthArray0,   -- :: (Storable a, Eq a) => a -> Ptr a -> IO Int\n"
"\n"
"  -- ** Indexing\n"
"  --\n"
"  advancePtr,     -- :: Storable a => Ptr a -> Int -> Ptr a\n"
") where\n"
"\n"
"import Control.Monad\n"
"import Foreign.Ptr	(Ptr, plusPtr)\n"
"import Foreign.Storable	(Storable(sizeOf,peekElemOff,pokeElemOff))\n"
"import Foreign.Marshal.Alloc (mallocBytes, allocaBytes, reallocBytes)\n"
"import Foreign.Marshal.Utils (copyBytes, moveBytes)\n"
"\n"
"-- allocation\n"
"-- ----------\n"
"\n"
"-- |Allocate storage for the given number of elements of a storable type.\n"
"--\n"
"mallocArray :: Storable a => Int -> IO (Ptr a)\n"
"mallocArray  = doMalloc undefined\n"
"  where\n"
"    doMalloc            :: Storable a => a -> Int -> IO (Ptr a)\n"
"    doMalloc dummy size  = mallocBytes (size * sizeOf dummy)\n"
"\n"
"-- |Like 'mallocArray', but add an extra element to signal the end of the array\n"
"--\n"
"mallocArray0      :: Storable a => Int -> IO (Ptr a)\n"
"mallocArray0 size  = mallocArray (size + 1)\n"
"\n"
"-- |Temporarily allocate space for the given number of elements.\n"
"--\n"
"-- * see 'Foreign.Marshal.Alloc.alloca' for the storage lifetime constraints\n"
"--\n"
"allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b\n"
"allocaArray  = doAlloca undefined\n"
"  where\n"
"    doAlloca            :: Storable a => a -> Int -> (Ptr a -> IO b) -> IO b\n"
"    doAlloca dummy size  = allocaBytes (size * sizeOf dummy)\n"
"\n"
"-- |Like 'allocaArray', but add an extra element to signal the end of the array\n"
"--\n"
"allocaArray0      :: Storable a => Int -> (Ptr a -> IO b) -> IO b\n"
"allocaArray0 size  = allocaArray (size + 1)\n"
"\n"
"-- |Adjust the size of an array\n"
"--\n"
"reallocArray :: Storable a => Ptr a -> Int -> IO (Ptr a)\n"
"reallocArray  = doRealloc undefined\n"
"  where\n"
"    doRealloc                :: Storable a => a -> Ptr a -> Int -> IO (Ptr a)\n"
"    doRealloc dummy ptr size  = reallocBytes ptr (size * sizeOf dummy)\n"
"\n"
"-- |Adjust the size of an array while adding an element for the end marker\n"
"--\n"
"reallocArray0          :: Storable a => Ptr a -> Int -> IO (Ptr a)\n"
"reallocArray0 ptr size  = reallocArray ptr (size + 1)\n"
"\n"
"-- marshalling\n"
"-- -----------\n"
"\n"
"-- |Convert an array of given length into a Haskell list.  This version\n"
"-- traverses the array backwards using an accumulating parameter,\n"
"-- which uses constant stack space.  The previous version using mapM\n"
"-- needed linear stack space.\n"
"--\n"
"peekArray          :: Storable a => Int -> Ptr a -> IO [a]\n"
"peekArray size ptr | size <= 0 = return []\n"
"                 | otherwise = f (size-1) []\n"
"  where\n"
"    f 0 acc = do e <- peekElemOff ptr 0; return (e:acc)\n"
"    f n acc = do e <- peekElemOff ptr n; f (n-1) (e:acc)\n"
"  \n"
"-- |Convert an array terminated by the given end marker into a Haskell list\n"
"--\n"
"peekArray0            :: (Storable a, Eq a) => a -> Ptr a -> IO [a]\n"
"peekArray0 marker ptr  = do\n"
"  size <- lengthArray0 marker ptr\n"
"  peekArray size ptr\n"
"\n"
"-- |Write the list elements consecutive into memory\n"
"--\n"
"pokeArray :: Storable a => Ptr a -> [a] -> IO ()\n"
"pokeArray ptr vals =  zipWithM_ (pokeElemOff ptr) [0..] vals\n"
"\n"
"-- |Write the list elements consecutive into memory and terminate them with the\n"
"-- given marker element\n"
"--\n"
"pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()\n"
"pokeArray0 marker ptr vals  = do\n"
"  pokeArray ptr vals\n"
"  pokeElemOff ptr (length vals) marker\n"
"\n"
"-- combined allocation and marshalling\n"
"-- -----------------------------------\n"
"\n"
"-- |Write a list of storable elements into a newly allocated, consecutive\n"
"-- sequence of storable values\n"
"--\n"
"newArray      :: Storable a => [a] -> IO (Ptr a)\n"
"newArray vals  = do\n"
"  ptr <- mallocArray (length vals)\n"
"  pokeArray ptr vals\n"
"  return ptr\n"
"\n"
"-- |Write a list of storable elements into a newly allocated, consecutive\n"
"-- sequence of storable values, where the end is fixed by the given end marker\n"
"--\n"
"newArray0             :: Storable a => a -> [a] -> IO (Ptr a)\n"
"newArray0 marker vals  = do\n"
"  ptr <- mallocArray0 (length vals)\n"
"  pokeArray0 marker ptr vals\n"
"  return ptr\n"
"\n"
"-- |Temporarily store a list of storable values in memory\n"
"--\n"
"withArray        :: Storable a => [a] -> (Ptr a -> IO b) -> IO b\n"
"withArray vals f  =\n"
"  allocaArray len $ \\ptr -> do\n"
"      pokeArray ptr vals\n"
"      res <- f ptr\n"
"      return res\n"
"  where\n"
"    len = length vals\n"
"\n"
"-- |Like 'withArray', but a terminator indicates where the array ends\n"
"--\n"
"withArray0               :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b\n"
"withArray0 marker vals f  =\n"
"  allocaArray0 len $ \\ptr -> do\n"
"      pokeArray0 marker ptr vals\n"
"      res <- f ptr\n"
"      return res\n"
"  where\n"
"    len = length vals\n"
"\n"
"-- copying (argument order: destination, source)\n"
"-- -------\n"
"\n"
"-- |Copy the given number of elements from the second array (source) into the\n"
"-- first array (destination); the copied areas may /not/ overlap\n"
"--\n"
"copyArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()\n"
"copyArray  = doCopy undefined\n"
"  where\n"
"    doCopy                     :: Storable a => a -> Ptr a -> Ptr a -> Int -> IO ()\n"
"    doCopy dummy dest src size  = copyBytes dest src (size * sizeOf dummy)\n"
"\n"
"-- |Copy the given number of elements from the second array (source) into the\n"
"-- first array (destination); the copied areas /may/ overlap\n"
"--\n"
"moveArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()\n"
"moveArray  = doMove undefined\n"
"  where\n"
"    doMove                     :: Storable a => a -> Ptr a -> Ptr a -> Int -> IO ()\n"
"    doMove dummy dest src size  = moveBytes dest src (size * sizeOf dummy)\n"
"\n"
"-- finding the length\n"
"-- ------------------\n"
"\n"
"-- |Return the number of elements in an array, excluding the terminator\n"
"--\n"
"lengthArray0            :: (Storable a, Eq a) => a -> Ptr a -> IO Int\n"
"lengthArray0 marker ptr  = loop 0\n"
"  where\n"
"    loop i = do\n"
"        val <- peekElemOff ptr i\n"
"        if val == marker then return i else loop (i+1)\n"
"\n"
"-- indexing\n"
"-- --------\n"
"\n"
"-- |Advance a pointer into an array by the given number of elements\n"
"--\n"
"advancePtr :: Storable a => Ptr a -> Int -> Ptr a\n"
"advancePtr  = doAdvance undefined\n"
"  where\n"
"    doAdvance             :: Storable a => a -> Ptr a -> Int -> Ptr a\n"
"    doAdvance dummy ptr i  = ptr `plusPtr` (i * sizeOf dummy)\n";
const char *Foreign_Marshal_Error = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.Marshal.Error\n"
"-- Copyright   :  (c) The FFI task force 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Marshalling support: Handling of common error conditions\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.Marshal.Error (\n"
"  -- * Error utilities\n"
"\n"
"  -- |Throw an exception on specific return values\n"
"  --\n"
"  throwIf,       -- :: (a -> Bool) -> (a -> String) -> IO a       -> IO a\n"
"  throwIf_,      -- :: (a -> Bool) -> (a -> String) -> IO a       -> IO ()\n"
"  throwIfNeg,    -- :: (Ord a, Num a) \n"
"	         -- =>                (a -> String) -> IO a       -> IO a\n"
"  throwIfNeg_,   -- :: (Ord a, Num a)\n"
"	         -- =>                (a -> String) -> IO a       -> IO ()\n"
"  throwIfNull,   -- ::                String        -> IO (Ptr a) -> IO (Ptr a)\n"
"\n"
"  -- Discard return value\n"
"  --\n"
"  void           -- IO a -> IO ()\n"
") where\n"
"\n"
"import Foreign.Ptr\n"
"\n"
"-- exported functions\n"
"-- ------------------\n"
"\n"
"-- |Guard an 'IO' operation and throw an exception if the result meets the given\n"
"-- predicate \n"
"--\n"
"-- * the second argument computes an error message from the result of the 'IO'\n"
"--   operation\n"
"--\n"
"throwIf                 :: (a -> Bool) -> (a -> String) -> IO a -> IO a\n"
"throwIf pred msgfct act  = \n"
"  do\n"
"    res <- act\n"
"    (if pred res then ioError . userError . msgfct else return) res\n"
"\n"
"-- |Like 'throwIf', but discarding the result\n"
"--\n"
"throwIf_                 :: (a -> Bool) -> (a -> String) -> IO a -> IO ()\n"
"throwIf_ pred msgfct act  = void $ throwIf pred msgfct act\n"
"\n"
"-- |Guards against negative result values\n"
"--\n"
"throwIfNeg :: (Ord a, Num a) => (a -> String) -> IO a -> IO a\n"
"throwIfNeg  = throwIf (< 0)\n"
"\n"
"-- |Like 'throwIfNeg', but discarding the result\n"
"--\n"
"throwIfNeg_ :: (Ord a, Num a) => (a -> String) -> IO a -> IO ()\n"
"throwIfNeg_  = throwIf_ (< 0)\n"
"\n"
"-- |Guards against null pointers\n"
"--\n"
"throwIfNull :: String -> IO (Ptr a) -> IO (Ptr a)\n"
"throwIfNull  = throwIf (== nullPtr) . const\n"
"\n"
"-- |Discard the return value of an 'IO' action\n"
"--\n"
"void     :: IO a -> IO ()\n"
"void act  = act >> return ()\n";
const char *Foreign_C_Types = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.C.Types\n"
"-- Copyright   :  (c) The FFI task force 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Mapping of C types to corresponding Haskell types.\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.C.Types\n"
"	( -- Integral types, instances of: Eq, Ord, Num, Read, Show, Enum,\n"
"	  -- Typeable, Storable, Bounded, Real, Integral, Bits\n"
"	  CChar,  CSChar,  CUChar\n"
"	, CShort, CUShort, CInt,   CUInt\n"
"	, CLong,  CULong\n"
"	, CPtrdiff, CSize, CWchar, CSigAtomic\n"
"        , CLLong, CULLong\n"
"	  -- Numeric types, instances of: Eq, Ord, Num, Read, Show, Enum,\n"
"	  -- Typeable, Storable\n"
"	, CClock,   CTime\n"
"\n"
"	  -- Floating types, instances of: Eq, Ord, Num, Read, Show, Enum,\n"
"	  -- Typeable, Storable, Real, Fractional, Floating, RealFrac,\n"
"	  -- RealFloat \n"
"	, CFloat,  CDouble, CLDouble\n"
"\n"
"          -- Instances of: Eq and Storable\n"
"	, CFile,        CFpos,     CJmpBuf\n"
"	) where\n"
"\n"
"import Foreign.Storable\n"
"import Data.Bits	( Bits(..) )\n"
"import Data.Int		( Int8,  Int16,  Int32,  Int64  )\n"
"import Data.Word	( Word8, Word16, Word32, Word64 )\n"
"import Data.Typeable\n"
"\n"
"import Control.Monad\n"
"import Foreign.Ptr\n"
"\n"
"newtype CChar = CChar Int8 deriving (Eq, Ord) ; instance Num CChar where {    (CChar i) + (CChar j) = CChar (i + j) ;    (CChar i) - (CChar j) = CChar (i - j) ;    (CChar i) * (CChar j) = CChar (i * j) ;    negate  (CChar i) = CChar (negate i) ;    abs     (CChar i) = CChar (abs    i) ;    signum  (CChar i) = CChar (signum i) ;    fromInteger x = CChar (fromInteger x) } ; instance Read CChar where {    readsPrec p s = map (\\(x, t) -> (CChar x, t)) (readsPrec p s) } ; instance Show CChar where {    showsPrec p (CChar x) = showsPrec p x } ; instance Enum CChar where {    succ           (CChar i)             = CChar (succ i) ;    pred           (CChar i)             = CChar (pred i) ;    toEnum               x           = CChar (toEnum x) ;    fromEnum       (CChar i)             = fromEnum i ;    enumFrom       (CChar i)             = map CChar (enumFrom i) ;    enumFromThen   (CChar i) (CChar j)       = map CChar (enumFromThen i j) ;    enumFromTo     (CChar i) (CChar j)       = map CChar (enumFromTo i j) ;    enumFromThenTo (CChar i) (CChar j) (CChar k) = map CChar (enumFromThenTo i j k) } ; instance Storable CChar where {    sizeOf    (CChar x)       = sizeOf x ;    alignment (CChar x)       = alignment x ;    peekElemOff a i       = liftM CChar (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CChar x) = pokeElemOff (castPtr a) i x } ; tyConCChar = mkTyCon \"CChar\"; instance Typeable CChar where { typeOf _ = mkAppTy tyConCChar [] } ; ; instance Bounded CChar where {    minBound = CChar minBound ;    maxBound = CChar maxBound } ; instance Real CChar where {    toRational (CChar i) = toRational i } ; instance Integral CChar where {    (CChar i) `quot`    (CChar j) = CChar (i `quot` j) ;    (CChar i) `rem`     (CChar j) = CChar (i `rem`  j) ;    (CChar i) `div`     (CChar j) = CChar (i `div`  j) ;    (CChar i) `mod`     (CChar j) = CChar (i `mod`  j) ;    (CChar i) `quotRem` (CChar j) = let (q,r) = i `quotRem` j in (CChar q, CChar r) ;    (CChar i) `divMod`  (CChar j) = let (d,m) = i `divMod`  j in (CChar d, CChar m) ;    toInteger (CChar i)       = toInteger i } ; instance Bits CChar where {   (CChar x) .&.     (CChar y)   = CChar (x .&.   y) ;   (CChar x) .|.     (CChar y)   = CChar (x .|.   y) ;   (CChar x) `xor`   (CChar y)   = CChar (x `xor` y) ;   complement    (CChar x)   = CChar (complement x) ;   shift         (CChar x) n = CChar (shift x n) ;   rotate        (CChar x) n = CChar (rotate x n) ;   bit                 n = CChar (bit n) ;   setBit        (CChar x) n = CChar (setBit x n) ;   clearBit      (CChar x) n = CChar (clearBit x n) ;   complementBit (CChar x) n = CChar (complementBit x n) ;   testBit       (CChar x) n = testBit x n ;   bitSize       (CChar x)   = bitSize x ;   isSigned      (CChar x)   = isSigned x }\n"
"newtype CSChar = CSChar Int8 deriving (Eq, Ord) ; instance Num CSChar where {    (CSChar i) + (CSChar j) = CSChar (i + j) ;    (CSChar i) - (CSChar j) = CSChar (i - j) ;    (CSChar i) * (CSChar j) = CSChar (i * j) ;    negate  (CSChar i) = CSChar (negate i) ;    abs     (CSChar i) = CSChar (abs    i) ;    signum  (CSChar i) = CSChar (signum i) ;    fromInteger x = CSChar (fromInteger x) } ; instance Read CSChar where {    readsPrec p s = map (\\(x, t) -> (CSChar x, t)) (readsPrec p s) } ; instance Show CSChar where {    showsPrec p (CSChar x) = showsPrec p x } ; instance Enum CSChar where {    succ           (CSChar i)             = CSChar (succ i) ;    pred           (CSChar i)             = CSChar (pred i) ;    toEnum               x           = CSChar (toEnum x) ;    fromEnum       (CSChar i)             = fromEnum i ;    enumFrom       (CSChar i)             = map CSChar (enumFrom i) ;    enumFromThen   (CSChar i) (CSChar j)       = map CSChar (enumFromThen i j) ;    enumFromTo     (CSChar i) (CSChar j)       = map CSChar (enumFromTo i j) ;    enumFromThenTo (CSChar i) (CSChar j) (CSChar k) = map CSChar (enumFromThenTo i j k) } ; instance Storable CSChar where {    sizeOf    (CSChar x)       = sizeOf x ;    alignment (CSChar x)       = alignment x ;    peekElemOff a i       = liftM CSChar (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CSChar x) = pokeElemOff (castPtr a) i x } ; tyConCSChar = mkTyCon \"CSChar\"; instance Typeable CSChar where { typeOf _ = mkAppTy tyConCSChar [] } ; ; instance Bounded CSChar where {    minBound = CSChar minBound ;    maxBound = CSChar maxBound } ; instance Real CSChar where {    toRational (CSChar i) = toRational i } ; instance Integral CSChar where {    (CSChar i) `quot`    (CSChar j) = CSChar (i `quot` j) ;    (CSChar i) `rem`     (CSChar j) = CSChar (i `rem`  j) ;    (CSChar i) `div`     (CSChar j) = CSChar (i `div`  j) ;    (CSChar i) `mod`     (CSChar j) = CSChar (i `mod`  j) ;    (CSChar i) `quotRem` (CSChar j) = let (q,r) = i `quotRem` j in (CSChar q, CSChar r) ;    (CSChar i) `divMod`  (CSChar j) = let (d,m) = i `divMod`  j in (CSChar d, CSChar m) ;    toInteger (CSChar i)       = toInteger i } ; instance Bits CSChar where {   (CSChar x) .&.     (CSChar y)   = CSChar (x .&.   y) ;   (CSChar x) .|.     (CSChar y)   = CSChar (x .|.   y) ;   (CSChar x) `xor`   (CSChar y)   = CSChar (x `xor` y) ;   complement    (CSChar x)   = CSChar (complement x) ;   shift         (CSChar x) n = CSChar (shift x n) ;   rotate        (CSChar x) n = CSChar (rotate x n) ;   bit                 n = CSChar (bit n) ;   setBit        (CSChar x) n = CSChar (setBit x n) ;   clearBit      (CSChar x) n = CSChar (clearBit x n) ;   complementBit (CSChar x) n = CSChar (complementBit x n) ;   testBit       (CSChar x) n = testBit x n ;   bitSize       (CSChar x)   = bitSize x ;   isSigned      (CSChar x)   = isSigned x }\n"
"newtype CUChar = CUChar Word8 deriving (Eq, Ord) ; instance Num CUChar where {    (CUChar i) + (CUChar j) = CUChar (i + j) ;    (CUChar i) - (CUChar j) = CUChar (i - j) ;    (CUChar i) * (CUChar j) = CUChar (i * j) ;    negate  (CUChar i) = CUChar (negate i) ;    abs     (CUChar i) = CUChar (abs    i) ;    signum  (CUChar i) = CUChar (signum i) ;    fromInteger x = CUChar (fromInteger x) } ; instance Read CUChar where {    readsPrec p s = map (\\(x, t) -> (CUChar x, t)) (readsPrec p s) } ; instance Show CUChar where {    showsPrec p (CUChar x) = showsPrec p x } ; instance Enum CUChar where {    succ           (CUChar i)             = CUChar (succ i) ;    pred           (CUChar i)             = CUChar (pred i) ;    toEnum               x           = CUChar (toEnum x) ;    fromEnum       (CUChar i)             = fromEnum i ;    enumFrom       (CUChar i)             = map CUChar (enumFrom i) ;    enumFromThen   (CUChar i) (CUChar j)       = map CUChar (enumFromThen i j) ;    enumFromTo     (CUChar i) (CUChar j)       = map CUChar (enumFromTo i j) ;    enumFromThenTo (CUChar i) (CUChar j) (CUChar k) = map CUChar (enumFromThenTo i j k) } ; instance Storable CUChar where {    sizeOf    (CUChar x)       = sizeOf x ;    alignment (CUChar x)       = alignment x ;    peekElemOff a i       = liftM CUChar (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CUChar x) = pokeElemOff (castPtr a) i x } ; tyConCUChar = mkTyCon \"CUChar\"; instance Typeable CUChar where { typeOf _ = mkAppTy tyConCUChar [] } ; ; instance Bounded CUChar where {    minBound = CUChar minBound ;    maxBound = CUChar maxBound } ; instance Real CUChar where {    toRational (CUChar i) = toRational i } ; instance Integral CUChar where {    (CUChar i) `quot`    (CUChar j) = CUChar (i `quot` j) ;    (CUChar i) `rem`     (CUChar j) = CUChar (i `rem`  j) ;    (CUChar i) `div`     (CUChar j) = CUChar (i `div`  j) ;    (CUChar i) `mod`     (CUChar j) = CUChar (i `mod`  j) ;    (CUChar i) `quotRem` (CUChar j) = let (q,r) = i `quotRem` j in (CUChar q, CUChar r) ;    (CUChar i) `divMod`  (CUChar j) = let (d,m) = i `divMod`  j in (CUChar d, CUChar m) ;    toInteger (CUChar i)       = toInteger i } ; instance Bits CUChar where {   (CUChar x) .&.     (CUChar y)   = CUChar (x .&.   y) ;   (CUChar x) .|.     (CUChar y)   = CUChar (x .|.   y) ;   (CUChar x) `xor`   (CUChar y)   = CUChar (x `xor` y) ;   complement    (CUChar x)   = CUChar (complement x) ;   shift         (CUChar x) n = CUChar (shift x n) ;   rotate        (CUChar x) n = CUChar (rotate x n) ;   bit                 n = CUChar (bit n) ;   setBit        (CUChar x) n = CUChar (setBit x n) ;   clearBit      (CUChar x) n = CUChar (clearBit x n) ;   complementBit (CUChar x) n = CUChar (complementBit x n) ;   testBit       (CUChar x) n = testBit x n ;   bitSize       (CUChar x)   = bitSize x ;   isSigned      (CUChar x)   = isSigned x }\n"
"\n"
"newtype CShort = CShort Int16 deriving (Eq, Ord) ; instance Num CShort where {    (CShort i) + (CShort j) = CShort (i + j) ;    (CShort i) - (CShort j) = CShort (i - j) ;    (CShort i) * (CShort j) = CShort (i * j) ;    negate  (CShort i) = CShort (negate i) ;    abs     (CShort i) = CShort (abs    i) ;    signum  (CShort i) = CShort (signum i) ;    fromInteger x = CShort (fromInteger x) } ; instance Read CShort where {    readsPrec p s = map (\\(x, t) -> (CShort x, t)) (readsPrec p s) } ; instance Show CShort where {    showsPrec p (CShort x) = showsPrec p x } ; instance Enum CShort where {    succ           (CShort i)             = CShort (succ i) ;    pred           (CShort i)             = CShort (pred i) ;    toEnum               x           = CShort (toEnum x) ;    fromEnum       (CShort i)             = fromEnum i ;    enumFrom       (CShort i)             = map CShort (enumFrom i) ;    enumFromThen   (CShort i) (CShort j)       = map CShort (enumFromThen i j) ;    enumFromTo     (CShort i) (CShort j)       = map CShort (enumFromTo i j) ;    enumFromThenTo (CShort i) (CShort j) (CShort k) = map CShort (enumFromThenTo i j k) } ; instance Storable CShort where {    sizeOf    (CShort x)       = sizeOf x ;    alignment (CShort x)       = alignment x ;    peekElemOff a i       = liftM CShort (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CShort x) = pokeElemOff (castPtr a) i x } ; tyConCShort = mkTyCon \"CShort\"; instance Typeable CShort where { typeOf _ = mkAppTy tyConCShort [] } ; ; instance Bounded CShort where {    minBound = CShort minBound ;    maxBound = CShort maxBound } ; instance Real CShort where {    toRational (CShort i) = toRational i } ; instance Integral CShort where {    (CShort i) `quot`    (CShort j) = CShort (i `quot` j) ;    (CShort i) `rem`     (CShort j) = CShort (i `rem`  j) ;    (CShort i) `div`     (CShort j) = CShort (i `div`  j) ;    (CShort i) `mod`     (CShort j) = CShort (i `mod`  j) ;    (CShort i) `quotRem` (CShort j) = let (q,r) = i `quotRem` j in (CShort q, CShort r) ;    (CShort i) `divMod`  (CShort j) = let (d,m) = i `divMod`  j in (CShort d, CShort m) ;    toInteger (CShort i)       = toInteger i } ; instance Bits CShort where {   (CShort x) .&.     (CShort y)   = CShort (x .&.   y) ;   (CShort x) .|.     (CShort y)   = CShort (x .|.   y) ;   (CShort x) `xor`   (CShort y)   = CShort (x `xor` y) ;   complement    (CShort x)   = CShort (complement x) ;   shift         (CShort x) n = CShort (shift x n) ;   rotate        (CShort x) n = CShort (rotate x n) ;   bit                 n = CShort (bit n) ;   setBit        (CShort x) n = CShort (setBit x n) ;   clearBit      (CShort x) n = CShort (clearBit x n) ;   complementBit (CShort x) n = CShort (complementBit x n) ;   testBit       (CShort x) n = testBit x n ;   bitSize       (CShort x)   = bitSize x ;   isSigned      (CShort x)   = isSigned x }\n"
"newtype CUShort = CUShort Word16 deriving (Eq, Ord) ; instance Num CUShort where {    (CUShort i) + (CUShort j) = CUShort (i + j) ;    (CUShort i) - (CUShort j) = CUShort (i - j) ;    (CUShort i) * (CUShort j) = CUShort (i * j) ;    negate  (CUShort i) = CUShort (negate i) ;    abs     (CUShort i) = CUShort (abs    i) ;    signum  (CUShort i) = CUShort (signum i) ;    fromInteger x = CUShort (fromInteger x) } ; instance Read CUShort where {    readsPrec p s = map (\\(x, t) -> (CUShort x, t)) (readsPrec p s) } ; instance Show CUShort where {    showsPrec p (CUShort x) = showsPrec p x } ; instance Enum CUShort where {    succ           (CUShort i)             = CUShort (succ i) ;    pred           (CUShort i)             = CUShort (pred i) ;    toEnum               x           = CUShort (toEnum x) ;    fromEnum       (CUShort i)             = fromEnum i ;    enumFrom       (CUShort i)             = map CUShort (enumFrom i) ;    enumFromThen   (CUShort i) (CUShort j)       = map CUShort (enumFromThen i j) ;    enumFromTo     (CUShort i) (CUShort j)       = map CUShort (enumFromTo i j) ;    enumFromThenTo (CUShort i) (CUShort j) (CUShort k) = map CUShort (enumFromThenTo i j k) } ; instance Storable CUShort where {    sizeOf    (CUShort x)       = sizeOf x ;    alignment (CUShort x)       = alignment x ;    peekElemOff a i       = liftM CUShort (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CUShort x) = pokeElemOff (castPtr a) i x } ; tyConCUShort = mkTyCon \"CUShort\"; instance Typeable CUShort where { typeOf _ = mkAppTy tyConCUShort [] } ; ; instance Bounded CUShort where {    minBound = CUShort minBound ;    maxBound = CUShort maxBound } ; instance Real CUShort where {    toRational (CUShort i) = toRational i } ; instance Integral CUShort where {    (CUShort i) `quot`    (CUShort j) = CUShort (i `quot` j) ;    (CUShort i) `rem`     (CUShort j) = CUShort (i `rem`  j) ;    (CUShort i) `div`     (CUShort j) = CUShort (i `div`  j) ;    (CUShort i) `mod`     (CUShort j) = CUShort (i `mod`  j) ;    (CUShort i) `quotRem` (CUShort j) = let (q,r) = i `quotRem` j in (CUShort q, CUShort r) ;    (CUShort i) `divMod`  (CUShort j) = let (d,m) = i `divMod`  j in (CUShort d, CUShort m) ;    toInteger (CUShort i)       = toInteger i } ; instance Bits CUShort where {   (CUShort x) .&.     (CUShort y)   = CUShort (x .&.   y) ;   (CUShort x) .|.     (CUShort y)   = CUShort (x .|.   y) ;   (CUShort x) `xor`   (CUShort y)   = CUShort (x `xor` y) ;   complement    (CUShort x)   = CUShort (complement x) ;   shift         (CUShort x) n = CUShort (shift x n) ;   rotate        (CUShort x) n = CUShort (rotate x n) ;   bit                 n = CUShort (bit n) ;   setBit        (CUShort x) n = CUShort (setBit x n) ;   clearBit      (CUShort x) n = CUShort (clearBit x n) ;   complementBit (CUShort x) n = CUShort (complementBit x n) ;   testBit       (CUShort x) n = testBit x n ;   bitSize       (CUShort x)   = bitSize x ;   isSigned      (CUShort x)   = isSigned x }\n"
"\n"
"newtype CInt = CInt Int32 deriving (Eq, Ord) ; instance Num CInt where {    (CInt i) + (CInt j) = CInt (i + j) ;    (CInt i) - (CInt j) = CInt (i - j) ;    (CInt i) * (CInt j) = CInt (i * j) ;    negate  (CInt i) = CInt (negate i) ;    abs     (CInt i) = CInt (abs    i) ;    signum  (CInt i) = CInt (signum i) ;    fromInteger x = CInt (fromInteger x) } ; instance Read CInt where {    readsPrec p s = map (\\(x, t) -> (CInt x, t)) (readsPrec p s) } ; instance Show CInt where {    showsPrec p (CInt x) = showsPrec p x } ; instance Enum CInt where {    succ           (CInt i)             = CInt (succ i) ;    pred           (CInt i)             = CInt (pred i) ;    toEnum               x           = CInt (toEnum x) ;    fromEnum       (CInt i)             = fromEnum i ;    enumFrom       (CInt i)             = map CInt (enumFrom i) ;    enumFromThen   (CInt i) (CInt j)       = map CInt (enumFromThen i j) ;    enumFromTo     (CInt i) (CInt j)       = map CInt (enumFromTo i j) ;    enumFromThenTo (CInt i) (CInt j) (CInt k) = map CInt (enumFromThenTo i j k) } ; instance Storable CInt where {    sizeOf    (CInt x)       = sizeOf x ;    alignment (CInt x)       = alignment x ;    peekElemOff a i       = liftM CInt (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CInt x) = pokeElemOff (castPtr a) i x } ; tyConCInt = mkTyCon \"CInt\"; instance Typeable CInt where { typeOf _ = mkAppTy tyConCInt [] } ; ; instance Bounded CInt where {    minBound = CInt minBound ;    maxBound = CInt maxBound } ; instance Real CInt where {    toRational (CInt i) = toRational i } ; instance Integral CInt where {    (CInt i) `quot`    (CInt j) = CInt (i `quot` j) ;    (CInt i) `rem`     (CInt j) = CInt (i `rem`  j) ;    (CInt i) `div`     (CInt j) = CInt (i `div`  j) ;    (CInt i) `mod`     (CInt j) = CInt (i `mod`  j) ;    (CInt i) `quotRem` (CInt j) = let (q,r) = i `quotRem` j in (CInt q, CInt r) ;    (CInt i) `divMod`  (CInt j) = let (d,m) = i `divMod`  j in (CInt d, CInt m) ;    toInteger (CInt i)       = toInteger i } ; instance Bits CInt where {   (CInt x) .&.     (CInt y)   = CInt (x .&.   y) ;   (CInt x) .|.     (CInt y)   = CInt (x .|.   y) ;   (CInt x) `xor`   (CInt y)   = CInt (x `xor` y) ;   complement    (CInt x)   = CInt (complement x) ;   shift         (CInt x) n = CInt (shift x n) ;   rotate        (CInt x) n = CInt (rotate x n) ;   bit                 n = CInt (bit n) ;   setBit        (CInt x) n = CInt (setBit x n) ;   clearBit      (CInt x) n = CInt (clearBit x n) ;   complementBit (CInt x) n = CInt (complementBit x n) ;   testBit       (CInt x) n = testBit x n ;   bitSize       (CInt x)   = bitSize x ;   isSigned      (CInt x)   = isSigned x }\n"
"newtype CUInt = CUInt Word32 deriving (Eq, Ord) ; instance Num CUInt where {    (CUInt i) + (CUInt j) = CUInt (i + j) ;    (CUInt i) - (CUInt j) = CUInt (i - j) ;    (CUInt i) * (CUInt j) = CUInt (i * j) ;    negate  (CUInt i) = CUInt (negate i) ;    abs     (CUInt i) = CUInt (abs    i) ;    signum  (CUInt i) = CUInt (signum i) ;    fromInteger x = CUInt (fromInteger x) } ; instance Read CUInt where {    readsPrec p s = map (\\(x, t) -> (CUInt x, t)) (readsPrec p s) } ; instance Show CUInt where {    showsPrec p (CUInt x) = showsPrec p x } ; instance Enum CUInt where {    succ           (CUInt i)             = CUInt (succ i) ;    pred           (CUInt i)             = CUInt (pred i) ;    toEnum               x           = CUInt (toEnum x) ;    fromEnum       (CUInt i)             = fromEnum i ;    enumFrom       (CUInt i)             = map CUInt (enumFrom i) ;    enumFromThen   (CUInt i) (CUInt j)       = map CUInt (enumFromThen i j) ;    enumFromTo     (CUInt i) (CUInt j)       = map CUInt (enumFromTo i j) ;    enumFromThenTo (CUInt i) (CUInt j) (CUInt k) = map CUInt (enumFromThenTo i j k) } ; instance Storable CUInt where {    sizeOf    (CUInt x)       = sizeOf x ;    alignment (CUInt x)       = alignment x ;    peekElemOff a i       = liftM CUInt (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CUInt x) = pokeElemOff (castPtr a) i x } ; tyConCUInt = mkTyCon \"CUInt\"; instance Typeable CUInt where { typeOf _ = mkAppTy tyConCUInt [] } ; ; instance Bounded CUInt where {    minBound = CUInt minBound ;    maxBound = CUInt maxBound } ; instance Real CUInt where {    toRational (CUInt i) = toRational i } ; instance Integral CUInt where {    (CUInt i) `quot`    (CUInt j) = CUInt (i `quot` j) ;    (CUInt i) `rem`     (CUInt j) = CUInt (i `rem`  j) ;    (CUInt i) `div`     (CUInt j) = CUInt (i `div`  j) ;    (CUInt i) `mod`     (CUInt j) = CUInt (i `mod`  j) ;    (CUInt i) `quotRem` (CUInt j) = let (q,r) = i `quotRem` j in (CUInt q, CUInt r) ;    (CUInt i) `divMod`  (CUInt j) = let (d,m) = i `divMod`  j in (CUInt d, CUInt m) ;    toInteger (CUInt i)       = toInteger i } ; instance Bits CUInt where {   (CUInt x) .&.     (CUInt y)   = CUInt (x .&.   y) ;   (CUInt x) .|.     (CUInt y)   = CUInt (x .|.   y) ;   (CUInt x) `xor`   (CUInt y)   = CUInt (x `xor` y) ;   complement    (CUInt x)   = CUInt (complement x) ;   shift         (CUInt x) n = CUInt (shift x n) ;   rotate        (CUInt x) n = CUInt (rotate x n) ;   bit                 n = CUInt (bit n) ;   setBit        (CUInt x) n = CUInt (setBit x n) ;   clearBit      (CUInt x) n = CUInt (clearBit x n) ;   complementBit (CUInt x) n = CUInt (complementBit x n) ;   testBit       (CUInt x) n = testBit x n ;   bitSize       (CUInt x)   = bitSize x ;   isSigned      (CUInt x)   = isSigned x }\n"
"\n"
"newtype CLong = CLong Int64 deriving (Eq, Ord) ; instance Num CLong where {    (CLong i) + (CLong j) = CLong (i + j) ;    (CLong i) - (CLong j) = CLong (i - j) ;    (CLong i) * (CLong j) = CLong (i * j) ;    negate  (CLong i) = CLong (negate i) ;    abs     (CLong i) = CLong (abs    i) ;    signum  (CLong i) = CLong (signum i) ;    fromInteger x = CLong (fromInteger x) } ; instance Read CLong where {    readsPrec p s = map (\\(x, t) -> (CLong x, t)) (readsPrec p s) } ; instance Show CLong where {    showsPrec p (CLong x) = showsPrec p x } ; instance Enum CLong where {    succ           (CLong i)             = CLong (succ i) ;    pred           (CLong i)             = CLong (pred i) ;    toEnum               x           = CLong (toEnum x) ;    fromEnum       (CLong i)             = fromEnum i ;    enumFrom       (CLong i)             = map CLong (enumFrom i) ;    enumFromThen   (CLong i) (CLong j)       = map CLong (enumFromThen i j) ;    enumFromTo     (CLong i) (CLong j)       = map CLong (enumFromTo i j) ;    enumFromThenTo (CLong i) (CLong j) (CLong k) = map CLong (enumFromThenTo i j k) } ; instance Storable CLong where {    sizeOf    (CLong x)       = sizeOf x ;    alignment (CLong x)       = alignment x ;    peekElemOff a i       = liftM CLong (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CLong x) = pokeElemOff (castPtr a) i x } ; tyConCLong = mkTyCon \"CLong\"; instance Typeable CLong where { typeOf _ = mkAppTy tyConCLong [] } ; ; instance Bounded CLong where {    minBound = CLong minBound ;    maxBound = CLong maxBound } ; instance Real CLong where {    toRational (CLong i) = toRational i } ; instance Integral CLong where {    (CLong i) `quot`    (CLong j) = CLong (i `quot` j) ;    (CLong i) `rem`     (CLong j) = CLong (i `rem`  j) ;    (CLong i) `div`     (CLong j) = CLong (i `div`  j) ;    (CLong i) `mod`     (CLong j) = CLong (i `mod`  j) ;    (CLong i) `quotRem` (CLong j) = let (q,r) = i `quotRem` j in (CLong q, CLong r) ;    (CLong i) `divMod`  (CLong j) = let (d,m) = i `divMod`  j in (CLong d, CLong m) ;    toInteger (CLong i)       = toInteger i } ; instance Bits CLong where {   (CLong x) .&.     (CLong y)   = CLong (x .&.   y) ;   (CLong x) .|.     (CLong y)   = CLong (x .|.   y) ;   (CLong x) `xor`   (CLong y)   = CLong (x `xor` y) ;   complement    (CLong x)   = CLong (complement x) ;   shift         (CLong x) n = CLong (shift x n) ;   rotate        (CLong x) n = CLong (rotate x n) ;   bit                 n = CLong (bit n) ;   setBit        (CLong x) n = CLong (setBit x n) ;   clearBit      (CLong x) n = CLong (clearBit x n) ;   complementBit (CLong x) n = CLong (complementBit x n) ;   testBit       (CLong x) n = testBit x n ;   bitSize       (CLong x)   = bitSize x ;   isSigned      (CLong x)   = isSigned x }\n"
"newtype CULong = CULong Word64 deriving (Eq, Ord) ; instance Num CULong where {    (CULong i) + (CULong j) = CULong (i + j) ;    (CULong i) - (CULong j) = CULong (i - j) ;    (CULong i) * (CULong j) = CULong (i * j) ;    negate  (CULong i) = CULong (negate i) ;    abs     (CULong i) = CULong (abs    i) ;    signum  (CULong i) = CULong (signum i) ;    fromInteger x = CULong (fromInteger x) } ; instance Read CULong where {    readsPrec p s = map (\\(x, t) -> (CULong x, t)) (readsPrec p s) } ; instance Show CULong where {    showsPrec p (CULong x) = showsPrec p x } ; instance Enum CULong where {    succ           (CULong i)             = CULong (succ i) ;    pred           (CULong i)             = CULong (pred i) ;    toEnum               x           = CULong (toEnum x) ;    fromEnum       (CULong i)             = fromEnum i ;    enumFrom       (CULong i)             = map CULong (enumFrom i) ;    enumFromThen   (CULong i) (CULong j)       = map CULong (enumFromThen i j) ;    enumFromTo     (CULong i) (CULong j)       = map CULong (enumFromTo i j) ;    enumFromThenTo (CULong i) (CULong j) (CULong k) = map CULong (enumFromThenTo i j k) } ; instance Storable CULong where {    sizeOf    (CULong x)       = sizeOf x ;    alignment (CULong x)       = alignment x ;    peekElemOff a i       = liftM CULong (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CULong x) = pokeElemOff (castPtr a) i x } ; tyConCULong = mkTyCon \"CULong\"; instance Typeable CULong where { typeOf _ = mkAppTy tyConCULong [] } ; ; instance Bounded CULong where {    minBound = CULong minBound ;    maxBound = CULong maxBound } ; instance Real CULong where {    toRational (CULong i) = toRational i } ; instance Integral CULong where {    (CULong i) `quot`    (CULong j) = CULong (i `quot` j) ;    (CULong i) `rem`     (CULong j) = CULong (i `rem`  j) ;    (CULong i) `div`     (CULong j) = CULong (i `div`  j) ;    (CULong i) `mod`     (CULong j) = CULong (i `mod`  j) ;    (CULong i) `quotRem` (CULong j) = let (q,r) = i `quotRem` j in (CULong q, CULong r) ;    (CULong i) `divMod`  (CULong j) = let (d,m) = i `divMod`  j in (CULong d, CULong m) ;    toInteger (CULong i)       = toInteger i } ; instance Bits CULong where {   (CULong x) .&.     (CULong y)   = CULong (x .&.   y) ;   (CULong x) .|.     (CULong y)   = CULong (x .|.   y) ;   (CULong x) `xor`   (CULong y)   = CULong (x `xor` y) ;   complement    (CULong x)   = CULong (complement x) ;   shift         (CULong x) n = CULong (shift x n) ;   rotate        (CULong x) n = CULong (rotate x n) ;   bit                 n = CULong (bit n) ;   setBit        (CULong x) n = CULong (setBit x n) ;   clearBit      (CULong x) n = CULong (clearBit x n) ;   complementBit (CULong x) n = CULong (complementBit x n) ;   testBit       (CULong x) n = testBit x n ;   bitSize       (CULong x)   = bitSize x ;   isSigned      (CULong x)   = isSigned x }\n"
"\n"
"newtype CLLong = CLLong Int64 deriving (Eq, Ord) ; instance Num CLLong where {    (CLLong i) + (CLLong j) = CLLong (i + j) ;    (CLLong i) - (CLLong j) = CLLong (i - j) ;    (CLLong i) * (CLLong j) = CLLong (i * j) ;    negate  (CLLong i) = CLLong (negate i) ;    abs     (CLLong i) = CLLong (abs    i) ;    signum  (CLLong i) = CLLong (signum i) ;    fromInteger x = CLLong (fromInteger x) } ; instance Read CLLong where {    readsPrec p s = map (\\(x, t) -> (CLLong x, t)) (readsPrec p s) } ; instance Show CLLong where {    showsPrec p (CLLong x) = showsPrec p x } ; instance Enum CLLong where {    succ           (CLLong i)             = CLLong (succ i) ;    pred           (CLLong i)             = CLLong (pred i) ;    toEnum               x           = CLLong (toEnum x) ;    fromEnum       (CLLong i)             = fromEnum i ;    enumFrom       (CLLong i)             = map CLLong (enumFrom i) ;    enumFromThen   (CLLong i) (CLLong j)       = map CLLong (enumFromThen i j) ;    enumFromTo     (CLLong i) (CLLong j)       = map CLLong (enumFromTo i j) ;    enumFromThenTo (CLLong i) (CLLong j) (CLLong k) = map CLLong (enumFromThenTo i j k) } ; instance Storable CLLong where {    sizeOf    (CLLong x)       = sizeOf x ;    alignment (CLLong x)       = alignment x ;    peekElemOff a i       = liftM CLLong (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CLLong x) = pokeElemOff (castPtr a) i x } ; tyConCLLong = mkTyCon \"CLLong\"; instance Typeable CLLong where { typeOf _ = mkAppTy tyConCLLong [] } ; ; instance Bounded CLLong where {    minBound = CLLong minBound ;    maxBound = CLLong maxBound } ; instance Real CLLong where {    toRational (CLLong i) = toRational i } ; instance Integral CLLong where {    (CLLong i) `quot`    (CLLong j) = CLLong (i `quot` j) ;    (CLLong i) `rem`     (CLLong j) = CLLong (i `rem`  j) ;    (CLLong i) `div`     (CLLong j) = CLLong (i `div`  j) ;    (CLLong i) `mod`     (CLLong j) = CLLong (i `mod`  j) ;    (CLLong i) `quotRem` (CLLong j) = let (q,r) = i `quotRem` j in (CLLong q, CLLong r) ;    (CLLong i) `divMod`  (CLLong j) = let (d,m) = i `divMod`  j in (CLLong d, CLLong m) ;    toInteger (CLLong i)       = toInteger i } ; instance Bits CLLong where {   (CLLong x) .&.     (CLLong y)   = CLLong (x .&.   y) ;   (CLLong x) .|.     (CLLong y)   = CLLong (x .|.   y) ;   (CLLong x) `xor`   (CLLong y)   = CLLong (x `xor` y) ;   complement    (CLLong x)   = CLLong (complement x) ;   shift         (CLLong x) n = CLLong (shift x n) ;   rotate        (CLLong x) n = CLLong (rotate x n) ;   bit                 n = CLLong (bit n) ;   setBit        (CLLong x) n = CLLong (setBit x n) ;   clearBit      (CLLong x) n = CLLong (clearBit x n) ;   complementBit (CLLong x) n = CLLong (complementBit x n) ;   testBit       (CLLong x) n = testBit x n ;   bitSize       (CLLong x)   = bitSize x ;   isSigned      (CLLong x)   = isSigned x }\n"
"newtype CULLong = CULLong Word64 deriving (Eq, Ord) ; instance Num CULLong where {    (CULLong i) + (CULLong j) = CULLong (i + j) ;    (CULLong i) - (CULLong j) = CULLong (i - j) ;    (CULLong i) * (CULLong j) = CULLong (i * j) ;    negate  (CULLong i) = CULLong (negate i) ;    abs     (CULLong i) = CULLong (abs    i) ;    signum  (CULLong i) = CULLong (signum i) ;    fromInteger x = CULLong (fromInteger x) } ; instance Read CULLong where {    readsPrec p s = map (\\(x, t) -> (CULLong x, t)) (readsPrec p s) } ; instance Show CULLong where {    showsPrec p (CULLong x) = showsPrec p x } ; instance Enum CULLong where {    succ           (CULLong i)             = CULLong (succ i) ;    pred           (CULLong i)             = CULLong (pred i) ;    toEnum               x           = CULLong (toEnum x) ;    fromEnum       (CULLong i)             = fromEnum i ;    enumFrom       (CULLong i)             = map CULLong (enumFrom i) ;    enumFromThen   (CULLong i) (CULLong j)       = map CULLong (enumFromThen i j) ;    enumFromTo     (CULLong i) (CULLong j)       = map CULLong (enumFromTo i j) ;    enumFromThenTo (CULLong i) (CULLong j) (CULLong k) = map CULLong (enumFromThenTo i j k) } ; instance Storable CULLong where {    sizeOf    (CULLong x)       = sizeOf x ;    alignment (CULLong x)       = alignment x ;    peekElemOff a i       = liftM CULLong (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CULLong x) = pokeElemOff (castPtr a) i x } ; tyConCULLong = mkTyCon \"CULLong\"; instance Typeable CULLong where { typeOf _ = mkAppTy tyConCULLong [] } ; ; instance Bounded CULLong where {    minBound = CULLong minBound ;    maxBound = CULLong maxBound } ; instance Real CULLong where {    toRational (CULLong i) = toRational i } ; instance Integral CULLong where {    (CULLong i) `quot`    (CULLong j) = CULLong (i `quot` j) ;    (CULLong i) `rem`     (CULLong j) = CULLong (i `rem`  j) ;    (CULLong i) `div`     (CULLong j) = CULLong (i `div`  j) ;    (CULLong i) `mod`     (CULLong j) = CULLong (i `mod`  j) ;    (CULLong i) `quotRem` (CULLong j) = let (q,r) = i `quotRem` j in (CULLong q, CULLong r) ;    (CULLong i) `divMod`  (CULLong j) = let (d,m) = i `divMod`  j in (CULLong d, CULLong m) ;    toInteger (CULLong i)       = toInteger i } ; instance Bits CULLong where {   (CULLong x) .&.     (CULLong y)   = CULLong (x .&.   y) ;   (CULLong x) .|.     (CULLong y)   = CULLong (x .|.   y) ;   (CULLong x) `xor`   (CULLong y)   = CULLong (x `xor` y) ;   complement    (CULLong x)   = CULLong (complement x) ;   shift         (CULLong x) n = CULLong (shift x n) ;   rotate        (CULLong x) n = CULLong (rotate x n) ;   bit                 n = CULLong (bit n) ;   setBit        (CULLong x) n = CULLong (setBit x n) ;   clearBit      (CULLong x) n = CULLong (clearBit x n) ;   complementBit (CULLong x) n = CULLong (complementBit x n) ;   testBit       (CULLong x) n = testBit x n ;   bitSize       (CULLong x)   = bitSize x ;   isSigned      (CULLong x)   = isSigned x }\n"
"\n"
"{-# RULES\n"
"\"fromIntegral/a->CChar\"   fromIntegral = \\x -> CChar   (fromIntegral x)\n"
"\"fromIntegral/a->CSChar\"  fromIntegral = \\x -> CSChar  (fromIntegral x)\n"
"\"fromIntegral/a->CUChar\"  fromIntegral = \\x -> CUChar  (fromIntegral x)\n"
"\"fromIntegral/a->CShort\"  fromIntegral = \\x -> CShort  (fromIntegral x)\n"
"\"fromIntegral/a->CUShort\" fromIntegral = \\x -> CUShort (fromIntegral x)\n"
"\"fromIntegral/a->CInt\"    fromIntegral = \\x -> CInt    (fromIntegral x)\n"
"\"fromIntegral/a->CUInt\"   fromIntegral = \\x -> CUInt   (fromIntegral x)\n"
"\"fromIntegral/a->CLong\"   fromIntegral = \\x -> CLong   (fromIntegral x)\n"
"\"fromIntegral/a->CULong\"  fromIntegral = \\x -> CULong  (fromIntegral x)\n"
"\"fromIntegral/a->CLLong\"  fromIntegral = \\x -> CLLong  (fromIntegral x)\n"
"\"fromIntegral/a->CULLong\" fromIntegral = \\x -> CULLong (fromIntegral x)\n"
"\n"
"\"fromIntegral/CChar->a\"   fromIntegral = \\(CChar   x) -> fromIntegral x\n"
"\"fromIntegral/CSChar->a\"  fromIntegral = \\(CSChar  x) -> fromIntegral x\n"
"\"fromIntegral/CUChar->a\"  fromIntegral = \\(CUChar  x) -> fromIntegral x\n"
"\"fromIntegral/CShort->a\"  fromIntegral = \\(CShort  x) -> fromIntegral x\n"
"\"fromIntegral/CUShort->a\" fromIntegral = \\(CUShort x) -> fromIntegral x\n"
"\"fromIntegral/CInt->a\"    fromIntegral = \\(CInt    x) -> fromIntegral x\n"
"\"fromIntegral/CUInt->a\"   fromIntegral = \\(CUInt   x) -> fromIntegral x\n"
"\"fromIntegral/CLong->a\"   fromIntegral = \\(CLong   x) -> fromIntegral x\n"
"\"fromIntegral/CULong->a\"  fromIntegral = \\(CULong  x) -> fromIntegral x\n"
"\"fromIntegral/CLLong->a\"  fromIntegral = \\(CLLong  x) -> fromIntegral x\n"
"\"fromIntegral/CULLong->a\" fromIntegral = \\(CULLong x) -> fromIntegral x\n"
" #-}\n"
"\n"
"newtype CFloat = CFloat Float deriving (Eq, Ord) ; instance Num CFloat where {    (CFloat i) + (CFloat j) = CFloat (i + j) ;    (CFloat i) - (CFloat j) = CFloat (i - j) ;    (CFloat i) * (CFloat j) = CFloat (i * j) ;    negate  (CFloat i) = CFloat (negate i) ;    abs     (CFloat i) = CFloat (abs    i) ;    signum  (CFloat i) = CFloat (signum i) ;    fromInteger x = CFloat (fromInteger x) } ; instance Read CFloat where {    readsPrec p s = map (\\(x, t) -> (CFloat x, t)) (readsPrec p s) } ; instance Show CFloat where {    showsPrec p (CFloat x) = showsPrec p x } ; instance Enum CFloat where {    succ           (CFloat i)             = CFloat (succ i) ;    pred           (CFloat i)             = CFloat (pred i) ;    toEnum               x           = CFloat (toEnum x) ;    fromEnum       (CFloat i)             = fromEnum i ;    enumFrom       (CFloat i)             = map CFloat (enumFrom i) ;    enumFromThen   (CFloat i) (CFloat j)       = map CFloat (enumFromThen i j) ;    enumFromTo     (CFloat i) (CFloat j)       = map CFloat (enumFromTo i j) ;    enumFromThenTo (CFloat i) (CFloat j) (CFloat k) = map CFloat (enumFromThenTo i j k) } ; instance Storable CFloat where {    sizeOf    (CFloat x)       = sizeOf x ;    alignment (CFloat x)       = alignment x ;    peekElemOff a i       = liftM CFloat (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CFloat x) = pokeElemOff (castPtr a) i x } ; tyConCFloat = mkTyCon \"CFloat\"; instance Typeable CFloat where { typeOf _ = mkAppTy tyConCFloat [] } ; ; instance Real CFloat where {    toRational (CFloat i) = toRational i } ; instance Fractional CFloat where {    (CFloat x) / (CFloat y)  = CFloat (x / y) ;    recip   (CFloat x)  = CFloat (recip x) ;    fromRational	r = CFloat (fromRational r) } ; instance Floating CFloat where {    pi                    = pi ;    exp   (CFloat x)           = CFloat (exp   x) ;    log   (CFloat x)           = CFloat (log   x) ;    sqrt  (CFloat x)           = CFloat (sqrt  x) ;    (CFloat x) **        (CFloat y) = CFloat (x ** y) ;    (CFloat x) `logBase` (CFloat y) = CFloat (x `logBase` y) ;    sin   (CFloat x)           = CFloat (sin   x) ;    cos   (CFloat x)           = CFloat (cos   x) ;    tan   (CFloat x)           = CFloat (tan   x) ;    asin  (CFloat x)           = CFloat (asin  x) ;    acos  (CFloat x)           = CFloat (acos  x) ;    atan  (CFloat x)           = CFloat (atan  x) ;    sinh  (CFloat x)           = CFloat (sinh  x) ;    cosh  (CFloat x)           = CFloat (cosh  x) ;    tanh  (CFloat x)           = CFloat (tanh  x) ;    asinh (CFloat x)           = CFloat (asinh x) ;    acosh (CFloat x)           = CFloat (acosh x) ;    atanh (CFloat x)           = CFloat (atanh x) } ; instance RealFrac CFloat where {    properFraction (CFloat x) = let (m,y) = properFraction x in (m, CFloat y) ;    truncate (CFloat x) = truncate x ;    round    (CFloat x) = round x ;    ceiling  (CFloat x) = ceiling x ;    floor    (CFloat x) = floor x } ; instance RealFloat CFloat where {    floatRadix     (CFloat x) = floatRadix x ;    floatDigits    (CFloat x) = floatDigits x ;    floatRange     (CFloat x) = floatRange x ;    decodeFloat    (CFloat x) = decodeFloat x ;    encodeFloat m n      = CFloat (encodeFloat m n) ;    exponent       (CFloat x) = exponent x ;    significand    (CFloat x) = CFloat (significand  x) ;    scaleFloat n   (CFloat x) = CFloat (scaleFloat n x) ;    isNaN          (CFloat x) = isNaN x ;    isInfinite     (CFloat x) = isInfinite x ;    isDenormalized (CFloat x) = isDenormalized x ;    isNegativeZero (CFloat x) = isNegativeZero x ;    isIEEE         (CFloat x) = isIEEE x ;    (CFloat x) `atan2`  (CFloat y) = CFloat (x `atan2` y) }\n"
"newtype CDouble = CDouble Double deriving (Eq, Ord) ; instance Num CDouble where {    (CDouble i) + (CDouble j) = CDouble (i + j) ;    (CDouble i) - (CDouble j) = CDouble (i - j) ;    (CDouble i) * (CDouble j) = CDouble (i * j) ;    negate  (CDouble i) = CDouble (negate i) ;    abs     (CDouble i) = CDouble (abs    i) ;    signum  (CDouble i) = CDouble (signum i) ;    fromInteger x = CDouble (fromInteger x) } ; instance Read CDouble where {    readsPrec p s = map (\\(x, t) -> (CDouble x, t)) (readsPrec p s) } ; instance Show CDouble where {    showsPrec p (CDouble x) = showsPrec p x } ; instance Enum CDouble where {    succ           (CDouble i)             = CDouble (succ i) ;    pred           (CDouble i)             = CDouble (pred i) ;    toEnum               x           = CDouble (toEnum x) ;    fromEnum       (CDouble i)             = fromEnum i ;    enumFrom       (CDouble i)             = map CDouble (enumFrom i) ;    enumFromThen   (CDouble i) (CDouble j)       = map CDouble (enumFromThen i j) ;    enumFromTo     (CDouble i) (CDouble j)       = map CDouble (enumFromTo i j) ;    enumFromThenTo (CDouble i) (CDouble j) (CDouble k) = map CDouble (enumFromThenTo i j k) } ; instance Storable CDouble where {    sizeOf    (CDouble x)       = sizeOf x ;    alignment (CDouble x)       = alignment x ;    peekElemOff a i       = liftM CDouble (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CDouble x) = pokeElemOff (castPtr a) i x } ; tyConCDouble = mkTyCon \"CDouble\"; instance Typeable CDouble where { typeOf _ = mkAppTy tyConCDouble [] } ; ; instance Real CDouble where {    toRational (CDouble i) = toRational i } ; instance Fractional CDouble where {    (CDouble x) / (CDouble y)  = CDouble (x / y) ;    recip   (CDouble x)  = CDouble (recip x) ;    fromRational	r = CDouble (fromRational r) } ; instance Floating CDouble where {    pi                    = pi ;    exp   (CDouble x)           = CDouble (exp   x) ;    log   (CDouble x)           = CDouble (log   x) ;    sqrt  (CDouble x)           = CDouble (sqrt  x) ;    (CDouble x) **        (CDouble y) = CDouble (x ** y) ;    (CDouble x) `logBase` (CDouble y) = CDouble (x `logBase` y) ;    sin   (CDouble x)           = CDouble (sin   x) ;    cos   (CDouble x)           = CDouble (cos   x) ;    tan   (CDouble x)           = CDouble (tan   x) ;    asin  (CDouble x)           = CDouble (asin  x) ;    acos  (CDouble x)           = CDouble (acos  x) ;    atan  (CDouble x)           = CDouble (atan  x) ;    sinh  (CDouble x)           = CDouble (sinh  x) ;    cosh  (CDouble x)           = CDouble (cosh  x) ;    tanh  (CDouble x)           = CDouble (tanh  x) ;    asinh (CDouble x)           = CDouble (asinh x) ;    acosh (CDouble x)           = CDouble (acosh x) ;    atanh (CDouble x)           = CDouble (atanh x) } ; instance RealFrac CDouble where {    properFraction (CDouble x) = let (m,y) = properFraction x in (m, CDouble y) ;    truncate (CDouble x) = truncate x ;    round    (CDouble x) = round x ;    ceiling  (CDouble x) = ceiling x ;    floor    (CDouble x) = floor x } ; instance RealFloat CDouble where {    floatRadix     (CDouble x) = floatRadix x ;    floatDigits    (CDouble x) = floatDigits x ;    floatRange     (CDouble x) = floatRange x ;    decodeFloat    (CDouble x) = decodeFloat x ;    encodeFloat m n      = CDouble (encodeFloat m n) ;    exponent       (CDouble x) = exponent x ;    significand    (CDouble x) = CDouble (significand  x) ;    scaleFloat n   (CDouble x) = CDouble (scaleFloat n x) ;    isNaN          (CDouble x) = isNaN x ;    isInfinite     (CDouble x) = isInfinite x ;    isDenormalized (CDouble x) = isDenormalized x ;    isNegativeZero (CDouble x) = isNegativeZero x ;    isIEEE         (CDouble x) = isIEEE x ;    (CDouble x) `atan2`  (CDouble y) = CDouble (x `atan2` y) }\n"
"-- HACK: Currently no long double in the FFI, so we simply re-use double\n"
"newtype CLDouble = CLDouble Double deriving (Eq, Ord) ; instance Num CLDouble where {    (CLDouble i) + (CLDouble j) = CLDouble (i + j) ;    (CLDouble i) - (CLDouble j) = CLDouble (i - j) ;    (CLDouble i) * (CLDouble j) = CLDouble (i * j) ;    negate  (CLDouble i) = CLDouble (negate i) ;    abs     (CLDouble i) = CLDouble (abs    i) ;    signum  (CLDouble i) = CLDouble (signum i) ;    fromInteger x = CLDouble (fromInteger x) } ; instance Read CLDouble where {    readsPrec p s = map (\\(x, t) -> (CLDouble x, t)) (readsPrec p s) } ; instance Show CLDouble where {    showsPrec p (CLDouble x) = showsPrec p x } ; instance Enum CLDouble where {    succ           (CLDouble i)             = CLDouble (succ i) ;    pred           (CLDouble i)             = CLDouble (pred i) ;    toEnum               x           = CLDouble (toEnum x) ;    fromEnum       (CLDouble i)             = fromEnum i ;    enumFrom       (CLDouble i)             = map CLDouble (enumFrom i) ;    enumFromThen   (CLDouble i) (CLDouble j)       = map CLDouble (enumFromThen i j) ;    enumFromTo     (CLDouble i) (CLDouble j)       = map CLDouble (enumFromTo i j) ;    enumFromThenTo (CLDouble i) (CLDouble j) (CLDouble k) = map CLDouble (enumFromThenTo i j k) } ; instance Storable CLDouble where {    sizeOf    (CLDouble x)       = sizeOf x ;    alignment (CLDouble x)       = alignment x ;    peekElemOff a i       = liftM CLDouble (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CLDouble x) = pokeElemOff (castPtr a) i x } ; tyConCLDouble = mkTyCon \"CLDouble\"; instance Typeable CLDouble where { typeOf _ = mkAppTy tyConCLDouble [] } ; ; instance Real CLDouble where {    toRational (CLDouble i) = toRational i } ; instance Fractional CLDouble where {    (CLDouble x) / (CLDouble y)  = CLDouble (x / y) ;    recip   (CLDouble x)  = CLDouble (recip x) ;    fromRational	r = CLDouble (fromRational r) } ; instance Floating CLDouble where {    pi                    = pi ;    exp   (CLDouble x)           = CLDouble (exp   x) ;    log   (CLDouble x)           = CLDouble (log   x) ;    sqrt  (CLDouble x)           = CLDouble (sqrt  x) ;    (CLDouble x) **        (CLDouble y) = CLDouble (x ** y) ;    (CLDouble x) `logBase` (CLDouble y) = CLDouble (x `logBase` y) ;    sin   (CLDouble x)           = CLDouble (sin   x) ;    cos   (CLDouble x)           = CLDouble (cos   x) ;    tan   (CLDouble x)           = CLDouble (tan   x) ;    asin  (CLDouble x)           = CLDouble (asin  x) ;    acos  (CLDouble x)           = CLDouble (acos  x) ;    atan  (CLDouble x)           = CLDouble (atan  x) ;    sinh  (CLDouble x)           = CLDouble (sinh  x) ;    cosh  (CLDouble x)           = CLDouble (cosh  x) ;    tanh  (CLDouble x)           = CLDouble (tanh  x) ;    asinh (CLDouble x)           = CLDouble (asinh x) ;    acosh (CLDouble x)           = CLDouble (acosh x) ;    atanh (CLDouble x)           = CLDouble (atanh x) } ; instance RealFrac CLDouble where {    properFraction (CLDouble x) = let (m,y) = properFraction x in (m, CLDouble y) ;    truncate (CLDouble x) = truncate x ;    round    (CLDouble x) = round x ;    ceiling  (CLDouble x) = ceiling x ;    floor    (CLDouble x) = floor x } ; instance RealFloat CLDouble where {    floatRadix     (CLDouble x) = floatRadix x ;    floatDigits    (CLDouble x) = floatDigits x ;    floatRange     (CLDouble x) = floatRange x ;    decodeFloat    (CLDouble x) = decodeFloat x ;    encodeFloat m n      = CLDouble (encodeFloat m n) ;    exponent       (CLDouble x) = exponent x ;    significand    (CLDouble x) = CLDouble (significand  x) ;    scaleFloat n   (CLDouble x) = CLDouble (scaleFloat n x) ;    isNaN          (CLDouble x) = isNaN x ;    isInfinite     (CLDouble x) = isInfinite x ;    isDenormalized (CLDouble x) = isDenormalized x ;    isNegativeZero (CLDouble x) = isNegativeZero x ;    isIEEE         (CLDouble x) = isIEEE x ;    (CLDouble x) `atan2`  (CLDouble y) = CLDouble (x `atan2` y) }\n"
"\n"
"{-# RULES\n"
"\"realToFrac/a->CFloat\"    realToFrac = \\x -> CFloat   (realToFrac x)\n"
"\"realToFrac/a->CDouble\"   realToFrac = \\x -> CDouble  (realToFrac x)\n"
"\"realToFrac/a->CLDouble\"  realToFrac = \\x -> CLDouble (realToFrac x)\n"
"\n"
"\"realToFrac/CFloat->a\"    realToFrac = \\(CFloat   x) -> realToFrac x\n"
"\"realToFrac/CDouble->a\"   realToFrac = \\(CDouble  x) -> realToFrac x\n"
"\"realToFrac/CLDouble->a\"  realToFrac = \\(CLDouble x) -> realToFrac x\n"
" #-}\n"
"\n"
"newtype CPtrdiff = CPtrdiff Int64 deriving (Eq, Ord) ; instance Num CPtrdiff where {    (CPtrdiff i) + (CPtrdiff j) = CPtrdiff (i + j) ;    (CPtrdiff i) - (CPtrdiff j) = CPtrdiff (i - j) ;    (CPtrdiff i) * (CPtrdiff j) = CPtrdiff (i * j) ;    negate  (CPtrdiff i) = CPtrdiff (negate i) ;    abs     (CPtrdiff i) = CPtrdiff (abs    i) ;    signum  (CPtrdiff i) = CPtrdiff (signum i) ;    fromInteger x = CPtrdiff (fromInteger x) } ; instance Read CPtrdiff where {    readsPrec p s = map (\\(x, t) -> (CPtrdiff x, t)) (readsPrec p s) } ; instance Show CPtrdiff where {    showsPrec p (CPtrdiff x) = showsPrec p x } ; instance Enum CPtrdiff where {    succ           (CPtrdiff i)             = CPtrdiff (succ i) ;    pred           (CPtrdiff i)             = CPtrdiff (pred i) ;    toEnum               x           = CPtrdiff (toEnum x) ;    fromEnum       (CPtrdiff i)             = fromEnum i ;    enumFrom       (CPtrdiff i)             = map CPtrdiff (enumFrom i) ;    enumFromThen   (CPtrdiff i) (CPtrdiff j)       = map CPtrdiff (enumFromThen i j) ;    enumFromTo     (CPtrdiff i) (CPtrdiff j)       = map CPtrdiff (enumFromTo i j) ;    enumFromThenTo (CPtrdiff i) (CPtrdiff j) (CPtrdiff k) = map CPtrdiff (enumFromThenTo i j k) } ; instance Storable CPtrdiff where {    sizeOf    (CPtrdiff x)       = sizeOf x ;    alignment (CPtrdiff x)       = alignment x ;    peekElemOff a i       = liftM CPtrdiff (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CPtrdiff x) = pokeElemOff (castPtr a) i x } ; tyConCPtrdiff = mkTyCon \"CPtrdiff\"; instance Typeable CPtrdiff where { typeOf _ = mkAppTy tyConCPtrdiff [] } ; ; instance Bounded CPtrdiff where {    minBound = CPtrdiff minBound ;    maxBound = CPtrdiff maxBound } ; instance Real CPtrdiff where {    toRational (CPtrdiff i) = toRational i } ; instance Integral CPtrdiff where {    (CPtrdiff i) `quot`    (CPtrdiff j) = CPtrdiff (i `quot` j) ;    (CPtrdiff i) `rem`     (CPtrdiff j) = CPtrdiff (i `rem`  j) ;    (CPtrdiff i) `div`     (CPtrdiff j) = CPtrdiff (i `div`  j) ;    (CPtrdiff i) `mod`     (CPtrdiff j) = CPtrdiff (i `mod`  j) ;    (CPtrdiff i) `quotRem` (CPtrdiff j) = let (q,r) = i `quotRem` j in (CPtrdiff q, CPtrdiff r) ;    (CPtrdiff i) `divMod`  (CPtrdiff j) = let (d,m) = i `divMod`  j in (CPtrdiff d, CPtrdiff m) ;    toInteger (CPtrdiff i)       = toInteger i } ; instance Bits CPtrdiff where {   (CPtrdiff x) .&.     (CPtrdiff y)   = CPtrdiff (x .&.   y) ;   (CPtrdiff x) .|.     (CPtrdiff y)   = CPtrdiff (x .|.   y) ;   (CPtrdiff x) `xor`   (CPtrdiff y)   = CPtrdiff (x `xor` y) ;   complement    (CPtrdiff x)   = CPtrdiff (complement x) ;   shift         (CPtrdiff x) n = CPtrdiff (shift x n) ;   rotate        (CPtrdiff x) n = CPtrdiff (rotate x n) ;   bit                 n = CPtrdiff (bit n) ;   setBit        (CPtrdiff x) n = CPtrdiff (setBit x n) ;   clearBit      (CPtrdiff x) n = CPtrdiff (clearBit x n) ;   complementBit (CPtrdiff x) n = CPtrdiff (complementBit x n) ;   testBit       (CPtrdiff x) n = testBit x n ;   bitSize       (CPtrdiff x)   = bitSize x ;   isSigned      (CPtrdiff x)   = isSigned x }\n"
"newtype CSize = CSize Word64 deriving (Eq, Ord) ; instance Num CSize where {    (CSize i) + (CSize j) = CSize (i + j) ;    (CSize i) - (CSize j) = CSize (i - j) ;    (CSize i) * (CSize j) = CSize (i * j) ;    negate  (CSize i) = CSize (negate i) ;    abs     (CSize i) = CSize (abs    i) ;    signum  (CSize i) = CSize (signum i) ;    fromInteger x = CSize (fromInteger x) } ; instance Read CSize where {    readsPrec p s = map (\\(x, t) -> (CSize x, t)) (readsPrec p s) } ; instance Show CSize where {    showsPrec p (CSize x) = showsPrec p x } ; instance Enum CSize where {    succ           (CSize i)             = CSize (succ i) ;    pred           (CSize i)             = CSize (pred i) ;    toEnum               x           = CSize (toEnum x) ;    fromEnum       (CSize i)             = fromEnum i ;    enumFrom       (CSize i)             = map CSize (enumFrom i) ;    enumFromThen   (CSize i) (CSize j)       = map CSize (enumFromThen i j) ;    enumFromTo     (CSize i) (CSize j)       = map CSize (enumFromTo i j) ;    enumFromThenTo (CSize i) (CSize j) (CSize k) = map CSize (enumFromThenTo i j k) } ; instance Storable CSize where {    sizeOf    (CSize x)       = sizeOf x ;    alignment (CSize x)       = alignment x ;    peekElemOff a i       = liftM CSize (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CSize x) = pokeElemOff (castPtr a) i x } ; tyConCSize = mkTyCon \"CSize\"; instance Typeable CSize where { typeOf _ = mkAppTy tyConCSize [] } ; ; instance Bounded CSize where {    minBound = CSize minBound ;    maxBound = CSize maxBound } ; instance Real CSize where {    toRational (CSize i) = toRational i } ; instance Integral CSize where {    (CSize i) `quot`    (CSize j) = CSize (i `quot` j) ;    (CSize i) `rem`     (CSize j) = CSize (i `rem`  j) ;    (CSize i) `div`     (CSize j) = CSize (i `div`  j) ;    (CSize i) `mod`     (CSize j) = CSize (i `mod`  j) ;    (CSize i) `quotRem` (CSize j) = let (q,r) = i `quotRem` j in (CSize q, CSize r) ;    (CSize i) `divMod`  (CSize j) = let (d,m) = i `divMod`  j in (CSize d, CSize m) ;    toInteger (CSize i)       = toInteger i } ; instance Bits CSize where {   (CSize x) .&.     (CSize y)   = CSize (x .&.   y) ;   (CSize x) .|.     (CSize y)   = CSize (x .|.   y) ;   (CSize x) `xor`   (CSize y)   = CSize (x `xor` y) ;   complement    (CSize x)   = CSize (complement x) ;   shift         (CSize x) n = CSize (shift x n) ;   rotate        (CSize x) n = CSize (rotate x n) ;   bit                 n = CSize (bit n) ;   setBit        (CSize x) n = CSize (setBit x n) ;   clearBit      (CSize x) n = CSize (clearBit x n) ;   complementBit (CSize x) n = CSize (complementBit x n) ;   testBit       (CSize x) n = testBit x n ;   bitSize       (CSize x)   = bitSize x ;   isSigned      (CSize x)   = isSigned x }\n"
"newtype CWchar = CWchar Int32 deriving (Eq, Ord) ; instance Num CWchar where {    (CWchar i) + (CWchar j) = CWchar (i + j) ;    (CWchar i) - (CWchar j) = CWchar (i - j) ;    (CWchar i) * (CWchar j) = CWchar (i * j) ;    negate  (CWchar i) = CWchar (negate i) ;    abs     (CWchar i) = CWchar (abs    i) ;    signum  (CWchar i) = CWchar (signum i) ;    fromInteger x = CWchar (fromInteger x) } ; instance Read CWchar where {    readsPrec p s = map (\\(x, t) -> (CWchar x, t)) (readsPrec p s) } ; instance Show CWchar where {    showsPrec p (CWchar x) = showsPrec p x } ; instance Enum CWchar where {    succ           (CWchar i)             = CWchar (succ i) ;    pred           (CWchar i)             = CWchar (pred i) ;    toEnum               x           = CWchar (toEnum x) ;    fromEnum       (CWchar i)             = fromEnum i ;    enumFrom       (CWchar i)             = map CWchar (enumFrom i) ;    enumFromThen   (CWchar i) (CWchar j)       = map CWchar (enumFromThen i j) ;    enumFromTo     (CWchar i) (CWchar j)       = map CWchar (enumFromTo i j) ;    enumFromThenTo (CWchar i) (CWchar j) (CWchar k) = map CWchar (enumFromThenTo i j k) } ; instance Storable CWchar where {    sizeOf    (CWchar x)       = sizeOf x ;    alignment (CWchar x)       = alignment x ;    peekElemOff a i       = liftM CWchar (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CWchar x) = pokeElemOff (castPtr a) i x } ; tyConCWchar = mkTyCon \"CWchar\"; instance Typeable CWchar where { typeOf _ = mkAppTy tyConCWchar [] } ; ; instance Bounded CWchar where {    minBound = CWchar minBound ;    maxBound = CWchar maxBound } ; instance Real CWchar where {    toRational (CWchar i) = toRational i } ; instance Integral CWchar where {    (CWchar i) `quot`    (CWchar j) = CWchar (i `quot` j) ;    (CWchar i) `rem`     (CWchar j) = CWchar (i `rem`  j) ;    (CWchar i) `div`     (CWchar j) = CWchar (i `div`  j) ;    (CWchar i) `mod`     (CWchar j) = CWchar (i `mod`  j) ;    (CWchar i) `quotRem` (CWchar j) = let (q,r) = i `quotRem` j in (CWchar q, CWchar r) ;    (CWchar i) `divMod`  (CWchar j) = let (d,m) = i `divMod`  j in (CWchar d, CWchar m) ;    toInteger (CWchar i)       = toInteger i } ; instance Bits CWchar where {   (CWchar x) .&.     (CWchar y)   = CWchar (x .&.   y) ;   (CWchar x) .|.     (CWchar y)   = CWchar (x .|.   y) ;   (CWchar x) `xor`   (CWchar y)   = CWchar (x `xor` y) ;   complement    (CWchar x)   = CWchar (complement x) ;   shift         (CWchar x) n = CWchar (shift x n) ;   rotate        (CWchar x) n = CWchar (rotate x n) ;   bit                 n = CWchar (bit n) ;   setBit        (CWchar x) n = CWchar (setBit x n) ;   clearBit      (CWchar x) n = CWchar (clearBit x n) ;   complementBit (CWchar x) n = CWchar (complementBit x n) ;   testBit       (CWchar x) n = testBit x n ;   bitSize       (CWchar x)   = bitSize x ;   isSigned      (CWchar x)   = isSigned x }\n"
"newtype CSigAtomic = CSigAtomic Int32 deriving (Eq, Ord) ; instance Num CSigAtomic where {    (CSigAtomic i) + (CSigAtomic j) = CSigAtomic (i + j) ;    (CSigAtomic i) - (CSigAtomic j) = CSigAtomic (i - j) ;    (CSigAtomic i) * (CSigAtomic j) = CSigAtomic (i * j) ;    negate  (CSigAtomic i) = CSigAtomic (negate i) ;    abs     (CSigAtomic i) = CSigAtomic (abs    i) ;    signum  (CSigAtomic i) = CSigAtomic (signum i) ;    fromInteger x = CSigAtomic (fromInteger x) } ; instance Read CSigAtomic where {    readsPrec p s = map (\\(x, t) -> (CSigAtomic x, t)) (readsPrec p s) } ; instance Show CSigAtomic where {    showsPrec p (CSigAtomic x) = showsPrec p x } ; instance Enum CSigAtomic where {    succ           (CSigAtomic i)             = CSigAtomic (succ i) ;    pred           (CSigAtomic i)             = CSigAtomic (pred i) ;    toEnum               x           = CSigAtomic (toEnum x) ;    fromEnum       (CSigAtomic i)             = fromEnum i ;    enumFrom       (CSigAtomic i)             = map CSigAtomic (enumFrom i) ;    enumFromThen   (CSigAtomic i) (CSigAtomic j)       = map CSigAtomic (enumFromThen i j) ;    enumFromTo     (CSigAtomic i) (CSigAtomic j)       = map CSigAtomic (enumFromTo i j) ;    enumFromThenTo (CSigAtomic i) (CSigAtomic j) (CSigAtomic k) = map CSigAtomic (enumFromThenTo i j k) } ; instance Storable CSigAtomic where {    sizeOf    (CSigAtomic x)       = sizeOf x ;    alignment (CSigAtomic x)       = alignment x ;    peekElemOff a i       = liftM CSigAtomic (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CSigAtomic x) = pokeElemOff (castPtr a) i x } ; tyConCSigAtomic = mkTyCon \"CSigAtomic\"; instance Typeable CSigAtomic where { typeOf _ = mkAppTy tyConCSigAtomic [] } ; ; instance Bounded CSigAtomic where {    minBound = CSigAtomic minBound ;    maxBound = CSigAtomic maxBound } ; instance Real CSigAtomic where {    toRational (CSigAtomic i) = toRational i } ; instance Integral CSigAtomic where {    (CSigAtomic i) `quot`    (CSigAtomic j) = CSigAtomic (i `quot` j) ;    (CSigAtomic i) `rem`     (CSigAtomic j) = CSigAtomic (i `rem`  j) ;    (CSigAtomic i) `div`     (CSigAtomic j) = CSigAtomic (i `div`  j) ;    (CSigAtomic i) `mod`     (CSigAtomic j) = CSigAtomic (i `mod`  j) ;    (CSigAtomic i) `quotRem` (CSigAtomic j) = let (q,r) = i `quotRem` j in (CSigAtomic q, CSigAtomic r) ;    (CSigAtomic i) `divMod`  (CSigAtomic j) = let (d,m) = i `divMod`  j in (CSigAtomic d, CSigAtomic m) ;    toInteger (CSigAtomic i)       = toInteger i } ; instance Bits CSigAtomic where {   (CSigAtomic x) .&.     (CSigAtomic y)   = CSigAtomic (x .&.   y) ;   (CSigAtomic x) .|.     (CSigAtomic y)   = CSigAtomic (x .|.   y) ;   (CSigAtomic x) `xor`   (CSigAtomic y)   = CSigAtomic (x `xor` y) ;   complement    (CSigAtomic x)   = CSigAtomic (complement x) ;   shift         (CSigAtomic x) n = CSigAtomic (shift x n) ;   rotate        (CSigAtomic x) n = CSigAtomic (rotate x n) ;   bit                 n = CSigAtomic (bit n) ;   setBit        (CSigAtomic x) n = CSigAtomic (setBit x n) ;   clearBit      (CSigAtomic x) n = CSigAtomic (clearBit x n) ;   complementBit (CSigAtomic x) n = CSigAtomic (complementBit x n) ;   testBit       (CSigAtomic x) n = testBit x n ;   bitSize       (CSigAtomic x)   = bitSize x ;   isSigned      (CSigAtomic x)   = isSigned x }\n"
"\n"
"{-# RULES\n"
"\"fromIntegral/a->CPtrdiff\"   fromIntegral = \\x -> CPtrdiff   (fromIntegral x)\n"
"\"fromIntegral/a->CSize\"      fromIntegral = \\x -> CSize      (fromIntegral x)\n"
"\"fromIntegral/a->CWchar\"     fromIntegral = \\x -> CWchar     (fromIntegral x)\n"
"\"fromIntegral/a->CSigAtomic\" fromIntegral = \\x -> CSigAtomic (fromIntegral x)\n"
"\n"
"\"fromIntegral/CPtrdiff->a\"   fromIntegral = \\(CPtrdiff   x) -> fromIntegral x\n"
"\"fromIntegral/CSize->a\"      fromIntegral = \\(CSize      x) -> fromIntegral x\n"
"\"fromIntegral/CWchar->a\"     fromIntegral = \\(CWchar     x) -> fromIntegral x\n"
"\"fromIntegral/CSigAtomic->a\" fromIntegral = \\(CSigAtomic x) -> fromIntegral x\n"
" #-}\n"
"\n"
"newtype CClock = CClock Int64 deriving (Eq, Ord) ; instance Num CClock where {    (CClock i) + (CClock j) = CClock (i + j) ;    (CClock i) - (CClock j) = CClock (i - j) ;    (CClock i) * (CClock j) = CClock (i * j) ;    negate  (CClock i) = CClock (negate i) ;    abs     (CClock i) = CClock (abs    i) ;    signum  (CClock i) = CClock (signum i) ;    fromInteger x = CClock (fromInteger x) } ; instance Read CClock where {    readsPrec p s = map (\\(x, t) -> (CClock x, t)) (readsPrec p s) } ; instance Show CClock where {    showsPrec p (CClock x) = showsPrec p x } ; instance Enum CClock where {    succ           (CClock i)             = CClock (succ i) ;    pred           (CClock i)             = CClock (pred i) ;    toEnum               x           = CClock (toEnum x) ;    fromEnum       (CClock i)             = fromEnum i ;    enumFrom       (CClock i)             = map CClock (enumFrom i) ;    enumFromThen   (CClock i) (CClock j)       = map CClock (enumFromThen i j) ;    enumFromTo     (CClock i) (CClock j)       = map CClock (enumFromTo i j) ;    enumFromThenTo (CClock i) (CClock j) (CClock k) = map CClock (enumFromThenTo i j k) } ; instance Storable CClock where {    sizeOf    (CClock x)       = sizeOf x ;    alignment (CClock x)       = alignment x ;    peekElemOff a i       = liftM CClock (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CClock x) = pokeElemOff (castPtr a) i x } ; tyConCClock = mkTyCon \"CClock\"; instance Typeable CClock where { typeOf _ = mkAppTy tyConCClock [] } ; ; instance Bounded CClock where {    minBound = CClock minBound ;    maxBound = CClock maxBound } ; instance Real CClock where {    toRational (CClock i) = toRational i } ; instance Integral CClock where {    (CClock i) `quot`    (CClock j) = CClock (i `quot` j) ;    (CClock i) `rem`     (CClock j) = CClock (i `rem`  j) ;    (CClock i) `div`     (CClock j) = CClock (i `div`  j) ;    (CClock i) `mod`     (CClock j) = CClock (i `mod`  j) ;    (CClock i) `quotRem` (CClock j) = let (q,r) = i `quotRem` j in (CClock q, CClock r) ;    (CClock i) `divMod`  (CClock j) = let (d,m) = i `divMod`  j in (CClock d, CClock m) ;    toInteger (CClock i)       = toInteger i } ; instance Bits CClock where {   (CClock x) .&.     (CClock y)   = CClock (x .&.   y) ;   (CClock x) .|.     (CClock y)   = CClock (x .|.   y) ;   (CClock x) `xor`   (CClock y)   = CClock (x `xor` y) ;   complement    (CClock x)   = CClock (complement x) ;   shift         (CClock x) n = CClock (shift x n) ;   rotate        (CClock x) n = CClock (rotate x n) ;   bit                 n = CClock (bit n) ;   setBit        (CClock x) n = CClock (setBit x n) ;   clearBit      (CClock x) n = CClock (clearBit x n) ;   complementBit (CClock x) n = CClock (complementBit x n) ;   testBit       (CClock x) n = testBit x n ;   bitSize       (CClock x)   = bitSize x ;   isSigned      (CClock x)   = isSigned x }\n"
"newtype CTime = CTime Int64 deriving (Eq, Ord) ; instance Num CTime where {    (CTime i) + (CTime j) = CTime (i + j) ;    (CTime i) - (CTime j) = CTime (i - j) ;    (CTime i) * (CTime j) = CTime (i * j) ;    negate  (CTime i) = CTime (negate i) ;    abs     (CTime i) = CTime (abs    i) ;    signum  (CTime i) = CTime (signum i) ;    fromInteger x = CTime (fromInteger x) } ; instance Read CTime where {    readsPrec p s = map (\\(x, t) -> (CTime x, t)) (readsPrec p s) } ; instance Show CTime where {    showsPrec p (CTime x) = showsPrec p x } ; instance Enum CTime where {    succ           (CTime i)             = CTime (succ i) ;    pred           (CTime i)             = CTime (pred i) ;    toEnum               x           = CTime (toEnum x) ;    fromEnum       (CTime i)             = fromEnum i ;    enumFrom       (CTime i)             = map CTime (enumFrom i) ;    enumFromThen   (CTime i) (CTime j)       = map CTime (enumFromThen i j) ;    enumFromTo     (CTime i) (CTime j)       = map CTime (enumFromTo i j) ;    enumFromThenTo (CTime i) (CTime j) (CTime k) = map CTime (enumFromThenTo i j k) } ; instance Storable CTime where {    sizeOf    (CTime x)       = sizeOf x ;    alignment (CTime x)       = alignment x ;    peekElemOff a i       = liftM CTime (peekElemOff (castPtr a) i) ;    pokeElemOff a i (CTime x) = pokeElemOff (castPtr a) i x } ; tyConCTime = mkTyCon \"CTime\"; instance Typeable CTime where { typeOf _ = mkAppTy tyConCTime [] } ; ; instance Bounded CTime where {    minBound = CTime minBound ;    maxBound = CTime maxBound } ; instance Real CTime where {    toRational (CTime i) = toRational i } ; instance Integral CTime where {    (CTime i) `quot`    (CTime j) = CTime (i `quot` j) ;    (CTime i) `rem`     (CTime j) = CTime (i `rem`  j) ;    (CTime i) `div`     (CTime j) = CTime (i `div`  j) ;    (CTime i) `mod`     (CTime j) = CTime (i `mod`  j) ;    (CTime i) `quotRem` (CTime j) = let (q,r) = i `quotRem` j in (CTime q, CTime r) ;    (CTime i) `divMod`  (CTime j) = let (d,m) = i `divMod`  j in (CTime d, CTime m) ;    toInteger (CTime i)       = toInteger i } ; instance Bits CTime where {   (CTime x) .&.     (CTime y)   = CTime (x .&.   y) ;   (CTime x) .|.     (CTime y)   = CTime (x .|.   y) ;   (CTime x) `xor`   (CTime y)   = CTime (x `xor` y) ;   complement    (CTime x)   = CTime (complement x) ;   shift         (CTime x) n = CTime (shift x n) ;   rotate        (CTime x) n = CTime (rotate x n) ;   bit                 n = CTime (bit n) ;   setBit        (CTime x) n = CTime (setBit x n) ;   clearBit      (CTime x) n = CTime (clearBit x n) ;   complementBit (CTime x) n = CTime (complementBit x n) ;   testBit       (CTime x) n = testBit x n ;   bitSize       (CTime x)   = bitSize x ;   isSigned      (CTime x)   = isSigned x }\n"
"\n"
"-- FIXME: Implement and provide instances for Eq and Storable\n"
"data CFile = CFile\n"
"data CFpos = CFpos\n"
"data CJmpBuf = CJmpBuf\n"
"\n"
"-- C99 types which are still missing include:\n"
"-- intptr_t, uintptr_t, intmax_t, uintmax_t, wint_t, wctrans_t, wctype_t\n"
"\n";
const char *Foreign_C_String = "\n"
"{-# OPTIONS -fno-implicit-prelude #-}\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.C.String\n"
"-- Copyright   :  (c) The FFI task force 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- Utilities for primitive marshaling\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.C.String (   -- representation of strings in C\n"
"\n"
"  CString,           -- = Ptr CChar\n"
"  CStringLen,        -- = (CString, Int)\n"
"\n"
"  -- conversion of C strings into Haskell strings\n"
"  --\n"
"  peekCString,       -- :: CString    -> IO String\n"
"  peekCStringLen,    -- :: CStringLen -> IO String\n"
"\n"
"  -- conversion of Haskell strings into C strings\n"
"  --\n"
"  newCString,        -- :: String -> IO CString\n"
"  newCStringLen,     -- :: String -> IO CStringLen\n"
"\n"
"  -- conversion of Haskell strings into C strings using temporary storage\n"
"  --\n"
"  withCString,       -- :: String -> (CString    -> IO a) -> IO a\n"
"  withCStringLen,    -- :: String -> (CStringLen -> IO a) -> IO a\n"
"\n"
"  -- conversion between Haskell and C characters *ignoring* the encoding\n"
"  --\n"
"  castCharToCChar,   -- :: Char -> CChar\n"
"  castCCharToChar,   -- :: CChar -> Char\n"
"\n"
"  ) where\n"
"\n"
"import Foreign.Marshal.Array\n"
"import Foreign.C.Types\n"
"import Foreign.Ptr\n"
"import Foreign.Storable\n"
"\n"
"import Data.Word\n"
"\n"
"import Data.Char ( chr, ord )\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Strings\n"
"\n"
"-- representation of strings in C\n"
"-- ------------------------------\n"
"\n"
"type CString    = Ptr CChar		-- conventional NUL terminates strings\n"
"type CStringLen = (CString, Int)	-- strings with explicit length\n"
"\n"
"-- exported functions\n"
"-- ------------------\n"
"--\n"
"-- * the following routines apply the default conversion when converting the\n"
"--   C-land character encoding into the Haskell-land character encoding\n"
"--\n"
"--   ** NOTE: The current implementation doesn't handle conversions yet! **\n"
"--\n"
"-- * the routines using an explicit length tolerate NUL characters in the\n"
"--   middle of a string\n"
"--\n"
"\n"
"-- marshal a NUL terminated C string into a Haskell string \n"
"--\n"
"peekCString    :: CString -> IO String\n"
"peekCString cp  = do cs <- peekArray0 nUL cp; return (cCharsToChars cs)\n"
"\n"
"-- marshal a C string with explicit length into a Haskell string \n"
"--\n"
"peekCStringLen           :: CStringLen -> IO String\n"
"peekCStringLen (cp, len)  = do cs <- peekArray len cp; return (cCharsToChars cs)\n"
"\n"
"-- marshal a Haskell string into a NUL terminated C strings\n"
"--\n"
"-- * the Haskell string may *not* contain any NUL characters\n"
"--\n"
"-- * new storage is allocated for the C string and must be explicitly freed\n"
"--\n"
"newCString :: String -> IO CString\n"
"newCString  = newArray0 nUL . charsToCChars\n"
"\n"
"-- marshal a Haskell string into a C string (ie, character array) with\n"
"-- explicit length information\n"
"--\n"
"-- * new storage is allocated for the C string and must be explicitly freed\n"
"--\n"
"newCStringLen     :: String -> IO CStringLen\n"
"newCStringLen str  = do a <- newArray (charsToCChars str)\n"
"			return (pairLength str a)\n"
"\n"
"-- marshal a Haskell string into a NUL terminated C strings using temporary\n"
"-- storage\n"
"--\n"
"-- * the Haskell string may *not* contain any NUL characters\n"
"--\n"
"-- * see the lifetime constraints of `MarshalAlloc.alloca'\n"
"--\n"
"withCString :: String -> (CString -> IO a) -> IO a\n"
"withCString  = withArray0 nUL . charsToCChars\n"
"\n"
"-- marshal a Haskell string into a NUL terminated C strings using temporary\n"
"-- storage\n"
"--\n"
"-- * the Haskell string may *not* contain any NUL characters\n"
"--\n"
"-- * see the lifetime constraints of `MarshalAlloc.alloca'\n"
"--\n"
"withCStringLen         :: String -> (CStringLen -> IO a) -> IO a\n"
"withCStringLen str act  = withArray (charsToCChars str) $ act . pairLength str\n"
"\n"
"-- auxilliary definitions\n"
"-- ----------------------\n"
"\n"
"-- C's end of string character\n"
"--\n"
"nUL :: CChar\n"
"nUL  = 0\n"
"\n"
"-- pair a C string with the length of the given Haskell string\n"
"--\n"
"pairLength :: String -> CString -> CStringLen\n"
"pairLength  = flip (,) . length\n"
"\n"
"-- cast [CChar] to [Char]\n"
"--\n"
"cCharsToChars :: [CChar] -> [Char]\n"
"cCharsToChars xs  = map castCCharToChar xs\n"
"\n"
"-- cast [Char] to [CChar]\n"
"--\n"
"charsToCChars :: [Char] -> [CChar]\n"
"charsToCChars xs  = map castCharToCChar xs\n"
"\n"
"castCCharToChar :: CChar -> Char\n"
"castCCharToChar ch = chr (fromIntegral (fromIntegral ch :: Word8))\n"
"\n"
"castCharToCChar :: Char -> CChar\n"
"castCharToCChar ch = fromIntegral (ord ch)\n";
const char *Foreign_C_Error = "\n"
"-----------------------------------------------------------------------------\n"
"-- |\n"
"-- Module      :  Foreign.C.Error\n"
"-- Copyright   :  (c) The FFI task force 2001\n"
"-- License     :  BSD-style (see the file libraries/base/LICENSE)\n"
"-- \n"
"-- Maintainer  :  ffi@haskell.org\n"
"-- Stability   :  provisional\n"
"-- Portability :  portable\n"
"--\n"
"-- C-specific Marshalling support: Handling of C \\\"errno\\\" error codes\n"
"--\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Foreign.C.Error (\n"
"\n"
"  -- Haskell representation for \"errno\" values\n"
"  --\n"
"  Errno(..),		-- instance: Eq\n"
"  eOK, e2BIG, eACCES, eADDRINUSE, eADDRNOTAVAIL, eADV, eAFNOSUPPORT, eAGAIN, \n"
"  eALREADY, eBADF, eBADMSG, eBADRPC, eBUSY, eCHILD, eCOMM, eCONNABORTED, \n"
"  eCONNREFUSED, eCONNRESET, eDEADLK, eDESTADDRREQ, eDIRTY, eDOM, eDQUOT, \n"
"  eEXIST, eFAULT, eFBIG, eFTYPE, eHOSTDOWN, eHOSTUNREACH, eIDRM, eILSEQ, \n"
"  eINPROGRESS, eINTR, eINVAL, eIO, eISCONN, eISDIR, eLOOP, eMFILE, eMLINK, \n"
"  eMSGSIZE, eMULTIHOP, eNAMETOOLONG, eNETDOWN, eNETRESET, eNETUNREACH, \n"
"  eNFILE, eNOBUFS, eNODATA, eNODEV, eNOENT, eNOEXEC, eNOLCK, eNOLINK, \n"
"  eNOMEM, eNOMSG, eNONET, eNOPROTOOPT, eNOSPC, eNOSR, eNOSTR, eNOSYS, \n"
"  eNOTBLK, eNOTCONN, eNOTDIR, eNOTEMPTY, eNOTSOCK, eNOTTY, eNXIO, \n"
"  eOPNOTSUPP, ePERM, ePFNOSUPPORT, ePIPE, ePROCLIM, ePROCUNAVAIL, \n"
"  ePROGMISMATCH, ePROGUNAVAIL, ePROTO, ePROTONOSUPPORT, ePROTOTYPE, \n"
"  eRANGE, eREMCHG, eREMOTE, eROFS, eRPCMISMATCH, eRREMOTE, eSHUTDOWN, \n"
"  eSOCKTNOSUPPORT, eSPIPE, eSRCH, eSRMNT, eSTALE, eTIME, eTIMEDOUT, \n"
"  eTOOMANYREFS, eTXTBSY, eUSERS, eWOULDBLOCK, eXDEV,\n"
"                        -- :: Errno\n"
"  isValidErrno,		-- :: Errno -> Bool\n"
"\n"
"  -- access to the current thread's \"errno\" value\n"
"  --\n"
"  getErrno,             -- :: IO Errno\n"
"  resetErrno,           -- :: IO ()\n"
"\n"
"  -- conversion of an \"errno\" value into IO error\n"
"  --\n"
"  errnoToIOError,       -- :: String       -- location\n"
"                        -- -> Errno        -- errno\n"
"                        -- -> Maybe Handle -- handle\n"
"                        -- -> Maybe String -- filename\n"
"                        -- -> IOError\n"
"\n"
"  -- throw current \"errno\" value\n"
"  --\n"
"  throwErrno,           -- ::                String               -> IO a\n"
"\n"
"  -- guards for IO operations that may fail\n"
"  --\n"
"  throwErrnoIf,         -- :: (a -> Bool) -> String -> IO a       -> IO a\n"
"  throwErrnoIf_,        -- :: (a -> Bool) -> String -> IO a       -> IO ()\n"
"  throwErrnoIfRetry,    -- :: (a -> Bool) -> String -> IO a       -> IO a\n"
"  throwErrnoIfRetry_,   -- :: (a -> Bool) -> String -> IO a       -> IO ()\n"
"  throwErrnoIfMinus1,   -- :: Num a \n"
"			-- =>                String -> IO a       -> IO a\n"
"  throwErrnoIfMinus1_,  -- :: Num a \n"
"			-- =>                String -> IO a       -> IO ()\n"
"  throwErrnoIfMinus1Retry,  \n"
"			-- :: Num a \n"
"			-- =>                String -> IO a       -> IO a\n"
"  throwErrnoIfMinus1Retry_,  \n"
"			-- :: Num a \n"
"			-- =>                String -> IO a       -> IO ()\n"
"  throwErrnoIfNull,	-- ::                String -> IO (Ptr a) -> IO (Ptr a)\n"
"  throwErrnoIfNullRetry,-- ::                String -> IO (Ptr a) -> IO (Ptr a)\n"
"\n"
"  throwErrnoIfRetryMayBlock, \n"
"  throwErrnoIfRetryMayBlock_,\n"
"  throwErrnoIfMinus1RetryMayBlock,\n"
"  throwErrnoIfMinus1RetryMayBlock_,  \n"
"  throwErrnoIfNullRetryMayBlock\n"
") where\n"
"\n"
"-- this is were we get the CONST_XXX definitions from that configure\n"
"-- calculated for us\n"
"--\n"
"\n"
"-- system dependent imports\n"
"-- ------------------------\n"
"\n"
"-- GHC allows us to get at the guts inside IO errors/exceptions\n"
"--\n"
"\n"
"-- regular imports\n"
"-- ---------------\n"
"\n"
"import Foreign.Storable\n"
"import Foreign.Ptr\n"
"import Foreign.C.Types\n"
"import Foreign.C.String\n"
"import Foreign.Marshal.Error 	( void )\n"
"import Data.Maybe\n"
"\n"
"import System.IO		( IOError, Handle, ioError )\n"
"import System.IO.Unsafe		( unsafePerformIO )\n"
"\n"
"{-# CBITS errno.c #-}\n"
"\n"
"-- \"errno\" type\n"
"-- ------------\n"
"\n"
"-- import of C function that gives address of errno\n"
"-- This function exists because errno is a variable on some systems, but on\n"
"-- Windows it is a macro for a function...\n"
"-- [yes, global variables and thread safety don't really go hand-in-hand. -- sof]\n"
"foreign import ccall unsafe \"HsBase.h ghcErrno\" _errno :: Ptr CInt\n"
"\n"
"-- Haskell representation for \"errno\" values\n"
"--\n"
"newtype Errno = Errno CInt\n"
"\n"
"instance Eq Errno where\n"
"  errno1@(Errno no1) == errno2@(Errno no2) \n"
"    | isValidErrno errno1 && isValidErrno errno2 = no1 == no2\n"
"    | otherwise					 = False\n"
"\n"
"-- common \"errno\" symbols\n"
"--\n"
"eOK, e2BIG, eACCES, eADDRINUSE, eADDRNOTAVAIL, eADV, eAFNOSUPPORT, eAGAIN, \n"
"  eALREADY, eBADF, eBADMSG, eBADRPC, eBUSY, eCHILD, eCOMM, eCONNABORTED, \n"
"  eCONNREFUSED, eCONNRESET, eDEADLK, eDESTADDRREQ, eDIRTY, eDOM, eDQUOT, \n"
"  eEXIST, eFAULT, eFBIG, eFTYPE, eHOSTDOWN, eHOSTUNREACH, eIDRM, eILSEQ, \n"
"  eINPROGRESS, eINTR, eINVAL, eIO, eISCONN, eISDIR, eLOOP, eMFILE, eMLINK, \n"
"  eMSGSIZE, eMULTIHOP, eNAMETOOLONG, eNETDOWN, eNETRESET, eNETUNREACH, \n"
"  eNFILE, eNOBUFS, eNODATA, eNODEV, eNOENT, eNOEXEC, eNOLCK, eNOLINK, \n"
"  eNOMEM, eNOMSG, eNONET, eNOPROTOOPT, eNOSPC, eNOSR, eNOSTR, eNOSYS, \n"
"  eNOTBLK, eNOTCONN, eNOTDIR, eNOTEMPTY, eNOTSOCK, eNOTTY, eNXIO, \n"
"  eOPNOTSUPP, ePERM, ePFNOSUPPORT, ePIPE, ePROCLIM, ePROCUNAVAIL, \n"
"  ePROGMISMATCH, ePROGUNAVAIL, ePROTO, ePROTONOSUPPORT, ePROTOTYPE, \n"
"  eRANGE, eREMCHG, eREMOTE, eROFS, eRPCMISMATCH, eRREMOTE, eSHUTDOWN, \n"
"  eSOCKTNOSUPPORT, eSPIPE, eSRCH, eSRMNT, eSTALE, eTIME, eTIMEDOUT, \n"
"  eTOOMANYREFS, eTXTBSY, eUSERS, eWOULDBLOCK, eXDEV		       :: Errno\n"
"--\n"
"-- the cCONST_XXX identifiers are cpp symbols whose value is computed by\n"
"-- configure \n"
"--\n"
"eOK             = Errno 0\n"
"e2BIG           = Errno (7)\n"
"eACCES		= Errno (13)\n"
"eADDRINUSE	= Errno (98)\n"
"eADDRNOTAVAIL	= Errno (99)\n"
"eADV		= Errno (68)\n"
"eAFNOSUPPORT	= Errno (97)\n"
"eAGAIN		= Errno (11)\n"
"eALREADY	= Errno (114)\n"
"eBADF		= Errno (9)\n"
"eBADMSG		= Errno (74)\n"
"eBADRPC		= Errno (-1)\n"
"eBUSY		= Errno (16)\n"
"eCHILD		= Errno (10)\n"
"eCOMM		= Errno (70)\n"
"eCONNABORTED	= Errno (103)\n"
"eCONNREFUSED	= Errno (111)\n"
"eCONNRESET	= Errno (104)\n"
"eDEADLK		= Errno (35)\n"
"eDESTADDRREQ	= Errno (89)\n"
"eDIRTY		= Errno (-1)\n"
"eDOM		= Errno (33)\n"
"eDQUOT		= Errno (122)\n"
"eEXIST		= Errno (17)\n"
"eFAULT		= Errno (14)\n"
"eFBIG		= Errno (27)\n"
"eFTYPE		= Errno (-1)\n"
"eHOSTDOWN	= Errno (112)\n"
"eHOSTUNREACH	= Errno (113)\n"
"eIDRM		= Errno (43)\n"
"eILSEQ		= Errno (84)\n"
"eINPROGRESS	= Errno (115)\n"
"eINTR		= Errno (4)\n"
"eINVAL		= Errno (22)\n"
"eIO		= Errno (5)\n"
"eISCONN		= Errno (106)\n"
"eISDIR		= Errno (21)\n"
"eLOOP		= Errno (40)\n"
"eMFILE		= Errno (24)\n"
"eMLINK		= Errno (31)\n"
"eMSGSIZE	= Errno (90)\n"
"eMULTIHOP	= Errno (72)\n"
"eNAMETOOLONG	= Errno (36)\n"
"eNETDOWN	= Errno (100)\n"
"eNETRESET	= Errno (102)\n"
"eNETUNREACH	= Errno (101)\n"
"eNFILE		= Errno (23)\n"
"eNOBUFS		= Errno (105)\n"
"eNODATA		= Errno (61)\n"
"eNODEV		= Errno (19)\n"
"eNOENT		= Errno (2)\n"
"eNOEXEC		= Errno (8)\n"
"eNOLCK		= Errno (37)\n"
"eNOLINK		= Errno (67)\n"
"eNOMEM		= Errno (12)\n"
"eNOMSG		= Errno (42)\n"
"eNONET		= Errno (64)\n"
"eNOPROTOOPT	= Errno (92)\n"
"eNOSPC		= Errno (28)\n"
"eNOSR		= Errno (63)\n"
"eNOSTR		= Errno (60)\n"
"eNOSYS		= Errno (38)\n"
"eNOTBLK		= Errno (15)\n"
"eNOTCONN	= Errno (107)\n"
"eNOTDIR		= Errno (20)\n"
"eNOTEMPTY	= Errno (39)\n"
"eNOTSOCK	= Errno (88)\n"
"eNOTTY		= Errno (25)\n"
"eNXIO		= Errno (6)\n"
"eOPNOTSUPP	= Errno (95)\n"
"ePERM		= Errno (1)\n"
"ePFNOSUPPORT	= Errno (96)\n"
"ePIPE		= Errno (32)\n"
"ePROCLIM	= Errno (-1)\n"
"ePROCUNAVAIL	= Errno (-1)\n"
"ePROGMISMATCH	= Errno (-1)\n"
"ePROGUNAVAIL	= Errno (-1)\n"
"ePROTO		= Errno (71)\n"
"ePROTONOSUPPORT = Errno (93)\n"
"ePROTOTYPE	= Errno (91)\n"
"eRANGE		= Errno (34)\n"
"eREMCHG		= Errno (78)\n"
"eREMOTE		= Errno (66)\n"
"eROFS		= Errno (30)\n"
"eRPCMISMATCH	= Errno (-1)\n"
"eRREMOTE	= Errno (-1)\n"
"eSHUTDOWN	= Errno (108)\n"
"eSOCKTNOSUPPORT = Errno (94)\n"
"eSPIPE		= Errno (29)\n"
"eSRCH		= Errno (3)\n"
"eSRMNT		= Errno (69)\n"
"eSTALE		= Errno (116)\n"
"eTIME		= Errno (62)\n"
"eTIMEDOUT	= Errno (110)\n"
"eTOOMANYREFS	= Errno (109)\n"
"eTXTBSY		= Errno (26)\n"
"eUSERS		= Errno (87)\n"
"eWOULDBLOCK	= Errno (11)\n"
"eXDEV		= Errno (18)\n"
"\n"
"-- checks whether the given errno value is supported on the current\n"
"-- architecture\n"
"--\n"
"isValidErrno               :: Errno -> Bool\n"
"--\n"
"-- the configure script sets all invalid \"errno\"s to -1\n"
"--\n"
"isValidErrno (Errno errno)  = errno /= -1\n"
"\n"
"-- access to the current thread's \"errno\" value\n"
"-- --------------------------------------------\n"
"\n"
"-- yield the current thread's \"errno\" value\n"
"--\n"
"getErrno :: IO Errno\n"
"getErrno  = do e <- peek _errno; return (Errno e)\n"
"\n"
"-- set the current thread's \"errno\" value to 0\n"
"--\n"
"resetErrno :: IO ()\n"
"resetErrno  = poke _errno 0\n"
"\n"
"-- throw current \"errno\" value\n"
"-- ---------------------------\n"
"\n"
"-- the common case: throw an IO error based on a textual description\n"
"-- of the error location and the current thread's \"errno\" value\n"
"--\n"
"throwErrno     :: String -> IO a\n"
"throwErrno loc  =\n"
"  do\n"
"    errno <- getErrno\n"
"    ioError (errnoToIOError loc errno Nothing Nothing)\n"
"\n"
"-- guards for IO operations that may fail\n"
"-- --------------------------------------\n"
"\n"
"-- guard an IO operation and throw an \"errno\" based exception of the result\n"
"-- value of the IO operation meets the given predicate\n"
"--\n"
"throwErrnoIf            :: (a -> Bool) -> String -> IO a -> IO a\n"
"throwErrnoIf pred loc f  = \n"
"  do\n"
"    res <- f\n"
"    if pred res then throwErrno loc else return res\n"
"\n"
"-- as `throwErrnoIf', but discards the result\n"
"--\n"
"throwErrnoIf_            :: (a -> Bool) -> String -> IO a -> IO ()\n"
"throwErrnoIf_ pred loc f  = void $ throwErrnoIf pred loc f\n"
"\n"
"-- as `throwErrnoIf', but retries interrupted IO operations (ie, those whose\n"
"-- flag `EINTR')\n"
"--\n"
"throwErrnoIfRetry            :: (a -> Bool) -> String -> IO a -> IO a\n"
"throwErrnoIfRetry pred loc f  = \n"
"  do\n"
"    res <- f\n"
"    if pred res\n"
"      then do\n"
"	err <- getErrno\n"
"	if err == eINTR\n"
"	  then throwErrnoIfRetry pred loc f\n"
"	  else throwErrno loc\n"
"      else return res\n"
"\n"
"-- as `throwErrnoIfRetry', but checks for operations that would block and\n"
"-- executes an alternative action in that case.\n"
"\n"
"throwErrnoIfRetryMayBlock  :: (a -> Bool) -> String -> IO a -> IO b -> IO a\n"
"throwErrnoIfRetryMayBlock pred loc f on_block  = \n"
"  do\n"
"    res <- f\n"
"    if pred res\n"
"      then do\n"
"	err <- getErrno\n"
"	if err == eINTR\n"
"	  then throwErrnoIfRetryMayBlock pred loc f on_block\n"
"          else if err == eWOULDBLOCK || err == eAGAIN\n"
"	         then do on_block; throwErrnoIfRetryMayBlock pred loc f on_block\n"
"                 else throwErrno loc\n"
"      else return res\n"
"\n"
"-- as `throwErrnoIfRetry', but discards the result\n"
"--\n"
"throwErrnoIfRetry_            :: (a -> Bool) -> String -> IO a -> IO ()\n"
"throwErrnoIfRetry_ pred loc f  = void $ throwErrnoIfRetry pred loc f\n"
"\n"
"-- as `throwErrnoIfRetryMayBlock', but discards the result\n"
"--\n"
"throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()\n"
"throwErrnoIfRetryMayBlock_ pred loc f on_block \n"
"  = void $ throwErrnoIfRetryMayBlock pred loc f on_block\n"
"\n"
"-- throws \"errno\" if a result of \"-1\" is returned\n"
"--\n"
"throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a\n"
"throwErrnoIfMinus1  = throwErrnoIf (== -1)\n"
"\n"
"-- as `throwErrnoIfMinus1', but discards the result\n"
"--\n"
"throwErrnoIfMinus1_ :: Num a => String -> IO a -> IO ()\n"
"throwErrnoIfMinus1_  = throwErrnoIf_ (== -1)\n"
"\n"
"-- throws \"errno\" if a result of \"-1\" is returned, but retries in case of an\n"
"-- interrupted operation\n"
"--\n"
"throwErrnoIfMinus1Retry :: Num a => String -> IO a -> IO a\n"
"throwErrnoIfMinus1Retry  = throwErrnoIfRetry (== -1)\n"
"\n"
"-- as `throwErrnoIfMinus1', but discards the result\n"
"--\n"
"throwErrnoIfMinus1Retry_ :: Num a => String -> IO a -> IO ()\n"
"throwErrnoIfMinus1Retry_  = throwErrnoIfRetry_ (== -1)\n"
"\n"
"-- as throwErrnoIfMinus1Retry, but checks for operations that would block\n"
"--\n"
"throwErrnoIfMinus1RetryMayBlock :: Num a => String -> IO a -> IO b -> IO a\n"
"throwErrnoIfMinus1RetryMayBlock  = throwErrnoIfRetryMayBlock (== -1)\n"
"\n"
"-- as `throwErrnoIfMinus1RetryMayBlock', but discards the result\n"
"--\n"
"throwErrnoIfMinus1RetryMayBlock_ :: Num a => String -> IO a -> IO b -> IO ()\n"
"throwErrnoIfMinus1RetryMayBlock_  = throwErrnoIfRetryMayBlock_ (== -1)\n"
"\n"
"-- throws \"errno\" if a result of a NULL pointer is returned\n"
"--\n"
"throwErrnoIfNull :: String -> IO (Ptr a) -> IO (Ptr a)\n"
"throwErrnoIfNull  = throwErrnoIf (== nullPtr)\n"
"\n"
"-- throws \"errno\" if a result of a NULL pointer is returned, but retries in\n"
"-- case of an interrupted operation\n"
"--\n"
"throwErrnoIfNullRetry :: String -> IO (Ptr a) -> IO (Ptr a)\n"
"throwErrnoIfNullRetry  = throwErrnoIfRetry (== nullPtr)\n"
"\n"
"-- as throwErrnoIfNullRetry, but checks for operations that would block\n"
"--\n"
"throwErrnoIfNullRetryMayBlock :: String -> IO (Ptr a) -> IO b -> IO (Ptr a)\n"
"throwErrnoIfNullRetryMayBlock  = throwErrnoIfRetryMayBlock (== nullPtr)\n"
"\n"
"-- conversion of an \"errno\" value into IO error\n"
"-- --------------------------------------------\n"
"\n"
"-- convert a location string, an \"errno\" value, an optional handle,\n"
"-- and an optional filename into a matching IO error\n"
"--\n"
"errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError\n"
"errnoToIOError loc errno maybeHdl maybeName = unsafePerformIO $ do\n"
"    str <- strerror errno >>= peekCString\n"
"    return (userError (loc ++ \": \" ++ str ++ maybe \"\" (\": \"++) maybeName))\n"
"\n"
"foreign import ccall unsafe \"string.h\" strerror :: Errno -> IO (Ptr CChar)\n";
const char *Hugs_Exception = "-- This is a cut-down version of GHC's Exception module\n"
"--\n"
"-- The main difference is that Hugs does not throw asynchronous\n"
"-- exceptions, in particular heap and stack overflow and ctrl-C.\n"
"-- Indeed, it is not entirely clear what to do in response to ctrl-C.\n"
"\n"
"module Hugs.Exception(\n"
"        Exception(..),\n"
"	IOException(..),\n"
"	ArithException(..),\n"
"	ArrayException(..),\n"
"	AsyncException(..),\n"
"\n"
"	catchException,		-- :: IO a -> (Exception -> IO a) -> IO a\n"
"\n"
"	-- Throwing exceptions\n"
"\n"
"	throwIO,		-- :: Exception -> IO a\n"
"	throw,			-- :: Exception -> a\n"
"\n"
"	evaluate,		-- :: a -> IO a\n"
"\n"
"	-- Async exception control\n"
"\n"
"        block,			-- :: IO a -> IO a\n"
"        unblock,		-- :: IO a -> IO a\n"
"  ) where\n"
"\n"
"import Hugs.Prelude\n"
"\n"
"instance Eq Exception where\n"
"  ArithException e1   == ArithException e2   = e1 == e2\n"
"  ArrayException e1   == ArrayException e2   = e1 == e2\n"
"  AssertionFailed e1  == AssertionFailed e2  = e1 == e2\n"
"  AsyncException e1   == AsyncException e2   = e1 == e2\n"
"  BlockedOnDeadMVar   == BlockedOnDeadMVar   = True\n"
"  Deadlock            == Deadlock            = True\n"
"  DynException _      == DynException _      = False -- incomparable\n"
"  ErrorCall e1        == ErrorCall e2        = e1 == e2\n"
"  ExitException e1    == ExitException e2    = e1 == e2\n"
"  IOException e1      == IOException e2      = e1 == e2\n"
"  NoMethodError e1    == NoMethodError e2    = e1 == e2\n"
"  NonTermination      == NonTermination      = True\n"
"  PatternMatchFail e1 == PatternMatchFail e2 = e1 == e2\n"
"  RecConError e1      == RecConError e2      = e1 == e2\n"
"  RecSelError e1      == RecSelError e2      = e1 == e2\n"
"  RecUpdError e1      == RecUpdError e2      = e1 == e2\n"
"  _                   == _                   = False\n"
"\n"
"----------------------------------------------------------------\n"
"-- Primitive throw and catch\n"
"----------------------------------------------------------------\n"
"\n"
"throwIO :: Exception -> IO a\n"
"throwIO exn = IO (\\ s -> throw exn)\n"
"\n"
"evaluate :: a -> IO a\n"
"evaluate x = IO (\\ s -> x `seq` s x)\n"
"\n"
"----------------------------------------------------------------\n"
"-- dummy implementations of block and unblock\n"
"----------------------------------------------------------------\n"
"\n"
"block, unblock :: IO a -> IO a\n"
"block   m = m\n"
"unblock m = m\n"
"\n"
"----------------------------------------------------------------\n"
"-- End\n"
"----------------------------------------------------------------\n";
const char *Hugs_System = "-----------------------------------------------------------------------------\n"
"-- Standard Library: System operations\n"
"--\n"
"-- Note: on Windows 9x, system always yields ExitSuccess.\n"
"--\n"
"-- Suitable for use with Hugs 98\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.System (\n"
"	getArgs, getProgName, withArgs, withProgName, getEnv,\n"
"	system\n"
"	) where\n"
"\n"
"import Hugs.Prelude( ExitCode(..), catchException, throw )\n"
"\n"
"-- In interpretive mode, the initial values of these two are [] and \"Hugs\",\n"
"-- but they can be (temporarily) changed using withArgs and withProgName.\n"
"primitive getArgs     \"primGetArgs\"     :: IO [String]\n"
"primitive getProgName \"primGetProgName\" :: IO String\n"
"\n"
"primitive setArgs     \"primSetArgs\"     :: [String] -> IO ()\n"
"primitive setProgName \"primSetProgName\" :: String -> IO ()\n"
"\n"
"-- Run an action with a value temporarily overridden\n"
"-- (a special case of Control.Exception.bracket)\n"
"with :: IO a -> (a -> IO ()) -> a -> IO b -> IO b\n"
"with getVal setVal newVal act = do\n"
"    oldVal <- getVal\n"
"    setVal newVal\n"
"    r <- act `catchException` \\e -> setVal oldVal >> throw e\n"
"    setVal oldVal\n"
"    return r\n"
"\n"
"withArgs :: [String] -> IO a -> IO a\n"
"withArgs = with getArgs setArgs\n"
"\n"
"withProgName :: String -> IO a -> IO a\n"
"withProgName = with getProgName setProgName\n"
"\n"
"primitive getEnv            :: String -> IO String\n"
"\n"
"system                      :: String -> IO ExitCode\n"
"system s                     = do r <- primSystem s\n"
"                                  return (toExitCode r)\n"
"\n"
"primitive primSystem        :: String -> IO Int\n"
"\n"
"toExitCode                  :: Int -> ExitCode\n"
"toExitCode 0                 = ExitSuccess\n"
"toExitCode n                 = ExitFailure n\n"
"\n"
"-----------------------------------------------------------------------------\n";
const char *Hugs_Trex = "-----------------------------------------------------------------------------\n"
"-- Trex utilities:  Functions to compare and show record values\n"
"--\n"
"-- Warning: This file is an integral part of the TREX implementation, and\n"
"-- should not be modified without corresponding changes in the interpreter.\n"
"--\n"
"-- Suitable for use with Hugs 98, if compiled with TREX support.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.Trex( Rec, emptyRec, EmptyRow,\n"
"	ShowRecRow(..), EqRecRow(..), insertField ) where\n"
"\n"
"import Hugs.Prelude ( Rec, emptyRec, EmptyRow )\n"
"\n"
"-- Code for equalities:\n"
"\n"
"instance EqRecRow r => Eq (Rec r) where\n"
"  r == s = eqFields (eqRecRow r s)\n"
"           where eqFields = and . map snd\n"
"\n"
"class EqRecRow r where\n"
"  eqRecRow :: Rec r -> Rec r -> [(String,Bool)]\n"
"\n"
"instance EqRecRow EmptyRow where\n"
"  eqRecRow _ _ = []\n"
"\n"
"\n"
"-- Code for showing values:\n"
"\n"
"instance ShowRecRow r => Show (Rec r) where\n"
"  showsPrec d = showFields . showRecRow\n"
"   where\n"
"    showFields   :: [(String, ShowS)] -> ShowS\n"
"    showFields [] = showString \"emptyRec\"\n"
"    showFields xs = showChar '(' . foldr1 comma (map fld xs) . showChar ')'\n"
"     where comma a b = a . showString \", \" . b\n"
"           fld (s,v) = showString s . showChar '=' . v\n"
"\n"
"class ShowRecRow r where\n"
"  showRecRow :: Rec r -> [(String, ShowS)]\n"
"\n"
"instance ShowRecRow EmptyRow where\n"
"  showRecRow _ = []\n"
"\n"
"\n"
"-- General utility:\n"
"\n"
"insertField       :: String -> v -> [(String, v)] -> [(String, v)]\n"
"insertField n v fs = {- case fs of\n"
"                       []     -> [(n,v)]\n"
"                       (r:rs) -> if n <= fst r\n"
"                                   then (n,v):fs\n"
"                                   else r : insertField n v rs -}\n"
"                     bef ++ [(n,v)] ++ aft\n"
" where (bef,aft) = span (\\r -> n > fst r) fs\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n";
const char *Hugs_Stable = "module Hugs.Stable where \n"
"\n"
"data StableName a -- abstract\n"
"\n"
"primitive makeStableName   :: a -> IO (StableName a)\n"
"primitive deRefStableName  :: StableName a -> a\n"
"primitive hashStableName   :: StableName a -> Int\n"
"primitive eqStableName	   :: StableName a -> StableName a -> Bool\n"
"\n"
"instance Eq (StableName a) where\n"
"    (==) = eqStableName\n";
const char *Hugs_ST = "-----------------------------------------------------------------------------\n"
"-- Strict State Thread module\n"
"-- \n"
"-- This library provides support for strict state threads, as described\n"
"-- in the PLDI '94 paper by John Launchbury and Simon Peyton Jones.\n"
"-- In addition to the monad ST, it also provides mutable variables STRef\n"
"-- and mutable arrays STArray.\n"
"--\n"
"-- Suitable for use with Hugs 98.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.ST \n"
"	( ST(..)\n"
"	, runST\n"
"	, unsafeRunST\n"
"	, RealWorld\n"
"	, stToIO\n"
"	, unsafeIOToST\n"
"\n"
"	, STRef\n"
"	  -- instance Eq (STRef s a)\n"
"	, newSTRef\n"
"	, readSTRef\n"
"	, writeSTRef \n"
"\n"
"        , STArray\n"
"          -- instance Eq (STArray s ix elt)\n"
"        , newSTArray\n"
"        , boundsSTArray\n"
"        , readSTArray\n"
"        , writeSTArray\n"
"        , thawSTArray\n"
"        , freezeSTArray\n"
"        , unsafeFreezeSTArray\n"
"\n"
"	, unsafeReadSTArray\n"
"	, unsafeWriteSTArray\n"
"	) where\n"
"\n"
"import Hugs.Prelude(IO(..))\n"
"import Hugs.Array(Array,Ix(index,rangeSize),bounds,elems)\n"
"import Hugs.IOExts(unsafePerformIO)\n"
"import Control.Monad   \n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- The ST representation generalizes that of IO (cf. Hugs.Prelude),\n"
"-- so it can use IO primitives that manipulate local state.\n"
"\n"
"newtype ST s a = ST (forall r. (a -> r) -> r)\n"
"\n"
"data RealWorld = RealWorld\n"
"\n"
"primitive thenStrictST \"primbindIO\" :: ST s a -> (a -> ST s b) -> ST s b\n"
"primitive returnST     \"primretIO\"  :: a -> ST s a\n"
"\n"
"unST                :: ST s a -> (a -> r) -> r\n"
"unST (ST f)          = f\n"
"\n"
"runST               :: (forall s. ST s a) -> a\n"
"runST m              = unST m id\n"
"\n"
"unsafeRunST         :: ST s a -> a\n"
"unsafeRunST m        = unST m id\n"
"\n"
"stToIO              :: ST RealWorld a -> IO a\n"
"stToIO (ST f)        = IO f\n"
"\n"
"unsafeIOToST        :: IO a -> ST s a\n"
"unsafeIOToST         = unsafePerformIO . liftM returnST\n"
"\n"
"instance Functor (ST s) where\n"
"    fmap = liftM\n"
"\n"
"instance Monad (ST s) where\n"
"    (>>=)  = thenStrictST\n"
"    return = returnST\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"data STRef s a   -- implemented as an internal primitive\n"
"\n"
"primitive newSTRef   \"newRef\"     :: a -> ST s (STRef s a)\n"
"primitive readSTRef  \"getRef\"     :: STRef s a -> ST s a\n"
"primitive writeSTRef \"setRef\"     :: STRef s a -> a -> ST s ()\n"
"primitive eqSTRef    \"eqRef\"      :: STRef s a -> STRef s a -> Bool\n"
"\n"
"instance Eq (STRef s a) where (==) = eqSTRef\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"data STArray s ix elt -- implemented as an internal primitive\n"
"\n"
"newSTArray          :: Ix ix => (ix,ix) -> elt -> ST s (STArray s ix elt)\n"
"boundsSTArray       :: Ix ix => STArray s ix elt -> (ix, ix)\n"
"readSTArray         :: Ix ix => STArray s ix elt -> ix -> ST s elt\n"
"writeSTArray        :: Ix ix => STArray s ix elt -> ix -> elt -> ST s ()\n"
"thawSTArray         :: Ix ix => Array ix elt -> ST s (STArray s ix elt)\n"
"freezeSTArray       :: Ix ix => STArray s ix elt -> ST s (Array ix elt)\n"
"unsafeFreezeSTArray :: Ix ix => STArray s ix elt -> ST s (Array ix elt)\n"
"\n"
"unsafeReadSTArray   :: Ix i => STArray s i e -> Int -> ST s e\n"
"unsafeReadSTArray    = primReadArr\n"
"\n"
"unsafeWriteSTArray  :: Ix i => STArray s i e -> Int -> e -> ST s ()\n"
"unsafeWriteSTArray   = primWriteArr\n"
"\n"
"newSTArray bs e      = primNewArr bs (rangeSize bs) e\n"
"boundsSTArray a      = primBounds a\n"
"readSTArray a i      = unsafeReadSTArray a (index (boundsSTArray a) i)\n"
"writeSTArray a i e   = unsafeWriteSTArray a (index (boundsSTArray a) i) e\n"
"thawSTArray arr      = do\n"
"		       stArr <- newSTArray (bounds arr) err\n"
"		       sequence_ (zipWith (unsafeWriteSTArray stArr)\n"
"						[0..] (elems arr))\n"
"		       return stArr\n"
" where\n"
"  err = error \"thawArray: element not overwritten\" -- shouldnae happen\n"
"freezeSTArray a      = primFreeze a\n"
"unsafeFreezeSTArray  = freezeSTArray  -- not as fast as GHC\n"
"\n"
"instance Eq (STArray s ix elt) where\n"
"  (==) = eqSTArray\n"
"\n"
"primitive primNewArr   \"IONewArr\"\n"
"          :: (a,a) -> Int -> b -> ST s (STArray s a b)\n"
"primitive primReadArr  \"IOReadArr\"\n"
"          :: STArray s a b -> Int -> ST s b\n"
"primitive primWriteArr \"IOWriteArr\"\n"
"          :: STArray s a b -> Int -> b -> ST s ()\n"
"primitive primFreeze   \"IOFreeze\"\n"
"          :: STArray s a b -> ST s (Array a b)\n"
"primitive primBounds   \"IOBounds\"\n"
"          :: STArray s a b -> (a,a)\n"
"primitive eqSTArray    \"IOArrEq\"\n"
"          :: STArray s a b -> STArray s a b -> Bool\n"
"\n"
"-----------------------------------------------------------------------------\n";
const char *Hugs_ByteArray = "-- Mutable and immutable byte arrays (identical internally), usable for\n"
"-- unboxed arrays, and built from FFI primitives.\n"
"\n"
"module Hugs.ByteArray (\n"
"	MutableByteArray,\n"
"	newMutableByteArray, readMutableByteArray, writeMutableByteArray,\n"
"	ByteArray,\n"
"	unsafeFreezeMutableByteArray, thawByteArray, readByteArray\n"
"    ) where\n"
"\n"
"import Data.Word		( Word8 )\n"
"import Foreign.ForeignPtr	( ForeignPtr,\n"
"				  mallocForeignPtrBytes, withForeignPtr )\n"
"import Foreign.Marshal.Utils	( copyBytes )\n"
"import Foreign.Ptr		( castPtr )\n"
"import Foreign.Storable		( Storable( peekElemOff, pokeElemOff ))\n"
"\n"
"import Hugs.IOExts		( unsafeCoerce )\n"
"import Hugs.ST			( ST, unsafeRunST )\n"
"\n"
"-- This implementation is based on the principle that the FFI primitives\n"
"-- used, though declared as IO actions, actually only manipulate local\n"
"-- state, and thus could have been declared in the strict ST monad:\n"
"--\n"
"--	mallocForeignPtrBytes :: Int -> ST s (STForeignPtr s a)\n"
"--	withForeignPtr :: STForeignPtr s a -> (STPtr s a -> ST s b) -> ST s b\n"
"--	copyBytes :: STPtr s a -> STPtr s a -> Int -> ST s ()\n"
"--	castPtr :: STPtr s a -> STPtr s b\n"
"--	peekElemOff :: Storable a => STPtr s a -> Int -> ST s a\n"
"--	pokeElemOff :: Storable a => STPtr s a -> Int -> a -> ST s ()\n"
"--\n"
"-- (where STPtr s and STForeignPtr s are just like Ptr and ForeignPtr,\n"
"-- but confined to the region s)\n"
"--\n"
"-- Since the strict ST monad has the same representation as the IO monad,\n"
"-- we are justified in coercing such actions to the ST monad.\n"
"\n"
"-- This conversion may be safely applied to computations that manipulate\n"
"-- only local state, but will give a runtime error if the IO action does\n"
"-- any concurrency.\n"
"specialIOToST :: IO a -> ST s a\n"
"specialIOToST = unsafeCoerce\n"
"\n"
"type BytePtr = ForeignPtr Word8\n"
"\n"
"data MutableByteArray s = MutableByteArray !Int !BytePtr\n"
"\n"
"newMutableByteArray :: Int -> ST s (MutableByteArray s)\n"
"newMutableByteArray size = do\n"
"    fp <- specialIOToST (mallocForeignPtrBytes size)\n"
"    return (MutableByteArray size fp)\n"
"\n"
"readMutableByteArray :: Storable e => MutableByteArray s -> Int -> ST s e\n"
"readMutableByteArray (MutableByteArray _ fp) i =\n"
"    specialIOToST $ withForeignPtr fp $ \\a -> peekElemOff (castPtr a) i\n"
"\n"
"writeMutableByteArray :: Storable e => MutableByteArray s -> Int -> e -> ST s ()\n"
"writeMutableByteArray (MutableByteArray _ fp) i e =\n"
"    specialIOToST $ withForeignPtr fp $ \\a -> pokeElemOff (castPtr a) i e\n"
"\n"
"data ByteArray = ByteArray !Int !BytePtr\n"
"\n"
"-- Don't change the MutableByteArray after calling this.\n"
"unsafeFreezeMutableByteArray :: MutableByteArray s -> ST s ByteArray\n"
"unsafeFreezeMutableByteArray (MutableByteArray size fp) =\n"
"    return (ByteArray size fp)\n"
"\n"
"thawByteArray :: ByteArray -> ST s (MutableByteArray s)\n"
"thawByteArray (ByteArray size fp) = specialIOToST $ do\n"
"    fp' <- mallocForeignPtrBytes size\n"
"    withForeignPtr fp $ \\p ->\n"
"	withForeignPtr fp' $ \\p' ->\n"
"	copyBytes p' p size\n"
"    return (MutableByteArray size fp')\n"
"\n"
"-- This one is safe because ByteArrays are immutable\n"
"-- (cf. unsafeFreezeMutableByteArray)\n"
"readByteArray :: Storable a => ByteArray -> Int -> a\n"
"readByteArray (ByteArray _ fp) i = unsafeRunST $ specialIOToST $\n"
"    withForeignPtr fp $ \\p -> peekElemOff (castPtr p) i\n";
const char *Hugs_CVHAssert = "----------------------------------------------------------------\n"
"-- This is a simple implementation of Cordy Hall's assertions\n"
"-- (for performance debugging).\n"
"--\n"
"-- NB These primitives are an _experimental_ feature which may be\n"
"--    removed in future versions of Hugs.\n"
"--    They can only be used if hugs was configured with the\n"
"--    \"--enable-internal-prims\" flag.\n"
"--\n"
"-- These primitives mostly break referential transparency - but you're\n"
"-- only supposed to use them for debugging purposes.\n"
"----------------------------------------------------------------\n"
"\n"
"module Hugs.CVHAssert(\n"
"	Test, Action, \n"
"	assert,\n"
"	isEvaluated,\n"
"	pointerEqual\n"
"	) where\n"
"\n"
"import Hugs.Internals(\n"
"	ptrEq,\n"
"	Name,   nameInfo,\n"
"	Cell,   getCell, cellPtrEq,\n"
"	CellKind(..), classifyCell,\n"
"	)\n"
"import Hugs.IOExts(\n"
"	unsafePerformIO\n"
"	)\n"
"\n"
"----------------------------------------------------------------\n"
"-- High level operations\n"
"----------------------------------------------------------------\n"
"\n"
"type Test a   = a -> Bool\n"
"type Action a = a -> IO ()\n"
"\n"
"assert :: Test a -> Action a -> a -> a\n"
"assert test action x = \n"
"  unsafePerformIO (if test x then return () else action x)\n"
"  `seq`\n"
"  x \n"
"\n"
"isEvaluated :: a -> Bool\n"
"isEvaluated x = unsafePerformIO (\n"
"  isEvaluatedCell (getCell x)\n"
"  )\n"
"\n"
"representationSize :: a -> Int\n"
"representationSize x = unsafePerformIO (do \n"
"  cells <- cellsOf (getCell x) []\n"
"  return (cellSize * length cells)\n"
"  )\n"
"\n"
"pointerEqual :: a -> a -> Bool\n"
"pointerEqual = ptrEq\n"
"\n"
"----------------------------------------------------------------\n"
"-- Utilities\n"
"----------------------------------------------------------------\n"
"\n"
"isEvaluatedCell :: Cell -> IO Bool\n"
"isEvaluatedCell cell = do\n"
"  kind <- classifyCell False cell\n"
"\n"
"  case kind of\n"
"    Apply fun args -> do \n"
"		    funkind <- classifyCell False fun\n"
"                    case funkind of\n"
"                      Fun nm    -> return (nameArity nm > length args)\n"
"                      _         -> return True\n"
"    _            -> return True\n"
"\n"
"arityOf :: Cell -> IO Int\n"
"arityOf cell = do\n"
"  kind <- classifyCell False cell\n"
"\n"
"  case kind of\n"
"    Apply fun args -> do \n"
"		    funarity <- arityOf fun\n"
"		    return (funarity - length args)\n"
"\n"
"    Fun   nm -> return (nameArity nm)\n"
"    Con   nm -> return (nameArity nm)\n"
"    Tuple i  -> return i\n"
"    _            -> return 0\n"
"\n"
"\n"
"nameArity :: Name -> Int\n"
"nameArity nm = case nameInfo nm of (arity,_,_) -> arity\n"
"\n"
"-- list cells occurring in Cell\n"
"cellsOf :: Cell -> [Cell] -> IO [Cell]\n"
"\n"
"cellsOf cell seen \n"
"  | cell `elemCell` seen \n"
"  = return seen\n"
"  | otherwise\n"
"  = do\n"
"      let seen' = cell:seen\n"
"\n"
"      kind <- classifyCell False cell\n"
"\n"
"      case kind of\n"
"	Apply f xs -> do\n"
"			    seen'' <- cellsOf f seen'\n"
"			    cellsOf' xs seen''\n"
"	Fun     _  -> return seen'\n"
"	Con     _  -> return seen'\n"
"	Tuple   _  -> return seen'\n"
"	Int     _  -> return seen'\n"
"	Integer _  -> return seen'\n"
"	Float   _  -> return seen'\n"
"	Char    _  -> return seen'\n"
"	Prim    _  -> return seen'\n"
"	Error   _  -> return seen'	-- we could argue about this one\n"
"\n"
"cellsOf' :: [Cell] -> [Cell] -> IO [Cell]\n"
"cellsOf' []     seen = return seen\n"
"cellsOf' (x:xs) seen = do seen' <- cellsOf x seen\n"
"                          cellsOf' xs seen'\n"
"\n"
"elemCell :: Cell -> [Cell] -> Bool\n"
"x `elemCell` []     = False\n"
"x `elemCell` (y:ys) = x `cellPtrEq` y || x `elemCell` ys\n"
"\n"
"cellSize :: Int\n"
"cellSize = 8\n"
"\n"
"----------------------------------------------------------------\n";
const char *Hugs_Prelude = "{----------------------------------------------------------------------------\n"
"__   __ __  __  ____   ___    _______________________________________________\n"
"||   || ||  || ||  || ||__    Hugs 98: The Nottingham and Yale Haskell system\n"
"||___|| ||__|| ||__||  __||   Copyright (c) 1994-1999\n"
"||---||         ___||         World Wide Web: http://haskell.org/hugs\n"
"||   ||                       Report bugs to: hugs-bugs@haskell.org\n"
"||   || Version: February 1999_______________________________________________\n"
"\n"
" This is the Hugs 98 Standard Prelude, based very closely on the Standard\n"
" Prelude for Haskell 98.\n"
"\n"
" WARNING: This file is an integral part of the Hugs source code.  Changes to\n"
" the definitions in this file without corresponding modifications in other\n"
" parts of the program may cause the interpreter to fail unexpectedly.  Under\n"
" normal circumstances, you should not attempt to modify this file in any way!\n"
"\n"
"-----------------------------------------------------------------------------\n"
" The Hugs 98 system is Copyright (c) Mark P Jones, Alastair Reid, the\n"
" Yale Haskell Group, and the OGI School of Science & Engineering at OHSU,\n"
" 1994-2003, All rights reserved.  It is distributed as free software under\n"
" the license in the file \"License\", which is included in the distribution.\n"
"----------------------------------------------------------------------------}\n"
"\n"
"module Hugs.Prelude (\n"
"--  module PreludeList,\n"
"    map, (++), concat, filter,\n"
"    head, last, tail, init, null, length, (!!),\n"
"    foldl, foldl1, scanl, scanl1, foldr, foldr1, scanr, scanr1,\n"
"    iterate, repeat, replicate, cycle,\n"
"    take, drop, splitAt, takeWhile, dropWhile, span, break,\n"
"    lines, words, unlines, unwords, reverse, and, or,\n"
"    any, all, elem, notElem, lookup,\n"
"    sum, product, maximum, minimum, concatMap, \n"
"    zip, zip3, zipWith, zipWith3, unzip, unzip3,\n"
"--  module PreludeText, \n"
"    ReadS, ShowS,\n"
"    Read(readsPrec, readList),\n"
"    Show(show, showsPrec, showList),\n"
"    reads, shows, read, lex,\n"
"    showChar, showString, readParen, showParen,\n"
"--  module PreludeIO,\n"
"    FilePath, IOError, ioError, userError, catch,\n"
"    putChar, putStr, putStrLn, print,\n"
"    getChar, getLine, getContents, interact,\n"
"    readFile, writeFile, appendFile, readIO, readLn,\n"
"--  module Ix,\n"
"    Ix(range, index, unsafeIndex, inRange, rangeSize, unsafeRangeSize),\n"
"--  module Char,\n"
"    isSpace, isUpper, isLower,\n"
"    isAlpha, isDigit, isOctDigit, isHexDigit, isAlphaNum,\n"
"    readLitChar, showLitChar, lexLitChar,\n"
"--  module Numeric\n"
"    showSigned, showInt,\n"
"    readSigned, readInt,\n"
"    readDec, readOct, readHex, readSigned,\n"
"    readFloat, lexDigits, \n"
"--  module Ratio,\n"
"    Ratio((:%)), (%), numerator, denominator,\n"
"--  Non-standard exports\n"
"    IO(..), IOResult(..),\n"
"    IOException(..), IOErrorType(..),\n"
"    Exception(..),\n"
"    ArithException(..), ArrayException(..), AsyncException(..),\n"
"    ExitCode(..),\n"
"    FunPtr, Ptr, Addr,\n"
"    Word, StablePtr, ForeignObj, ForeignPtr,\n"
"    Int8, Int16, Int32, Int64,\n"
"    Word8, Word16, Word32, Word64,\n"
"    Handle, Object,\n"
"    basicIORun, blockIO, IOFinished(..),\n"
"    threadToIOResult,\n"
"    catchException, throw,\n"
"    Dynamic(..), TypeRep(..), Key(..), TyCon(..), Obj,\n"
"\n"
"    Bool(False, True),\n"
"    Maybe(Nothing, Just),\n"
"    Either(Left, Right),\n"
"    Ordering(LT, EQ, GT),\n"
"    Char, String, Int, Integer, Float, Double, Rational, IO,\n"
"--  List type: []((:), [])\n"
"    (:),\n"
"--  Tuple types: (,), (,,), etc.\n"
"--  Trivial type: ()\n"
"--  Functions: (->)\n"
"    Rec, emptyRec, EmptyRow, -- non-standard, should only be exported if TREX\n"
"    Eq((==), (/=)),\n"
"    Ord(compare, (<), (<=), (>=), (>), max, min),\n"
"    Enum(succ, pred, toEnum, fromEnum, enumFrom, enumFromThen,\n"
"         enumFromTo, enumFromThenTo),\n"
"    Bounded(minBound, maxBound),\n"
"--  Num((+), (-), (*), negate, abs, signum, fromInteger),\n"
"    Num((+), (-), (*), negate, abs, signum, fromInteger, fromInt),\n"
"    Real(toRational),\n"
"--  Integral(quot, rem, div, mod, quotRem, divMod, toInteger),\n"
"    Integral(quot, rem, div, mod, quotRem, divMod, toInteger, toInt),\n"
"--  Fractional((/), recip, fromRational),\n"
"    Fractional((/), recip, fromRational, fromDouble),\n"
"    Floating(pi, exp, log, sqrt, (**), logBase, sin, cos, tan,\n"
"             asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh),\n"
"    RealFrac(properFraction, truncate, round, ceiling, floor),\n"
"    RealFloat(floatRadix, floatDigits, floatRange, decodeFloat,\n"
"              encodeFloat, exponent, significand, scaleFloat, isNaN,\n"
"              isInfinite, isDenormalized, isIEEE, isNegativeZero, atan2),\n"
"    Monad((>>=), (>>), return, fail),\n"
"    Functor(fmap),\n"
"    mapM, mapM_, sequence, sequence_, (=<<),\n"
"    maybe, either,\n"
"    (&&), (||), not, otherwise,\n"
"    subtract, even, odd, gcd, lcm, (^), (^^), \n"
"    fromIntegral, realToFrac,\n"
"    fst, snd, curry, uncurry, id, const, (.), flip, ($), until,\n"
"    asTypeOf, error, undefined,\n"
"    seq, ($!),\n"
"\n"
"    numericEnumFrom,\n"
"    numericEnumFromTo,\n"
"    numericEnumFromThen,\n"
"    numericEnumFromThenTo\n"
"  ) where\n"
"\n"
"-- Standard value bindings {Prelude} ----------------------------------------\n"
"\n"
"infixr 9  .\n"
"infixl 9  !!\n"
"infixr 8  ^, ^^, **\n"
"infixl 7  *, /, `quot`, `rem`, `div`, `mod`, :%, %\n"
"infixl 6  +, -\n"
"--infixr 5  :    -- this fixity declaration is hard-wired into Hugs\n"
"infixr 5  ++\n"
"infix  4  ==, /=, <, <=, >=, >, `elem`, `notElem`\n"
"infixr 3  &&\n"
"infixr 2  ||\n"
"infixl 1  >>, >>=\n"
"infixr 1  =<<\n"
"infixr 0  $, $!, `seq`\n"
"\n"
"-- Equality and Ordered classes ---------------------------------------------\n"
"\n"
"class Eq a where\n"
"    (==), (/=) :: a -> a -> Bool\n"
"\n"
"    -- Minimal complete definition: (==) or (/=)\n"
"    x == y      = not (x/=y)\n"
"    x /= y      = not (x==y)\n"
"\n"
"class (Eq a) => Ord a where\n"
"    compare                :: a -> a -> Ordering\n"
"    (<), (<=), (>=), (>)   :: a -> a -> Bool\n"
"    max, min               :: a -> a -> a\n"
"\n"
"    -- Minimal complete definition: (<=) or compare\n"
"    -- using compare can be more efficient for complex types\n"
"    compare x y | x==y      = EQ\n"
"		| x<=y      = LT\n"
"		| otherwise = GT\n"
"\n"
"    x <= y                  = compare x y /= GT\n"
"    x <  y                  = compare x y == LT\n"
"    x >= y                  = compare x y /= LT\n"
"    x >  y                  = compare x y == GT\n"
"\n"
"    max x y   | x <= y      = y\n"
"	      | otherwise   = x\n"
"    min x y   | x <= y      = x\n"
"	      | otherwise   = y\n"
"\n"
"class Bounded a where\n"
"    minBound, maxBound :: a\n"
"    -- Minimal complete definition: All\n"
"\n"
"-- Numeric classes ----------------------------------------------------------\n"
"\n"
"class (Eq a, Show a) => Num a where\n"
"    (+), (-), (*)  :: a -> a -> a\n"
"    negate         :: a -> a\n"
"    abs, signum    :: a -> a\n"
"    fromInteger    :: Integer -> a\n"
"    fromInt        :: Int -> a\n"
"\n"
"    -- Minimal complete definition: All, except negate or (-)\n"
"    x - y           = x + negate y\n"
"    fromInt         = fromIntegral\n"
"    negate x        = 0 - x\n"
"\n"
"class (Num a, Ord a) => Real a where\n"
"    toRational     :: a -> Rational\n"
"\n"
"class (Real a, Enum a) => Integral a where\n"
"    quot, rem, div, mod :: a -> a -> a\n"
"    quotRem, divMod     :: a -> a -> (a,a)\n"
"    toInteger           :: a -> Integer\n"
"    toInt               :: a -> Int\n"
"\n"
"    -- Minimal complete definition: quotRem and toInteger\n"
"    n `quot` d           = q where (q,r) = quotRem n d\n"
"    n `rem` d            = r where (q,r) = quotRem n d\n"
"    n `div` d            = q where (q,r) = divMod n d\n"
"    n `mod` d            = r where (q,r) = divMod n d\n"
"    divMod n d           = if signum r == - signum d then (q-1, r+d) else qr\n"
"			   where qr@(q,r) = quotRem n d\n"
"    toInt                = toInt . toInteger\n"
"\n"
"class (Num a) => Fractional a where\n"
"    (/)          :: a -> a -> a\n"
"    recip        :: a -> a\n"
"    fromRational :: Rational -> a\n"
"    fromDouble   :: Double -> a\n"
"\n"
"    -- Minimal complete definition: fromRational and ((/) or recip)\n"
"    recip x       = 1 / x\n"
"    fromDouble    = fromRational . fromDouble\n"
"    x / y         = x * recip y\n"
"\n"
"\n"
"class (Fractional a) => Floating a where\n"
"    pi                  :: a\n"
"    exp, log, sqrt      :: a -> a\n"
"    (**), logBase       :: a -> a -> a\n"
"    sin, cos, tan       :: a -> a\n"
"    asin, acos, atan    :: a -> a\n"
"    sinh, cosh, tanh    :: a -> a\n"
"    asinh, acosh, atanh :: a -> a\n"
"\n"
"    -- Minimal complete definition: pi, exp, log, sin, cos, sinh, cosh,\n"
"    --				    asinh, acosh, atanh\n"
"    pi                   = 4 * atan 1\n"
"    x ** y               = exp (log x * y)\n"
"    logBase x y          = log y / log x\n"
"    sqrt x               = x ** 0.5\n"
"    tan x                = sin x / cos x\n"
"    sinh x               = (exp x - exp (-x)) / 2\n"
"    cosh x               = (exp x + exp (-x)) / 2\n"
"    tanh x               = sinh x / cosh x\n"
"    asinh x              = log (x + sqrt (x*x + 1))\n"
"    acosh x              = log (x + sqrt (x*x - 1))\n"
"    atanh x              = (log (1 + x) - log (1 - x)) / 2\n"
"\n"
"class (Real a, Fractional a) => RealFrac a where\n"
"    properFraction   :: (Integral b) => a -> (b,a)\n"
"    truncate, round  :: (Integral b) => a -> b\n"
"    ceiling, floor   :: (Integral b) => a -> b\n"
"\n"
"    -- Minimal complete definition: properFraction\n"
"    truncate x        = m where (m,_) = properFraction x\n"
"\n"
"    round x           = let (n,r) = properFraction x\n"
"			    m     = if r < 0 then n - 1 else n + 1\n"
"			in case signum (abs r - 0.5) of\n"
"			    -1 -> n\n"
"			    0  -> if even n then n else m\n"
"			    1  -> m\n"
"\n"
"    ceiling x         = if r > 0 then n + 1 else n\n"
"			where (n,r) = properFraction x\n"
"\n"
"    floor x           = if r < 0 then n - 1 else n\n"
"			where (n,r) = properFraction x\n"
"\n"
"class (RealFrac a, Floating a) => RealFloat a where\n"
"    floatRadix       :: a -> Integer\n"
"    floatDigits      :: a -> Int\n"
"    floatRange       :: a -> (Int,Int)\n"
"    decodeFloat      :: a -> (Integer,Int)\n"
"    encodeFloat      :: Integer -> Int -> a\n"
"    exponent         :: a -> Int\n"
"    significand      :: a -> a\n"
"    scaleFloat       :: Int -> a -> a\n"
"    isNaN, isInfinite, isDenormalized, isNegativeZero, isIEEE\n"
"		     :: a -> Bool\n"
"    atan2	     :: a -> a -> a\n"
"\n"
"    -- Minimal complete definition: All, except exponent, signficand,\n"
"    --				    scaleFloat, atan2\n"
"    exponent x        = if m==0 then 0 else n + floatDigits x\n"
"			where (m,n) = decodeFloat x\n"
"    significand x     = encodeFloat m (- floatDigits x)\n"
"			where (m,_) = decodeFloat x\n"
"    scaleFloat k x    = encodeFloat m (n+k)\n"
"			where (m,n) = decodeFloat x\n"
"    atan2 y x\n"
"      | x>0           = atan (y/x)\n"
"      | x==0 && y>0   = pi/2\n"
"      | x<0 && y>0    = pi + atan (y/x)\n"
"      | (x<=0 && y<0) ||\n"
"        (x<0 && isNegativeZero y) ||\n"
"        (isNegativeZero x && isNegativeZero y)\n"
"		      = - atan2 (-y) x\n"
"      | y==0 && (x<0 || isNegativeZero x)\n"
"		      = pi    -- must be after the previous test on zero y\n"
"      | x==0 && y==0  = y     -- must be after the other double zero tests\n"
"      | otherwise     = x + y -- x or y is a NaN, return a NaN (via +)\n"
"\n"
"-- Numeric functions --------------------------------------------------------\n"
"\n"
"subtract       :: Num a => a -> a -> a\n"
"subtract        = flip (-)\n"
"\n"
"even, odd        :: (Integral a) => a -> Bool\n"
"even n           =  n `rem` 2 == 0\n"
"odd              =  not . even\n"
"\n"
"gcd            :: Integral a => a -> a -> a\n"
"gcd 0 0         = error \"Prelude.gcd: gcd 0 0 is undefined\"\n"
"gcd x y         = gcd' (abs x) (abs y)\n"
"		  where gcd' x 0 = x\n"
"			gcd' x y = gcd' y (x `rem` y)\n"
"\n"
"lcm            :: (Integral a) => a -> a -> a\n"
"lcm _ 0         = 0\n"
"lcm 0 _         = 0\n"
"lcm x y         = abs ((x `quot` gcd x y) * y)\n"
"\n"
"(^)            :: (Num a, Integral b) => a -> b -> a\n"
"x ^ 0           = 1\n"
"x ^ n  | n > 0  = f x (n-1) x\n"
"		  where f _ 0 y = y\n"
"			f x n y = g x n where\n"
"				  g x n | even n    = g (x*x) (n`quot`2)\n"
"					| otherwise = f x (n-1) (x*y)\n"
"_ ^ _           = error \"Prelude.^: negative exponent\"\n"
"\n"
"(^^)           :: (Fractional a, Integral b) => a -> b -> a\n"
"x ^^ n          = if n >= 0 then x ^ n else recip (x^(-n))\n"
"\n"
"fromIntegral   :: (Integral a, Num b) => a -> b\n"
"fromIntegral    = fromInteger . toInteger\n"
"\n"
"realToFrac     :: (Real a, Fractional b) => a -> b\n"
"realToFrac      = fromRational . toRational\n"
"\n"
"-- Index and Enumeration classes --------------------------------------------\n"
"\n"
"class (Ord a) => Ix a where\n"
"    range                :: (a,a) -> [a]\n"
"    index, unsafeIndex   :: (a,a) -> a -> Int\n"
"    inRange              :: (a,a) -> a -> Bool\n"
"    rangeSize            :: (a,a) -> Int\n"
"    unsafeRangeSize      :: (a,a) -> Int\n"
"\n"
"	-- Must specify one of index, unsafeIndex\n"
"    index b i | inRange b i = unsafeIndex b i\n"
"              | otherwise   = error \"Error in array index\"\n"
"    unsafeIndex b i = index b i\n"
"\n"
"	-- As long as you don't override the default rangeSize,\n"
"	-- you can specify unsafeRangeSize as follows, to speed up\n"
"	-- some operations:\n"
"	--\n"
"	--    unsafeRangeSize b@(_l,h) = unsafeIndex b h + 1\n"
"	--\n"
"    rangeSize b@(_l,h) | inRange b h = unsafeIndex b h + 1\n"
"                       | otherwise   = 0\n"
"    unsafeRangeSize b = rangeSize b\n"
"\n"
"	-- NB: replacing \"inRange b h\" by  \"l <= u\"\n"
"	-- fails if the bounds are tuples.  For example,\n"
"	-- 	(1,2) <= (2,1)\n"
"	-- but the range is nevertheless empty\n"
"	--	range ((1,2),(2,1)) = []\n"
"\n"
"class Enum a where\n"
"    succ, pred           :: a -> a\n"
"    toEnum               :: Int -> a\n"
"    fromEnum             :: a -> Int\n"
"    enumFrom             :: a -> [a]              -- [n..]\n"
"    enumFromThen         :: a -> a -> [a]         -- [n,m..]\n"
"    enumFromTo           :: a -> a -> [a]         -- [n..m]\n"
"    enumFromThenTo       :: a -> a -> a -> [a]    -- [n,n'..m]\n"
"\n"
"    -- Minimal complete definition: toEnum, fromEnum\n"
"    succ                  = toEnum . (1+)       . fromEnum\n"
"    pred                  = toEnum . subtract 1 . fromEnum\n"
"    enumFrom x            = map toEnum [ fromEnum x ..]\n"
"    enumFromTo x y        = map toEnum [ fromEnum x .. fromEnum y ]\n"
"    enumFromThen x y      = map toEnum [ fromEnum x, fromEnum y ..]\n"
"    enumFromThenTo x y z  = map toEnum [ fromEnum x, fromEnum y .. fromEnum z ]\n"
"\n"
"-- Read and Show classes ------------------------------------------------------\n"
"\n"
"type ReadS a = String -> [(a,String)]\n"
"type ShowS   = String -> String\n"
"\n"
"class Read a where\n"
"    readsPrec :: Int -> ReadS a\n"
"    readList  :: ReadS [a]\n"
"\n"
"    -- Minimal complete definition: readsPrec\n"
"    readList   = readParen False (\\r -> [pr | (\"[\",s) <- lex r,\n"
"					      pr      <- readl s ])\n"
"		 where readl  s = [([],t)   | (\"]\",t) <- lex s] ++\n"
"				  [(x:xs,u) | (x,t)   <- reads s,\n"
"					      (xs,u)  <- readl' t]\n"
"		       readl' s = [([],t)   | (\"]\",t) <- lex s] ++\n"
"				  [(x:xs,v) | (\",\",t) <- lex s,\n"
"					      (x,u)   <- reads t,\n"
"					      (xs,v)  <- readl' u]\n"
"\n"
"class Show a where\n"
"    show      :: a -> String\n"
"    showsPrec :: Int -> a -> ShowS\n"
"    showList  :: [a] -> ShowS\n"
"\n"
"    -- Minimal complete definition: show or showsPrec\n"
"    show x          = showsPrec 0 x \"\"\n"
"    showsPrec _ x s = show x ++ s\n"
"    showList []     = showString \"[]\"\n"
"    showList (x:xs) = showChar '[' . shows x . showl xs\n"
"		      where showl []     = showChar ']'\n"
"			    showl (x:xs) = showChar ',' . shows x . showl xs\n"
"\n"
"-- Monad classes ------------------------------------------------------------\n"
"\n"
"class Functor f where\n"
"    fmap :: (a -> b) -> (f a -> f b)\n"
"\n"
"class Monad m where\n"
"    return :: a -> m a\n"
"    (>>=)  :: m a -> (a -> m b) -> m b\n"
"    (>>)   :: m a -> m b -> m b\n"
"    fail   :: String -> m a\n"
"\n"
"    -- Minimal complete definition: (>>=), return\n"
"    p >> q  = p >>= \\ _ -> q\n"
"    fail s  = error s\n"
"\n"
"sequence       :: Monad m => [m a] -> m [a]\n"
"sequence []     = return []\n"
"sequence (c:cs) = do x  <- c\n"
"		     xs <- sequence cs\n"
"		     return (x:xs)\n"
"\n"
"sequence_        :: Monad m => [m a] -> m ()\n"
"sequence_         = foldr (>>) (return ())\n"
"\n"
"mapM             :: Monad m => (a -> m b) -> [a] -> m [b]\n"
"mapM f            = sequence . map f\n"
"\n"
"mapM_            :: Monad m => (a -> m b) -> [a] -> m ()\n"
"mapM_ f           = sequence_ . map f\n"
"\n"
"(=<<)            :: Monad m => (a -> m b) -> m a -> m b\n"
"f =<< x           = x >>= f\n"
"\n"
"-- Evaluation and strictness ------------------------------------------------\n"
"\n"
"primitive seq           :: a -> b -> b\n"
"\n"
"primitive ($!) \"strict\" :: (a -> b) -> a -> b\n"
"-- f $! x                = x `seq` f x\n"
"\n"
"-- Trivial type -------------------------------------------------------------\n"
"\n"
"-- data () = () deriving (Eq, Ord, Ix, Enum, Read, Show, Bounded)\n"
"\n"
"instance Eq () where\n"
"    () == ()  =  True\n"
"\n"
"instance Ord () where\n"
"    compare () () = EQ\n"
"\n"
"instance Ix () where\n"
"    range ((),())      = [()]\n"
"    index ((),()) ()   = 0\n"
"    inRange ((),()) () = True\n"
"\n"
"instance Enum () where\n"
"    toEnum 0           = ()\n"
"    fromEnum ()        = 0\n"
"    enumFrom ()        = [()]\n"
"    enumFromThen () () = [()]\n"
"\n"
"instance Read () where\n"
"    readsPrec p = readParen False (\\r -> [((),t) | (\"(\",s) <- lex r,\n"
"						   (\")\",t) <- lex s ])\n"
"\n"
"instance Show () where\n"
"    showsPrec p () = showString \"()\"\n"
"\n"
"instance Bounded () where\n"
"    minBound = ()\n"
"    maxBound = ()\n"
"\n"
"-- Boolean type -------------------------------------------------------------\n"
"\n"
"data Bool    = False | True\n"
"	       deriving (Eq, Ord, Ix, Enum, Read, Show, Bounded)\n"
"\n"
"(&&), (||)  :: Bool -> Bool -> Bool\n"
"False && x   = False\n"
"True  && x   = x\n"
"False || x   = x\n"
"True  || x   = True\n"
"\n"
"not         :: Bool -> Bool\n"
"not True     = False\n"
"not False    = True\n"
"\n"
"otherwise   :: Bool\n"
"otherwise    = True\n"
"\n"
"-- Character type -----------------------------------------------------------\n"
"\n"
"data Char               -- builtin datatype of ISO Latin characters\n"
"type String = [Char]    -- strings are lists of characters\n"
"\n"
"primitive primEqChar    :: Char -> Char -> Bool\n"
"primitive primCmpChar   :: Char -> Char -> Ordering\n"
"\n"
"instance Eq Char  where (==)    = primEqChar\n"
"instance Ord Char where compare = primCmpChar\n"
"\n"
"primitive primCharToInt :: Char -> Int\n"
"primitive primIntToChar :: Int -> Char\n"
"\n"
"instance Enum Char where\n"
"    toEnum           = primIntToChar\n"
"    fromEnum         = primCharToInt\n"
"    enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Char)]\n"
"    enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (lastChar::Char)]\n"
"		       where lastChar = if d < c then minBound else maxBound\n"
"\n"
"instance Ix Char where\n"
"    range (c,c')      = [c..c']\n"
"    index b@(c,c') ci\n"
"       | inRange b ci = fromEnum ci - fromEnum c\n"
"       | otherwise    = error \"Ix.index: Index out of range.\"\n"
"    inRange (c,c') ci = fromEnum c <= i && i <= fromEnum c'\n"
"			where i = fromEnum ci\n"
"\n"
"instance Read Char where\n"
"    readsPrec p      = readParen False\n"
"			    (\\r -> [(c,t) | ('\\'':s,t) <- lex r,\n"
"					    (c,\"\\'\")   <- readLitChar s ])\n"
"    readList = readParen False (\\r -> [(l,t) | ('\"':s, t) <- lex r,\n"
"					       (l,_)      <- readl s ])\n"
"	       where readl ('\"':s)      = [(\"\",s)]\n"
"		     readl ('\\\\':'&':s) = readl s\n"
"		     readl s            = [(c:cs,u) | (c ,t) <- readLitChar s,\n"
"						      (cs,u) <- readl t ]\n"
"instance Show Char where\n"
"    showsPrec p '\\'' = showString \"'\\\\''\"\n"
"    showsPrec p c    = showChar '\\'' . showLitChar c . showChar '\\''\n"
"\n"
"    showList cs   = showChar '\"' . showl cs\n"
"		    where showl \"\"       = showChar '\"'\n"
"			  showl ('\"':cs) = showString \"\\\\\\\"\" . showl cs\n"
"			  showl (c:cs)   = showLitChar c . showl cs\n"
"\n"
"instance Bounded Char where\n"
"    minBound = '\\0'\n"
"    maxBound = '\\255'\n"
"\n"
"isSpace, isUpper, isLower, isAlpha, isDigit, isAlphaNum :: Char -> Bool\n"
"\n"
"isSpace c              =  c == ' '  ||\n"
"			  c == '\\t' ||\n"
"			  c == '\\n' ||\n"
"			  c == '\\r' ||\n"
"			  c == '\\f' ||\n"
"			  c == '\\v' ||\n"
"			  c == '\\xa0'\n"
"\n"
"isUpper c              =  c >= 'A'    && c <= 'Z'    ||\n"
"                          c >= '\\xc0' && c <= '\\xd6' ||\n"
"                          c >= '\\xd8' && c <= '\\xde'\n"
"\n"
"isLower c              =  c >= 'a'   &&  c <= 'z'    ||\n"
"                          c >= '\\xdf' && c <= '\\xf6' ||\n"
"                          c >= '\\xf8' && c <= '\\xff'\n"
"\n"
"isAlpha c              =  isUpper c  ||  isLower c\n"
"isDigit c              =  c >= '0'   &&  c <= '9'\n"
"isAlphaNum c           =  isAlpha c  ||  isDigit c\n"
"\n"
"-- Maybe type ---------------------------------------------------------------\n"
"\n"
"data Maybe a = Nothing | Just a\n"
"	       deriving (Eq, Ord, Read, Show)\n"
"\n"
"maybe             :: b -> (a -> b) -> Maybe a -> b\n"
"maybe n f Nothing  = n\n"
"maybe n f (Just x) = f x\n"
"\n"
"instance Functor Maybe where\n"
"    fmap f Nothing  = Nothing\n"
"    fmap f (Just x) = Just (f x)\n"
"\n"
"instance Monad Maybe where\n"
"    Just x  >>= k = k x\n"
"    Nothing >>= k = Nothing\n"
"    return        = Just\n"
"    fail s        = Nothing\n"
"\n"
"-- Either type --------------------------------------------------------------\n"
"\n"
"data Either a b = Left a | Right b\n"
"		  deriving (Eq, Ord, Read, Show)\n"
"\n"
"either              :: (a -> c) -> (b -> c) -> Either a b -> c\n"
"either l r (Left x)  = l x\n"
"either l r (Right y) = r y\n"
"\n"
"-- Ordering type ------------------------------------------------------------\n"
"\n"
"data Ordering = LT | EQ | GT\n"
"		deriving (Eq, Ord, Ix, Enum, Read, Show, Bounded)\n"
"\n"
"-- Lists --------------------------------------------------------------------\n"
"\n"
"-- data [a] = [] | a : [a] deriving (Eq, Ord)\n"
"\n"
"instance Eq a => Eq [a] where\n"
"    []     == []     =  True\n"
"    (x:xs) == (y:ys) =  x==y && xs==ys\n"
"    _      == _      =  False\n"
"\n"
"instance Ord a => Ord [a] where\n"
"    compare []     (_:_)  = LT\n"
"    compare []     []     = EQ\n"
"    compare (_:_)  []     = GT\n"
"    compare (x:xs) (y:ys) = primCompAux x y (compare xs ys)\n"
"\n"
"instance Functor [] where\n"
"    fmap = map\n"
"\n"
"instance Monad [ ] where\n"
"    (x:xs) >>= f = f x ++ (xs >>= f)\n"
"    []     >>= f = []\n"
"    return x     = [x]\n"
"    fail s       = []\n"
"\n"
"instance Read a => Read [a]  where\n"
"    readsPrec p = readList\n"
"\n"
"instance Show a => Show [a]  where\n"
"    showsPrec p = showList\n"
"\n"
"-- Tuples -------------------------------------------------------------------\n"
"\n"
"-- data (a,b) = (a,b) deriving (Eq, Ord, Ix, Read, Show)\n"
"-- etc..\n"
"\n"
"-- Standard Integral types --------------------------------------------------\n"
"\n"
"data Int      -- builtin datatype of fixed size integers\n"
"data Integer  -- builtin datatype of arbitrary size integers\n"
"\n"
"primitive primEqInt      :: Int -> Int -> Bool\n"
"primitive primCmpInt     :: Int -> Int -> Ordering\n"
"primitive primEqInteger  :: Integer -> Integer -> Bool\n"
"primitive primCmpInteger :: Integer -> Integer -> Ordering\n"
"\n"
"instance Eq  Int     where (==)    = primEqInt\n"
"instance Eq  Integer where (==)    = primEqInteger\n"
"instance Ord Int     where compare = primCmpInt\n"
"instance Ord Integer where compare = primCmpInteger\n"
"\n"
"primitive primPlusInt,\n"
"	  primMinusInt,\n"
"	  primMulInt	   :: Int -> Int -> Int\n"
"primitive primNegInt	   :: Int -> Int\n"
"primitive primIntegerToInt :: Integer -> Int\n"
"\n"
"instance Num Int where\n"
"    (+)           = primPlusInt\n"
"    (-)           = primMinusInt\n"
"    negate        = primNegInt\n"
"    (*)           = primMulInt\n"
"    abs           = absReal\n"
"    signum        = signumReal\n"
"    fromInteger   = primIntegerToInt\n"
"    fromInt x     = x\n"
"\n"
"primitive primMinInt, primMaxInt :: Int\n"
"\n"
"instance Bounded Int where\n"
"    minBound = primMinInt\n"
"    maxBound = primMaxInt\n"
"\n"
"primitive primPlusInteger,\n"
"	  primMinusInteger,\n"
"	  primMulInteger   :: Integer -> Integer -> Integer\n"
"primitive primNegInteger   :: Integer -> Integer\n"
"primitive primIntToInteger :: Int -> Integer\n"
"\n"
"instance Num Integer where\n"
"    (+)           = primPlusInteger\n"
"    (-)           = primMinusInteger\n"
"    negate        = primNegInteger\n"
"    (*)           = primMulInteger\n"
"    abs           = absReal\n"
"    signum        = signumReal\n"
"    fromInteger x = x\n"
"    fromInt       = primIntToInteger\n"
"\n"
"absReal x    | x >= 0    = x\n"
"	     | otherwise = -x\n"
"\n"
"signumReal x | x == 0    =  0\n"
"	     | x > 0     =  1\n"
"	     | otherwise = -1\n"
"\n"
"instance Real Int where\n"
"    toRational x = toInteger x % 1\n"
"\n"
"instance Real Integer where\n"
"    toRational x = x % 1\n"
"\n"
"primitive primDivInt,\n"
"	  primQuotInt,\n"
"	  primRemInt,\n"
"	  primModInt  :: Int -> Int -> Int\n"
"primitive primQrmInt  :: Int -> Int -> (Int,Int)\n"
"\n"
"instance Integral Int where\n"
"    div       = primDivInt\n"
"    quot      = primQuotInt\n"
"    rem       = primRemInt\n"
"    mod       = primModInt\n"
"    quotRem   = primQrmInt\n"
"    toInteger = primIntToInteger\n"
"    toInt x   = x\n"
"\n"
"primitive primQrmInteger  :: Integer -> Integer -> (Integer,Integer)\n"
"\n"
"instance Integral Integer where\n"
"    quotRem     = primQrmInteger\n"
"    toInteger x = x\n"
"    toInt       = primIntegerToInt\n"
"\n"
"instance Ix Int where\n"
"    range (m,n)          = [m..n]\n"
"    index b@(m,n) i\n"
"	   | inRange b i = i - m\n"
"	   | otherwise   = error \"index: Index out of range\"\n"
"    inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Ix Integer where\n"
"    range (m,n)          = [m..n]\n"
"    index b@(m,n) i\n"
"	   | inRange b i = fromInteger (i - m)\n"
"	   | otherwise   = error \"index: Index out of range\"\n"
"    inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Int where\n"
"    toEnum               = id\n"
"    fromEnum             = id\n"
"    enumFrom       = numericEnumFrom\n"
"    enumFromTo     = numericEnumFromTo\n"
"    enumFromThen   = numericEnumFromThen\n"
"    enumFromThenTo = numericEnumFromThenTo\n"
"\n"
"instance Enum Integer where\n"
"    succ x         = x + 1\n"
"    pred x         = x - 1\n"
"\n"
"    toEnum         = primIntToInteger\n"
"    fromEnum       = primIntegerToInt\n"
"    enumFrom       = numericEnumFrom\n"
"    enumFromThen   = numericEnumFromThen\n"
"    enumFromTo     = numericEnumFromTo\n"
"    enumFromThenTo = numericEnumFromThenTo\n"
"\n"
"\n"
"numericEnumFrom        :: Real a => a -> [a]\n"
"numericEnumFromThen    :: Real a => a -> a -> [a]\n"
"numericEnumFromTo      :: Real a => a -> a -> [a]\n"
"numericEnumFromThenTo  :: Real a => a -> a -> a -> [a]\n"
"numericEnumFrom n            = n : (numericEnumFrom $! (n+1))\n"
"numericEnumFromThen n m      = iterate ((m-n)+) n\n"
"numericEnumFromTo n m        = takeWhile (<= m) (numericEnumFrom n)\n"
"numericEnumFromThenTo n n' m = takeWhile p (numericEnumFromThen n n')\n"
"                               where p | n' >= n   = (<= m)\n"
"				       | otherwise = (>= m)\n"
"\n"
"primitive primShowsInt :: Int -> Int -> ShowS\n"
"\n"
"instance Read Int where\n"
"    readsPrec p = readSigned readDec\n"
"\n"
"instance Show Int where\n"
"    showsPrec   = primShowsInt\n"
"\n"
"primitive primShowsInteger :: Int -> Integer -> ShowS\n"
"\n"
"instance Read Integer where\n"
"    readsPrec p = readSigned readDec\n"
"\n"
"instance Show Integer where\n"
"    showsPrec   = primShowsInteger\n"
"\n"
"-- Standard Floating types --------------------------------------------------\n"
"\n"
"data Float     -- builtin datatype of single precision floating point numbers\n"
"data Double    -- builtin datatype of double precision floating point numbers\n"
"\n"
"primitive primEqFloat   :: Float -> Float -> Bool\n"
"primitive primCmpFloat  :: Float -> Float -> Ordering\n"
"primitive primEqDouble  :: Double -> Double -> Bool\n"
"primitive primCmpDouble :: Double -> Double -> Ordering\n"
"\n"
"instance Eq  Float  where (==) = primEqFloat\n"
"instance Eq  Double where (==) = primEqDouble\n"
"\n"
"instance Ord Float  where compare = primCmpFloat\n"
"instance Ord Double where compare = primCmpDouble\n"
"\n"
"primitive primPlusFloat,\n"
"	  primMinusFloat,\n"
"	  primMulFloat       :: Float -> Float -> Float\n"
"primitive primNegFloat       :: Float -> Float\n"
"primitive primIntToFloat     :: Int -> Float\n"
"primitive primIntegerToFloat :: Integer -> Float\n"
"\n"
"instance Num Float where\n"
"    (+)           = primPlusFloat\n"
"    (-)           = primMinusFloat\n"
"    negate        = primNegFloat\n"
"    (*)           = primMulFloat\n"
"    abs           = absReal\n"
"    signum        = signumReal\n"
"    fromInteger   = primIntegerToFloat\n"
"    fromInt       = primIntToFloat\n"
"\n"
"primitive primPlusDouble,\n"
"	  primMinusDouble,\n"
"	  primMulDouble       :: Double -> Double -> Double\n"
"primitive primNegDouble       :: Double -> Double\n"
"primitive primIntToDouble     :: Int -> Double\n"
"primitive primIntegerToDouble :: Integer -> Double\n"
"\n"
"instance Num Double where\n"
"    (+)         = primPlusDouble\n"
"    (-)         = primMinusDouble\n"
"    negate      = primNegDouble\n"
"    (*)         = primMulDouble\n"
"    abs         = absReal\n"
"    signum      = signumReal\n"
"    fromInteger = primIntegerToDouble\n"
"    fromInt     = primIntToDouble\n"
"\n"
"instance Real Float where\n"
"    toRational = floatToRational\n"
"\n"
"instance Real Double where\n"
"    toRational = doubleToRational\n"
"\n"
"-- Calls to these functions are optimised when passed as arguments to\n"
"-- fromRational.\n"
"floatToRational  :: Float  -> Rational\n"
"doubleToRational :: Double -> Rational\n"
"floatToRational  x = realFloatToRational x \n"
"doubleToRational x = realFloatToRational x\n"
"\n"
"realFloatToRational x = (m%1)*(b%1)^^n\n"
"			where (m,n) = decodeFloat x\n"
"			      b     = floatRadix x\n"
"\n"
"primitive primDivFloat      :: Float -> Float -> Float\n"
"primitive doubleToFloat     :: Double -> Float\n"
"\n"
"instance Fractional Float where\n"
"    (/)          = primDivFloat\n"
"    fromRational = primRationalToFloat\n"
"    fromDouble   = doubleToFloat\n"
"\n"
"primitive primDivDouble :: Double -> Double -> Double\n"
"\n"
"instance Fractional Double where\n"
"    (/)          = primDivDouble\n"
"    fromRational = primRationalToDouble\n"
"    fromDouble x = x\n"
"\n"
"-- These primitives are equivalent to (and are defined using) \n"
"-- rationalTo{Float,Double}.  The difference is that they test to see\n"
"-- if their argument is of the form (fromDouble x) - which allows a much\n"
"-- more efficient implementation.\n"
"primitive primRationalToFloat  :: Rational -> Float\n"
"primitive primRationalToDouble :: Rational -> Double\n"
"\n"
"-- These functions are used by Hugs - don't change their types.\n"
"rationalToFloat  :: Rational -> Float\n"
"rationalToDouble :: Rational -> Double\n"
"rationalToFloat  = rationalToRealFloat\n"
"rationalToDouble = rationalToRealFloat\n"
"\n"
"rationalToRealFloat x = x'\n"
" where x'    = f e\n"
"       f e   = if e' == e then y else f e'\n"
"	       where y      = encodeFloat (round (x * (1%b)^^e)) e\n"
"		     (_,e') = decodeFloat y\n"
"       (_,e) = decodeFloat (fromInteger (numerator x) `asTypeOf` x'\n"
"			     / fromInteger (denominator x))\n"
"       b     = floatRadix x'\n"
"\n"
"primitive primSinFloat,  primAsinFloat, primCosFloat,\n"
"	  primAcosFloat, primTanFloat,  primAtanFloat,\n"
"	  primLogFloat,  primExpFloat,  primSqrtFloat :: Float -> Float\n"
"\n"
"instance Floating Float where\n"
"    exp   = primExpFloat\n"
"    log   = primLogFloat\n"
"    sqrt  = primSqrtFloat\n"
"    sin   = primSinFloat\n"
"    cos   = primCosFloat\n"
"    tan   = primTanFloat\n"
"    asin  = primAsinFloat\n"
"    acos  = primAcosFloat\n"
"    atan  = primAtanFloat\n"
"\n"
"primitive primSinDouble,  primAsinDouble, primCosDouble,\n"
"	  primAcosDouble, primTanDouble,  primAtanDouble,\n"
"	  primLogDouble,  primExpDouble,  primSqrtDouble :: Double -> Double\n"
"\n"
"instance Floating Double where\n"
"    exp   = primExpDouble\n"
"    log   = primLogDouble\n"
"    sqrt  = primSqrtDouble\n"
"    sin   = primSinDouble\n"
"    cos   = primCosDouble\n"
"    tan   = primTanDouble\n"
"    asin  = primAsinDouble\n"
"    acos  = primAcosDouble\n"
"    atan  = primAtanDouble\n"
"\n"
"instance RealFrac Float where\n"
"    properFraction = floatProperFraction\n"
"\n"
"instance RealFrac Double where\n"
"    properFraction = floatProperFraction\n"
"\n"
"floatProperFraction x\n"
"   | n >= 0      = (fromInteger m * fromInteger b ^ n, 0)\n"
"   | otherwise   = (fromInteger w, encodeFloat r n)\n"
"		   where (m,n) = decodeFloat x\n"
"			 b     = floatRadix x\n"
"			 (w,r) = quotRem m (b^(-n))\n"
"\n"
"primitive primFloatRadix  :: Integer\n"
"primitive primFloatDigits :: Int\n"
"primitive primFloatMinExp,\n"
"          primFloatMaxExp :: Int\n"
"primitive primFloatEncode :: Integer -> Int -> Float\n"
"primitive primFloatDecode :: Float -> (Integer, Int)\n"
"\n"
"instance RealFloat Float where\n"
"    floatRadix  _ = primFloatRadix\n"
"    floatDigits _ = primFloatDigits\n"
"    floatRange  _ = (primFloatMinExp, primFloatMaxExp)\n"
"    encodeFloat = primFloatEncode\n"
"    decodeFloat = primFloatDecode\n"
"    isNaN       _ = False\n"
"    isInfinite  _ = False\n"
"    isDenormalized _ = False\n"
"    isNegativeZero _ = False\n"
"    isIEEE      _ = False\n"
"\n"
"primitive primDoubleRadix  :: Integer\n"
"primitive primDoubleDigits :: Int\n"
"primitive primDoubleMinExp,\n"
"          primDoubleMaxExp :: Int\n"
"primitive primDoubleEncode :: Integer -> Int -> Double\n"
"primitive primDoubleDecode :: Double -> (Integer, Int)\n"
"\n"
"instance RealFloat Double where\n"
"    floatRadix  _ = primDoubleRadix\n"
"    floatDigits _ = primDoubleDigits\n"
"    floatRange  _ = (primDoubleMinExp, primDoubleMaxExp)\n"
"    encodeFloat   = primDoubleEncode\n"
"    decodeFloat   = primDoubleDecode\n"
"    isNaN       _ = False\n"
"    isInfinite  _ = False\n"
"    isDenormalized _ = False\n"
"    isNegativeZero _ = False\n"
"    isIEEE      _ = False\n"
"\n"
"instance Enum Float where\n"
"    succ x                = x+1\n"
"    pred x                = x-1\n"
"    toEnum		  = primIntToFloat\n"
"    fromEnum		  = fromInteger . truncate   -- may overflow\n"
"    enumFrom		  = numericEnumFrom\n"
"    enumFromThen	  = numericEnumFromThen\n"
"    enumFromTo n m	  = numericEnumFromTo n (m+1/2)\n"
"    enumFromThenTo n n' m = numericEnumFromThenTo n n' (m + (n'-n)/2)\n"
"\n"
"instance Enum Double where\n"
"    succ x                = x+1\n"
"    pred x                = x-1\n"
"    toEnum		  = primIntToDouble\n"
"    fromEnum		  = fromInteger . truncate   -- may overflow\n"
"    enumFrom		  = numericEnumFrom\n"
"    enumFromThen	  = numericEnumFromThen\n"
"    enumFromTo n m	  = numericEnumFromTo n (m+1/2)\n"
"    enumFromThenTo n n' m = numericEnumFromThenTo n n' (m + (n'-n)/2)\n"
"\n"
"primitive primShowsFloat :: Int -> Float -> ShowS\n"
"\n"
"instance Read Float where\n"
"    readsPrec p = readSigned readFloat\n"
"\n"
"-- Note that showFloat in Numeric isn't used here\n"
"instance Show Float where\n"
"    showsPrec   = primShowsFloat\n"
"\n"
"primitive primShowsDouble :: Int -> Double -> ShowS\n"
"\n"
"instance Read Double where\n"
"    readsPrec p = readSigned readFloat\n"
"\n"
"-- Note that showFloat in Numeric isn't used here\n"
"instance Show Double where\n"
"    showsPrec   = primShowsDouble\n"
"\n"
"-- Some standard functions --------------------------------------------------\n"
"\n"
"fst            :: (a,b) -> a\n"
"fst (x,_)       = x\n"
"\n"
"snd            :: (a,b) -> b\n"
"snd (_,y)       = y\n"
"\n"
"curry          :: ((a,b) -> c) -> (a -> b -> c)\n"
"curry f x y     = f (x,y)\n"
"\n"
"uncurry        :: (a -> b -> c) -> ((a,b) -> c)\n"
"uncurry f p     = f (fst p) (snd p)\n"
"\n"
"id             :: a -> a\n"
"id    x         = x\n"
"\n"
"const          :: a -> b -> a\n"
"const k _       = k\n"
"\n"
"(.)            :: (b -> c) -> (a -> b) -> (a -> c)\n"
"(f . g) x       = f (g x)\n"
"\n"
"flip           :: (a -> b -> c) -> b -> a -> c\n"
"flip f x y      = f y x\n"
"\n"
"($)            :: (a -> b) -> a -> b\n"
"f $ x           = f x\n"
"\n"
"until          :: (a -> Bool) -> (a -> a) -> a -> a\n"
"until p f x     = if p x then x else until p f (f x)\n"
"\n"
"asTypeOf       :: a -> a -> a\n"
"asTypeOf        = const\n"
"\n"
"error          :: String -> a\n"
"error s         = throw (ErrorCall s)\n"
"\n"
"undefined      :: a\n"
"undefined       = error \"Prelude.undefined\"\n"
"\n"
"-- Standard functions on rational numbers {PreludeRatio} --------------------\n"
"\n"
"data Integral a => Ratio a = !a :% !a deriving (Eq)\n"
"type Rational              = Ratio Integer\n"
"\n"
"(%)                       :: Integral a => a -> a -> Ratio a\n"
"x % y                      = reduce (x * signum y) (abs y)\n"
"\n"
"reduce                    :: Integral a => a -> a -> Ratio a\n"
"reduce x y | y == 0        = error \"Ratio.%: zero denominator\"\n"
"	   | otherwise     = (x `quot` d) :% (y `quot` d)\n"
"			     where d = gcd x y\n"
"\n"
"numerator, denominator    :: Integral a => Ratio a -> a\n"
"numerator (x :% y)         = x\n"
"denominator (x :% y)       = y\n"
"\n"
"instance Integral a => Ord (Ratio a) where\n"
"    compare (x:%y) (x':%y') = compare (x*y') (x'*y)\n"
"\n"
"instance Integral a => Num (Ratio a) where\n"
"    (x:%y) + (x':%y') = reduce (x*y' + x'*y) (y*y')\n"
"    (x:%y) * (x':%y') = reduce (x*x') (y*y')\n"
"    negate (x :% y)   = negate x :% y\n"
"    abs (x :% y)      = abs x :% y\n"
"    signum (x :% y)   = signum x :% 1\n"
"    fromInteger x     = fromInteger x :% 1\n"
"    fromInt           = intToRatio\n"
"\n"
"-- Hugs optimises code of the form fromRational (intToRatio x)\n"
"intToRatio :: Integral a => Int -> Ratio a\n"
"intToRatio x = fromInt x :% 1\n"
"\n"
"instance Integral a => Real (Ratio a) where\n"
"    toRational (x:%y) = toInteger x :% toInteger y\n"
"\n"
"instance Integral a => Fractional (Ratio a) where\n"
"    (x:%y) / (x':%y')   = (x*y') % (y*x')\n"
"    recip (x:%y)        = y % x\n"
"    fromRational (x:%y) = fromInteger x :% fromInteger y\n"
"    fromDouble 		= doubleToRatio\n"
"\n"
"-- Hugs optimises code of the form fromRational (doubleToRatio x)\n"
"-- Since this function is private, and only used to convert floating point\n"
"-- literals, it yields a decimal fraction, hopefully the one the user\n"
"-- specified in the first place (but some precision may be lost).  A real\n"
"-- Haskell implementation would use Rational to represent these literals.\n"
"doubleToRatio :: Integral a => Double -> Ratio a\n"
"doubleToRatio x\n"
"	    | n>=0      = (round (x / fromInteger pow) * fromInteger pow) % 1\n"
"	    | otherwise = fromRational (round (x * fromInteger denom) % denom)\n"
"			  where (m,n) = decodeFloat x\n"
"				n_dec = ceiling (logBase 10 (encodeFloat 1 n))\n"
"				denom = 10 ^ (-n_dec)\n"
"				pow   = 10 ^ n_dec\n"
"\n"
"instance Integral a => RealFrac (Ratio a) where\n"
"    properFraction (x:%y) = (fromIntegral q, r:%y)\n"
"			    where (q,r) = quotRem x y\n"
"\n"
"instance Integral a => Enum (Ratio a) where\n"
"    succ x         = x+1\n"
"    pred x         = x-1\n"
"    toEnum         = fromInt\n"
"    fromEnum       = fromInteger . truncate   -- may overflow\n"
"    enumFrom       = numericEnumFrom\n"
"    enumFromTo     = numericEnumFromTo\n"
"    enumFromThen   = numericEnumFromThen\n"
"    enumFromThenTo = numericEnumFromThenTo\n"
"\n"
"instance (Read a, Integral a) => Read (Ratio a) where\n"
"    readsPrec p = readParen (p > 7)\n"
"			    (\\r -> [(x%y,u) | (x,s)   <- reads r,\n"
"					      (\"%\",t) <- lex s,\n"
"					      (y,u)   <- reads t ])\n"
"\n"
"instance Integral a => Show (Ratio a) where\n"
"    showsPrec p (x:%y) = showParen (p > 7)\n"
"			     (shows x . showString \" % \" . shows y)\n"
"\n"
"-- Standard list functions {PreludeList} ------------------------------------\n"
"\n"
"head             :: [a] -> a\n"
"head (x:_)        = x\n"
"\n"
"last             :: [a] -> a\n"
"last [x]          = x\n"
"last (_:xs)       = last xs\n"
"\n"
"tail             :: [a] -> [a]\n"
"tail (_:xs)       = xs\n"
"\n"
"init             :: [a] -> [a]\n"
"init [x]          = []\n"
"init (x:xs)       = x : init xs\n"
"\n"
"null             :: [a] -> Bool\n"
"null []           = True\n"
"null (_:_)        = False\n"
"\n"
"(++)             :: [a] -> [a] -> [a]\n"
"[]     ++ ys      = ys\n"
"(x:xs) ++ ys      = x : (xs ++ ys)\n"
"\n"
"map              :: (a -> b) -> [a] -> [b]\n"
"map f xs          = [ f x | x <- xs ]\n"
"\n"
"filter           :: (a -> Bool) -> [a] -> [a]\n"
"filter p xs       = [ x | x <- xs, p x ]\n"
"\n"
"concat           :: [[a]] -> [a]\n"
"concat            = foldr (++) []\n"
"\n"
"length           :: [a] -> Int\n"
"length            = foldl' (\\n _ -> n + 1) 0\n"
"\n"
"(!!)             :: [a] -> Int -> a\n"
"(x:_)  !! 0       = x\n"
"(_:xs) !! n | n>0 = xs !! (n-1)\n"
"(_:_)  !! _       = error \"Prelude.!!: negative index\"\n"
"[]     !! _       = error \"Prelude.!!: index too large\"\n"
"\n"
"foldl            :: (a -> b -> a) -> a -> [b] -> a\n"
"foldl f z []      = z\n"
"foldl f z (x:xs)  = foldl f (f z x) xs\n"
"\n"
"foldl'           :: (a -> b -> a) -> a -> [b] -> a\n"
"foldl' f a []     = a\n"
"foldl' f a (x:xs) = (foldl' f $! f a x) xs\n"
"\n"
"foldl1           :: (a -> a -> a) -> [a] -> a\n"
"foldl1 f (x:xs)   = foldl f x xs\n"
"\n"
"scanl            :: (a -> b -> a) -> a -> [b] -> [a]\n"
"scanl f q xs      = q : (case xs of\n"
"			 []   -> []\n"
"			 x:xs -> scanl f (f q x) xs)\n"
"\n"
"scanl1           :: (a -> a -> a) -> [a] -> [a]\n"
"scanl1 _ []       = []\n"
"scanl1 f (x:xs)   = scanl f x xs\n"
"\n"
"foldr            :: (a -> b -> b) -> b -> [a] -> b\n"
"foldr f z []      = z\n"
"foldr f z (x:xs)  = f x (foldr f z xs)\n"
"\n"
"foldr1           :: (a -> a -> a) -> [a] -> a\n"
"foldr1 f [x]      = x\n"
"foldr1 f (x:xs)   = f x (foldr1 f xs)\n"
"\n"
"scanr            :: (a -> b -> b) -> b -> [a] -> [b]\n"
"scanr f q0 []     = [q0]\n"
"scanr f q0 (x:xs) = f x q : qs\n"
"		    where qs@(q:_) = scanr f q0 xs\n"
"\n"
"scanr1           :: (a -> a -> a) -> [a] -> [a]\n"
"scanr1 f []       = []\n"
"scanr1 f [x]      = [x]\n"
"scanr1 f (x:xs)   = f x q : qs\n"
"		    where qs@(q:_) = scanr1 f xs\n"
"\n"
"iterate          :: (a -> a) -> a -> [a]\n"
"iterate f x       = x : iterate f (f x)\n"
"\n"
"repeat           :: a -> [a]\n"
"repeat x          = xs where xs = x:xs\n"
"\n"
"replicate        :: Int -> a -> [a]\n"
"replicate n x     = take n (repeat x)\n"
"\n"
"cycle            :: [a] -> [a]\n"
"cycle []          = error \"Prelude.cycle: empty list\"\n"
"cycle xs          = xs' where xs'=xs++xs'\n"
"\n"
"take                :: Int -> [a] -> [a]\n"
"take n _  | n <= 0  = []\n"
"take _ []           = []\n"
"take n (x:xs)       = x : take (n-1) xs\n"
"\n"
"drop                :: Int -> [a] -> [a]\n"
"drop n xs | n <= 0  = xs\n"
"drop _ []           = []\n"
"drop n (_:xs)       = drop (n-1) xs\n"
"\n"
"splitAt               :: Int -> [a] -> ([a], [a])\n"
"splitAt n xs | n <= 0 = ([],xs)\n"
"splitAt _ []          = ([],[])\n"
"splitAt n (x:xs)      = (x:xs',xs'') where (xs',xs'') = splitAt (n-1) xs\n"
"\n"
"takeWhile           :: (a -> Bool) -> [a] -> [a]\n"
"takeWhile p []       = []\n"
"takeWhile p (x:xs)\n"
"	 | p x       = x : takeWhile p xs\n"
"	 | otherwise = []\n"
"\n"
"dropWhile           :: (a -> Bool) -> [a] -> [a]\n"
"dropWhile p []       = []\n"
"dropWhile p xs@(x:xs')\n"
"	 | p x       = dropWhile p xs'\n"
"	 | otherwise = xs\n"
"\n"
"span, break         :: (a -> Bool) -> [a] -> ([a],[a])\n"
"span p []            = ([],[])\n"
"span p xs@(x:xs')\n"
"	 | p x       = (x:ys, zs)\n"
"	 | otherwise = ([],xs)\n"
"                       where (ys,zs) = span p xs'\n"
"break p              = span (not . p)\n"
"\n"
"lines     :: String -> [String]\n"
"lines \"\"   = []\n"
"lines s    = let (l,s') = break ('\\n'==) s\n"
"             in l : case s' of []      -> []\n"
"                               (_:s'') -> lines s''\n"
"\n"
"words     :: String -> [String]\n"
"words s    = case dropWhile isSpace s of\n"
"		  \"\" -> []\n"
"		  s' -> w : words s''\n"
"			where (w,s'') = break isSpace s'\n"
"\n"
"unlines   :: [String] -> String\n"
"unlines []      = []\n"
"unlines (l:ls)  = l ++ '\\n' : unlines ls\n"
"\n"
"unwords   :: [String] -> String\n"
"unwords []	=  \"\"\n"
"unwords [w]	= w\n"
"unwords (w:ws)	= w ++ ' ' : unwords ws\n"
"\n"
"reverse   :: [a] -> [a]\n"
"reverse    = foldl (flip (:)) []\n"
"\n"
"and, or   :: [Bool] -> Bool\n"
"and        = foldr (&&) True\n"
"or         = foldr (||) False\n"
"\n"
"any, all  :: (a -> Bool) -> [a] -> Bool\n"
"any p      = or  . map p\n"
"all p      = and . map p\n"
"\n"
"elem, notElem    :: Eq a => a -> [a] -> Bool\n"
"elem              = any . (==)\n"
"notElem           = all . (/=)\n"
"\n"
"lookup           :: Eq a => a -> [(a,b)] -> Maybe b\n"
"lookup k []       = Nothing\n"
"lookup k ((x,y):xys)\n"
"      | k==x      = Just y\n"
"      | otherwise = lookup k xys\n"
"\n"
"sum, product     :: Num a => [a] -> a\n"
"sum               = foldl' (+) 0\n"
"product           = foldl' (*) 1\n"
"\n"
"maximum, minimum :: Ord a => [a] -> a\n"
"maximum           = foldl1 max\n"
"minimum           = foldl1 min\n"
"\n"
"concatMap        :: (a -> [b]) -> [a] -> [b]\n"
"concatMap f       = concat . map f\n"
"\n"
"zip              :: [a] -> [b] -> [(a,b)]\n"
"zip               = zipWith  (\\a b -> (a,b))\n"
"\n"
"zip3             :: [a] -> [b] -> [c] -> [(a,b,c)]\n"
"zip3              = zipWith3 (\\a b c -> (a,b,c))\n"
"\n"
"zipWith                  :: (a->b->c) -> [a]->[b]->[c]\n"
"zipWith z (a:as) (b:bs)   = z a b : zipWith z as bs\n"
"zipWith _ _      _        = []\n"
"\n"
"zipWith3                 :: (a->b->c->d) -> [a]->[b]->[c]->[d]\n"
"zipWith3 z (a:as) (b:bs) (c:cs)\n"
"			  = z a b c : zipWith3 z as bs cs\n"
"zipWith3 _ _ _ _          = []\n"
"\n"
"unzip                    :: [(a,b)] -> ([a],[b])\n"
"unzip                     = foldr (\\(a,b) ~(as,bs) -> (a:as, b:bs)) ([], [])\n"
"\n"
"unzip3                   :: [(a,b,c)] -> ([a],[b],[c])\n"
"unzip3                    = foldr (\\(a,b,c) ~(as,bs,cs) -> (a:as,b:bs,c:cs))\n"
"				  ([],[],[])\n"
"\n"
"-- PreludeText ----------------------------------------------------------------\n"
"\n"
"reads        :: Read a => ReadS a\n"
"reads         = readsPrec 0\n"
"\n"
"shows        :: Show a => a -> ShowS\n"
"shows         = showsPrec 0\n"
"\n"
"read         :: Read a => String -> a\n"
"read s        =  case [x | (x,t) <- reads s, (\"\",\"\") <- lex t] of\n"
"		      [x] -> x\n"
"		      []  -> error \"Prelude.read: no parse\"\n"
"		      _   -> error \"Prelude.read: ambiguous parse\"\n"
"\n"
"showChar     :: Char -> ShowS\n"
"showChar      = (:)\n"
"\n"
"showString   :: String -> ShowS\n"
"showString    = (++)\n"
"\n"
"showParen    :: Bool -> ShowS -> ShowS\n"
"showParen b p = if b then showChar '(' . p . showChar ')' else p\n"
"\n"
"showField    :: Show a => String -> a -> ShowS\n"
"showField m v = showString m . showChar '=' . shows v\n"
"\n"
"readParen    :: Bool -> ReadS a -> ReadS a\n"
"readParen b g = if b then mandatory else optional\n"
"		where optional r  = g r ++ mandatory r\n"
"		      mandatory r = [(x,u) | (\"(\",s) <- lex r,\n"
"					     (x,t)   <- optional s,\n"
"					     (\")\",u) <- lex t    ]\n"
"\n"
"readField    :: Read a => String -> ReadS a\n"
"readField m s0 = [ r | (t,  s1) <- lex s0, t == m,\n"
"                       (\"=\",s2) <- lex s1,\n"
"                       r        <- reads s2 ]\n"
"\n"
"lex                    :: ReadS String\n"
"lex \"\"                  = [(\"\",\"\")]\n"
"lex (c:s) | isSpace c   = lex (dropWhile isSpace s)\n"
"lex ('\\'':s)            = [('\\'':ch++\"'\", t) | (ch,'\\'':t)  <- lexLitChar s,\n"
"					       ch /= \"'\"                ]\n"
"lex ('\"':s)             = [('\"':str, t)      | (str,t) <- lexString s]\n"
"			  where\n"
"			  lexString ('\"':s) = [(\"\\\"\",s)]\n"
"			  lexString s = [(ch++str, u)\n"
"						| (ch,t)  <- lexStrItem s,\n"
"						  (str,u) <- lexString t  ]\n"
"\n"
"			  lexStrItem ('\\\\':'&':s) = [(\"\\\\&\",s)]\n"
"			  lexStrItem ('\\\\':c:s) | isSpace c\n"
"			      = [(\"\",t) | '\\\\':t <- [dropWhile isSpace s]]\n"
"			  lexStrItem s            = lexLitChar s\n"
"\n"
"lex (c:s) | isSym c     = [(c:sym,t)         | (sym,t) <- [span isSym s]]\n"
"          | isAlpha c   = [(c:nam,t)         | (nam,t) <- [span isIdChar s]]\n"
"             -- '_' can be the start of a single char or a name/id.\n"
"          | c == '_'    = case span isIdChar s of \n"
"                            ([],_) -> [([c],s)]\n"
"                            (nm,t) -> [((c:nm),t)]\n"
"          | isSingle c  = [([c],s)]\n"
"          | isDigit c   = [(c:ds++fe,t)      | (ds,s)  <- [span isDigit s],\n"
"                                               (fe,t)  <- lexFracExp s     ]\n"
"          | otherwise   = []    -- bad character\n"
"		where\n"
"		isSingle c  =  c `elem` \",;()[]{}_`\"\n"
"		isSym c     =  c `elem` \"!@#$%&*+./<=>?\\\\^|:-~\"\n"
"		isIdChar c  =  isAlphaNum c || c `elem` \"_'\"\n"
"\n"
"		lexFracExp ('.':c:cs) | isDigit c \n"
"                            = [('.':ds++e,u) | (ds,t) <- lexDigits (c:cs),\n"
"					       (e,u)  <- lexExp t    ]\n"
"		lexFracExp s       = lexExp s\n"
"\n"
"		lexExp (e:s) | e `elem` \"eE\"\n"
"			 = [(e:c:ds,u) | (c:t)  <- [s], c `elem` \"+-\",\n"
"						   (ds,u) <- lexDigits t] ++\n"
"			   [(e:ds,t)   | (ds,t) <- lexDigits s]\n"
"		lexExp s = [(\"\",s)]\n"
"\n"
"lexDigits               :: ReadS String\n"
"lexDigits               =  nonnull isDigit\n"
"\n"
"nonnull                 :: (Char -> Bool) -> ReadS String\n"
"nonnull p s             =  [(cs,t) | (cs@(_:_),t) <- [span p s]]\n"
"\n"
"lexLitChar          :: ReadS String\n"
"lexLitChar \"\"       =  []\n"
"lexLitChar (c:s)\n"
" | c /= '\\\\'        =  [([c],s)]\n"
" | otherwise        =  map (prefix '\\\\') (lexEsc s)\n"
" where\n"
"   lexEsc (c:s)     | c `elem` \"abfnrtv\\\\\\\"'\" = [([c],s)]\n"
"   lexEsc ('^':c:s) | c >= '@' && c <= '_'    = [(['^',c],s)]\n"
"    -- Numeric escapes\n"
"   lexEsc ('o':s)  = [prefix 'o' (span isOctDigit s)]\n"
"   lexEsc ('x':s)  = [prefix 'x' (span isHexDigit s)]\n"
"   lexEsc s@(c:_) \n"
"     | isDigit c   = [span isDigit s]  \n"
"     | isUpper c   = case [(mne,s') | (c, mne) <- table,\n"
"	 	        ([],s') <- [lexmatch mne s]] of\n"
"                       (pr:_) -> [pr]\n"
"	               []     -> []\n"
"   lexEsc _        = []\n"
"\n"
"   table = ('\\DEL',\"DEL\") : asciiTab\n"
"   prefix c (t,s) = (c:t, s)\n"
"\n"
"isOctDigit c  =  c >= '0' && c <= '7'\n"
"isHexDigit c  =  isDigit c || c >= 'A' && c <= 'F'\n"
"			   || c >= 'a' && c <= 'f'\n"
"\n"
"lexmatch                   :: (Eq a) => [a] -> [a] -> ([a],[a])\n"
"lexmatch (x:xs) (y:ys) | x == y  =  lexmatch xs ys\n"
"lexmatch xs     ys               =  (xs,ys)\n"
"\n"
"asciiTab = zip ['\\NUL'..' ']\n"
"	   [\"NUL\", \"SOH\", \"STX\", \"ETX\", \"EOT\", \"ENQ\", \"ACK\", \"BEL\",\n"
"	    \"BS\",  \"HT\",  \"LF\",  \"VT\",  \"FF\",  \"CR\",  \"SO\",  \"SI\",\n"
"	    \"DLE\", \"DC1\", \"DC2\", \"DC3\", \"DC4\", \"NAK\", \"SYN\", \"ETB\",\n"
"	    \"CAN\", \"EM\",  \"SUB\", \"ESC\", \"FS\",  \"GS\",  \"RS\",  \"US\",\n"
"	    \"SP\"]\n"
"\n"
"readLitChar            :: ReadS Char\n"
"readLitChar ('\\\\':s)    = readEsc s\n"
" where\n"
"       readEsc ('a':s)  = [('\\a',s)]\n"
"       readEsc ('b':s)  = [('\\b',s)]\n"
"       readEsc ('f':s)  = [('\\f',s)]\n"
"       readEsc ('n':s)  = [('\\n',s)]\n"
"       readEsc ('r':s)  = [('\\r',s)]\n"
"       readEsc ('t':s)  = [('\\t',s)]\n"
"       readEsc ('v':s)  = [('\\v',s)]\n"
"       readEsc ('\\\\':s) = [('\\\\',s)]\n"
"       readEsc ('\"':s)  = [('\"',s)]\n"
"       readEsc ('\\'':s) = [('\\'',s)]\n"
"       readEsc ('^':c:s) | c >= '@' && c <= '_'\n"
"			= [(toEnum (fromEnum c - fromEnum '@'), s)]\n"
"       readEsc s@(d:_) | isDigit d\n"
"			= [(toEnum n, t) | (n,t) <- readDec s]\n"
"       readEsc ('o':s)  = [(toEnum n, t) | (n,t) <- readOct s]\n"
"       readEsc ('x':s)  = [(toEnum n, t) | (n,t) <- readHex s]\n"
"       readEsc s@(c:_) | isUpper c\n"
"			= let table = ('\\DEL',\"DEL\") : asciiTab\n"
"			  in case [(c,s') | (c, mne) <- table,\n"
"					    ([],s') <- [lexmatch mne s]]\n"
"			     of (pr:_) -> [pr]\n"
"				[]     -> []\n"
"       readEsc _        = []\n"
"readLitChar (c:s)       = [(c,s)]\n"
"\n"
"showLitChar               :: Char -> ShowS\n"
"showLitChar c | c > '\\DEL' = showChar '\\\\' .\n"
"			     protectEsc isDigit (shows (fromEnum c))\n"
"showLitChar '\\DEL'         = showString \"\\\\DEL\"\n"
"showLitChar '\\\\'           = showString \"\\\\\\\\\"\n"
"showLitChar c | c >= ' '   = showChar c\n"
"showLitChar '\\a'           = showString \"\\\\a\"\n"
"showLitChar '\\b'           = showString \"\\\\b\"\n"
"showLitChar '\\f'           = showString \"\\\\f\"\n"
"showLitChar '\\n'           = showString \"\\\\n\"\n"
"showLitChar '\\r'           = showString \"\\\\r\"\n"
"showLitChar '\\t'           = showString \"\\\\t\"\n"
"showLitChar '\\v'           = showString \"\\\\v\"\n"
"showLitChar '\\SO'          = protectEsc ('H'==) (showString \"\\\\SO\")\n"
"showLitChar c              = showString ('\\\\' : snd (asciiTab!!fromEnum c))\n"
"\n"
"protectEsc p f             = f . cont\n"
" where cont s@(c:_) | p c  = \"\\\\&\" ++ s\n"
"       cont s              = s\n"
"\n"
"-- Unsigned readers for various bases\n"
"readDec, readOct, readHex :: Integral a => ReadS a\n"
"readDec = readInt 10 isDigit    (\\ d -> fromEnum d - fromEnum_0)\n"
"readOct = readInt  8 isOctDigit (\\ d -> fromEnum d - fromEnum_0)\n"
"readHex = readInt 16 isHexDigit hex\n"
"	    where hex d = fromEnum d - (if isDigit d then fromEnum_0\n"
"				       else fromEnum (if isUpper d then 'A' else 'a') - 10)\n"
"\n"
"fromEnum_0 :: Int\n"
"fromEnum_0 = fromEnum '0'\n"
"\n"
"-- showInt is used for positive numbers only\n"
"showInt    :: Integral a => a -> ShowS\n"
"showInt n r | n < 0 = error \"Numeric.showInt: can't show negative numbers\"\n"
"            | otherwise =\n"
"              let (n',d) = quotRem n 10\n"
"		  r'     = toEnum (fromEnum '0' + fromIntegral d) : r\n"
"	      in  if n' == 0 then r' else showInt n' r'\n"
"\n"
"showSigned    :: Real a => (a -> ShowS) -> Int -> a -> ShowS\n"
"showSigned showPos p x = if x < 0 then showParen (p > 6)\n"
"						 (showChar '-' . showPos (-x))\n"
"				  else showPos x\n"
"\n"
"-- readInt reads a string of digits using an arbitrary base.  \n"
"-- Leading minus signs must be handled elsewhere.\n"
"\n"
"readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a\n"
"readInt radix isDig digToInt s =\n"
"    [(foldl1 (\\n d -> n * radix + d) (map (fromIntegral . digToInt) ds), r)\n"
"	| (ds,r) <- nonnull isDig s ]\n"
"\n"
"readSigned:: Real a => ReadS a -> ReadS a\n"
"readSigned readPos = readParen False read'\n"
"		     where read' r  = read'' r ++\n"
"				      [(-x,t) | (\"-\",s) <- lex r,\n"
"						(x,t)   <- read'' s]\n"
"			   read'' r = [(n,s)  | (str,s) <- lex r,\n"
"						(n,\"\")  <- readPos str]\n"
"\n"
"\n"
"-- This floating point reader uses a less restrictive syntax for floating\n"
"-- point than the Haskell lexer.  The `.' is optional.\n"
"readFloat     :: RealFrac a => ReadS a\n"
"readFloat r    = [(fromRational ((n%1)*10^^(k-d)),t) | (n,d,s) <- readFix r,\n"
"						       (k,t)   <- readExp s] ++\n"
"                 [ (0/0, t) | (\"NaN\",t)      <- lex r] ++\n"
"                 [ (1/0, t) | (\"Infinity\",t) <- lex r]\n"
"		 where readFix r = [(read (ds++ds'), length ds', t)\n"
"					| (ds, d) <- lexDigits r\n"
"                                        , (ds',t) <- lexFrac d   ]\n"
"\n"
"                       lexFrac ('.':s) = lexDigits s\n"
"		       lexFrac s       = [(\"\",s)]\n"
"\n"
"		       readExp (e:s) | e `elem` \"eE\" = readExp' s\n"
"		       readExp s                     = [(0,s)]\n"
"\n"
"		       readExp' ('-':s) = [(-k,t) | (k,t) <- readDec s]\n"
"		       readExp' ('+':s) = readDec s\n"
"		       readExp' s       = readDec s\n"
"\n"
"----------------------------------------------------------------\n"
"-- Exception datatype and operations\n"
"----------------------------------------------------------------\n"
"\n"
"data Exception\n"
"  = ArithException      ArithException\n"
"  | ArrayException      ArrayException\n"
"  | AssertionFailed     String\n"
"  | AsyncException      AsyncException\n"
"  | BlockedOnDeadMVar\n"
"  | Deadlock\n"
"  | DynException        Dynamic\n"
"  | ErrorCall           String\n"
"  | ExitException       ExitCode\n"
"  | IOException 	IOException	-- IO exceptions (from 'ioError')\n"
"  | NoMethodError       String\n"
"  | NonTermination\n"
"  | PatternMatchFail    String\n"
"  | RecConError         String\n"
"  | RecSelError         String\n"
"  | RecUpdError         String\n"
"\n"
"instance Show Exception where\n"
"  showsPrec _ (ArithException e)  = shows e\n"
"  showsPrec _ (ArrayException e)  = shows e\n"
"  showsPrec _ (AssertionFailed s) = showException \"assertion failed\" s\n"
"  showsPrec _ (AsyncException e)  = shows e\n"
"  showsPrec _ BlockedOnDeadMVar   = showString \"thread blocked indefinitely\"\n"
"  showsPrec _ Deadlock            = showString \"<<deadlock>>\"\n"
"  showsPrec _ (DynException _)    = showString \"unknown exception\"\n"
"  showsPrec _ (ErrorCall s)       = showString s\n"
"  showsPrec _ (ExitException err) = showString \"exit: \" . shows err\n"
"  showsPrec _ (IOException err)	  = shows err\n"
"  showsPrec _ (NoMethodError s)   = showException \"undefined member\" s\n"
"  showsPrec _ NonTermination	  = showString \"<<loop>>\"\n"
"  showsPrec _ (PatternMatchFail s) = showException \"pattern match failure\" s\n"
"  showsPrec _ (RecConError s)     = showException \"undefined field\" s\n"
"  showsPrec _ (RecSelError s)     = showException \"select of missing field\" s\n"
"  showsPrec _ (RecUpdError s)     = showException \"update of missing field\" s\n"
"\n"
"data ArithException\n"
"  = Overflow\n"
"  | Underflow\n"
"  | LossOfPrecision\n"
"  | DivideByZero\n"
"  | Denormal\n"
"  deriving (Eq, Ord)\n"
"\n"
"instance Show ArithException where\n"
"  showsPrec _ Overflow        = showString \"arithmetic overflow\"\n"
"  showsPrec _ Underflow       = showString \"arithmetic underflow\"\n"
"  showsPrec _ LossOfPrecision = showString \"loss of precision\"\n"
"  showsPrec _ DivideByZero    = showString \"divide by zero\"\n"
"  showsPrec _ Denormal        = showString \"denormal\"\n"
"\n"
"data ArrayException\n"
"  = IndexOutOfBounds    String\n"
"  | UndefinedElement    String\n"
"  deriving (Eq, Ord)\n"
"\n"
"instance Show ArrayException where\n"
"  showsPrec _ (IndexOutOfBounds s) =\n"
"    showException \"array index out of range\" s\n"
"  showsPrec _ (UndefinedElement s) =\n"
"    showException \"undefined array element\" s\n"
"\n"
"data AsyncException\n"
"  = StackOverflow\n"
"  | HeapOverflow\n"
"  | ThreadKilled\n"
"  deriving (Eq, Ord)\n"
"\n"
"instance Show AsyncException where\n"
"  showsPrec _ StackOverflow   = showString \"stack overflow\"\n"
"  showsPrec _ HeapOverflow    = showString \"heap overflow\"\n"
"  showsPrec _ ThreadKilled    = showString \"thread killed\"\n"
"\n"
"showException :: String -> String -> ShowS\n"
"showException tag msg =\n"
"  showString tag . (if null msg then id else showString \": \" . showString msg)\n"
"\n"
"data ExitCode = ExitSuccess | ExitFailure Int\n"
"                deriving (Eq, Ord, Read, Show)\n"
"\n"
"-- data type describing IOErrors / exceptions.\n"
"type IOError = IOException\n"
"\n"
"data IOException\n"
"  = IOError\n"
"      { ioe_handle      :: Maybe Handle   -- the handle used by the action\n"
"					  -- flagging the error\n"
"      , ioe_type        :: IOErrorType    -- what kind of (std) error\n"
"      , ioe_location    :: String         -- location of the error\n"
"      , ioe_description :: String         -- error-specific string\n"
"      , ioe_filename    :: Maybe FilePath -- the resource involved.\n"
"      } \n"
"      deriving (Eq)\n"
"\n"
"data IOErrorType\n"
"  = AlreadyExists\n"
"  | NoSuchThing\n"
"  | ResourceBusy\n"
"  | ResourceExhausted\n"
"  | EOF\n"
"  | IllegalOperation\n"
"  | PermissionDenied\n"
"  | UserError\n"
"     -- GHC compatibility\n"
"  | UnsupportedOperation\n"
"  | OtherError\n"
"     -- DOTNET only\n"
"  | DotNetException\n"
"    deriving (Eq)\n"
"\n"
"instance Show IOErrorType where\n"
"  show x = \n"
"    case x of\n"
"      AlreadyExists     -> \"already exists\"\n"
"      NoSuchThing       -> \"does not exist\"\n"
"      ResourceBusy      -> \"resource busy\"\n"
"      ResourceExhausted -> \"resource exhausted\"\n"
"      EOF               -> \"end of file\"\n"
"      IllegalOperation  -> \"illegal operation\"\n"
"      PermissionDenied  -> \"permission denied\"\n"
"      UserError         -> \"user error\"\n"
"      UnsupportedOperation -> \"unsupported operation\"\n"
"      OtherError        -> \"failed\"\n"
"      DotNetException   -> \".NET exception\"\n"
"\n"
"instance Show IOException where\n"
"  showsPrec p (IOError hdl iot loc s fn) =\n"
"    (case fn of\n"
"       Nothing -> case hdl of\n"
"		      Nothing -> id\n"
"		      Just h  -> showsPrec p h . showString \": \"\n"
"       Just name -> showString name . showString \": \") .\n"
"    (case loc of\n"
"       \"\" -> id\n"
"       _  -> showString loc . showString \": \") .\n"
"    showsPrec p iot .\n"
"    (case s of\n"
"       \"\" -> id\n"
"       _  -> showString \" (\" . showString s . showString \")\")\n"
"\n"
"-- Monadic I/O: --------------------------------------------------------------\n"
"\n"
"--data IO a             -- builtin datatype of IO actions\n"
"\n"
"type FilePath = String  -- file pathnames are represented by strings\n"
"\n"
"primitive primbindIO		 :: IO a -> (a -> IO b) -> IO b\n"
"primitive primretIO		 :: a -> IO a\n"
"primitive putChar		 :: Char -> IO ()\n"
"primitive putStr		 :: String -> IO ()\n"
"primitive getChar   		 :: IO Char\n"
"\n"
"ioError :: IOError -> IO a\n"
"ioError e = IO (\\ s -> throw (IOException e))\n"
"\n"
"userError :: String -> IOError\n"
"userError str = IOError Nothing UserError \"\" str Nothing\n"
"\n"
"catch :: IO a -> (IOError -> IO a) -> IO a\n"
"catch m h = catchException m $ \\e -> case e of\n"
"		IOException err -> h err\n"
"		_ -> throw e\n"
"\n"
"print     :: Show a => a -> IO ()\n"
"print      = putStrLn . show\n"
"\n"
"putStrLn  :: String -> IO ()\n"
"putStrLn s = do putStr s\n"
"		putChar '\\n'\n"
"\n"
"getLine :: IO String\n"
"getLine  = do \n"
"  c <- getChar\n"
"  if c=='\\n' \n"
"   then return \"\"\n"
"   else do\n"
"     ls <- getRest \n"
"     return (c:ls)\n"
"  where\n"
"   getRest = do\n"
"     c <- catch getChar\n"
"                (\\ ex -> if ioe_type ex == EOF then \n"
"			    return '\\n'\n"
"			 else\n"
"			    ioError ex)\n"
"     if c=='\\n'\n"
"      then return \"\"\n"
"      else do\n"
"       cs <- getRest \n"
"       return (c:cs)\n"
"\n"
"-- raises an exception instead of an error\n"
"readIO          :: Read a => String -> IO a\n"
"readIO s         = case [x | (x,t) <- reads s, (\"\",\"\") <- lex t] of\n"
"                        [x] -> return x\n"
"                        []  -> ioError (userError \"PreludeIO.readIO: no parse\")\n"
"                        _   -> ioError (userError \n"
"                                       \"PreludeIO.readIO: ambiguous parse\")\n"
"\n"
"readLn          :: Read a => IO a\n"
"readLn           = do l <- getLine\n"
"                      r <- readIO l\n"
"                      return r\n"
"\n"
"primitive getContents 		 :: IO String\n"
"primitive writeFile   		 :: FilePath -> String -> IO ()\n"
"primitive appendFile  		 :: FilePath -> String -> IO ()\n"
"primitive readFile    		 :: FilePath -> IO String\n"
"\n"
"interact  :: (String -> String) -> IO ()\n"
"interact f = getContents >>= (putStr . f)\n"
"\n"
"instance Functor IO where\n"
"    fmap f x = x >>= (return . f)\n"
"\n"
"instance Monad IO where\n"
"    (>>=)  = primbindIO\n"
"    return = primretIO\n"
"    \n"
"    fail s = ioError (userError s)\n"
"\n"
"-- Hooks for primitives: -----------------------------------------------------\n"
"-- Do not mess with these!\n"
"\n"
"data FunPtr a -- builtin datatype of C function pointers\n"
"data Ptr a    -- builtin datatype of C pointers\n"
"data Addr     -- builtin datatype of C pointers (deprecated)\n"
"data Word     -- builtin datatype of unsigned ints (deprecated)\n"
"data Int8\n"
"data Int16\n"
"data Int32\n"
"data Int64\n"
"data Word8\n"
"data Word16\n"
"data Word32\n"
"data Word64\n"
"data ForeignObj  -- builtin datatype of C pointers with finalizers (deprecated)\n"
"data ForeignPtr a -- builtin datatype of C pointers with finalizers\n"
"data StablePtr a\n"
"data Handle\n"
"\n"
"data Object a -- builtin datatype of external object references.\n"
"              -- (needed as primitive since they're supported in FFI decls.)\n"
"\n"
"instance Eq Handle where (==) = primEqHandle\n"
"primitive primEqHandle :: Handle -> Handle -> Bool\n"
"\n"
"instance Show Handle where\n"
"    showsPrec _ h = case primGetHandleNumber h of\n"
"	0 -> showString \"stdin\"\n"
"	1 -> showString \"stdout\"\n"
"	2 -> showString \"stderr\"\n"
"	_ -> showString \"<handle>\"\n"
"\n"
"primitive primGetHandleNumber :: Handle -> Int\n"
"\n"
"primitive unsafeCoerce \"primUnsafeCoerce\" :: a -> b\n"
"\n"
"data Dynamic = Dynamic TypeRep Obj\n"
"\n"
"data TypeRep = TypeRep !Key TyCon [TypeRep]\n"
"\n"
"instance Eq TypeRep where\n"
"  (TypeRep k1 _ _) == (TypeRep k2 _ _) = k1 == k2\n"
"\n"
"data TyCon = TyCon !Key String\n"
"\n"
"instance Eq TyCon where\n"
"  (TyCon t1 _) == (TyCon t2 _) = t1 == t2\n"
"\n"
"newtype Key = Key Int deriving( Eq )\n"
"\n"
"data Obj = Obj\n"
"\n"
"toObj :: a -> Obj\n"
"toObj   = unsafeCoerce\n"
"\n"
"fromObj :: Obj -> a\n"
"fromObj = unsafeCoerce\n"
"\n"
"newtype IO a = IO ((a -> IOResult) -> IOResult)\n"
"\n"
"data IOResult \n"
"  = Hugs_ExitWith    Int\n"
"  | Hugs_Catch       IOResult (Exception -> IOResult) (Obj -> IOResult)\n"
"  | Hugs_ForkThread  IOResult IOResult\n"
"  | Hugs_DeadThread\n"
"  | Hugs_YieldThread IOResult\n"
"  | Hugs_Return      Obj\n"
"  | Hugs_BlockThread (Obj -> IOResult) ((Obj -> IOResult) -> IOResult) \n"
"\n"
"data IOFinished a\n"
"  = Finished_ExitWith Int\n"
"  | Finished_Return   a\n"
"\n"
"primitive throw \"primThrowException\" :: Exception -> a\n"
"primitive primCatchException :: a -> Either Exception a\n"
"\n"
"catchException :: IO a -> (Exception -> IO a) -> IO a\n"
"catchException (IO m) k = IO $ \\ s ->\n"
"  Hugs_Catch (m hugsReturn)\n"
"             (\\ e -> case (k e) of { IO k' -> k' s })\n"
"             (s . fromObj)\n"
"\n"
"hugsReturn :: a -> IOResult\n"
"hugsReturn x = Hugs_Return (toObj x)\n"
"\n"
"-- reify current thread, execute 'm <thread>' and switch to next thread\n"
"blockIO :: ((a -> IOResult) -> IO ()) -> IO a\n"
"blockIO m = IO (\\ s -> Hugs_BlockThread (s . fromObj) m')\n"
" where\n"
"  m' k = threadToIOResult (m (k . toObj))\n"
"\n"
"hugsIORun  :: IO a -> Either Int a\n"
"hugsIORun m = \n"
"  case basicIORun (runAndShowError m) of\n"
"    Finished_ExitWith i -> Left i\n"
"    Finished_Return   a -> Right a\n"
" where\n"
"  runAndShowError :: IO a -> IO a\n"
"  runAndShowError m = m `catchException` exceptionHandler\n"
"  exceptionHandler :: Exception -> IO a\n"
"  exceptionHandler (ExitException ExitSuccess) = primExitWith 0\n"
"  exceptionHandler (ExitException (ExitFailure n)) = primExitWith n\n"
"  exceptionHandler err = runAndShowError $ do\n"
"	putChar '\\n'\n"
"	putStr \"Program error: \"\n"
"	putStrLn (show err)\n"
"	primExitWith 1\n"
"\n"
"basicIORun :: IO a -> IOFinished a\n"
"basicIORun (IO m) = loop [m hugsReturn]\n"
"\n"
"threadToIOResult :: IO a -> IOResult\n"
"threadToIOResult (IO m) = m (const Hugs_DeadThread)\n"
"\n"
"-- This is the queue of *runnable* threads.\n"
"-- There may be blocked threads attached to MVars\n"
"-- An important invariant is that at most one thread will result in\n"
"-- Hugs_Return - and its Obj value has type \\alpha\n"
"loop :: [IOResult] -> IOFinished a\n"
"loop []                      = error \"no more threads (deadlock?)\"\n"
"loop [Hugs_Return   a]       = Finished_Return (fromObj a)\n"
"loop (Hugs_Return   a:r)     = loop (r ++ [Hugs_Return a])\n"
"loop (Hugs_Catch m f s:r)    = loop (hugs_catch m f s : r)\n"
"loop (Hugs_ExitWith i:_)     = Finished_ExitWith i\n"
"loop (Hugs_DeadThread:r)     = loop r\n"
"loop (Hugs_ForkThread a b:r) = loop (a:b:r)\n"
"loop (Hugs_YieldThread a:r)  = loop (r ++ [a])\n"
"loop (Hugs_BlockThread a b:r)= loop (b a : r)\n"
"loop _                       = error \"Fatal error in Hugs scheduler\"\n"
"\n"
"hugs_catch :: IOResult -> (Exception -> IOResult) -> (Obj -> IOResult) -> IOResult\n"
"hugs_catch m f s = case primCatchException (catch' m) of\n"
"  Left  exn                   -> f exn\n"
"  Right (Hugs_Return a)       -> s a\n"
"  Right (Hugs_ForkThread a b) -> Hugs_ForkThread (Hugs_Catch a f s) b\n"
"  Right (Hugs_YieldThread a)  -> Hugs_YieldThread (Hugs_Catch a f s)\n"
"  Right (Hugs_BlockThread a b)-> Hugs_BlockThread (\\x -> Hugs_Catch (a x) f s) b\n"
"  Right r                     -> r\n"
" where\n"
"  catch' :: IOResult -> IOResult\n"
"  catch' (Hugs_Catch m' f' s') = catch' (hugs_catch m' f' s')\n"
"  catch' x                     = x\n"
"\n"
"primExitWith     :: Int -> IO a\n"
"primExitWith c    = IO (\\ s -> Hugs_ExitWith c)\n"
"\n"
"primCompAux      :: Ord a => a -> a -> Ordering -> Ordering\n"
"primCompAux x y o = case compare x y of EQ -> o; LT -> LT; GT -> GT\n"
"\n"
"primPmInt        :: Num a => Int -> a -> Bool\n"
"primPmInt n x     = fromInt n == x\n"
"\n"
"primPmInteger    :: Num a => Integer -> a -> Bool\n"
"primPmInteger n x = fromInteger n == x\n"
"\n"
"primPmFlt        :: Fractional a => Double -> a -> Bool\n"
"primPmFlt n x     = fromDouble n == x\n"
"\n"
"-- The following primitives are only needed if (n+k) patterns are enabled:\n"
"primPmNpk        :: Integral a => Int -> a -> Maybe a\n"
"primPmNpk n x     = if n'<=x then Just (x-n') else Nothing\n"
"		    where n' = fromInt n\n"
"\n"
"primPmSub        :: Integral a => Int -> a -> a\n"
"primPmSub n x     = x - fromInt n\n"
"\n"
"-- Trex\n"
"emptyRec :: Rec EmptyRow\n"
"emptyRec = EmptyRec\n"
"\n"
"-- End of Hugs standard prelude ----------------------------------------------\n";
const char *Hugs_ForeignPtr = "module Hugs.ForeignPtr\n"
"        ( \n"
"	  ForeignPtr             -- abstract, instance of: Eq\n"
"	, FinalizerPtr\n"
"	, FinalizerEnvPtr\n"
"        , newForeignPtr_         -- :: Ptr a -> IO (ForeignPtr a)\n"
"        , addForeignPtrFinalizer -- :: FinalizerPtr a -> ForeignPtr a -> IO ()\n"
"	, addForeignPtrFinalizerEnv -- :: FinalizerEnvPtr env a -> Ptr env ->\n"
"				    --    ForeignPtr a -> IO ()\n"
"	, unsafeForeignPtrToPtr	 -- :: ForeignPtr a -> Ptr a\n"
"	, touchForeignPtr        -- :: ForeignPtr a -> IO ()\n"
"	, castForeignPtr	 -- :: ForeignPtr a -> ForeignPtr b\n"
"        ) \n"
"	where\n"
"\n"
"import Hugs.Prelude		( ForeignPtr )\n"
"import Foreign.Ptr		( Ptr, FunPtr )\n"
"\n"
"-- data ForeignPtr a -- defined in Prelude.hs\n"
"\n"
"type FinalizerPtr        a = FunPtr (           Ptr a -> IO ())\n"
"type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())\n"
"\n"
"primitive newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)\n"
"primitive addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()\n"
"primitive addForeignPtrFinalizerEnv ::\n"
"		FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()\n"
"primitive touchForeignPtr :: ForeignPtr a -> IO ()\n"
"primitive unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a\n"
"primitive castForeignPtr \"primUnsafeCoerce\" :: ForeignPtr a -> ForeignPtr b\n";
const char *Hugs_Observe = "module Hugs.Observe (observe, bkpt, setBkpt) where\n"
"\n"
"primitive observe :: String -> a -> a\n"
"primitive bkpt    :: String -> a -> a\n"
"primitive setBkpt :: String -> Bool -> IO ()\n";
const char *Hugs_Dynamic = "module Hugs.Dynamic(module Data.Dynamic, coerceDynamic, runDyn) where\n"
"\n"
"import Data.Dynamic\n"
"\n"
"coerceDynamic :: Typeable a => Dynamic -> a\n"
"coerceDynamic d = fromDyn d def\n"
"  where def = error (\"coerceDynamic: expecting \" ++ show (toDyn def) ++\n"
"			\" found \" ++ show d)\n"
"\n"
"runDyn :: Dynamic -> IO ()\n"
"runDyn = coerceDynamic\n";
const char *Hugs_Word = "-----------------------------------------------------------------------------\n"
"-- Unsigned Integers\n"
"-- Suitable for use with Hugs 98 on 32 bit systems.\n"
"-----------------------------------------------------------------------------\n"
"module Hugs.Word\n"
"	( Word\n"
"	, Word8\n"
"	, Word16\n"
"	, Word32\n"
"	, Word64\n"
"	) where\n"
"\n"
"import Hugs.Prelude ( Word, Word8, Word16, Word32, Word64 )\n"
"import Data.Bits\n"
"import Data.Int\n"
"import Hugs.Prelude ( Ix(..) )\n"
"import Hugs.Prelude ( (%) )\n"
"import Hugs.Prelude ( readDec, showInt )\n"
"import Hugs.Prelude ( Num(fromInt), Integral(toInt) )\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- The \"official\" coercion functions\n"
"-----------------------------------------------------------------------------\n"
"\n"
"word8ToInt   :: Word8  -> Int\n"
"intToWord8   :: Int    -> Word8\n"
"word16ToInt  :: Word16 -> Int\n"
"intToWord16  :: Int    -> Word16\n"
"\n"
"word8ToInt  = word32ToInt    . word8ToWord32\n"
"intToWord8  = word32ToWord8  . intToWord32\n"
"word16ToInt = word32ToInt    . word16ToWord32\n"
"intToWord16 = word32ToWord16 . intToWord32\n"
"\n"
"primitive intToWord32 \"intToWord32\" :: Int    -> Word32\n"
"primitive word32ToInt \"word32ToInt\" :: Word32 -> Int\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Word8\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive word8ToWord32 \"primWord8ToWord32\" :: Word8  -> Word32\n"
"primitive word32ToWord8 \"primWord32ToWord8\" :: Word32 -> Word8\n"
"\n"
"instance Eq  Word8     where (==)    = binop (==)\n"
"instance Ord Word8     where compare = binop compare\n"
"\n"
"instance Num Word8 where\n"
"    x + y         = to (binop (+) x y)\n"
"    x - y         = to (binop (-) x y)\n"
"    negate        = to . negate . from\n"
"    x * y         = to (binop (*) x y)\n"
"    abs           = absReal\n"
"    signum        = signumReal\n"
"    fromInteger   = to . primIntegerToWord\n"
"    fromInt       = intToWord8\n"
"\n"
"instance Bounded Word8 where\n"
"    minBound = 0\n"
"    maxBound = 0xff\n"
"\n"
"instance Real Word8 where\n"
"    toRational x = toInteger x % 1\n"
"\n"
"instance Integral Word8 where\n"
"    x `div` y     = to  (binop div x y)\n"
"    x `quot` y    = to  (binop quot x y)\n"
"    x `rem` y     = to  (binop rem x y)\n"
"    x `mod` y     = to  (binop mod x y)\n"
"    x `quotRem` y = to2 (binop quotRem x y)\n"
"    divMod        = quotRem\n"
"    toInteger     = toInteger . from\n"
"    toInt         = word8ToInt\n"
"\n"
"instance Ix Word8 where\n"
"    range (m,n)          = [m..n]\n"
"    index b@(m,n) i\n"
"	   | inRange b i = word32ToInt (from (i - m))\n"
"	   | otherwise   = error \"index: Index out of range\"\n"
"    inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Word8 where\n"
"    toEnum         = to . intToWord32\n"
"    fromEnum       = word32ToInt . from\n"
"    enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Word8)]\n"
"    enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (last::Word8)]\n"
"		       where last = if d < c then minBound else maxBound\n"
"\n"
"instance Read Word8 where\n"
"    readsPrec p = readDec\n"
"\n"
"instance Show Word8 where\n"
"    showsPrec p = showInt  -- a particularily counterintuitive name!\n"
"\n"
"instance Bits Word8 where\n"
"  x .&. y       = to (binop (.&.) x y)\n"
"  x .|. y       = to (binop (.|.) x y)\n"
"  x `xor` y     = to (binop xor x y)\n"
"  complement    = to . complement . from\n"
"  x `shift` i   = to (from x `shift` i)\n"
"  x `rotate` i  = to (from x `rot` i)\n"
"    where rot = primRotateWord 8\n"
"  bit           = to . bit\n"
"  setBit x i    = to (setBit (from x) i)\n"
"  clearBit x i  = to (clearBit (from x) i)\n"
"  complementBit x i = to (complementBit (from x) i)\n"
"  testBit x i   = testBit (from x) i\n"
"  bitSize  _    = 8\n"
"  isSigned _    = False\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Word16\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive word16ToWord32 \"primWord16ToWord32\" :: Word16 -> Word32\n"
"primitive word32ToWord16 \"primWord32ToWord16\" :: Word32 -> Word16\n"
"\n"
"instance Eq  Word16     where (==)    = binop (==)\n"
"instance Ord Word16     where compare = binop compare\n"
"\n"
"instance Num Word16 where\n"
"    x + y         = to (binop (+) x y)\n"
"    x - y         = to (binop (-) x y)\n"
"    negate        = to . negate . from\n"
"    x * y         = to (binop (*) x y)\n"
"    abs           = absReal\n"
"    signum        = signumReal\n"
"    fromInteger   = to . primIntegerToWord\n"
"    fromInt       = intToWord16\n"
"\n"
"instance Bounded Word16 where\n"
"    minBound = 0\n"
"    maxBound = 0xffff\n"
"\n"
"instance Real Word16 where\n"
"  toRational x = toInteger x % 1\n"
"\n"
"instance Integral Word16 where\n"
"  x `div` y     = to  (binop div x y)\n"
"  x `quot` y    = to  (binop quot x y)\n"
"  x `rem` y     = to  (binop rem x y)\n"
"  x `mod` y     = to  (binop mod x y)\n"
"  x `quotRem` y = to2 (binop quotRem x y)\n"
"  divMod        = quotRem\n"
"  toInteger     = toInteger . from\n"
"  toInt         = word16ToInt\n"
"\n"
"instance Ix Word16 where\n"
"  range (m,n)          = [m..n]\n"
"  index b@(m,n) i\n"
"         | inRange b i = word32ToInt (from (i - m))\n"
"         | otherwise   = error \"index: Index out of range\"\n"
"  inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Word16 where\n"
"  toEnum         = to . intToWord32\n"
"  fromEnum       = word32ToInt . from\n"
"  enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Word16)]\n"
"  enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (last::Word16)]\n"
"		       where last = if d < c then minBound else maxBound\n"
"\n"
"instance Read Word16 where\n"
"  readsPrec p = readDec\n"
"\n"
"instance Show Word16 where\n"
"  showsPrec p = showInt  -- a particularily counterintuitive name!\n"
"\n"
"instance Bits Word16 where\n"
"  x .&. y       = to (binop (.&.) x y)\n"
"  x .|. y       = to (binop (.|.) x y)\n"
"  x `xor` y     = to (binop xor x y)\n"
"  complement    = to . complement . from\n"
"  x `shift` i   = to (from x `shift` i)\n"
"  x `rotate` i  = to (from x `rot` i)\n"
"    where rot = primRotateWord 16\n"
"  bit           = to . bit\n"
"  setBit x i    = to (setBit (from x) i)\n"
"  clearBit x i  = to (clearBit (from x) i)\n"
"  complementBit x i = to (complementBit (from x) i)\n"
"  testBit x i   = testBit (from x) i\n"
"  bitSize  _    = 16\n"
"  isSigned _    = False\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Word32\n"
"-----------------------------------------------------------------------------\n"
"\n"
"instance Eq  Word32     where (==)    = primEqWord\n"
"instance Ord Word32     where compare = primCmpWord\n"
"\n"
"instance Num Word32 where\n"
"    (+)           = primPlusWord\n"
"    (-)           = primMinusWord\n"
"    negate        = primNegateWord\n"
"    (*)           = primMulWord\n"
"    abs           = absReal\n"
"    signum        = signumReal\n"
"    fromInteger   = primIntegerToWord\n"
"    fromInt       = intToWord32\n"
"\n"
"instance Bounded Word32 where\n"
"    minBound = 0\n"
"    maxBound = primMaxWord\n"
"\n"
"instance Real Word32 where\n"
"    toRational x = toInteger x % 1\n"
"\n"
"instance Integral Word32 where\n"
"    div       = primDivWord\n"
"    quot      = primQuotWord\n"
"    rem       = primRemWord\n"
"    mod       = primModWord\n"
"    quotRem   = primQrmWord\n"
"    divMod    = quotRem\n"
"    toInteger = primWordToInteger\n"
"    toInt     = word32ToInt \n"
"\n"
"instance Ix Word32 where\n"
"    range (m,n)          = [m..n]\n"
"    index b@(m,n) i\n"
"	   | inRange b i = word32ToInt (i - m)\n"
"	   | otherwise   = error \"index: Index out of range\"\n"
"    inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Word32 where\n"
"    toEnum        = intToWord32\n"
"    fromEnum      = word32ToInt\n"
"\n"
"    --No: suffers from overflow problems: \n"
"    --   [4294967295 .. 1] :: [Word32]\n"
"    --   = [4294967295,0,1]\n"
"    --enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Word32)]\n"
"    --enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (last::Word32)]\n"
"    --     	           where last = if d < c then minBound else maxBound\n"
"\n"
"    enumFrom       = boundedEnumFrom\n"
"    enumFromTo     = boundedEnumFromTo\n"
"    enumFromThen   = boundedEnumFromThen\n"
"    enumFromThenTo = boundedEnumFromThenTo\n"
"\n"
"boundedEnumFrom        :: (Ord a, Num a, Bounded a, Enum a) => a -> [a]\n"
"boundedEnumFromThen    :: (Ord a, Num a, Bounded a, Enum a) => a -> a -> [a]\n"
"boundedEnumFromTo      :: (Ord a, Num a, Bounded a, Enum a) => a -> a -> [a]\n"
"boundedEnumFromThenTo  :: (Ord a, Num a, Bounded a, Enum a) => a -> a -> a -> [a]\n"
"boundedEnumFrom n\n"
"  | n == maxBound = [n]\n"
"  | otherwise     = n : (boundedEnumFrom $! (n+1))\n"
"boundedEnumFromThen n m\n"
"  | n <= m    = enum (< maxBound - delta) delta n\n"
"  | otherwise = enum (> minBound - delta) delta n\n"
" where\n"
"  delta = m - n\n"
"boundedEnumFromTo n m = takeWhile (<= m) (boundedEnumFrom n)\n"
"boundedEnumFromThenTo n n' m \n"
"  | n' >= n   = if n <= m then enum (<= m - delta) delta n else []\n"
"  | otherwise = if n >= m then enum (>= m - delta) delta n else []\n"
" where\n"
"  delta = n'-n\n"
"\n"
"enum :: (Num a) => (a -> Bool) -> a -> a -> [a]\n"
"enum p delta x = if p x then x : (enum p delta $! (x+delta)) else [x]\n"
"\n"
"instance Read Word32 where\n"
"    readsPrec p = readDec\n"
"\n"
"instance Show Word32 where\n"
"    showsPrec p = showInt  -- a particularily counterintuitive name!\n"
"\n"
"instance Bits Word32 where\n"
"  (.&.)         = primAndWord\n"
"  (.|.)         = primOrWord\n"
"  xor           = primXorWord\n"
"  complement    = primComplementWord\n"
"  shift         = primShiftWord\n"
"  rotate        = primRotateWord 32\n"
"  bit           = primBitWord\n"
"  setBit x i    = x .|. bit i\n"
"  clearBit x i  = x .&. complement (bit i)\n"
"  complementBit x i = x `xor` bit i\n"
"  testBit       = primTestWord\n"
"  bitSize  _    = 32\n"
"  isSigned _    = False\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Word64\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive word64ToWord32 \"primWord64ToWord32\" :: Word64 -> (Word32,Word32)\n"
"primitive word32ToWord64 \"primWord32ToWord64\" :: Word32 -> Word32 -> Word64\n"
"\n"
"integerToW64 :: Integer -> Word64\n"
"integerToW64 x = case x `quotRem` 0x100000000 of\n"
"	(hi,lo) -> word32ToWord64 (fromInteger hi) (fromInteger lo)\n"
"\n"
"w64ToInteger :: Word64 -> Integer\n"
"w64ToInteger x = case word64ToWord32 x of\n"
"	(hi,lo) -> toInteger hi * 0x100000000 + toInteger lo\n"
"\n"
"instance Eq Word64 where\n"
"    x == y = word64ToWord32 x == word64ToWord32 y\n"
"\n"
"instance Ord Word64 where\n"
"    compare x y = compare (word64ToWord32 x) (word64ToWord32 y)\n"
"\n"
"instance Bounded Word64 where\n"
"    minBound = word32ToWord64 minBound minBound\n"
"    maxBound = word32ToWord64 maxBound maxBound\n"
"\n"
"instance Show Word64 where\n"
"    showsPrec p = showInt . toInteger\n"
"\n"
"instance Read Word64 where\n"
"    readsPrec p s = [ (fromInteger x,r) | (x,r) <- readDec s ]\n"
"\n"
"instance Num Word64 where\n"
"    x + y         = fromInteger (toInteger x + toInteger y)\n"
"    x - y         = fromInteger (toInteger x - toInteger y)\n"
"    x * y         = fromInteger (toInteger x * toInteger y)\n"
"    abs           = absReal\n"
"    signum        = signumReal\n"
"    fromInteger   = integerToW64\n"
"\n"
"instance Real Word64 where\n"
"    toRational x = toInteger x % 1\n"
"\n"
"instance Ix Word64 where\n"
"    range (m,n)          = [m..n]\n"
"    index b@(m,n) i\n"
"	   | inRange b i = toInt (i - m)\n"
"	   | otherwise   = error \"index: Index out of range\"\n"
"    inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Word64 where\n"
"    toEnum           = fromInt\n"
"    fromEnum         = toInt\n"
"\n"
"    succ             = fromInteger . (+1) . toInteger\n"
"    pred             = fromInteger . (subtract 1) . toInteger\n"
"    enumFrom x       = map fromInteger [toInteger x ..]\n"
"    enumFromTo x y   = map fromInteger [toInteger x .. toInteger y]\n"
"    enumFromThen x y = map fromInteger [toInteger x, toInteger y ..]\n"
"    enumFromThenTo x y z =\n"
"                       map fromInteger [toInteger x, toInteger y .. toInteger z]\n"
"\n"
"instance Integral Word64 where\n"
"    x `quotRem` y = (fromInteger q, fromInteger r)\n"
"	where (q,r) = toInteger x `quotRem` toInteger y\n"
"    toInteger     = w64ToInteger\n"
"\n"
"instance Bits Word64 where\n"
"    x .&. y       = liftBinary (.&.) x y\n"
"    x .|. y       = liftBinary (.|.) x y\n"
"    x `xor` y     = liftBinary xor x y\n"
"    complement    = liftUnary complement\n"
"    x `shift` i   = fromInteger (toInteger x `shift` i)\n"
"    x `rotate` i  | i<0  = (x `shift` i) .|. (x `shift` (i+bitSize x))\n"
"		  | i==0 = x\n"
"		  | i>0  = (x `shift` i) .|. (x `shift` (i-bitSize x))\n"
"    bit i | i `mod` 64 < 32 = word32ToWord64 0 (bit i)\n"
"          | otherwise       = word32ToWord64 (bit i) 0\n"
"    bitSize  _    = 64\n"
"    isSigned _    = False\n"
"\n"
"liftBinary :: (Word32 -> Word32 -> Word32) -> Word64 -> Word64 -> Word64\n"
"liftBinary op x y = word32ToWord64 (op xhi yhi) (op xlo ylo)\n"
"	where	(xhi,xlo) = word64ToWord32 x\n"
"		(yhi,ylo) = word64ToWord32 y\n"
"\n"
"liftUnary :: (Word32 -> Word32) -> Word64 -> Word64\n"
"liftUnary op x = word32ToWord64 (op xhi) (op xlo)\n"
"	where	(xhi,xlo) = word64ToWord32 x\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- End of exported definitions\n"
"--\n"
"-- The remainder of this file consists of definitions which are only\n"
"-- used in the implementation.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Coercions - used to make the instance declarations more uniform\n"
"-----------------------------------------------------------------------------\n"
"\n"
"class Coerce a where\n"
"  to   :: Word32 -> a\n"
"  from :: a -> Word32\n"
"\n"
"instance Coerce Word8 where\n"
"  from = word8ToWord32\n"
"  to   = word32ToWord8\n"
"\n"
"instance Coerce Word16 where\n"
"  from = word16ToWord32\n"
"  to   = word32ToWord16\n"
"\n"
"binop :: Coerce word => (Word32 -> Word32 -> a) -> (word -> word -> a)\n"
"binop op x y = from x `op` from y\n"
"\n"
"to2 :: Coerce word => (Word32, Word32) -> (word, word)\n"
"to2 (x,y) = (to x, to y)\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- primitives\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive primEqWord        :: Word32 -> Word32 -> Bool\n"
"primitive primCmpWord       :: Word32 -> Word32 -> Ordering\n"
"primitive primPlusWord,\n"
"	  primMinusWord,\n"
"	  primMulWord	    :: Word32 -> Word32 -> Word32\n"
"primitive primNegateWord    :: Word32 -> Word32\n"
"primitive primIntegerToWord :: Integer -> Word32\n"
"primitive primMaxWord       :: Word32\n"
"primitive primDivWord,\n"
"	  primQuotWord,\n"
"	  primRemWord,\n"
"	  primModWord       :: Word32 -> Word32 -> Word32\n"
"primitive primQrmWord       :: Word32 -> Word32 -> (Word32,Word32)\n"
"primitive primWordToInteger :: Word32 -> Integer\n"
"primitive primAndWord       :: Word32 -> Word32 -> Word32\n"
"primitive primOrWord        :: Word32 -> Word32 -> Word32\n"
"primitive primXorWord       :: Word32 -> Word32 -> Word32\n"
"primitive primComplementWord:: Word32 -> Word32\n"
"primitive primShiftWord     :: Word32 -> Int -> Word32\n"
"primitive primRotateWord    :: Int -> Word32 -> Int -> Word32\n"
"primitive primBitWord       :: Int -> Word32\n"
"primitive primTestWord      :: Word32 -> Int -> Bool\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Code copied from the Prelude\n"
"-----------------------------------------------------------------------------\n"
"\n"
"absReal x    | x >= 0    = x\n"
"	     | otherwise = -x\n"
"\n"
"signumReal x | x == 0    =  0\n"
"	     | x > 0     =  1\n"
"	     | otherwise = -1\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- End\n"
"-----------------------------------------------------------------------------\n";
const char *Hugs_Quote = "module Hugs.Quote(Quote, quote, trim) where\n"
"\n"
"import Data.List\n"
"import Data.Ratio(Ratio)\n"
"\n"
"class Quote a where\n"
"    quote :: a -> String\n"
"\n"
"instance Quote Char where\n"
"    quote c = [c]\n"
"\n"
"instance Quote String where\n"
"    quote = id\n"
"\n"
"instance Quote Bool where\n"
"    quote = show\n"
"\n"
"instance Show a => Quote (Maybe a) where\n"
"    quote = show\n"
"\n"
"instance Quote Int where\n"
"    quote = show\n"
"\n"
"instance Quote Integer where\n"
"    quote = show\n"
"\n"
"instance Quote Float where\n"
"    quote = show\n"
"\n"
"instance Quote Double where\n"
"    quote = show\n"
"\n"
"instance Integral a => Quote (Ratio a) where\n"
"    quote = show\n"
"\n"
"-- trims off leading whitespace up to a common prefix,\n"
"-- making it easy to layout here docs indented so that\n"
"-- are not visually confusing (especially if you are doing\n"
"-- something like using here docs to generate Haskell code)\n"
"\n"
"trim s = unlines' ls'\n"
"  where ls  = lines' s\n"
"	ls' = map (trimoff 0 n) ls\n"
"	n = case filter (/= 0) $ map (whitecount 0) ls of\n"
"	      [] -> 0\n"
"	      xs -> minimum xs\n"
"\n"
"-- like the prelude functions, but preserve (lack of) trailing newline\n"
"lines' s    = let (l,s') = break ('\\n'==) s\n"
"	      in l : case s' of []      -> []\n"
"				(_:s'') -> lines' s''\n"
"unlines' ss = concat $ intersperse \"\\n\" ss\n"
"\n"
"whitecount n []        = n\n"
"whitecount n (' ':cs)  = whitecount (n + 1) cs\n"
"whitecount n ('\\t':cs) = whitecount (8 * ((n + 8) `div` 8)) cs\n"
"whitecount n _         = n\n"
"\n"
"trimoff n m [] = []\n"
"trimoff n m cs | n >= m = cs\n"
"trimoff n m (' ' :cs) = trimoff (n + 1) m cs\n"
"trimoff n m ('\\t':cs) = trimoff (8 * ((n + 8) `div` 8)) m cs\n"
"trimoff n m cs        = cs\n";
const char *Hugs_LazyST = "-----------------------------------------------------------------------------\n"
"-- Lazy State Thread module\n"
"-- \n"
"-- This library provides support for both lazy and strict state threads,\n"
"-- as described in the PLDI '94 paper by John Launchbury and Simon Peyton\n"
"-- Jones.  In addition to the monad ST, it also provides mutable variables\n"
"-- STRef and mutable arrays STArray.  It is identical to the ST module\n"
"-- except that the ST instance is lazy.\n"
"--\n"
"-- Suitable for use with Hugs 98.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.LazyST \n"
"	( ST\n"
"	, runST\n"
"	, unsafeInterleaveST\n"
"	, fixST \n"
"\n"
"	, lazyToStrictST\n"
"	, strictToLazyST\n"
"	) where\n"
"\n"
"import qualified Hugs.ST as ST\n"
"import Control.Monad   \n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"newtype ST s a = ST (State s -> (a, State s))\n"
"\n"
"unST :: ST s a -> State s -> (a, State s)\n"
"unST (ST f) = f\n"
"\n"
"runST :: (forall s. ST s a) -> a\n"
"runST m = fst (unST m S)\n"
"\n"
"unsafeInterleaveST :: ST s a -> ST s a\n"
"unsafeInterleaveST (ST m) = return (fst (m S))\n"
"\n"
"fixST :: (a -> ST s a) -> ST s a\n"
"fixST f = ST (\\s -> let (x,s') = unST (f x) s in (x,s'))\n"
"\n"
"instance Functor (ST s) where\n"
"    fmap = liftM\n"
"\n"
"instance Monad (ST s) where\n"
"    return a = ST (\\s -> (a, s))\n"
"    ST m >>= f = ST (\\S -> let (a,s') = m S in unST (f a) s')\n"
"    -- ST m >>= f = ST (\\s -> let (a,s') = m s in unST (f a) s')\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"data State s = S\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"lazyToStrictST :: ST s a -> ST.ST s a\n"
"lazyToStrictST (ST m) = ST.ST (\\k -> case m S of (a,S) -> k a)\n"
"\n"
"strictToLazyST :: ST.ST s a -> ST s a\n"
"strictToLazyST (ST.ST m) = ST (\\S -> m delay)\n"
"--	\\s -> let (a',s') = case s of S -> m (\\a -> (a,S)) in (a',s'))\n"
"\n"
"delay :: a -> (a, State s)\n"
"delay a = (a,S)\n"
"\n"
"-----------------------------------------------------------------------------\n";
const char *Hugs_Char = "module Hugs.Char (\n"
"    isAscii, isLatin1, isControl, isPrint, isSpace, isUpper, isLower,\n"
"    isAlpha, isDigit, isOctDigit, isHexDigit, isAlphaNum,\n"
"    intToDigit,\n"
"    toUpper, toLower,\n"
"    ord, chr,\n"
"    readLitChar, showLitChar, lexLitChar\n"
"    ) where\n"
"\n"
"import Hugs.Prelude(\n"
"    isSpace, isUpper, isLower,\n"
"    isAlpha, isDigit, isOctDigit, isHexDigit, isAlphaNum,\n"
"    readLitChar, showLitChar, lexLitChar)\n"
"\n"
"-- The Hugs Char type covers only the ISO 8859-1 (Latin-1) subset of Unicode,\n"
"-- i.e. '\\0' to '\\xff'.\n"
"\n"
"-- Character-testing operations (some others are in Hugs.Prelude)\n"
"isAscii, isLatin1, isControl, isPrint :: Char -> Bool\n"
"\n"
"isAscii c                =  c < '\\x80'\n"
"\n"
"isLatin1 c               =  True	-- c <= '\\xff'\n"
" \n"
"isControl c              =  c < ' ' || c >= '\\DEL' && c <= '\\x9f'\n"
" \n"
"isPrint c                =  not (isControl c)\n"
"\n"
"-- Digit conversion operations\n"
"intToDigit               :: Int -> Char\n"
"intToDigit i\n"
"  | i >= 0  && i <=  9   =  toEnum (fromEnum '0' + i)\n"
"  | i >= 10 && i <= 15   =  toEnum (fromEnum 'a' + i - 10)\n"
"  | otherwise            =  error \"Char.intToDigit: not a digit\"\n"
"\n"
"-- Case-changing operations\n"
"toUpper                  :: Char -> Char\n"
"toUpper '\\xdf'           = '\\xdf'	-- lower, but no upper in Latin-1\n"
"toUpper '\\xff'           = '\\xff'	-- lower, but no upper in Latin-1\n"
"toUpper c | isLower c    =  toEnum (fromEnum c - fromEnum 'a' + fromEnum 'A')\n"
"          | otherwise    =  c\n"
"\n"
"toLower                  :: Char -> Char\n"
"toLower c | isUpper c    =  toEnum (fromEnum c - fromEnum 'A' + fromEnum 'a')\n"
"          | otherwise    =  c\n"
"\n"
"-- Character code functions\n"
"ord                      :: Char -> Int\n"
"ord                      =  fromEnum\n"
"\n"
"chr                      :: Int  -> Char\n"
"chr                      =  toEnum\n";
const char *Hugs_Internals = "----------------------------------------------------------------\n"
"-- Primitives for accessing Hugs internals.\n"
"--\n"
"-- NB These primitives are an _experimental_ feature which may be\n"
"--    removed in future versions of Hugs.\n"
"--    They can only be used if hugs was configured with the\n"
"--    \"--enable-internal-prims\" flag.\n"
"--\n"
"-- The primitives defined in this module provide the means with\n"
"-- which to implement simple error-recovery and debugging facilities\n"
"-- in Haskell.  \n"
"--\n"
"-- The error catching primitive only works if the \"failOnError\" flag \n"
"-- is FALSE - ie Hugs was invoked with the \"-f\" flag.\n"
"--\n"
"-- Despite appearances, these primitives are referentially transparent\n"
"-- (with the exception of the rarely used pointer equality operations)\n"
"-- (The proof is really neat - but there just isn't enough space in the margin)\n"
"----------------------------------------------------------------\n"
"\n"
"module Hugs.Internals(\n"
"	ptrEq,\n"
"\n"
"	Name,\n"
"	  nameString,\n"
"	  nameInfo,\n"
"	  nameEq,\n"
"	Cell,\n"
"	  getCell,\n"
"	  cellPtrEq,\n"
"	CellKind(..),\n"
"	  classifyCell,\n"
"\n"
"	catchError,\n"
"\n"
"	Addr,\n"
"          nameCode,\n"
"	Instr(..),\n"
"	  instrAt, instrsAt,\n"
"\n"
"	) where\n"
"\n"
"import Hugs.Prelude hiding ( Addr )\n"
"\n"
"----------------------------------------------------------------\n"
"-- pointer equality\n"
"----------------------------------------------------------------\n"
"\n"
"-- breaks referential transparency - use with care\n"
"primitive ptrEq \"unsafePtrEq\" :: a -> a -> Bool\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"-- Name\n"
"----------------------------------------------------------------\n"
"\n"
"data Name\n"
"-- newtype Name = Name Int\n"
"\n"
"-- returns (arity, precedence, associativity)\n"
"primitive nameInfo       :: Name -> (Int, Int, Char)\n"
"primitive nameString     :: Name -> String\n"
"primitive nameEq         :: Name -> Name -> Bool\n"
"\n"
"instance Show Name where\n"
"  showsPrec _ nm = showString (nameString nm)\n"
"\n"
"instance Eq Name where\n"
"  (==) = nameEq\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"-- Cell\n"
"-- Note: cellPtrEq breaks referential transparency - use with care\n"
"----------------------------------------------------------------\n"
"\n"
"data Cell\n"
"\n"
"primitive getCell                  :: a -> Cell\n"
"primitive cellPtrEq                :: Cell -> Cell -> Bool\n"
"primitive catchError \"catchError2\" :: a -> Either Cell a\n"
"\n"
"instance Show Cell where \n"
"  showsPrec _ _ = showString \"{Cell}\"\n"
"\n"
"----------------------------------------------------------------\n"
"-- CellType\n"
"----------------------------------------------------------------\n"
"\n"
"data CellKind       \n"
"  = Apply   Cell [Cell]\n"
"  | Fun     Name    \n"
"  | Con     Name    \n"
"  | Tuple   Int         \n"
"  | Int     Int         \n"
"  | Integer Integer   \n"
"  | Float   Float       \n"
"  | Double  Double       \n"
"  | Char    Char        \n"
"  | Prim    String      \n"
"  | Error   Cell  \n"
"  deriving (Show)\n"
"\n"
"primitive classifyCell :: Bool -> Cell -> IO CellKind\n"
"\n"
"----------------------------------------------------------------\n"
"-- Addr\n"
"----------------------------------------------------------------\n"
"\n"
"newtype Addr  = Addr  Int deriving (Eq, Show)\n"
"\n"
"s :: Addr -> Addr\n"
"s (Addr a) = Addr (a+1)\n"
"\n"
"primitive nameCode    :: Name -> Addr\n"
"primitive intAt       :: Addr -> Int\n"
"primitive floatAt     :: Addr -> Float\n"
"primitive doubleAt    :: Addr -> Double\n"
"primitive cellAt      :: Addr -> Cell\n"
"primitive nameAt      :: Addr -> Name\n"
"primitive textAt      :: Addr -> String\n"
"primitive addrAt      :: Addr -> Addr\n"
"primitive bytecodeAt :: Addr -> Bytecode\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"-- Bytecode\n"
"----------------------------------------------------------------\n"
"\n"
"newtype Bytecode = Bytecode Int deriving (Eq, Show)\n"
"\n"
"iLOAD    = Bytecode 0\n"
"iCELL	 = Bytecode 1\n"
"iCHAR	 = Bytecode 2\n"
"iINT	 = Bytecode 3\n"
"iFLOAT	 = Bytecode 4\n"
"iSTRING	 = Bytecode 5\n"
"iMKAP	 = Bytecode 6\n"
"iUPDATE	 = Bytecode 7\n"
"iUPDAP	 = Bytecode 8\n"
"iEVAL	 = Bytecode 9\n"
"iRETURN	 = Bytecode 10\n"
"iTEST	 = Bytecode 11\n"
"iGOTO	 = Bytecode 12\n"
"iSETSTK	 = Bytecode 13\n"
"iROOT	 = Bytecode 14\n"
"iDICT	 = Bytecode 15\n"
"iFAIL	 = Bytecode 16\n"
"iALLOC	 = Bytecode 17\n"
"iSLIDE	 = Bytecode 18\n"
"iSTAP	 = Bytecode 19\n"
"iTABLE	 = Bytecode 20\n"
"iLEVAL	 = Bytecode 21\n"
"iRUPDAP	 = Bytecode 22\n"
"iRUPDATE = Bytecode 23\n"
"\n"
"data Instr \n"
"  = LOAD    Int\n"
"  | CELL    Cell\n"
"  | CHAR    Char\n"
"  | INT	    Int    \n"
"  | FLOAT   Float   	  \n"
"  | DOUBLE  Double\n"
"  | STRING  String  	  \n"
"  | MKAP    Int   \n"
"  | UPDATE  Int  	  \n"
"  | UPDAP   Int  	  \n"
"  | EVAL    	   \n"
"  | RETURN  	   \n"
"  | TEST    Name Addr\n"
"  | GOTO    Addr  	  \n"
"  | SETSTK  Int  	  \n"
"  | ROOT    Int  	  \n"
"  | DICT    Int\n"
"  | FAIL    	   \n"
"  | ALLOC   Int\n"
"  | SLIDE   Int	   \n"
"  | STAP    	   \n"
"  | TABLE   	   \n"
"  | LEVAL   Int	   \n"
"  | RUPDAP  	   \n"
"  | RUPDATE \n"
"  deriving (Show)\n"
"\n"
"instrAt :: Addr -> (Instr, Addr)\n"
"instrAt pc = case bytecodeAt pc of \n"
"  i | i == iLOAD    -> (LOAD    (intAt   (s pc)), s (s pc))\n"
"  i | i == iCELL    -> (CELL    (cellAt  (s pc)), s (s pc))\n"
"  i | i == iCHAR    -> (CHAR    (toEnum (intAt (s pc))), s (s pc))\n"
"  i | i == iINT     -> (INT     (intAt   (s pc)), s (s pc))\n"
"  i | i == iFLOAT   -> (FLOAT   (floatAt (s pc)), s (s pc))\n"
"  i | i == iSTRING  -> (STRING  (textAt  (s pc)), s (s pc))\n"
"  i | i == iMKAP    -> (MKAP    (intAt   (s pc)), s (s pc))\n"
"  i | i == iUPDATE  -> (UPDATE  (intAt   (s pc)), s (s pc))\n"
"  i | i == iUPDAP   -> (UPDAP   (intAt   (s pc)), s (s pc))\n"
"  i | i == iEVAL    -> (EVAL                    , s pc)\n"
"  i | i == iRETURN  -> (RETURN                  , s pc)\n"
"  i | i == iTEST    -> (TEST    (nameAt  (s pc)) (addrAt (s (s (pc)))), s (s (s pc)))\n"
"  i | i == iGOTO    -> (GOTO    (addrAt  (s pc)), s (s pc))\n"
"  i | i == iSETSTK  -> (SETSTK  (intAt   (s pc)), s (s pc))\n"
"  i | i == iROOT    -> (ROOT    (intAt   (s pc)), s (s pc))\n"
"  i | i == iDICT    -> (DICT    (intAt   (s pc)), s (s pc))\n"
"  i | i == iFAIL    -> (FAIL                    , s pc)\n"
"  i | i == iALLOC   -> (ALLOC   (intAt   (s pc)), s (s pc))\n"
"  i | i == iSLIDE   -> (SLIDE   (intAt   (s pc)), s (s pc))\n"
"  i | i == iSTAP    -> (STAP                    , s pc)\n"
"  i | i == iTABLE   -> (TABLE                   , s pc)\n"
"  i | i == iLEVAL   -> (LEVAL   (intAt   (s pc)), s (s pc))\n"
"  i | i == iRUPDAP  -> (RUPDAP                  , s pc)\n"
"  i | i == iRUPDATE -> (RUPDATE                 , s pc)\n"
"\n"
"-- list of instructions starting at given address\n"
"instrsAt :: Addr -> [Instr]\n"
"instrsAt pc = let (i, pc')  = instrAt pc in i : instrsAt pc'\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"-- tests\n"
"----------------------------------------------------------------\n"
"\n"
"-- test1, test2 :: Either Cell Int\n"
"-- \n"
"-- test1 = catchError (error \"foo\")\n"
"-- test2 = catchError 1\n"
"-- \n"
"-- \n"
"-- test3, test4, test5 :: Int\n"
"-- \n"
"-- test3 = myCatch (1+error \"foo\") 2\n"
"-- test4 = myCatch 1 (error \"bar\")\n"
"-- test5 = myCatch (error \"foo\") (error \"bar\")\n"
"-- \n"
"-- \n"
"-- test6, test7, test8, test9 :: IO ()\n"
"-- \n"
"-- test6 = printString \"abcdefg\"\n"
"-- test7 = printString (error \"a\" : \"bcdefg\")\n"
"-- test8 = printString (\"abc\" ++ error \"defg\")\n"
"-- test9 = printString (error \"a\" : \"bc\" ++ error \"defg\")\n"
"-- \n"
"-- -- if an error occurs, replace it with a default (hopefully error-free) value\n"
"-- myCatch :: a -> a -> a\n"
"-- myCatch x deflt = case catchError x of\n"
"-- 		   Right x' -> x'\n"
"-- 		   Left _   -> deflt\n"
"-- \n"
"-- -- lazily print a string - catching any errors as necessary\n"
"-- printString :: String -> IO ()\n"
"-- printString str =\n"
"--   case catchError str of\n"
"--   Left _       -> putStr \"<error>\"\n"
"--   Right []     -> return ()\n"
"--   Right (c:cs) -> case catchError c of\n"
"-- 		     Left _   -> putStr \"<error>\" >> printString cs\n"
"-- 		     Right c' -> putChar c' >> printString cs\n"
"\n"
"\n"
"\n";
const char *Hugs_Memo = "{-----------------------------------------------------------------------------\n"
"\n"
"                   A LIBRARY OF MEMOIZATION COMBINATORS\n"
"\n"
"                            15th September 1999\n"
"\n"
"	                         Byron Cook\n"
"			            OGI\n"
"\n"
"This Hugs module implements several flavors of memoization functions,\n"
"as described in Haskell Workshop 1997.\n"
"-----------------------------------------------------------------------------}\n"
"\n"
"module Hugs.Memo(\n"
"        memo,  \n"
"        memoN,  \n"
"        memoFix,\n"
"        memoFixN,\n"
"        cache, \n"
"        cacheN, \n"
"        cacheFix,\n"
"        cacheFixN\n"
"        ) where\n"
"\n"
"import Hugs.ST\n"
"-- import Hugs.IOExts (unsafePtrEq)\n"
"-- import Debug.Trace (trace)\n"
"\n"
"memo      :: (a -> b) -> (a -> b)\n"
"memoN     :: Int -> (a -> b) -> (a -> b)\n"
"memoFix   :: ((a -> b) -> (a -> b)) -> (a -> b)\n"
"memoFixN  :: Int -> ((a -> b) -> (a -> b)) -> (a -> b)\n"
"cache     :: (a -> b) -> (a -> b)\n"
"cacheN    :: Int -> (a -> b) -> (a -> b)\n"
"cacheFix  :: ((a -> b) -> (a -> b)) -> (a -> b)\n"
"cacheFixN :: Int -> ((a -> b) -> (a -> b)) -> (a -> b)\n"
"\n"
"----------------------------------------------------------------\n"
"-- Memoization Functions (memo-tables are hash-tables)\n"
"----------------------------------------------------------------\n"
"memo          = memoN defaultSize \n"
"memoN         = mkMemo eql hash \n"
"\n"
"memoFix       = memoFixN defaultSize \n"
"memoFixN n f  = let g = f h\n"
"                    h = memoN n g\n"
"                in g\n"
"\n"
"----------------------------------------------------------------\n"
"-- Caching Functions (memo-tables are caches)\n"
"----------------------------------------------------------------\n"
"cache          = cacheN defaultSize\n"
"cacheN         = mkCache eql hash\n"
"cacheFix       = cacheFixN defaultSize\n"
"cacheFixN n f  = let g = f h\n"
"                     h = cacheN n g\n"
"                 in g\n"
"\n"
"----------------------------------------------------------------\n"
"-- Type synonyms\n"
"----------------------------------------------------------------\n"
"type TaintedEq a   = a -> a -> ST Mem Bool\n"
"type HashTable a b = STArray Mem Int [(a,b)]\n"
"type Cache a b     = STArray Mem Int (Maybe (a,b))\n"
"type HashSize      = Int\n"
"type HashFunc a    = a -> ST Mem Int\n"
"type Mem           = ()\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"-- Foundation functions\n"
"----------------------------------------------------------------\n"
"defaultSize :: HashSize\n"
"defaultSize = 40\n"
"\n"
"memoize :: ST Mem t -> (t -> a -> b -> ST Mem b) -> \n"
"           (a -> b) -> a -> b\n"
"memoize new access f = {-trace \"memoize\" $-} unsafeRunST $ do \n"
"  t <- new\n"
"  return (\\x -> unsafeRunST $ access t x (f x))\n"
"\n"
"\n"
"mkMemo  :: TaintedEq a -> HashFunc a -> Int -> (a -> c) -> (a -> c)\n"
"mkCache :: TaintedEq a -> HashFunc a -> Int -> (a -> c) -> (a -> c)\n"
"\n"
"mkCache e h sz = memoize (newCache sz) (accessCache e h sz)\n"
"mkMemo  e h sz = memoize (newHash sz)  (accessHash e  h sz)\n"
"\n"
"\n"
"----------------------------------------------------------------\n"
"-- Hash and Cache Tables\n"
"----------------------------------------------------------------\n"
"accessHash  :: TaintedEq a ->  \n"
"               HashFunc a -> \n"
"               Int -> \n"
"               HashTable a b -> \n"
"               a -> b -> ST Mem b\n"
"\n"
"accessHash equal h sz table x v = do \n"
"  hv' <- h x\n"
"  let hv = hv' `mod` sz\n"
"  l <- readSTArray table hv\n"
"  find l l hv\n"
" where find l [] hv = {-trace \"miss \" $-} do\n"
"         u <- writeSTArray table  hv ((x,v):l) \n"
"         case u of {() -> return v}\n"
"       find l ((x',v'):xs) hv = do\n"
"         a <- equal x x'\n"
"         if a then {-trace \"hit \"-} (return $ v')\n"
"          else find l xs hv\n"
"\n"
"newHash :: Int -> ST Mem (HashTable a b)\n"
"newHash n = newSTArray (0,n) []\n"
"\n"
"\n"
"accessCache  :: TaintedEq a ->\n"
"                HashFunc a ->\n"
"                Int ->\n"
"                Cache a b ->\n"
"                a -> b -> ST Mem b\n"
"\n"
"accessCache equal h sz table x v = do \n"
"  hv' <- h x \n"
"  let hv = hv' `mod` sz \n"
"  l <-  readSTArray table hv\n"
"  case l of\n"
"     Nothing      -> do u <- writeSTArray table hv (Just (x,v))\n"
"                        case u of {() -> return v}\n"
"     Just (x',y)  -> do e <- equal x' x\n"
"                        if e then return y\n"
"                         else do u <- writeSTArray table hv (Just (x,v))\n"
"                                 case u of {() -> return v}\n"
"\n"
"newCache :: Int -> ST Mem (Cache a b)\n"
"newCache n = newSTArray (0,n) Nothing\n"
"\n"
"------------------------------------------------------------------\n"
"-- These functions are bad --- dont pay attention to them\n"
"\n"
"-- lisp style eql --- as described in \"Lazy-memo functions\"\n"
"primitive eql \"IOEql\" :: a -> a -> ST Mem Bool\n"
"-- a `eql` b = return (a `unsafePtrEq` b)\n"
"\n"
"-- hash based on addresses (or values if the arg is a base type)\n"
"primitive hash \"IOHash\" :: a -> ST Mem Int\n"
"\n"
"------------------------------------------------------------------\n";
const char *Hugs_IOArray = "-----------------------------------------------------------------------------\n"
"-- Mutable arrays in the IO monad:\n"
"--\n"
"-- Suitable for use with Hugs 98.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.IOArray\n"
"	( IOArray			-- instance of: Eq, Typeable\n"
"	, newIOArray\n"
"	, boundsIOArray\n"
"	, readIOArray\n"
"	, writeIOArray\n"
"	, freezeIOArray\n"
"	, thawIOArray\n"
"	, unsafeFreezeIOArray\n"
"	, unsafeReadIOArray\n"
"	, unsafeWriteIOArray\n"
"	) where\n"
"\n"
"import Hugs.Array\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"data IOArray ix elt -- implemented as an internal primitive\n"
"\n"
"newIOArray          :: Ix ix => (ix,ix) -> elt -> IO (IOArray ix elt)\n"
"boundsIOArray       :: Ix ix => IOArray ix elt -> (ix, ix)\n"
"readIOArray         :: Ix ix => IOArray ix elt -> ix -> IO elt\n"
"writeIOArray        :: Ix ix => IOArray ix elt -> ix -> elt -> IO ()\n"
"thawIOArray         :: Ix ix => Array ix elt -> IO (IOArray ix elt)\n"
"freezeIOArray       :: Ix ix => IOArray ix elt -> IO (Array ix elt)\n"
"unsafeFreezeIOArray :: Ix ix => IOArray ix elt -> IO (Array ix elt)\n"
"\n"
"unsafeReadIOArray   :: Ix i => IOArray i e -> Int -> IO e\n"
"unsafeReadIOArray    = primReadArr\n"
"\n"
"unsafeWriteIOArray  :: Ix i => IOArray i e -> Int -> e -> IO ()\n"
"unsafeWriteIOArray   = primWriteArr\n"
"\n"
"newIOArray bs e      = primNewArr bs (rangeSize bs) e\n"
"boundsIOArray a      = primBounds a\n"
"readIOArray a i      = unsafeReadIOArray a (index (boundsIOArray a) i)\n"
"writeIOArray a i e   = unsafeWriteIOArray a (index (boundsIOArray a) i) e\n"
"thawIOArray arr      = do a <- newIOArray (bounds arr) err\n"
"			  let fillin []          = return a\n"
"			      fillin((ix,v):ixs) = do writeIOArray a ix v\n"
"                                                      fillin ixs\n"
"                          fillin (assocs arr)\n"
"                       where err =  error \"thawArray: element not overwritten\"\n"
"\n"
"freezeIOArray a      = primFreeze a\n"
"unsafeFreezeIOArray  = freezeIOArray  -- not as fast as GHC\n"
"\n"
"instance Eq (IOArray ix elt) where\n"
"  (==) = eqIOArray\n"
"\n"
"primitive primNewArr   \"IONewArr\"\n"
"          :: (a,a) -> Int -> b -> IO (IOArray a b)\n"
"primitive primReadArr  \"IOReadArr\"\n"
"          :: IOArray a b -> Int -> IO b\n"
"primitive primWriteArr \"IOWriteArr\"\n"
"          :: IOArray a b -> Int -> b -> IO ()\n"
"primitive primFreeze   \"IOFreeze\"\n"
"          :: IOArray a b -> IO (Array a b)\n"
"primitive primBounds   \"IOBounds\"\n"
"          :: IOArray a b -> (a,a)\n"
"primitive eqIOArray    \"IOArrEq\"\n"
"          :: IOArray a b -> IOArray a b -> Bool\n"
"\n"
"-----------------------------------------------------------------------------\n";
const char *Hugs_Weak = "-- A first cut at implementing the (key,value) form of Weak pointers.\n"
"--\n"
"-- Notes (please refer to the draft specification for background):\n"
"--\n"
"--  - Programmers using weak pointers should call runFinalizer at\n"
"--    regular intervals to ensure that finalizers are scheduled for\n"
"--    execution.  This implementation provides functions runFinalizer,\n"
"--    finalizerWaiting, and runAllFinalizers to provide programmers with\n"
"--    control over the execution of finalizers.  None of these functions\n"
"--    are part of the current specification.\n"
"--\n"
"-- Tested with Hugs 98.\n"
"\n"
"module Hugs.Weak(Weak,\n"
"	    mkWeak, deRefWeak, finalize, replaceFinalizer,\n"
"	    runFinalizer, finalizerWaiting, runAllFinalizers ) where\n"
"\n"
"data Weak a\n"
"\n"
"primitive mkWeak    :: k -> v -> Maybe (IO ()) -> IO (Weak v)\n"
"primitive deRefWeak :: Weak v -> IO (Maybe v)\n"
"primitive replaceFinalizer :: Weak v -> Maybe (IO ()) -> IO (Maybe (IO ()))\n"
"primitive finalize  :: Weak v -> IO ()\n"
"primitive weakPtrEq :: Weak a -> Weak a -> Bool\n"
"\n"
"instance Eq (Weak a) where\n"
"  (==) = weakPtrEq\n"
"\n"
"primitive runFinalizer     :: IO ()\n"
"primitive finalizerWaiting :: IO Bool\n"
"\n"
"runAllFinalizers    :: IO ()\n"
"runAllFinalizers     = do waiting <- finalizerWaiting\n"
"			  if waiting then do runFinalizer\n"
"					     runAllFinalizers\n"
"				     else return ()\n"
"\n"
"{- for testing purposes\n"
"primitive gc \"primGC\" :: IO ()\n"
"\n"
"-- not a CAF!\n"
"test z = do\n"
"  { let k = [z]		-- use a list so we're sure it's heap allocated\n"
"  ; print k		-- this makes sure x is in whnf\n"
"  ; w <- mkWeak k \"value\" (Just (putStrLn (\"Finalizer for \"++show k)))\n"
"			-- note that the finalizer uses the key, but\n"
"			-- this shouldn't keep the weak ptr alive!\n"
"  ; showWeakPtr w\n"
"  ; gc\n"
"  ; print k		-- this makes sure k is still alive after the GC\n"
"  ; showWeakPtr w	-- so it's probably still alive here\n"
"  ; gc\n"
"  ; showWeakPtr w	-- but ought to be dead by here\n"
"  }\n"
"\n"
"showWeakPtr :: Show a => Weak a -> IO ()\n"
"showWeakPtr w = do\n"
"  { x <- deRefWeak w\n"
"  ; print x\n"
"  }\n"
"\n"
"-}\n"
"\n"
"-- End of module Weak\n";
const char *Hugs_IO = "-----------------------------------------------------------------------------\n"
"-- Standard Library: IO operations, beyond those included in the prelude\n"
"--\n"
"-- Suitable for use with Hugs 98\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.IO (\n"
"    Handle,          -- instances: Eq, Show.\n"
"    HandlePosn,      -- instances: Eq, Show.\n"
"    \n"
"    IOMode(ReadMode,WriteMode,AppendMode,ReadWriteMode),\n"
"    BufferMode(NoBuffering,LineBuffering,BlockBuffering),\n"
"    SeekMode(AbsoluteSeek,RelativeSeek,SeekFromEnd),\n"
"    \n"
"    stdin, stdout, stderr,  -- :: Handle\n"
"    openFile,		    -- :: FilePath -> IOMode -> IO Handle\n"
"    hClose, 		    -- :: Handle -> IO ()\n"
"\n"
"    hFileSize,		    -- :: Handle -> IO Integer\n"
"\n"
"    hIsEOF,                 -- :: Handle -> IO Bool\n"
"    isEOF,                  -- :: IO Bool\n"
"\n"
"    hSetBuffering,          -- :: Handle -> BufferMode -> IO ()\n"
"    hGetBuffering,          -- :: Handle -> IO BufferMode\n"
"\n"
"    hFlush,                 -- :: Handle -> IO ()\n"
"    hGetPosn,		    -- :: Handle -> IO HandlePosn\n"
"    hSetPosn,               -- :: HandlePosn -> IO ()\n"
"    hSeek,                  -- :: Handle -> SeekMode -> Integer -> IO ()\n"
"    hTell,                  -- :: Handle -> IO Integer\n"
"\n"
"    hLookAhead,             -- :: Handle -> IO Char\n"
"\n"
"    hWaitForInput,          -- :: Handle -> Int -> IO Bool\n"
"\n"
"    hGetChar,               -- :: Handle -> IO Char\n"
"    hGetLine,               -- :: Handle -> IO String\n"
"    hGetContents,           -- :: Handle -> IO String\n"
"\n"
"    hPutChar,               -- :: Handle -> Char -> IO ()\n"
"    hPutStr,                -- :: Handle -> String -> IO ()\n"
"\n"
"    hIsOpen,		    -- :: Handle -> IO Bool\n"
"    hIsClosed,		    -- :: Handle -> IO Bool\n"
"    hIsReadable,            -- :: Handle -> IO Bool\n"
"    hIsWritable,            -- :: Handle -> IO Bool\n"
"    hIsSeekable,            -- :: Handle -> IO Bool\n"
"\n"
"    -- Non-standard extensions \n"
"    handleToFd,             -- :: Handle -> IO Int\n"
"    openFd                  -- :: Int -> Bool -> IOMode -> Bool -> IO Handle\n"
"    ) where\n"
"\n"
"import Hugs.Prelude	( Handle )\n"
"import Hugs.Prelude	( Ix(..) )\n"
"import System.IO.Error\n"
"\n"
"-- data Handle\n"
"\n"
"data IOMode      =  ReadMode | WriteMode | AppendMode | ReadWriteMode\n"
"                    deriving (Eq, Ord, Ix, Bounded, Enum, Read, Show)\n"
"data BufferMode  =  NoBuffering | LineBuffering \n"
"                 |  BlockBuffering (Maybe Int)\n"
"                    deriving (Eq, Ord, Read, Show)\n"
"data SeekMode    =  AbsoluteSeek | RelativeSeek | SeekFromEnd\n"
"                    deriving (Eq, Ord, Ix, Bounded, Enum, Read, Show)\n"
"\n"
"primitive stdin       :: Handle\n"
"primitive stdout      :: Handle\n"
"primitive stderr      :: Handle\n"
"primitive openFile    :: FilePath -> IOMode -> IO Handle\n"
"primitive hClose      :: Handle -> IO ()\n"
"\n"
"primitive hFileSize   :: Handle -> IO Integer\n"
"\n"
"primitive hIsEOF      :: Handle -> IO Bool\n"
"\n"
"isEOF               :: IO Bool\n"
"isEOF                = hIsEOF stdin\n"
"\n"
"hSetBuffering       :: Handle  -> BufferMode -> IO ()\n"
"hSetBuffering h bMode = \n"
"  case bMode of\n"
"    NoBuffering   -> hSetBuff h 0 0\n"
"    LineBuffering -> hSetBuff h 1 0\n"
"    BlockBuffering (Just x) -> hSetBuff h 2 x\n"
"    BlockBuffering _        -> hSetBuff h 2 0\n"
"\n"
"primitive hSetBuff  :: Handle -> Int -> Int -> IO ()\n"
"\n"
"hGetBuffering       :: Handle  -> IO BufferMode\n"
"hGetBuffering h = do\n"
"  (k, sz) <- hGetBuff h\n"
"  case k of\n"
"    1 -> return NoBuffering\n"
"    2 -> return LineBuffering\n"
"    3 -> return (BlockBuffering (Just sz))\n"
"     -- fatal - never to happen.\n"
"    _ -> error \"IO.hGetBuffering: unknown buffering mode\"\n"
"\n"
"primitive hGetBuff :: Handle -> IO (Int,Int)\n"
"\n"
"primitive hFlush   :: Handle -> IO ()\n"
"\n"
"data HandlePosn = HandlePosn Handle Int deriving Eq\n"
"\n"
"instance Show HandlePosn where\n"
"   showsPrec p (HandlePosn h pos) = \n"
"        showsPrec p h . showString \" at position \" . shows pos\n"
"\n"
"hGetPosn :: Handle -> IO HandlePosn\n"
"hGetPosn h = do\n"
"  p <- hGetPosnPrim h\n"
"  return (HandlePosn h p)\n"
"\n"
"hTell :: Handle -> IO Integer\n"
"hTell h = do\n"
"  p <- hGetPosnPrim h\n"
"  return (toInteger p)\n"
"\n"
"primitive hGetPosnPrim :: Handle -> IO Int\n"
"\n"
"hSetPosn :: HandlePosn -> IO ()\n"
"hSetPosn (HandlePosn h p) = hSetPosnPrim h p\n"
"\n"
"primitive hSetPosnPrim  :: Handle -> Int -> IO () \n"
"\n"
"hSeek :: Handle -> SeekMode -> Integer -> IO () \n"
"hSeek h sMode int \n"
" | int >  fromIntegral (maxBound :: Int) ||\n"
"   int <  fromIntegral (minBound :: Int) =\n"
"   ioError (userError (\"IO.hSeek: seek offset out of supported range\"))\n"
" | otherwise = \n"
"   hSeekPrim h (fromEnum sMode) ((fromIntegral int)::Int)\n"
"  \n"
"primitive hSeekPrim :: Handle -> Int -> Int -> IO () \n"
"\n"
"primitive hWaitForInput :: Handle -> Int -> IO Bool\n"
"\n"
"primitive hGetChar    :: Handle -> IO Char\n"
"\n"
"hGetLine   :: Handle -> IO String\n"
"hGetLine h = do\n"
"  c <- hGetChar h\n"
"  if c=='\\n'\n"
"   then return \"\"\n"
"   else do\n"
"     ls <- getRest \n"
"     return (c:ls)\n"
"  where\n"
"   getRest = do\n"
"     c <- catch (hGetChar h)\n"
"                (\\ ex -> if isEOFError ex then \n"
"			    return '\\n'\n"
"			 else\n"
"			    ioError ex)\n"
"     if c=='\\n'\n"
"      then return \"\"\n"
"      else do\n"
"       cs <- getRest \n"
"       return (c:cs)\n"
"\n"
"\n"
"primitive hLookAhead    :: Handle -> IO Char\n"
"primitive hGetContents  :: Handle -> IO String\n"
"primitive hPutChar      :: Handle -> Char -> IO ()\n"
"primitive hPutStr       :: Handle -> String -> IO ()\n"
"\n"
"primitive hIsOpen,    \n"
"   	  hIsClosed,  \n"
"   	  hIsReadable,\n"
"   	  hIsWritable,\n"
"	  hIsSeekable :: Handle -> IO Bool\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- Extract the file descriptor from a Handle, closing the Handle\n"
"primitive handleToFd :: Handle -> IO Int\n"
"\n"
"--\n"
"-- Creating a handle from a file descriptor/socket.\n"
"--\n"
"primitive openFd    :: Int    -- file descriptor\n"
"		    -> Bool   -- True => it's a socket.\n"
"		    -> IOMode -- what mode to open the handle in.\n"
"		    -> Bool   -- binary?\n"
"		    -> IO Handle\n";
const char *Hugs_Array = "-----------------------------------------------------------------------------\n"
"-- Standard Library: Array operations\n"
"--\n"
"-- Suitable for use with Hugs 98\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.Array ( \n"
"    module Data.Ix,  -- export all of Ix \n"
"    unsafeIndex, unsafeRangeSize,\n"
"\n"
"    Array, array, listArray, (!), bounds, indices, elems, assocs, \n"
"    accumArray, (//), accum, ixmap,\n"
"    unsafeArray, unsafeAt, unsafeReplace, unsafeAccum, unsafeAccumArray\n"
"    ) where\n"
"\n"
"import Data.Ix\n"
"import Hugs.Prelude( unsafeIndex, unsafeRangeSize )\n"
"\n"
"infixl 9  !, //\n"
"\n"
"data Array a b -- Arrays are implemented as a primitive type\n"
"\n"
"array          :: Ix a => (a,a) -> [(a,b)] -> Array a b\n"
"listArray      :: Ix a => (a,a) -> [b] -> Array a b\n"
"(!)	       :: Ix a => Array a b -> a -> b\n"
"bounds         :: Ix a => Array a b -> (a,a)\n"
"indices        :: Ix a => Array a b -> [a]\n"
"elems          :: Ix a => Array a b -> [b]\n"
"assocs	       :: Ix a => Array a b -> [(a,b)]\n"
"(//)           :: Ix a => Array a b -> [(a,b)] -> Array a b\n"
"accum          :: Ix a => (b -> c -> b) -> Array a b -> [(a,c)] -> Array a b\n"
"accumArray     :: Ix a => (b -> c -> b) -> b -> (a,a) -> [(a,c)] -> Array a b\n"
"ixmap	       :: (Ix a, Ix b) => (a,a) -> (a -> b) -> Array b c -> Array a c\n"
"\n"
"primitive primArray :: (a,a) -> Int -> [(Int,b)] -> Array a b\n"
"primitive primUpdate :: [(Int,b)] -> Array a b -> Array a b\n"
"primitive primAccum :: [(Int,c)] -> Array a b -> (b -> c -> b) -> Array a b\n"
"primitive primAccumArray\n"
"    :: (a,a) -> Int -> (b -> c -> b) -> b -> [(Int,c)] -> Array a b\n"
"primitive primSubscript :: Array a b -> Int -> b\n"
"\n"
"primitive primBounds :: Array a b -> (a,a)\n"
"primitive primElems  :: Array a b -> [b]\n"
"primitive primAmap   :: (b -> c) -> Array a b -> Array a c\n"
"\n"
"unsafeArray :: Ix i => (i,i) -> [(Int, e)] -> Array i e\n"
"unsafeArray bnds	= primArray bnds (rangeSize bnds)\n"
"\n"
"unsafeAt :: Ix i => Array i e -> Int -> e\n"
"unsafeAt		= primSubscript\n"
"\n"
"unsafeReplace :: Ix i => Array i e -> [(Int, e)] -> Array i e\n"
"unsafeReplace iarr ies	= primUpdate ies iarr\n"
"\n"
"unsafeAccum :: Ix i => (e -> a -> e) -> Array i e -> [(Int, a)] -> Array i e\n"
"unsafeAccum f iarr ies	= primAccum ies iarr f\n"
"\n"
"unsafeAccumArray :: Ix i => (e -> a -> e) -> e -> (i,i) -> [(Int, a)] -> Array i e\n"
"unsafeAccumArray f z bnds = primAccumArray bnds (rangeSize bnds) f z\n"
"\n"
"indexAll :: Ix i => (i,i) -> [(i, a)] -> [(Int, a)]\n"
"indexAll bnds ivs = [(index bnds i,v) | (i,v) <- ivs]\n"
"\n"
"array bnds          = unsafeArray bnds . indexAll bnds\n"
"listArray bnds vs   = unsafeArray bnds (zip [0..rangeSize bnds-1] vs)\n"
"arr!i               = unsafeAt arr (index (bounds arr) i)\n"
"bounds              = primBounds\n"
"indices	            = range . bounds\n"
"elems               = primElems\n"
"assocs a            = zip (indices a) (elems a)\n"
"accumArray f z bnds = unsafeAccumArray f z bnds . indexAll bnds\n"
"a // ivs            = unsafeReplace a (indexAll (bounds a) ivs)\n"
"accum f a ivs       = unsafeAccum f a (indexAll (bounds a) ivs)\n"
"ixmap bnds f arr =\n"
"    unsafeArray bnds [(unsafeIndex bnds i, arr ! f i) | i <- range bnds]\n"
"\n"
"instance (Ix a) => Functor (Array a) where\n"
"    fmap = primAmap\n"
"\n"
"instance (Ix a, Eq b) => Eq (Array a b) where\n"
"    a == a'   =   assocs a == assocs a'\n"
"\n"
"instance (Ix a, Ord b) => Ord (Array a b) where\n"
"    a <= a'   =   assocs a <= assocs a'\n"
"\n"
"instance  (Ix a, Show a, Show b) => Show (Array a b)  where\n"
"    showsPrec p a = showParen (p > 9) (\n"
"		    showString \"array \" .\n"
"		    shows (bounds a) . showChar ' ' .\n"
"		    shows (assocs a)                  )\n"
"\n"
"instance  (Ix a, Read a, Read b) => Read (Array a b)  where\n"
"    readsPrec p = readParen (p > 9)\n"
"	     (\\r -> [(array b as, u) | (\"array\",s) <- lex r,\n"
"				       (b,t)       <- reads s,\n"
"				       (as,u)      <- reads t   ])\n"
"\n"
"-----------------------------------------------------------------------------\n";
const char *Hugs_Directory = "--\n"
"-- Hugs98 implementation of the Haskell 98 module, Directory.\n"
"--\n"
"module Hugs.Directory\n"
"	( Permissions ( readable     -- :: Permissions -> Bool\n"
"	              , writable     -- :: Permissions -> Bool\n"
"		      , executable   -- :: Permissions -> Bool\n"
"		      , searchable   -- :: Permissions -> Bool\n"
"		      )\n"
"	   -- instances: Eq, Ord, Read, Show\n"
"	, createDirectory	     -- :: FilePath -> IO ()\n"
"\n"
"	, removeDirectory            -- :: FilePath -> IO ()\n"
"	, removeFile                 -- :: FilePath -> IO ()\n"
"\n"
"	, renameDirectory            -- :: FilePath -> FilePath -> IO ()\n"
"	, renameFile		     -- :: FilePath -> FilePath -> IO ()\n"
"\n"
"	, getDirectoryContents       -- :: FilePath -> IO [FilePath]\n"
"\n"
"	, getCurrentDirectory        -- :: IO FilePath\n"
"	, setCurrentDirectory        -- :: FilePath -> IO ()\n"
"\n"
"	, doesFileExist	             -- :: FilePath -> IO Bool\n"
"	, doesDirectoryExist	     -- :: FilePath -> IO Bool\n"
"\n"
"	, getPermissions	     -- :: FilePath -> IO Permissions\n"
"	, setPermissions	     -- :: FilePath -> Permissions -> IO ()\n"
"\n"
"	, getModificationTime 	     -- :: FilePath -> IO ClockTime\n"
"	) where\n"
"\n"
"import System.Time ( ClockTime(..) )\n"
"\n"
"data Permissions\n"
" = Permissions \n"
"   { readable     :: Bool\n"
"   , writable     :: Bool\n"
"   , executable   :: Bool\n"
"   , searchable   :: Bool\n"
"   } deriving (Eq, Ord, Read, Show)\n"
"\n"
"{-\n"
" This module is really just a wrapper for various directory\n"
" and file-related system calls.\n"
"-}\n"
"primitive createDirectory :: FilePath -> IO ()\n"
"\n"
"primitive removeFile :: FilePath -> IO ()\n"
"primitive removeDirectory :: FilePath -> IO ()\n"
"\n"
"primitive renameFile :: FilePath -> FilePath -> IO ()\n"
"primitive renameDirectory :: FilePath -> FilePath -> IO ()\n"
"\n"
"primitive setCurrentDirectory :: FilePath -> IO ()\n"
"primitive getCurrentDirectory :: IO FilePath\n"
"\n"
"primitive doesDirectoryExist :: FilePath -> IO Bool\n"
"primitive doesFileExist :: FilePath -> IO Bool\n"
"\n"
"getPermissions :: FilePath -> IO Permissions\n"
"getPermissions fpath = do\n"
"    (r,w,e,s) <- getPerms fpath\n"
"    return (Permissions{readable=r,writable=w,executable=e,searchable=s})\n"
"\n"
"setPermissions :: FilePath -> Permissions -> IO ()\n"
"setPermissions fpath perms = \n"
"  setPerms fpath (readable perms)\n"
"  		 (writable perms)\n"
"		 (executable perms)\n"
"		 (searchable perms)\n"
"\n"
"primitive getPerms :: FilePath -> IO (Bool,Bool,Bool,Bool)\n"
"primitive setPerms :: FilePath -> Bool -> Bool -> Bool -> Bool -> IO ()\n"
"\n"
"getDirectoryContents :: FilePath -> IO [FilePath]\n"
"getDirectoryContents fpath = do\n"
"  ls <- getDirContents fpath\n"
"    -- it is easiest for the primitive to create the\n"
"    -- list of entries in the order in which they're\n"
"    -- read, so the resulting list will be back to front.\n"
"    -- Hence, list reversal is needed.\n"
"  return (reverse ls)\n"
"\n"
"primitive getDirContents :: FilePath -> IO [FilePath]\n"
"\n"
"getModificationTime :: FilePath -> IO ClockTime\n"
"getModificationTime fPath = do\n"
"  x <- getModTime fPath\n"
"  return (TOD (fromIntegral x) 0)\n"
"\n"
"primitive getModTime :: FilePath -> IO Int\n";
const char *Hugs_ConcBase = "-----------------------------------------------------------------------------\n"
"-- This implements Concurrent Haskell's \"MVar\"s as described in the paper\n"
"--\n"
"--   \"Concurrent Haskell\"\n"
"--   Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne.\n"
"--   In Proceedings of the ACM Symposium on Principles of Programming\n"
"--   Languages,St Petersburg Beach, Florida, January 1996. \n"
"--   http://www.dcs.gla.ac.uk/fp/authors/Simon_Peyton_Jones/\n"
"--     concurrent-haskell.ps\n"
"--\n"
"-- except that we have made the following name changes for compatability\n"
"-- with GHC 2.05.\n"
"--\n"
"--   newMVar  -> newEmptyMVar\n"
"--\n"
"-- There is one significant difference between this implementation and\n"
"-- GHC 2.05: \n"
"--\n"
"-- o GHC uses preemptive multitasking.\n"
"-- \n"
"--   Context switches can occur at any time (except if you call a C\n"
"--   function (like \"getchar\") which blocks the entire process while\n"
"--   waiting for input.\n"
"-- \n"
"-- o Hugs uses cooperative multitasking.  \n"
"-- \n"
"--   Context switches only occur when you use one of the primitives\n"
"--   defined in this module.  This means that programs such as:\n"
"-- \n"
"--     main = forkIO (write 'a') >> write 'b'\n"
"-- 	where\n"
"-- 	 write c = putChar c >> write c\n"
"-- \n"
"--   will print either \"aaaaaaaaaaaaaa...\" or \"bbbbbbbbbbbb...\"\n"
"--   instead of some random interleaving of 'a's and 'b's.\n"
"-- \n"
"-- Cooperative multitasking is sufficient for writing coroutines and simple\n"
"-- graphical user interfaces but the usual assumptions of fairness don't\n"
"-- apply and Channel.getChanContents cannot be implemented.\n"
"-----------------------------------------------------------------------------\n"
"module Hugs.ConcBase(\n"
"	forkIO,\n"
"	MVar,\n"
"	newEmptyMVar, newMVar, takeMVar, tryTakeMVar, putMVar, tryPutMVar,\n"
"	isEmptyMVar,\n"
"        yield\n"
"	) where\n"
"\n"
"import Hugs.Prelude(\n"
"	IO(..), IOResult(..), threadToIOResult,\n"
"	Exception(..), catchException, blockIO)\n"
"import Hugs.IORef\n"
"\n"
"----------------------------------------------------------------\n"
"-- The interface\n"
"----------------------------------------------------------------\n"
"\n"
"forkIO       :: IO () -> IO () -- Spawn a thread\n"
"yield        :: IO ()\n"
"\n"
"newEmptyMVar :: IO (MVar a)\n"
"newMVar      :: a -> IO (MVar a)\n"
"takeMVar     :: MVar a -> IO a\n"
"putMVar      :: MVar a -> a -> IO ()\n"
"tryPutMVar   :: MVar a -> a -> IO Bool\n"
"tryTakeMVar  :: MVar a -> IO (Maybe a)\n"
"\n"
"isEmptyMVar :: MVar a -> IO Bool\n"
"\n"
"----------------------------------------------------------------\n"
"-- Implementation\n"
"----------------------------------------------------------------\n"
"\n"
"kill :: IO a\n"
"kill = IO (\\ s -> Hugs_DeadThread)\n"
"\n"
"yield = IO (\\ s -> Hugs_YieldThread (s ()))\n"
"\n"
"-- add the continuation to the runnable list, and continue\n"
"continueIO :: IOResult -> IO ()\n"
"continueIO cc = IO (\\ s -> Hugs_ForkThread (s ()) cc)\n"
"\n"
"-- The thread is scheduled immediately and runs with its own success/error\n"
"-- continuations.\n"
"forkIO m = continueIO (threadToIOResult (m `catchException` forkExnHandler))\n"
"\n"
"forkExnHandler :: Exception -> IO a\n"
"forkExnHandler e = do\n"
"    putStr \"\\nThread raised exception: \"\n"
"    putStr (show e)\n"
"    putStr \"\\n\"           \n"
"    kill\n"
"\n"
"newtype MVar a = MkMVar (IORef (MVarState a)) deriving Eq\n"
"data MVarState a\n"
"  = Full a [(a,()->IOResult)]\n"
"	-- a value and a list of value-thread pairs blocked waiting\n"
"	-- to write to the MVar.\n"
"	-- The ()-> part of the thread is because blocked threads have\n"
"	-- to be functions. :-(\n"
"  | Empty [a -> IOResult]\n"
"	-- no value, just a list of threads waiting to receive a value\n"
"\n"
"newEmptyMVar = fmap MkMVar (newIORef (Empty []))\n"
"\n"
"newMVar x    = fmap MkMVar (newIORef (Full x []))\n"
"\n"
"takeMVar (MkMVar v) = do\n"
"  state <- readIORef v\n"
"  case state of\n"
"    Full a [] -> do\n"
"      writeIORef v (Empty [])\n"
"      return a\n"
"    Full a ((a',t):ts) -> do\n"
"      writeIORef v (Full a' ts)\n"
"      continueIO (t ())		-- reschedule t\n"
"      return a\n"
"    Empty cs ->\n"
"      blockIO (\\cc -> writeIORef v (Empty (cs ++ [cc])))\n"
"\n"
"-- tryTakeMVar is a non-blocking takeMVar\n"
"tryTakeMVar (MkMVar v) = do\n"
"  state <- readIORef v\n"
"  case state of\n"
"    Full a [] -> do\n"
"      writeIORef v (Empty [])\n"
"      return (Just a)\n"
"    Full a ((a',t):ts) -> do\n"
"      writeIORef v (Full a' ts)\n"
"      continueIO (t ())		-- reschedule t\n"
"      return (Just a)\n"
"    Empty cs ->\n"
"      return Nothing\n"
"\n"
"putMVar (MkMVar v) a = do\n"
"  state <- readIORef v\n"
"  case state of\n"
"    Full a' ts ->\n"
"      blockIO (\\cc -> writeIORef v (Full a' (ts++[(a,cc)])))\n"
"    Empty [] ->\n"
"      writeIORef v (Full a [])\n"
"    Empty (c:cs) -> do\n"
"      writeIORef v (Empty cs)\n"
"      continueIO (c a)		-- reschedule the blocked thread\n"
"\n"
"tryPutMVar (MkMVar v) a = do\n"
"  state <- readIORef v\n"
"  case state of\n"
"    Full _ _ ->\n"
"      return False\n"
"    Empty [] -> do\n"
"      writeIORef v (Full a [])\n"
"      return True\n"
"    Empty (c:cs) -> do\n"
"      writeIORef v (Empty cs)\n"
"      continueIO (c a)		-- reschedule the blocked thread\n"
"      return True\n"
"\n"
"{- \n"
" Low-level op. for checking whether an MVar is filled-in or not.\n"
" Notice that the boolean value returned  is just a snapshot of\n"
" the state of the MVar. By the time you get to react on its result,\n"
" the MVar may have been filled (or emptied) - so be extremely\n"
" careful when using this operation.  \n"
"\n"
" Use tryTakeMVar instead if possible.\n"
"\n"
" If you can re-work your abstractions to avoid having to\n"
" depend on isEmptyMVar, then you're encouraged to do so,\n"
" i.e., consider yourself warned about the imprecision in\n"
" general of isEmptyMVar :-)\n"
"-}\n"
"isEmptyMVar (MkMVar v) = do\n"
"  state <- readIORef v\n"
"  case state of\n"
"    Full _ _ -> return False\n"
"    Empty _  -> return True\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n";
const char *Hugs_Bits = "module Hugs.Bits where\n"
"\n"
"primitive primAndInt        :: Int -> Int -> Int\n"
"primitive primOrInt         :: Int -> Int -> Int\n"
"primitive primXorInt        :: Int -> Int -> Int\n"
"primitive primComplementInt :: Int -> Int\n"
"primitive primShiftInt      :: Int -> Int -> Int\n"
"primitive primBitInt        :: Int -> Int\n"
"primitive primTestInt       :: Int -> Int -> Bool\n";
const char *Hugs_Int = "-----------------------------------------------------------------------------\n"
"-- Signed Integers\n"
"-- Suitable for use with Hugs 98 on 32 bit systems.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.Int\n"
"	( Int8\n"
"	, Int16\n"
"	, Int32\n"
"	, Int64\n"
"	-- plus Eq, Ord, Num, Bounded, Real, Integral, Ix, Enum, Read,\n"
"	--  Show and Bits instances for each of Int8, Int16 and Int32\n"
"	) where\n"
"\n"
"import Hugs.Prelude ( Int8, Int16, Int32, Int64 )\n"
"import Hugs.Prelude ( Ix(..) )\n"
"import Hugs.Prelude ( (%) )\n"
"import Hugs.Prelude ( readDec, showInt )\n"
"import Hugs.Prelude ( Num(fromInt), Integral(toInt) )\n"
"import Hugs.Bits\n"
"import Data.Bits\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- The \"official\" coercion functions\n"
"-----------------------------------------------------------------------------\n"
"\n"
"int8ToInt  :: Int8  -> Int  \n"
"intToInt8  :: Int   -> Int8 \n"
"int16ToInt :: Int16 -> Int  \n"
"intToInt16 :: Int   -> Int16\n"
"\n"
"int8ToInt  = int32ToInt   . int8ToInt32\n"
"intToInt8  = int32ToInt8  . intToInt32\n"
"int16ToInt = int32ToInt   . int16ToInt32\n"
"intToInt16 = int32ToInt16 . intToInt32  \n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Int8\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive int8ToInt32 \"primInt8ToInt32\" :: Int8 -> Int32\n"
"primitive int32ToInt8 \"primInt32ToInt8\" :: Int32 -> Int8\n"
"\n"
"instance Eq  Int8     where (==)    = binop (==)\n"
"instance Ord Int8     where compare = binop compare\n"
"\n"
"instance Num Int8 where\n"
"    x + y         = to (binop (+) x y)\n"
"    x - y         = to (binop (-) x y)\n"
"    negate        = to . negate . from\n"
"    x * y         = to (binop (*) x y)\n"
"    abs           = absReal\n"
"    signum        = signumReal\n"
"    fromInteger   = to . fromInteger\n"
"    fromInt       = intToInt8\n"
"\n"
"instance Bounded Int8 where\n"
"    minBound = 0x80\n"
"    maxBound = 0x7f \n"
"\n"
"instance Real Int8 where\n"
"    toRational x = toInteger x % 1\n"
"\n"
"instance Integral Int8 where\n"
"    x `div` y     = to  (binop div x y)\n"
"    x `quot` y    = to  (binop quot x y)\n"
"    x `rem` y     = to  (binop rem x y)\n"
"    x `mod` y     = to  (binop mod x y)\n"
"    x `quotRem` y = to2 (binop quotRem x y)\n"
"    toInteger     = toInteger . from\n"
"    toInt         = int8ToInt\n"
"\n"
"instance Ix Int8 where\n"
"    range (m,n)          = [m..n]\n"
"    index b@(m,n) i\n"
"	      | inRange b i = toInt (i - m)\n"
"	      | otherwise   = error \"index: Index out of range\"\n"
"    inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Int8 where\n"
"    toEnum           = fromInt\n"
"    fromEnum         = toInt\n"
"    enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Int8)]\n"
"    enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (last::Int8)]\n"
"			  where last = if d < c then minBound else maxBound\n"
"\n"
"instance Read Int8 where\n"
"    readsPrec p s = [ (to x,r) | (x,r) <- readsPrec p s ]\n"
"\n"
"instance Show Int8 where\n"
"    showsPrec p = showsPrec p . from\n"
"\n"
"binop8 :: (Int32 -> Int32 -> a) -> (Int8 -> Int8 -> a)\n"
"binop8 op x y = int8ToInt32 x `op` int8ToInt32 y\n"
"\n"
"instance Bits Int8 where\n"
"  x .&. y       = int32ToInt8 (binop8 (.&.) x y)\n"
"  x .|. y       = int32ToInt8 (binop8 (.|.) x y)\n"
"  x `xor` y     = int32ToInt8 (binop8 xor x y)\n"
"  complement    = int32ToInt8 . complement . int8ToInt32\n"
"  x `shift` i   = int32ToInt8 (int8ToInt32 x `shift` i)\n"
"  rotate        = rotateSigned\n"
"  bit           = int32ToInt8 . bit\n"
"  setBit x i    = int32ToInt8 (setBit (int8ToInt32 x) i)\n"
"  clearBit x i  = int32ToInt8 (clearBit (int8ToInt32 x) i)\n"
"  complementBit x i = int32ToInt8 (complementBit (int8ToInt32 x) i)\n"
"  testBit x i   = testBit (int8ToInt32 x) i\n"
"  bitSize  _    = 8\n"
"  isSigned _    = True\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Int16\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive int16ToInt32 \"primInt16ToInt32\" :: Int16 -> Int32\n"
"primitive int32ToInt16 \"primInt32ToInt16\" :: Int32 -> Int16\n"
"\n"
"instance Eq  Int16     where (==)    = binop (==)\n"
"instance Ord Int16     where compare = binop compare\n"
"\n"
"instance Num Int16 where\n"
"    x + y         = to (binop (+) x y)\n"
"    x - y         = to (binop (-) x y)\n"
"    negate        = to . negate . from\n"
"    x * y         = to (binop (*) x y)\n"
"    abs           = absReal\n"
"    signum        = signumReal\n"
"    fromInteger   = to . fromInteger\n"
"    fromInt       = intToInt16\n"
"\n"
"instance Bounded Int16 where\n"
"    minBound = 0x8000\n"
"    maxBound = 0x7fff \n"
"\n"
"instance Real Int16 where\n"
"    toRational x = toInteger x % 1\n"
"\n"
"instance Integral Int16 where\n"
"    x `div` y     = to  (binop div x y)\n"
"    x `quot` y    = to  (binop quot x y)\n"
"    x `rem` y     = to  (binop rem x y)\n"
"    x `mod` y     = to  (binop mod x y)\n"
"    x `quotRem` y = to2 (binop quotRem x y)\n"
"    toInteger     = toInteger . from\n"
"    toInt         = int16ToInt\n"
"\n"
"instance Ix Int16 where\n"
"    range (m,n)          = [m..n]\n"
"    index b@(m,n) i\n"
"	      | inRange b i = toInt (i - m)\n"
"	      | otherwise   = error \"index: Index out of range\"\n"
"    inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Int16 where\n"
"    toEnum           = fromInt \n"
"    fromEnum         = toInt\n"
"    enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Int16)]\n"
"    enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (last::Int16)]\n"
"			  where last = if d < c then minBound else maxBound\n"
"\n"
"instance Read Int16 where\n"
"    readsPrec p s = [ (to x,r) | (x,r) <- readsPrec p s ]\n"
"\n"
"instance Show Int16 where\n"
"    showsPrec p = showsPrec p . from\n"
"\n"
"binop16 :: (Int32 -> Int32 -> a) -> (Int16 -> Int16 -> a)\n"
"binop16 op x y = int16ToInt32 x `op` int16ToInt32 y\n"
"\n"
"instance Bits Int16 where\n"
"  x .&. y       = int32ToInt16 (binop16 (.&.) x y)\n"
"  x .|. y       = int32ToInt16 (binop16 (.|.) x y)\n"
"  x `xor` y     = int32ToInt16 (binop16 xor x y)\n"
"  complement    = int32ToInt16 . complement . int16ToInt32\n"
"  x `shift` i   = int32ToInt16 (int16ToInt32 x `shift` i)\n"
"  rotate        = rotateSigned\n"
"  bit           = int32ToInt16 . bit\n"
"  setBit x i    = int32ToInt16 (setBit (int16ToInt32 x) i)\n"
"  clearBit x i  = int32ToInt16 (clearBit (int16ToInt32 x) i)\n"
"  complementBit x i = int32ToInt16 (complementBit (int16ToInt32 x) i)\n"
"  testBit x i   = testBit (int16ToInt32 x) i\n"
"  bitSize  _    = 16\n"
"  isSigned _    = True\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Int32\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive int32ToInt \"primInt32ToInt\" :: Int32 -> Int\n"
"primitive intToInt32 \"primIntToInt32\" :: Int -> Int32\n"
"primitive primEqInt32  :: Int32 -> Int32 -> Bool\n"
"primitive primCmpInt32 :: Int32 -> Int32 -> Ordering\n"
"\n"
"instance Eq  Int32 where (==)    = primEqInt32\n"
"instance Ord Int32 where compare = primCmpInt32\n"
"\n"
"instance Num Int32 where\n"
"    x + y         = intToInt32 (binop32 (+) x y)\n"
"    x - y         = intToInt32 (binop32 (-) x y)\n"
"    negate        = intToInt32 . negate . int32ToInt\n"
"    x * y         = intToInt32 (binop32 (*) x y)\n"
"    abs           = absReal\n"
"    signum        = signumReal\n"
"    fromInteger   = intToInt32 . fromInteger\n"
"    fromInt       = intToInt32\n"
"\n"
"instance Bounded Int32 where\n"
"    minBound = intToInt32 minBound\n"
"    maxBound = intToInt32 maxBound\n"
"\n"
"instance Real Int32 where\n"
"    toRational x = toInteger x % 1\n"
"\n"
"instance Integral Int32 where\n"
"    x `div` y     = intToInt32 (binop32 div x y)\n"
"    x `quot` y    = intToInt32 (binop32 quot x y)\n"
"    x `rem` y     = intToInt32 (binop32 rem x y)\n"
"    x `mod` y     = intToInt32 (binop32 mod x y)\n"
"    x `quotRem` y = to2' (binop32 quotRem x y)\n"
"    toInteger     = toInteger . int32ToInt\n"
"    toInt         = int32ToInt\n"
"\n"
"instance Ix Int32 where\n"
"    range (m,n)          = [m..n]\n"
"    index b@(m,n) i\n"
"	      | inRange b i = toInt (i - m)\n"
"	      | otherwise   = error \"index: Index out of range\"\n"
"    inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Int32 where\n"
"    toEnum           = fromInt\n"
"    fromEnum         = toInt\n"
"    enumFrom c       = map toEnum [fromEnum c .. fromEnum (maxBound::Int32)]\n"
"    enumFromThen c d = map toEnum [fromEnum c, fromEnum d .. fromEnum (last::Int32)]\n"
"			  where last = if d < c then minBound else maxBound\n"
"\n"
"instance Read Int32 where\n"
"    readsPrec p s = [ (intToInt32 x,r) | (x,r) <- readsPrec p s ]\n"
"\n"
"instance Show Int32 where\n"
"    showsPrec p = showsPrec p . int32ToInt\n"
"\n"
"instance Bits Int32 where\n"
"    x .&. y       = intToInt32 (binop32 (.&.) x y)\n"
"    x .|. y       = intToInt32 (binop32 (.|.) x y)\n"
"    x `xor` y     = intToInt32 (binop32 xor x y)\n"
"    complement    = intToInt32 . complement . int32ToInt\n"
"    x `shift` i   = intToInt32 (int32ToInt x `shift` i)\n"
"    rotate        = rotateSigned\n"
"    bit           = intToInt32 . bit\n"
"    setBit x i    = intToInt32 (setBit (int32ToInt x) i)\n"
"    clearBit x i  = intToInt32 (clearBit (int32ToInt x) i)\n"
"    complementBit x i = intToInt32 (complementBit (int32ToInt x) i)\n"
"    testBit x i   = testBit (int32ToInt x) i\n"
"    bitSize  _    = 32\n"
"    isSigned _    = True\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Int64\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-- Assume a 2s-complement representation, and that this function\n"
"-- separates the top 32 bits from the lower 32.\n"
"\n"
"primitive int64ToInt32 \"primInt64ToInt32\" :: Int64 -> (Int32,Int32)\n"
"primitive int32ToInt64 \"primInt32ToInt64\" :: Int32 -> Int32 -> Int64\n"
"\n"
"integerToI64 :: Integer -> Int64\n"
"integerToI64 x = case x `divMod` 0x100000000 of\n"
"    (hi,lo) -> int32ToInt64 (fromInteger hi) (fromInteger lo)\n"
"\n"
"i64ToInteger :: Int64 -> Integer\n"
"i64ToInteger x = case int64ToInt32 x of\n"
"    (hi,lo) -> (if lo<0 then toInteger hi+1 else toInteger hi)*0x100000000 +\n"
"	toInteger lo\n"
"\n"
"instance Eq Int64 where\n"
"    x == y = int64ToInt32 x == int64ToInt32 y\n"
"\n"
"instance Ord Int64 where\n"
"    compare x y = compare (toInteger x) (toInteger y)\n"
"\n"
"instance Bounded Int64 where\n"
"    minBound = int32ToInt64 minBound 0\n"
"    maxBound = int32ToInt64 maxBound (-1)\n"
"\n"
"instance Show Int64 where\n"
"    showsPrec p = showsPrec p . toInteger\n"
"\n"
"instance Read Int64 where\n"
"    readsPrec p s = [ (fromInteger x,r) | (x,r) <- readDec s ]\n"
"\n"
"instance Num Int64 where\n"
"    x + y         = fromInteger (toInteger x + toInteger y)\n"
"    x - y         = fromInteger (toInteger x - toInteger y)\n"
"    x * y         = fromInteger (toInteger x * toInteger y)\n"
"    abs           = absReal\n"
"    signum        = signumReal\n"
"    fromInteger   = integerToI64\n"
"\n"
"instance Real Int64 where\n"
"    toRational x = toInteger x % 1\n"
"\n"
"instance Ix Int64 where\n"
"    range (m,n)          = [m..n]\n"
"    index b@(m,n) i\n"
"	      | inRange b i = toInt (i - m)\n"
"	      | otherwise   = error \"index: Index out of range\"\n"
"    inRange (m,n) i      = m <= i && i <= n\n"
"\n"
"instance Enum Int64 where\n"
"    toEnum           = fromInt\n"
"    fromEnum         = toInt\n"
"\n"
"    succ             = fromInteger . (+1) . toInteger\n"
"    pred             = fromInteger . (subtract 1) . toInteger\n"
"    enumFrom x       = map fromInteger [toInteger x ..]\n"
"    enumFromTo x y   = map fromInteger [toInteger x .. toInteger y]\n"
"    enumFromThen x y = map fromInteger [toInteger x, toInteger y ..]\n"
"    enumFromThenTo x y z =\n"
"                       map fromInteger [toInteger x, toInteger y .. toInteger z]\n"
"\n"
"instance Integral Int64 where\n"
"    x `quotRem` y = (fromInteger q, fromInteger r)\n"
"	where (q,r) = toInteger x `quotRem` toInteger y\n"
"    toInteger     = i64ToInteger\n"
"\n"
"instance Bits Int64 where\n"
"    x .&. y       = liftBinary (.&.) x y\n"
"    x .|. y       = liftBinary (.|.) x y\n"
"    x `xor` y     = liftBinary xor x y\n"
"    complement    = liftUnary complement\n"
"    x `shift` i   = fromInteger (toInteger x `shift` i)\n"
"    rotate        = rotateSigned\n"
"    bit i | i `mod` 64 < 32 = int32ToInt64 0 (bit i)\n"
"          | otherwise       = int32ToInt64 (bit i) 0\n"
"    bitSize  _    = 64\n"
"    isSigned _    = True\n"
"\n"
"liftBinary :: (Int32 -> Int32 -> Int32) -> Int64 -> Int64 -> Int64\n"
"liftBinary op x y = int32ToInt64 (op xhi yhi) (op xlo ylo)\n"
"	where	(xhi,xlo) = int64ToInt32 x\n"
"		(yhi,ylo) = int64ToInt32 y\n"
"\n"
"liftUnary :: (Int32 -> Int32) -> Int64 -> Int64\n"
"liftUnary op x = int32ToInt64 (op xhi) (op xlo)\n"
"	where	(xhi,xlo) = int64ToInt32 x\n"
"\n"
"rotateSigned :: (Bits a, Ord a) => a -> Int -> a\n"
"rotateSigned x i | i<0 && x<0\n"
"                        = let left = i+bitSize x in\n"
"                          ((x `shift` i) .&. complement ((-1) `shift` left))\n"
"                          .|. (x `shift` left)\n"
"                 | i<0  = (x `shift` i) .|. (x `shift` (i+bitSize x))\n"
"                 | i==0 = x\n"
"                 | i>0  = (x `shift` i) .|. (x `shift` (i-bitSize x))\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- End of exported definitions\n"
"--\n"
"-- The remainder of this file consists of definitions which are only\n"
"-- used in the implementation.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Coercions - used to make the instance declarations more uniform\n"
"-----------------------------------------------------------------------------\n"
"\n"
"class Coerce a where\n"
"  to   :: Int32 -> a\n"
"  from :: a -> Int32\n"
"\n"
"instance Coerce Int where\n"
"  from = intToInt32\n"
"  to   = int32ToInt\n"
"\n"
"instance Coerce Int8 where\n"
"  from = int8ToInt32\n"
"  to   = int32ToInt8\n"
"\n"
"instance Coerce Int16 where\n"
"  from = int16ToInt32\n"
"  to   = int32ToInt16\n"
"\n"
"binop :: Coerce int => (Int32 -> Int32 -> a) -> (int -> int -> a)\n"
"binop op x y = from x `op` from y\n"
"\n"
"to2 :: Coerce int => (Int32, Int32) -> (int, int)\n"
"to2 (x,y) = (to x, to y)\n"
"\n"
"to2' :: (Int, Int) -> (Int32, Int32)\n"
"to2' (x,y) = (intToInt32 x, intToInt32 y)\n"
"\n"
"binop32 :: (Int -> Int -> a) -> (Int32 -> Int32 -> a)\n"
"binop32 op x y = int32ToInt x `op` int32ToInt y\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Code copied from the Prelude\n"
"-----------------------------------------------------------------------------\n"
"\n"
"absReal x    | x >= 0    = x\n"
"	     | otherwise = -x\n"
"\n"
"signumReal x | x == 0    =  0\n"
"	     | x > 0     =  1\n"
"	     | otherwise = -1\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- End\n"
"-----------------------------------------------------------------------------\n";
const char *Hugs_Numeric = "-----------------------------------------------------------------------------\n"
"-- Standard Library: Numeric operations\n"
"--\n"
"-- Suitable for use with Hugs 98\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.Numeric\n"
"	( fromRat 	-- :: (RealFloat a) => Rational -> a\n"
"\n"
"	, showEFloat	-- :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
"	, showFFloat	-- :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
"	, showGFloat	-- :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
"	, showFloat	-- :: (RealFloat a) => a -> ShowS\n"
"\n"
"	, floatToDigits -- :: (RealFloat a) => Integer -> a -> ([Int], Int)\n"
"	) where\n"
"\n"
"import Data.Char   ( intToDigit )\n"
"import Data.Ratio  ( (%), numerator, denominator )\n"
"import Hugs.Array  ( (!), Array, array )\n"
"\n"
"-- This converts a rational to a floating.  This should be used in the\n"
"-- Fractional instances of Float and Double.\n"
"\n"
"fromRat :: (RealFloat a) => Rational -> a\n"
"fromRat x \n"
" | x == 0    = encodeFloat 0 0    -- Handle exceptional cases\n"
" | x < 0     = -fromRat' (-x)     -- first.\n"
" | otherwise = fromRat' x\n"
"\n"
"-- Conversion process:\n"
"-- Scale the rational number by the RealFloat base until\n"
"-- it lies in the range of the mantissa (as used by decodeFloat/encodeFloat).\n"
"-- Then round the rational to an Integer and encode it with the exponent\n"
"-- that we got from the scaling.\n"
"-- To speed up the scaling process we compute the log2 of the number to get\n"
"-- a first guess of the exponent.\n"
"fromRat' :: (RealFloat a) => Rational -> a\n"
"fromRat' x = r\n"
"  where b = floatRadix r\n"
"        p = floatDigits r\n"
"        (minExp0, _) = floatRange r\n"
"        minExp = minExp0 - p            -- the real minimum exponent\n"
"        xMin = toRational (expt b (p-1))\n"
"        xMax = toRational (expt b p)\n"
"        p0 = (integerLogBase b (numerator x) -\n"
"              integerLogBase b (denominator x) - p) `max` minExp\n"
"        f = if p0 < 0 then 1 % expt b (-p0) else expt b p0 % 1\n"
"        (x', p') = scaleRat (toRational b) minExp xMin xMax p0 (x / f)\n"
"        r = encodeFloat (round x') p'\n"
"\n"
"-- Scale x until xMin <= x < xMax, or p (the exponent) <= minExp.\n"
"scaleRat :: Rational -> Int -> Rational -> Rational -> \n"
"             Int -> Rational -> (Rational, Int)\n"
"scaleRat b minExp xMin xMax p x\n"
" | p <= minExp = (x,p)\n"
" | x >= xMax   = scaleRat b minExp xMin xMax (p+1) (x/b)\n"
" | x <  xMin   = scaleRat b minExp xMin xMax (p-1) (x*b)\n"
" | otherwise   = (x, p)\n"
"\n"
"-- Exponentiation with a cache for the most common numbers.\n"
"minExpt = 0::Int\n"
"maxExpt = 1100::Int\n"
"expt :: Integer -> Int -> Integer\n"
"expt base n =\n"
"    if base == 2 && n >= minExpt && n <= maxExpt then\n"
"        expts!n\n"
"    else\n"
"        base^n\n"
"\n"
"expts :: Array Int Integer\n"
"expts = array (minExpt,maxExpt) [(n,2^n) | n <- [minExpt .. maxExpt]]\n"
"\n"
"-- Compute the (floor of the) log of i in base b.\n"
"-- Simplest way would be just divide i by b until it's smaller then b,\n"
"-- but that would be very slow!  We are just slightly more clever.\n"
"integerLogBase :: Integer -> Integer -> Int\n"
"integerLogBase b i =\n"
"     if i < b then\n"
"        0\n"
"     else\n"
"        -- Try squaring the base first to cut down the number of divisions.\n"
"        let l = 2 * integerLogBase (b*b) i\n"
"            doDiv :: Integer -> Int -> Int\n"
"            doDiv i l = if i < b then l else doDiv (i `div` b) (l+1)\n"
"        in  doDiv (i `div` (b^l)) l\n"
"\n"
"-- Misc utilities to show integers and floats\n"
"\n"
"showEFloat     :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
"showFFloat     :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
"showGFloat     :: (RealFloat a) => Maybe Int -> a -> ShowS\n"
"showFloat      :: (RealFloat a) => a -> ShowS\n"
"\n"
"showEFloat d x =  showString (formatRealFloat FFExponent d x)\n"
"showFFloat d x =  showString (formatRealFloat FFFixed d x)\n"
"showGFloat d x =  showString (formatRealFloat FFGeneric d x)\n"
"showFloat      =  showGFloat Nothing \n"
"\n"
"-- These are the format types.  This type is not exported.\n"
"\n"
"data FFFormat = FFExponent | FFFixed | FFGeneric\n"
"\n"
"formatRealFloat :: (RealFloat a) => FFFormat -> Maybe Int -> a -> String\n"
"formatRealFloat fmt decs x \n"
"  | isNaN      x = \"NaN\"\n"
"  | isInfinite x = if x < 0 then \"-Infinity\" else \"Infinity\"\n"
"  | x < 0 || isNegativeZero x = '-' : doFmt fmt (floatToDigits (toInteger base) (-x))\n"
"  | otherwise    = doFmt fmt (floatToDigits (toInteger base) x)\n"
"  where base = 10\n"
"\n"
"        doFmt fmt (is, e) =\n"
"            let ds = map intToDigit is\n"
"            in  case fmt of\n"
"                FFGeneric -> \n"
"                    doFmt (if e < 0 || e > 7 then FFExponent else FFFixed)\n"
"                          (is, e)\n"
"                FFExponent ->\n"
"                    case decs of\n"
"                    Nothing ->\n"
"                        case ds of\n"
"			 []    -> \"0.0e0\"\n"
"                         [d]   -> d : \".0e\" ++ show (e-1)\n"
"                         d:ds  -> d : '.' : ds ++ 'e':show (e-1)\n"
"                    Just dec ->\n"
"                        let dec' = max dec 1 in\n"
"                        case is of\n"
"                         [] -> '0':'.':take dec' (repeat '0') ++ \"e0\"\n"
"                         _ ->\n"
"                          let (ei, is') = roundTo base (dec'+1) is\n"
"                              d:ds = map intToDigit\n"
"                                         (if ei > 0 then init is' else is')\n"
"                          in d:'.':ds  ++ \"e\" ++ show (e-1+ei)\n"
"                FFFixed ->\n"
"                  case decs of\n"
"                    Nothing \n"
"		     | e > 0 -> take e (ds ++ repeat '0')\n"
"		     	        ++ '.' : mk0 (drop e ds)\n"
"		     | otherwise -> '0' : '.' : mk0 (replicate (-e) '0' ++ ds)\n"
"                    Just dec ->\n"
"                        let dec' = max dec 0 in\n"
"                        if e >= 0 then\n"
"                            let (ei, is') = roundTo base (dec' + e) is\n"
"                                (ls, rs) = splitAt (e+ei) (map intToDigit is')\n"
"                            in  mk0 ls ++ mkdot0 rs\n"
"                        else\n"
"                            let (ei, is') = roundTo base dec'\n"
"                                              (replicate (-e) 0 ++ is)\n"
"                                d : ds = map intToDigit\n"
"                                            (if ei > 0 then is' else 0:is')\n"
"                            in  d : mkdot0 ds\n"
"		  where\n"
"		    mk0 \"\" = \"0\"     -- Used to ensure we print 34.0, not 34.\n"
"	       	    mk0 s  = s       -- and 0.34 not .34\n"
"    \n"
"    		    mkdot0 \"\" = \"\"   -- Used to ensure we print 34, not 34.\n"
"		    mkdot0 s  = '.' : s\n"
"\n"
"roundTo :: Int -> Int -> [Int] -> (Int, [Int])\n"
"roundTo base d is = case f d is of\n"
"                v@(0, is) -> v\n"
"                (1, is)   -> (1, 1 : is)\n"
"  where b2 = base `div` 2\n"
"        f n [] = (0, replicate n 0)\n"
"        f 0 (i:_) = (if i >= b2 then 1 else 0, [])\n"
"        f d (i:is) = \n"
"            let (c, ds) = f (d-1) is\n"
"                i' = c + i\n"
"            in  if i' == base then (1, 0:ds) else (0, i':ds)\n"
"\n"
"--\n"
"-- Based on \"Printing Floating-Point Numbers Quickly and Accurately\"\n"
"-- by R.G. Burger and R. K. Dybvig, in PLDI 96.\n"
"-- This version uses a much slower logarithm estimator.  It should be improved.\n"
"\n"
"-- This function returns a list of digits (Ints in [0..base-1]) and an\n"
"-- exponent.\n"
"\n"
"floatToDigits :: (RealFloat a) => Integer -> a -> ([Int], Int)\n"
"\n"
"floatToDigits _ 0 = ([0], 0)\n"
"floatToDigits base x =\n"
"    let (f0, e0) = decodeFloat x\n"
"        (minExp0, _) = floatRange x\n"
"        p = floatDigits x\n"
"        b = floatRadix x\n"
"        minExp = minExp0 - p            -- the real minimum exponent\n"
"        -- Haskell requires that f be adjusted so denormalized numbers\n"
"        -- will have an impossibly low exponent.  Adjust for this.\n"
"	f :: Integer\n"
"	e :: Int\n"
"        (f, e) = let n = minExp - e0\n"
"                 in  if n > 0 then (f0 `div` (b^n), e0+n) else (f0, e0)\n"
"\n"
"        (r, s, mUp, mDn) =\n"
"           if e >= 0 then\n"
"               let be = b^e in\n"
"               if f == b^(p-1) then\n"
"                   (f*be*b*2, 2*b, be*b, b)\n"
"               else\n"
"                   (f*be*2, 2, be, be)\n"
"           else\n"
"               if e > minExp && f == b^(p-1) then\n"
"                   (f*b*2, b^(-e+1)*2, b, 1)\n"
"               else\n"
"                   (f*2, b^(-e)*2, 1, 1)\n"
"        k = \n"
"            let k0 =\n"
"                    if b==2 && base==10 then\n"
"                        -- logBase 10 2 is slightly bigger than 3/10 so\n"
"                        -- the following will err on the low side.  Ignoring\n"
"                        -- the fraction will make it err even more.\n"
"                        -- Haskell promises that p-1 <= logBase b f < p.\n"
"                        (p - 1 + e0) * 3 `div` 10\n"
"                    else\n"
"                        ceiling ((log (fromInteger (f+1)) + \n"
"                                 fromIntegral e * log (fromInteger b)) / \n"
"                                  log (fromInteger base))\n"
"                fixup n =\n"
"                    if n >= 0 then\n"
"                        if r + mUp <= expt base n * s then n else fixup (n+1)\n"
"                    else\n"
"                        if expt base (-n) * (r + mUp) <= s then n\n"
"                                                           else fixup (n+1)\n"
"            in  fixup k0\n"
"\n"
"        gen ds rn sN mUpN mDnN =\n"
"            let (dn, rn') = (rn * base) `divMod` sN\n"
"                mUpN' = mUpN * base\n"
"                mDnN' = mDnN * base\n"
"            in  case (rn' < mDnN', rn' + mUpN' > sN) of\n"
"                (True,  False) -> dn : ds\n"
"                (False, True)  -> dn+1 : ds\n"
"                (True,  True)  -> if rn' * 2 < sN then dn : ds else dn+1 : ds\n"
"                (False, False) -> gen (dn:ds) rn' sN mUpN' mDnN'\n"
"        rds =\n"
"            if k >= 0 then\n"
"                gen [] r (s * expt base k) mUp mDn\n"
"            else\n"
"                let bk = expt base (-k)\n"
"                in  gen [] (r * bk) s (mUp * bk) (mDn * bk)\n"
"    in  (map fromIntegral (reverse rds), k)\n";
const char *Hugs_Ptr = "-----------------------------------------------------------------------------\n"
"-- Machine Addresses:\n"
"-- Suitable for use with Hugs 98 on 32 bit machines.\n"
"-----------------------------------------------------------------------------\n"
"module Hugs.Ptr\n"
"	( Ptr\n"
"	, nullPtr          -- :: Ptr a\n"
" 	, plusPtr          -- :: Ptr a -> Int -> Ptr b\n"
"        , castPtr          -- :: Ptr a -> Ptr b\n"
"	, alignPtr         -- :: Ptr a -> Int -> Ptr a\n"
"	, minusPtr         -- :: Ptr a -> Ptr b -> Int\n"
"	, ptrToInt         -- :: Ptr a -> Int\n"
"	-- instance Eq   (Ptr a)\n"
"	-- instance Ord  (Ptr a)\n"
"	-- instance Show (Ptr a)\n"
"\n"
"        , FunPtr\n"
"	, nullFunPtr        -- :: FunPtr a\n"
"	, castFunPtr        -- :: FunPtr a -> FunPtr b\n"
"	, castFunPtrToPtr   -- :: FunPtr a -> Ptr b\n"
"	, castPtrToFunPtr   -- :: Ptr a -> FunPtr b\n"
"        , freeHaskellFunPtr -- :: FunPtr a -> IO ()\n"
"	-- instance Eq   (FunPtr a)\n"
"	-- instance Ord  (FunPtr a)\n"
"	-- instance Show (FunPtr a)\n"
"	) where\n"
"\n"
"import Hugs.Prelude ( Ptr, FunPtr )\n"
"\n"
"-- data Ptr a -- in Hugs.Prelude\n"
"\n"
"instance Eq   (Ptr a) where (==)      = primEqPtr\n"
"instance Ord  (Ptr a) where compare   = primCmpPtr\n"
"instance Show (Ptr a) where showsPrec = primShowsPtr\n"
"\n"
"primitive nullPtr                    :: Ptr a\n"
"primitive plusPtr                    :: Ptr a -> Int -> Ptr b\n"
"primitive minusPtr                   :: Ptr a -> Ptr b -> Int\n"
"primitive castPtr \"primUnsafeCoerce\" :: Ptr a -> Ptr b\n"
"primitive primShowsPtr               :: Int -> Ptr a -> ShowS\n"
"primitive primEqPtr                  :: Ptr a -> Ptr a -> Bool\n"
"primitive primCmpPtr                 :: Ptr a -> Ptr a -> Ordering\n"
"primitive ptrToInt                   :: Ptr a -> Int\n"
"\n"
"alignPtr :: Ptr a -> Int -> Ptr a\n"
"alignPtr p n = p `plusPtr` ((n - ptrToInt p `mod` n) `mod` n)\n"
"\n"
"-- data FunPtr a -- in Hugs.Prelude\n"
"\n"
"instance Eq   (FunPtr a) where (==)      = primEqFPtr\n"
"instance Ord  (FunPtr a) where compare   = primCmpFPtr\n"
"instance Show (FunPtr a) where showsPrec = primShowsFPtr\n"
"\n"
"primitive nullFunPtr    \"nullPtr\"       :: FunPtr a\n"
"primitive primShowsFPtr \"primShowsPtr\"  :: Int -> FunPtr a -> ShowS\n"
"primitive primEqFPtr    \"primEqPtr\"     :: FunPtr a -> FunPtr a -> Bool\n"
"primitive primCmpFPtr   \"primCmpPtr\"    :: FunPtr a -> FunPtr a -> Ordering\n"
"primitive castFunPtr \"primUnsafeCoerce\" :: FunPtr a -> FunPtr b\n"
"primitive castFunPtrToPtr \"primUnsafeCoerce\" :: FunPtr a -> Ptr b\n"
"primitive castPtrToFunPtr \"primUnsafeCoerce\" :: Ptr a -> FunPtr b\n"
"primitive freeHaskellFunPtr             :: FunPtr a -> IO ()\n"
"\n"
"-----------------------------------------------------------------------------\n";
const char *Hugs_GenericPrint = "----------------------------------------------------------------\n"
"-- A \"generic\" (or \"polymorphic\") print function in Haskell\n"
"-- This is very heavily based on the code in printer.c\n"
"-- (Together with the decompiler and error catching primitives,\n"
"-- this might make a good base on which to build a debugger?)\n"
"--\n"
"-- NB This library is an _experimental_ feature which may be\n"
"--    removed in future versions of Hugs.\n"
"--    It can only be used if Hugs was configured with the\n"
"--    \"--enable-internal--prims\" flag.\n"
"----------------------------------------------------------------\n"
"\n"
"module Hugs.GenericPrint(\n"
"        printError, \n"
"        outputString, \n"
"        print\n"
"        ) where\n"
"\n"
"import Prelude hiding (print)\n"
"\n"
"import Hugs.Internals(\n"
"        Name, nameInfo, nameString,\n"
"        Cell, getCell,\n"
"        CellKind(..), classifyCell,\n"
"        )\n"
"\n"
"import Hugs.IOExts( unsafePerformIO )\n"
"import Hugs.Array\n"
"import Data.Char( showLitChar, isAlpha )\n"
"import Data.List( intersperse )\n"
"\n"
"----------------------------------------------------------------\n"
"-- The top-level print routine \n"
"----------------------------------------------------------------\n"
"\n"
"printError   :: Cell -> IO ()\n"
"outputString :: String -> IO ()\n"
"print        :: a -> IO ()\n"
"\n"
"printError err = do\n"
"  putStr \"\\nProgram error: \" \n"
"  printDBadRedex err \n"
"  putStr \"\\n\"\n"
"\n"
"outputString s = outputStr (getCell s)\n"
"\n"
"print x        = print' True (getCell x)\n"
"\n"
"----------------------------------------------------------------\n"
"\n"
"printBadRedex err = do\n"
"  putChar '{' \n"
"  print' False err \n"
"  putChar '}'\n"
"\n"
"printDBadRedex err = do\n"
"  kind <- classifyCell False err\n"
"  case kind of\n"
"    Apply fun args -> do\n"
"      funkind <- classifyCell False fun\n"
"      case (funkind, args) of\n"
"        (Fun nm, [msg]) | nm == nameError ->\n"
"          outputStr msg\n"
"        _ -> printBadRedex err\n"
"    _ -> printBadRedex err\n"
"\n"
"outputStr :: Cell -> IO ()\n"
"outputStr xs = do\n"
"  kind <- hugsClassifyCell True xs\n"
"  case kind of\n"
"    Apply fun args ->\n"
"      hugsClassifyCell True fun >>= \\ funkind ->\n"
"      case (funkind, args) of\n"
"      (Con nm, [y,ys]) | nm == nameCons ->\n"
"        hugsClassifyCell True y >>= \\ ykind ->\n"
"        case ykind of\n"
"        Char c ->\n"
"          putChar c >>\n"
"          outputStr ys\n"
"        Error err ->\n"
"          printBadRedex err >>\n"
"          outputStr ys\n"
"        _ ->\n"
"          printBadRedex y >>\n"
"          outputStr ys\n"
"      (Error err, _) ->\n"
"        printBadRedex err\n"
"      _ ->\n"
"        printBadRedex xs\n"
"    Con nm | nm == nameNil ->\n"
"        return ()\n"
"    Error err ->\n"
"        printBadRedex err\n"
"    _ ->\n"
"        printBadRedex xs\n"
"\n"
"print' :: Bool -> Cell -> IO ()\n"
"print' strict x = printCell strict min_prec x\n"
"\n"
"--ToDo: combine with sprint (if possible)\n"
"lprint :: Bool -> Cell -> Cell -> IO ()\n"
"lprint strict x xs =\n"
"  printCell strict min_prec x >>\n"
"  hugsClassifyCell strict xs >>= \\ kind ->\n"
"  case kind of\n"
"  Apply fun args ->\n"
"      hugsClassifyCell strict fun >>= \\ funkind ->\n"
"        case (funkind, args) of\n"
"        (Con nm, [y,ys]) | nm == nameCons ->\n"
"          putStr \", \" >>\n"
"          lprint strict y ys\n"
"        (Error err, _) ->\n"
"          printBadRedex err\n"
"        _ ->\n"
"          putStr \"] ++ \" >>\n"
"          printBadRedex xs\n"
"  Con nm | nm == nameNil ->\n"
"          putChar ']'\n"
"  Error err ->\n"
"          printBadRedex err\n"
"  _ ->\n"
"          putStr \"] ++ \" >>\n"
"          printBadRedex xs\n"
"\n"
"sprint :: Bool -> Char -> Cell -> IO ()\n"
"sprint strict c xs =\n"
"  putStr (showLitChar c \"\") >>\n"
"  hugsClassifyCell strict xs >>= \\ kind ->\n"
"  case kind of\n"
"  Apply fun args ->\n"
"      hugsClassifyCell strict fun >>= \\ funkind ->\n"
"        case (funkind, args) of\n"
"        (Con nm, [y,ys]) | nm == nameCons ->\n"
"          hugsClassifyCell strict y >>= \\ ykind ->\n"
"          case ykind of\n"
"          Char c -> sprint strict c ys\n"
"          _      -> lprint False y ys\n"
"        _ ->\n"
"          putStr \"\\\" ++ \" >>\n"
"          printBadRedex xs\n"
"  Con nm | nm == nameNil ->\n"
"          putChar '\"'\n"
"  _ ->\n"
"          putStr \"\\\" ++ \" >>\n"
"          printBadRedex xs\n"
"\n"
"printCell :: Bool -> Int -> Cell -> IO ()\n"
"printCell strict d x =\n"
"  hugsClassifyCell strict x >>= \\ kind ->\n"
"  case kind of\n"
"  Apply fun args ->\n"
"      hugsClassifyCell strict fun >>= \\ funkind ->\n"
"      case funkind of\n"
"      Con nm ->\n"
"        case args of\n"
"          [x,xs] | nm == nameCons\n"
"            -> hugsClassifyCell strict x >>= \\ xkind ->\n"
"               case xkind of\n"
"               Char c -> putChar '\"' >> sprint strict c xs\n"
"               _      -> putChar '[' >> lprint strict x xs\n"
"\n"
"          [x] | assoc /= 'A'\n"
"            -> printParen True (\n"
"                 printCell strict (fun_prec-1) x >>\n"
"                 putChar ' ' >>\n"
"                 putStr (asOp nameStr)\n"
"               )\n"
"\n"
"          (x1:x2:xs) | assoc /= 'A'\n"
"            -> printParen (not (null xs) && d >= fun_prec) (\n"
"                 printParen (d <= p) (do\n"
"                   printCell strict lp x1\n"
"                   putChar ' '           \n"
"                   putStr (asOp nameStr) \n"
"                   putChar ' '           \n"
"                   printCell strict rp x2\n"
"                   ) >>\n"
"                 mapM_ (\\ arg ->\n"
"                   putChar ' ' >>\n"
"                   printCell strict p arg\n"
"                 ) xs\n"
"                 )\n"
"\n"
"          xs\n"
"            -> printParen (not (null xs) && d >= fun_prec) (\n"
"                 -- test that xs is nonNull should be redundant but\n"
"                 -- no harm being robust\n"
"                 putStr (asVar nameStr)       >>\n"
"                 mapM_ (\\arg ->\n"
"                   putChar ' ' >>\n"
"                   printCell strict fun_prec arg\n"
"                 ) xs\n"
"                 )\n"
"         where\n"
"          (arity, p, assoc) = nameInfo nm\n"
"          nameStr = nameString nm\n"
"\n"
"          -- from Appendix E2 of Haskell 1.2 report\n"
"          lp = if assoc == 'L' then p else p+1\n"
"          rp = if assoc == 'R' then p else p+1\n"
"        \n"
"      Fun nm ->\n"
"        printParen (d >= fun_prec) (\n"
"          putStr (asVar nameStr)       >>\n"
"          mapM_ (\\arg ->\n"
"            putChar ' ' >>\n"
"            -- switch to lazy printing!\n"
"            printCell False fun_prec arg\n"
"          ) args\n"
"          )\n"
"       where\n"
"        nameStr = nameString nm\n"
"      \n"
"      Tuple arity ->\n"
"        printParen (not (null extra) && d >= fun_prec) (\n"
"          printParen True (\n"
"            for__ fields (\\ field ->\n"
"              printCell strict min_prec field\n"
"            ) (putChar ',') >>\n"
"            -- Haskell's syntax makes it impossible to construct an\n"
"            -- incomplete tuple - but let's play safe!\n"
"            mapM_ (\\_ ->\n"
"              putChar ','\n"
"            ) [numArgs+1..arity]\n"
"          ) >>\n"
"          -- Haskell's type system makes extra arguments impossible\n"
"          -- - but let's play safe!\n"
"          mapM_ (\\ arg ->\n"
"            putChar ' ' >>\n"
"            printCell strict fun_prec arg\n"
"          ) extra\n"
"        )\n"
"       where\n"
"        (fields, extra) = splitAt arity args\n"
"\n"
"      Error err ->\n"
"          printBadRedex err\n"
"\n"
"      _\n"
"        -> printParen (not (null args) && d >= fun_prec) (\n"
"             printCell strict fun_prec fun   >>\n"
"             mapM_ (\\arg ->\n"
"               putChar ' ' >>\n"
"               printCell strict fun_prec arg\n"
"             ) args\n"
"             )\n"
"     where\n"
"        numArgs = length args\n"
"\n"
"  Fun nm ->\n"
"    putStr (asVar (nameString nm))\n"
"\n"
"  Con nm ->\n"
"    putStr (asVar (nameString nm))\n"
"\n"
"  Tuple arity ->\n"
"    putStr ('(' : replicate arity ',' ++ \")\")\n"
"\n"
"  Int x ->\n"
"    putStr (show x)\n"
"\n"
"  Integer x ->\n"
"    putStr (show x)\n"
"\n"
"  Float x ->\n"
"    putStr (show x)\n"
"\n"
"  Char x ->\n"
"    putStr ('\\'' : showLitChar x \"\\'\")\n"
"\n"
"  Prim prim ->\n"
"    putStr prim\n"
"\n"
"  Error err ->\n"
"    printBadRedex err\n"
"\n"
"----------------------------------------------------------------\n"
"-- Cell/Name utilities\n"
"----------------------------------------------------------------\n"
"\n"
"nameCons    =  cellName (:)\n"
"nameNil     =  cellName []\n"
"nameError   =  cellName error\n"
"\n"
"-- Here's something VERY subtle.\n"
"-- We use classifyCell instead of hugsClassifyCell because\n"
"-- otherwise, this gets put in the same dependency class as everything\n"
"-- else and the lack of polymorphic recursion bites us.\n"
"-- (Using classifyCell is equally good here because it wont fail.)\n"
"cellName :: a -> Name\n"
"cellName x = unsafePerformIO (\n"
"  classifyCell True (getCell x) >>= \\ kind ->\n"
"  case kind of\n"
"  Fun nm -> return nm\n"
"  Con nm -> return nm\n"
"  )\n"
"\n"
"-- This implements the error-handling policy:\n"
"hugsClassifyCell :: Bool -> Cell -> IO CellKind\n"
"hugsClassifyCell strict obj =\n"
"  classifyCell strict obj >>= \\ kind ->\n"
"  case kind of\n"
"  Error err ->\n"
"    if failOnError then\n"
"      exitWith (printError err)\n"
"    else\n"
"      return kind\n"
"  _ ->\n"
"    return kind\n"
"\n"
"----------------------------------------------------------------\n"
"-- Utilities\n"
"----------------------------------------------------------------\n"
"\n"
"for__ :: Monad m => [a] -> (a -> m ()) -> m () -> m ()\n"
"for__ xs f inc = sequence_ $ intersperse inc $ map f xs\n"
"\n"
"min_prec, max_prec, fun_prec :: Int\n"
"min_prec = 0\n"
"max_prec = 9\n"
"fun_prec = max_prec+2\n"
"\n"
"asOp str\n"
" | isOp str  = str\n"
" | otherwise = '`' : str ++ \"`\"\n"
"\n"
"asVar str\n"
" | isOp str  = '(' : str ++ \")\"\n"
" | otherwise = str\n"
"\n"
"isOp (c:_) = not (isAlpha c || c == '[')\n"
"isOp _     = False\n"
"\n"
"printParen :: Bool -> IO () -> IO ()\n"
"printParen True m  = putChar '(' >> m >> putChar ')'\n"
"printParen False m = m\n"
"\n"
"----------------------------------------------------------------\n"
"-- Missing primitives\n"
"----------------------------------------------------------------\n"
"\n"
"-- In Hugs0, this accessed the value of the :set -f\" flag\n"
"failOnError :: Bool\n"
"failOnError = True\n"
"\n"
"-- In Hugs0, this executed the action and terminated the current evaluation\n"
"exitWith :: IO () -> IO a\n"
"exitWith m = m >> error \"{exitWith}\"\n"
"\n"
"----------------------------------------------------------------\n";
const char *Hugs_IORef = "module Hugs.IORef\n"
"	( IORef		      -- abstract, instance of: Eq\n"
"        , newIORef	      -- :: a -> IO (IORef a)\n"
"        , readIORef	      -- :: IORef a -> IO a\n"
"        , writeIORef	      -- :: IORef a -> a -> IO ()\n"
"	) where\n"
"\n"
"data IORef a        -- mutable variables containing values of type a\n"
"\n"
"primitive newIORef   \"newRef\" :: a -> IO (IORef a)\n"
"primitive readIORef  \"getRef\" :: IORef a -> IO a\n"
"primitive writeIORef \"setRef\" :: IORef a -> a -> IO ()\n"
"primitive eqIORef    \"eqRef\"  :: IORef a -> IORef a -> Bool\n"
"\n"
"instance Eq (IORef a) where\n"
"    (==) = eqIORef\n";
const char *Hugs_Storable = "module Hugs.Storable where\n"
"\n"
"import Hugs.Prelude\n"
"\n"
"foreign import ccall unsafe \"Storable_aux.h\" readIntOffPtr       :: Ptr Int           -> Int -> IO Int\n"
"foreign import ccall unsafe \"Storable_aux.h\" readCharOffPtr      :: Ptr Char          -> Int -> IO Char\n"
"-- foreign import ccall unsafe \"Storable_aux.h\" readWideCharOffPtr  :: Ptr Char          -> Int -> IO Char\n"
"-- foreign import ccall unsafe \"Storable_aux.h\" readWordOffPtr      :: Ptr Word          -> Int -> IO Word\n"
"foreign import ccall unsafe \"Storable_aux.h\" readPtrOffPtr       :: Ptr (Ptr a)       -> Int -> IO (Ptr a)\n"
"foreign import ccall unsafe \"Storable_aux.h\" readFunPtrOffPtr    :: Ptr (FunPtr a)    -> Int -> IO (FunPtr a)\n"
"foreign import ccall unsafe \"Storable_aux.h\" readFloatOffPtr     :: Ptr Float         -> Int -> IO Float\n"
"foreign import ccall unsafe \"Storable_aux.h\" readDoubleOffPtr    :: Ptr Double        -> Int -> IO Double\n"
"foreign import ccall unsafe \"Storable_aux.h\" readStablePtrOffPtr :: Ptr (StablePtr a) -> Int -> IO (StablePtr a)\n"
"foreign import ccall unsafe \"Storable_aux.h\" readInt8OffPtr      :: Ptr Int8          -> Int -> IO Int8\n"
"foreign import ccall unsafe \"Storable_aux.h\" readInt16OffPtr     :: Ptr Int16         -> Int -> IO Int16\n"
"foreign import ccall unsafe \"Storable_aux.h\" readInt32OffPtr     :: Ptr Int32         -> Int -> IO Int32\n"
"foreign import ccall unsafe \"Storable_aux.h\" readInt64OffPtr     :: Ptr Int64         -> Int -> IO Int64\n"
"foreign import ccall unsafe \"Storable_aux.h\" readWord8OffPtr     :: Ptr Word8         -> Int -> IO Word8\n"
"foreign import ccall unsafe \"Storable_aux.h\" readWord16OffPtr    :: Ptr Word16        -> Int -> IO Word16\n"
"foreign import ccall unsafe \"Storable_aux.h\" readWord32OffPtr    :: Ptr Word32        -> Int -> IO Word32\n"
"foreign import ccall unsafe \"Storable_aux.h\" readWord64OffPtr    :: Ptr Word64        -> Int -> IO Word64\n"
"\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeIntOffPtr       :: Ptr Int           -> Int -> Int         -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeCharOffPtr      :: Ptr Char          -> Int -> Char        -> IO ()\n"
"-- foreign import ccall unsafe \"Storable_aux.h\" writeWideCharOffPtr  :: Ptr Char          -> Int -> Char        -> IO ()\n"
"-- foreign import ccall unsafe \"Storable_aux.h\" writeWordOffPtr      :: Ptr Word          -> Int -> Word        -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writePtrOffPtr       :: Ptr (Ptr a)       -> Int -> Ptr a       -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeFunPtrOffPtr    :: Ptr (FunPtr a)    -> Int -> FunPtr a    -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeFloatOffPtr     :: Ptr Float         -> Int -> Float       -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeDoubleOffPtr    :: Ptr Double        -> Int -> Double      -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeStablePtrOffPtr :: Ptr (StablePtr a) -> Int -> StablePtr a -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeInt8OffPtr      :: Ptr Int8          -> Int -> Int8        -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeInt16OffPtr     :: Ptr Int16         -> Int -> Int16       -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeInt32OffPtr     :: Ptr Int32         -> Int -> Int32       -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeInt64OffPtr     :: Ptr Int64         -> Int -> Int64       -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeWord8OffPtr     :: Ptr Word8         -> Int -> Word8       -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeWord16OffPtr    :: Ptr Word16        -> Int -> Word16      -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeWord32OffPtr    :: Ptr Word32        -> Int -> Word32      -> IO ()\n"
"foreign import ccall unsafe \"Storable_aux.h\" writeWord64OffPtr    :: Ptr Word64        -> Int -> Word64      -> IO ()\n"
"\n";
const char *Hugs_Time = "--\n"
"-- Time primitives for Hugs98.\n"
"--\n"
"module Hugs.Time\n"
"	( getClockTimePrim\n"
"	, toCalTimePrim\n"
"	, toClockTimePrim\n"
"\n"
"	, getCPUTime		-- :: IO Integer\n"
"	, clockTicks		-- :: Int\n"
"	) where\n"
"\n"
"primitive getClockTimePrim :: IO (Int,Int)\n"
"primitive toCalTimePrim ::\n"
"	Int -> Int -> IO (Int,Int,Int,Int,Int,Int,Int,Int,Int,String,Int)\n"
"primitive toClockTimePrim ::\n"
"	Int -> Int -> Int -> Int -> Int -> Int -> Int -> IO Int\n"
"\n"
"picoSec :: Integer\n"
"picoSec = 1000000000000 -- 10^12\n"
"\n"
"getCPUTime :: IO Integer\n"
"getCPUTime = do\n"
"   (usec, unsec, ssec, snsec) <- getCPUUsage\n"
"   return (picoSec * fromIntegral usec  +\n"
"   	   1000    * fromIntegral unsec + \n"
"	   picoSec * fromIntegral ssec  + \n"
"	   1000    * fromIntegral snsec)\n"
"	   \n"
"primitive getCPUUsage  :: IO (Int,Int,Int,Int)\n"
"primitive clockTicks   :: Int\n";
const char *Hugs_StablePtr = "module Hugs.StablePtr( StablePtr, module Hugs.StablePtr ) where\n"
"\n"
"import Hugs.Prelude( StablePtr, Ptr )\n"
"\n"
"-- recently renamed\n"
"newStablePtr = makeStablePtr \n"
"\n"
"primitive makeStablePtr      :: a -> IO (StablePtr a)\n"
"primitive deRefStablePtr     :: StablePtr a -> IO a\n"
"primitive freeStablePtr      :: StablePtr a -> IO ()\n"
"primitive castStablePtrToPtr :: StablePtr a -> Ptr ()\n"
"primitive castPtrToStablePtr :: Ptr () -> StablePtr a\n"
"\n";
const char *Hugs_IOExts = "-----------------------------------------------------------------------------\n"
"-- IO monad extensions:\n"
"--\n"
"-- Suitable for use with Hugs 98.\n"
"-----------------------------------------------------------------------------\n"
"\n"
"module Hugs.IOExts\n"
"	( fixIO				-- :: (a -> IO a) -> IO a\n"
"	, unsafePerformIO		-- :: IO a -> a\n"
"\n"
"	, performGC\n"
"\n"
"	, IOModeEx(..)	      	-- instance (Eq, Read, Show)\n"
"	, openFileEx	      	-- :: FilePath -> IOModeEx -> IO Handle\n"
"\n"
"	, unsafePtrEq\n"
"	, unsafePtrToInt\n"
"	, unsafeCoerce\n"
"	\n"
"	  -- backward compatibility with IOExtensions\n"
"	, readBinaryFile        -- :: FilePath -> IO String\n"
"	, writeBinaryFile       -- :: FilePath -> String -> IO ()\n"
"	, appendBinaryFile      -- :: FilePath -> String -> IO ()\n"
"	, openBinaryFile        -- :: FilePath -> IOMode -> IO Handle\n"
"\n"
"	   -- non-echoing getchar\n"
"	, getCh                 -- :: IO Char\n"
"	, argv                  -- :: [String]\n"
"\n"
"	  -- Non-standard extensions \n"
"	, hugsIsEOF             -- :: IO Bool\n"
"	, hugsHIsEOF            -- :: Handle  -> IO Bool\n"
"	) where\n"
"\n"
"import Hugs.Prelude\n"
"import Hugs.IO\n"
"import Hugs.IORef\n"
"import Hugs.System ( getArgs )\n"
"\n"
"-----------------------------------------------------------------------------\n"
"\n"
"primitive performGC \"primGC\" :: IO ()\n"
"\n"
"unsafePerformIO :: IO a -> a\n"
"unsafePerformIO m = valueOf (basicIORun m)\n"
"\n"
"primitive unsafePtrEq    :: a -> a -> Bool\n"
"primitive unsafePtrToInt :: a -> Int\n"
"\n"
"fixIO :: (a -> IO a) -> IO a\n"
"fixIO f = do\n"
"	r <- newIORef (throw NonTermination)\n"
"	x <- f (unsafePerformIO (readIORef r))\n"
"	writeIORef r x\n"
"	return x\n"
"\n"
"primitive unsafeCoerce \"primUnsafeCoerce\" :: a -> b\n"
"\n"
"valueOf :: IOFinished a -> a\n"
"valueOf (Finished_Return a) = a\n"
"valueOf _ = error \"IOExts.valueOf: thread failed\"	-- shouldn't happen\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Binary files \n"
"-----------------------------------------------------------------------------\n"
"data IOModeEx \n"
" = BinaryMode IOMode\n"
" | TextMode   IOMode\n"
"   deriving (Eq, Read, Show)\n"
"\n"
"openFileEx :: FilePath -> IOModeEx -> IO Handle\n"
"openFileEx fp m = \n"
"  case m of\n"
"    BinaryMode m -> openBinaryFile fp m\n"
"    TextMode m   -> openFile fp m\n"
"\n"
"argv :: [String]\n"
"argv = unsafePerformIO getArgs\n"
"\n"
"primitive writeBinaryFile   	 :: FilePath -> String -> IO ()\n"
"primitive appendBinaryFile  	 :: FilePath -> String -> IO ()\n"
"primitive readBinaryFile    	 :: FilePath -> IO String\n"
"primitive openBinaryFile         :: FilePath -> IOMode -> IO Handle\n"
"\n"
"-----------------------------------------------------------------------------\n"
"-- Non-standard extensions \n"
"-- (likely to disappear when IO library is more complete)\n"
"--\n"
"-- keep them around for now.\n"
"\n"
"primitive getCh                  :: IO Char -- non-echoing getchar\n"
"\n"
"-- C library style test for EOF (doesn't obey Haskell semantics)\n"
"primitive hugsHIsEOF \"hugsHIsEOF\" :: Handle -> IO Bool\n"
"hugsIsEOF             :: IO Bool\n"
"hugsIsEOF              = hugsHIsEOF stdin\n";
const int N_PRELUDE_FILES = 210;

const char *prelude_paths[] = {
"Ratio.hs"
, "System.hs"
, "Maybe.hs"
, "CPUTime.hs"
, "Network.hs"
, "Random.hs"
, "CString.hs"
, "Prelude.hs"
, "Foreign.hs"
, "ForeignPtr.hs"
, "CForeign.hs"
, "Word.hs"
, "List.hs"
, "Ix.hs"
, "Char.hs"
, "Complex.hs"
, "CTypes.hs"
, "Monad.hs"
, "MarshalError.hs"
, "IO.hs"
, "Array.hs"
, "MarshalAlloc.hs"
, "CError.hs"
, "Directory.hs"
, "Bits.hs"
, "Int.hs"
, "Numeric.hs"
, "Ptr.hs"
, "MarshalUtils.hs"
, "MarshalArray.hs"
, "Storable.hs"
, "Time.hs"
, "Locale.hs"
, "StablePtr.hs"
, "Debug/Trace.hs"
, "Debug/QuickCheck.hs"
, "Debug/QuickCheck/Utils.hs"
, "Debug/QuickCheck/Poly.hs"
, "Language/Haskell/Syntax.hs"
, "Language/Haskell/Parser.hs"
, "Language/Haskell/ParseUtils.hs"
, "Language/Haskell/Pretty.hs"
, "Language/Haskell/Lexer.hs"
, "Language/Haskell/ParseMonad.hs"
, "Network/Socket.hs"
, "Network/BSD.hs"
, "Network/URI.hs"
, "Network/CGI.hs"
, "Control/Exception.hs"
, "Control/Concurrent.hs"
, "Control/Monad.hs"
, "Control/Arrow.hs"
, "Control/Parallel.hs"
, "Control/Monad/ST.hs"
, "Control/Monad/RWS.hs"
, "Control/Monad/Fix.hs"
, "Control/Monad/Writer.hs"
, "Control/Monad/List.hs"
, "Control/Monad/Identity.hs"
, "Control/Monad/Cont.hs"
, "Control/Monad/Error.hs"
, "Control/Monad/State.hs"
, "Control/Monad/Trans.hs"
, "Control/Monad/Reader.hs"
, "Control/Monad/ST/Strict.hs"
, "Control/Monad/ST/Lazy.hs"
, "Control/Concurrent/QSemN.hs"
, "Control/Concurrent/SampleVar.hs"
, "Control/Concurrent/Chan.hs"
, "Control/Concurrent/QSem.hs"
, "Control/Concurrent/MVar.hs"
, "Text/Read.hs"
, "Text/PrettyPrint.hs"
, "Text/Html.hs"
, "Text/Show.hs"
, "Text/Regex.hs"
, "Text/Regex/Posix.hs"
, "Text/PrettyPrint/HughesPJ.hs"
, "Text/Show/Functions.hs"
, "Text/Html/BlockTable.hs"
, "Text/Read/Lex.hs"
, "Text/ParserCombinators/ReadP.hs"
, "Text/ParserCombinators/ReadPrec.hs"
, "Text/ParserCombinators/Parsec.hs"
, "Text/ParserCombinators/Parsec/Language.hs"
, "Text/ParserCombinators/Parsec/Char.hs"
, "Text/ParserCombinators/Parsec/Token.hs"
, "Text/ParserCombinators/Parsec/Error.hs"
, "Text/ParserCombinators/Parsec/Pos.hs"
, "Text/ParserCombinators/Parsec/Expr.hs"
, "Text/ParserCombinators/Parsec/Prim.hs"
, "Text/ParserCombinators/Parsec/Combinator.hs"
, "Text/ParserCombinators/Parsec/Perm.hs"
, "Data/Monoid.hs"
, "Data/Ratio.hs"
, "Data/Maybe.hs"
, "Data/Graph.hs"
, "Data/PackedString.hs"
, "Data/STRef.hs"
, "Data/Bool.hs"
, "Data/Dynamic.hs"
, "Data/Word.hs"
, "Data/List.hs"
, "Data/Ix.hs"
, "Data/Char.hs"
, "Data/Complex.hs"
, "Data/Set.hs"
, "Data/Either.hs"
, "Data/FiniteMap.hs"
, "Data/HashTable.hs"
, "Data/Tree.hs"
, "Data/Array.hs"
, "Data/Unique.hs"
, "Data/Bits.hs"
, "Data/Int.hs"
, "Data/IORef.hs"
, "Data/Tuple.hs"
, "Data/Typeable.hs"
, "Data/Array/IArray.hs"
, "Data/Array/Diff.hs"
, "Data/Array/MArray.hs"
, "Data/Array/ST.hs"
, "Data/Array/IO.hs"
, "Data/Array/Unboxed.hs"
, "Data/Array/Base.hs"
, "Data/Array/Storable.hs"
, "Data/Array/IO/Internals.hs"
, "Data/STRef/Strict.hs"
, "Data/STRef/Lazy.hs"
, "System/Posix.hs"
, "System/CPUTime.hs"
, "System/Random.hs"
, "System/Exit.hs"
, "System/Environment.hs"
, "System/Mem.hs"
, "System/Cmd.hs"
, "System/IO.hs"
, "System/Directory.hs"
, "System/Info.hs"
, "System/Time.hs"
, "System/Locale.hs"
, "System/IO/Unsafe.hs"
, "System/IO/Error.hs"
, "System/Posix/Resource.hs"
, "System/Posix/Types.hs"
, "System/Posix/Signals.hs"
, "System/Posix/User.hs"
, "System/Posix/Temp.hs"
, "System/Posix/Terminal.hs"
, "System/Posix/Files.hs"
, "System/Posix/Process.hs"
, "System/Posix/Internals.hs"
, "System/Posix/IO.hs"
, "System/Posix/Env.hs"
, "System/Posix/Directory.hs"
, "System/Posix/DynamicLinker.hs"
, "System/Posix/Time.hs"
, "System/Posix/Unistd.hs"
, "System/Posix/DynamicLinker/Module.hs"
, "System/Posix/DynamicLinker/Prim.hs"
, "System/Mem/StableName.hs"
, "System/Mem/Weak.hs"
, "System/Console/GetOpt.hs"
, "Foreign/C.hs"
, "Foreign/ForeignPtr.hs"
, "Foreign/Marshal.hs"
, "Foreign/Ptr.hs"
, "Foreign/Storable.hs"
, "Foreign/StablePtr.hs"
, "Foreign/Marshal/Alloc.hs"
, "Foreign/Marshal/Pool.hs"
, "Foreign/Marshal/Utils.hs"
, "Foreign/Marshal/Array.hs"
, "Foreign/Marshal/Error.hs"
, "Foreign/C/Types.hs"
, "Foreign/C/String.hs"
, "Foreign/C/Error.hs"
, "Hugs/Exception.hs"
, "Hugs/System.hs"
, "Hugs/Trex.hs"
, "Hugs/Stable.hs"
, "Hugs/ST.hs"
, "Hugs/ByteArray.hs"
, "Hugs/CVHAssert.hs"
, "Hugs/Prelude.hs"
, "Hugs/ForeignPtr.hs"
, "Hugs/Observe.hs"
, "Hugs/Dynamic.hs"
, "Hugs/Word.hs"
, "Hugs/Quote.hs"
, "Hugs/LazyST.hs"
, "Hugs/Char.hs"
, "Hugs/Internals.hs"
, "Hugs/Memo.hs"
, "Hugs/IOArray.hs"
, "Hugs/Weak.hs"
, "Hugs/IO.hs"
, "Hugs/Array.hs"
, "Hugs/Directory.hs"
, "Hugs/ConcBase.hs"
, "Hugs/Bits.hs"
, "Hugs/Int.hs"
, "Hugs/Numeric.hs"
, "Hugs/Ptr.hs"
, "Hugs/GenericPrint.hs"
, "Hugs/IORef.hs"
, "Hugs/Storable.hs"
, "Hugs/Time.hs"
, "Hugs/StablePtr.hs"
, "Hugs/IOExts.hs"
};

const char *prelude_contents[210];
__attribute__((constructor)) void initialize_prelude_contents() {
	prelude_contents[0] = Ratio;
	prelude_contents[1] = System;
	prelude_contents[2] = Maybe;
	prelude_contents[3] = CPUTime;
	prelude_contents[4] = Network;
	prelude_contents[5] = Random;
	prelude_contents[6] = CString;
	prelude_contents[7] = Prelude;
	prelude_contents[8] = Foreign;
	prelude_contents[9] = ForeignPtr;
	prelude_contents[10] = CForeign;
	prelude_contents[11] = Word;
	prelude_contents[12] = List;
	prelude_contents[13] = Ix;
	prelude_contents[14] = Char;
	prelude_contents[15] = Complex;
	prelude_contents[16] = CTypes;
	prelude_contents[17] = Monad;
	prelude_contents[18] = MarshalError;
	prelude_contents[19] = IO;
	prelude_contents[20] = Array;
	prelude_contents[21] = MarshalAlloc;
	prelude_contents[22] = CError;
	prelude_contents[23] = Directory;
	prelude_contents[24] = Bits;
	prelude_contents[25] = Int;
	prelude_contents[26] = Numeric;
	prelude_contents[27] = Ptr;
	prelude_contents[28] = MarshalUtils;
	prelude_contents[29] = MarshalArray;
	prelude_contents[30] = Storable;
	prelude_contents[31] = Time;
	prelude_contents[32] = Locale;
	prelude_contents[33] = StablePtr;
	prelude_contents[34] = Debug_Trace;
	prelude_contents[35] = Debug_QuickCheck;
	prelude_contents[36] = Debug_QuickCheck_Utils;
	prelude_contents[37] = Debug_QuickCheck_Poly;
	prelude_contents[38] = Language_Haskell_Syntax;
	prelude_contents[39] = Language_Haskell_Parser;
	prelude_contents[40] = Language_Haskell_ParseUtils;
	prelude_contents[41] = Language_Haskell_Pretty;
	prelude_contents[42] = Language_Haskell_Lexer;
	prelude_contents[43] = Language_Haskell_ParseMonad;
	prelude_contents[44] = Network_Socket;
	prelude_contents[45] = Network_BSD;
	prelude_contents[46] = Network_URI;
	prelude_contents[47] = Network_CGI;
	prelude_contents[48] = Control_Exception;
	prelude_contents[49] = Control_Concurrent;
	prelude_contents[50] = Control_Monad;
	prelude_contents[51] = Control_Arrow;
	prelude_contents[52] = Control_Parallel;
	prelude_contents[53] = Control_Monad_ST;
	prelude_contents[54] = Control_Monad_RWS;
	prelude_contents[55] = Control_Monad_Fix;
	prelude_contents[56] = Control_Monad_Writer;
	prelude_contents[57] = Control_Monad_List;
	prelude_contents[58] = Control_Monad_Identity;
	prelude_contents[59] = Control_Monad_Cont;
	prelude_contents[60] = Control_Monad_Error;
	prelude_contents[61] = Control_Monad_State;
	prelude_contents[62] = Control_Monad_Trans;
	prelude_contents[63] = Control_Monad_Reader;
	prelude_contents[64] = Control_Monad_ST_Strict;
	prelude_contents[65] = Control_Monad_ST_Lazy;
	prelude_contents[66] = Control_Concurrent_QSemN;
	prelude_contents[67] = Control_Concurrent_SampleVar;
	prelude_contents[68] = Control_Concurrent_Chan;
	prelude_contents[69] = Control_Concurrent_QSem;
	prelude_contents[70] = Control_Concurrent_MVar;
	prelude_contents[71] = Text_Read;
	prelude_contents[72] = Text_PrettyPrint;
	prelude_contents[73] = Text_Html;
	prelude_contents[74] = Text_Show;
	prelude_contents[75] = Text_Regex;
	prelude_contents[76] = Text_Regex_Posix;
	prelude_contents[77] = Text_PrettyPrint_HughesPJ;
	prelude_contents[78] = Text_Show_Functions;
	prelude_contents[79] = Text_Html_BlockTable;
	prelude_contents[80] = Text_Read_Lex;
	prelude_contents[81] = Text_ParserCombinators_ReadP;
	prelude_contents[82] = Text_ParserCombinators_ReadPrec;
	prelude_contents[83] = Text_ParserCombinators_Parsec;
	prelude_contents[84] = Text_ParserCombinators_Parsec_Language;
	prelude_contents[85] = Text_ParserCombinators_Parsec_Char;
	prelude_contents[86] = Text_ParserCombinators_Parsec_Token;
	prelude_contents[87] = Text_ParserCombinators_Parsec_Error;
	prelude_contents[88] = Text_ParserCombinators_Parsec_Pos;
	prelude_contents[89] = Text_ParserCombinators_Parsec_Expr;
	prelude_contents[90] = Text_ParserCombinators_Parsec_Prim;
	prelude_contents[91] = Text_ParserCombinators_Parsec_Combinator;
	prelude_contents[92] = Text_ParserCombinators_Parsec_Perm;
	prelude_contents[93] = Data_Monoid;
	prelude_contents[94] = Data_Ratio;
	prelude_contents[95] = Data_Maybe;
	prelude_contents[96] = Data_Graph;
	prelude_contents[97] = Data_PackedString;
	prelude_contents[98] = Data_STRef;
	prelude_contents[99] = Data_Bool;
	prelude_contents[100] = Data_Dynamic;
	prelude_contents[101] = Data_Word;
	prelude_contents[102] = Data_List;
	prelude_contents[103] = Data_Ix;
	prelude_contents[104] = Data_Char;
	prelude_contents[105] = Data_Complex;
	prelude_contents[106] = Data_Set;
	prelude_contents[107] = Data_Either;
	prelude_contents[108] = Data_FiniteMap;
	prelude_contents[109] = Data_HashTable;
	prelude_contents[110] = Data_Tree;
	prelude_contents[111] = Data_Array;
	prelude_contents[112] = Data_Unique;
	prelude_contents[113] = Data_Bits;
	prelude_contents[114] = Data_Int;
	prelude_contents[115] = Data_IORef;
	prelude_contents[116] = Data_Tuple;
	prelude_contents[117] = Data_Typeable;
	prelude_contents[118] = Data_Array_IArray;
	prelude_contents[119] = Data_Array_Diff;
	prelude_contents[120] = Data_Array_MArray;
	prelude_contents[121] = Data_Array_ST;
	prelude_contents[122] = Data_Array_IO;
	prelude_contents[123] = Data_Array_Unboxed;
	prelude_contents[124] = Data_Array_Base;
	prelude_contents[125] = Data_Array_Storable;
	prelude_contents[126] = Data_Array_IO_Internals;
	prelude_contents[127] = Data_STRef_Strict;
	prelude_contents[128] = Data_STRef_Lazy;
	prelude_contents[129] = System_Posix;
	prelude_contents[130] = System_CPUTime;
	prelude_contents[131] = System_Random;
	prelude_contents[132] = System_Exit;
	prelude_contents[133] = System_Environment;
	prelude_contents[134] = System_Mem;
	prelude_contents[135] = System_Cmd;
	prelude_contents[136] = System_IO;
	prelude_contents[137] = System_Directory;
	prelude_contents[138] = System_Info;
	prelude_contents[139] = System_Time;
	prelude_contents[140] = System_Locale;
	prelude_contents[141] = System_IO_Unsafe;
	prelude_contents[142] = System_IO_Error;
	prelude_contents[143] = System_Posix_Resource;
	prelude_contents[144] = System_Posix_Types;
	prelude_contents[145] = System_Posix_Signals;
	prelude_contents[146] = System_Posix_User;
	prelude_contents[147] = System_Posix_Temp;
	prelude_contents[148] = System_Posix_Terminal;
	prelude_contents[149] = System_Posix_Files;
	prelude_contents[150] = System_Posix_Process;
	prelude_contents[151] = System_Posix_Internals;
	prelude_contents[152] = System_Posix_IO;
	prelude_contents[153] = System_Posix_Env;
	prelude_contents[154] = System_Posix_Directory;
	prelude_contents[155] = System_Posix_DynamicLinker;
	prelude_contents[156] = System_Posix_Time;
	prelude_contents[157] = System_Posix_Unistd;
	prelude_contents[158] = System_Posix_DynamicLinker_Module;
	prelude_contents[159] = System_Posix_DynamicLinker_Prim;
	prelude_contents[160] = System_Mem_StableName;
	prelude_contents[161] = System_Mem_Weak;
	prelude_contents[162] = System_Console_GetOpt;
	prelude_contents[163] = Foreign_C;
	prelude_contents[164] = Foreign_ForeignPtr;
	prelude_contents[165] = Foreign_Marshal;
	prelude_contents[166] = Foreign_Ptr;
	prelude_contents[167] = Foreign_Storable;
	prelude_contents[168] = Foreign_StablePtr;
	prelude_contents[169] = Foreign_Marshal_Alloc;
	prelude_contents[170] = Foreign_Marshal_Pool;
	prelude_contents[171] = Foreign_Marshal_Utils;
	prelude_contents[172] = Foreign_Marshal_Array;
	prelude_contents[173] = Foreign_Marshal_Error;
	prelude_contents[174] = Foreign_C_Types;
	prelude_contents[175] = Foreign_C_String;
	prelude_contents[176] = Foreign_C_Error;
	prelude_contents[177] = Hugs_Exception;
	prelude_contents[178] = Hugs_System;
	prelude_contents[179] = Hugs_Trex;
	prelude_contents[180] = Hugs_Stable;
	prelude_contents[181] = Hugs_ST;
	prelude_contents[182] = Hugs_ByteArray;
	prelude_contents[183] = Hugs_CVHAssert;
	prelude_contents[184] = Hugs_Prelude;
	prelude_contents[185] = Hugs_ForeignPtr;
	prelude_contents[186] = Hugs_Observe;
	prelude_contents[187] = Hugs_Dynamic;
	prelude_contents[188] = Hugs_Word;
	prelude_contents[189] = Hugs_Quote;
	prelude_contents[190] = Hugs_LazyST;
	prelude_contents[191] = Hugs_Char;
	prelude_contents[192] = Hugs_Internals;
	prelude_contents[193] = Hugs_Memo;
	prelude_contents[194] = Hugs_IOArray;
	prelude_contents[195] = Hugs_Weak;
	prelude_contents[196] = Hugs_IO;
	prelude_contents[197] = Hugs_Array;
	prelude_contents[198] = Hugs_Directory;
	prelude_contents[199] = Hugs_ConcBase;
	prelude_contents[200] = Hugs_Bits;
	prelude_contents[201] = Hugs_Int;
	prelude_contents[202] = Hugs_Numeric;
	prelude_contents[203] = Hugs_Ptr;
	prelude_contents[204] = Hugs_GenericPrint;
	prelude_contents[205] = Hugs_IORef;
	prelude_contents[206] = Hugs_Storable;
	prelude_contents[207] = Hugs_Time;
	prelude_contents[208] = Hugs_StablePtr;
	prelude_contents[209] = Hugs_IOExts;
}
#endif